/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/procaddress/ProcAddressEmitter.java on Thu Jul 26 21:47:13 CEST 2012 ----! */

package jogamp.openal;

import com.jogamp.openal.*;
import jogamp.openal.*;
import java.security.AccessController;
import java.security.PrivilegedAction;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class ALImpl implements AL{
  /** Entry point (through function pointer) to C language function: <br> <code> void alAuxiliaryEffectSlotf(ALuint asid, ALenum param, ALfloat value); </code>    */
  public void alAuxiliaryEffectSlotf(int asid, int param, float value)  {

    final long __addr_ = alProcAddressTable._addressof_alAuxiliaryEffectSlotf;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alAuxiliaryEffectSlotf\" not available");
    }
        dispatch_alAuxiliaryEffectSlotf1(asid, param, value, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alAuxiliaryEffectSlotf(ALuint asid, ALenum param, ALfloat value); </code>    */
  public native void dispatch_alAuxiliaryEffectSlotf1(int asid, int param, float value, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alAuxiliaryEffectSlotfv(ALuint asid, ALenum param, ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void alAuxiliaryEffectSlotfv(int asid, int param, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alAuxiliaryEffectSlotfv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alAuxiliaryEffectSlotfv\" not available");
    }
        dispatch_alAuxiliaryEffectSlotfv1(asid, param, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alAuxiliaryEffectSlotfv(ALuint asid, ALenum param, ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_alAuxiliaryEffectSlotfv1(int asid, int param, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alAuxiliaryEffectSlotfv(ALuint asid, ALenum param, ALfloat *  values); </code>    */
  public void alAuxiliaryEffectSlotfv(int asid, int param, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alAuxiliaryEffectSlotfv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alAuxiliaryEffectSlotfv\" not available");
    }
        dispatch_alAuxiliaryEffectSlotfv1(asid, param, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alAuxiliaryEffectSloti(ALuint asid, ALenum param, ALint value); </code>    */
  public void alAuxiliaryEffectSloti(int asid, int param, int value)  {

    final long __addr_ = alProcAddressTable._addressof_alAuxiliaryEffectSloti;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alAuxiliaryEffectSloti\" not available");
    }
        dispatch_alAuxiliaryEffectSloti1(asid, param, value, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alAuxiliaryEffectSloti(ALuint asid, ALenum param, ALint value); </code>    */
  public native void dispatch_alAuxiliaryEffectSloti1(int asid, int param, int value, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alAuxiliaryEffectSlotiv(ALuint asid, ALenum param, ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alAuxiliaryEffectSlotiv(int asid, int param, IntBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alAuxiliaryEffectSlotiv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alAuxiliaryEffectSlotiv\" not available");
    }
        dispatch_alAuxiliaryEffectSlotiv1(asid, param, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alAuxiliaryEffectSlotiv(ALuint asid, ALenum param, ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alAuxiliaryEffectSlotiv1(int asid, int param, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alAuxiliaryEffectSlotiv(ALuint asid, ALenum param, ALint *  values); </code>    */
  public void alAuxiliaryEffectSlotiv(int asid, int param, int[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alAuxiliaryEffectSlotiv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alAuxiliaryEffectSlotiv\" not available");
    }
        dispatch_alAuxiliaryEffectSlotiv1(asid, param, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alBuffer3f(ALuint bid, ALenum param, ALfloat value1, ALfloat value2, ALfloat value3); </code>    */
  public void alBuffer3f(int bid, int param, float value1, float value2, float value3)  {

    final long __addr_ = alProcAddressTable._addressof_alBuffer3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alBuffer3f\" not available");
    }
        dispatch_alBuffer3f1(bid, param, value1, value2, value3, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alBuffer3f(ALuint bid, ALenum param, ALfloat value1, ALfloat value2, ALfloat value3); </code>    */
  public native void dispatch_alBuffer3f1(int bid, int param, float value1, float value2, float value3, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alBuffer3i(ALuint bid, ALenum param, ALint value1, ALint value2, ALint value3); </code>    */
  public void alBuffer3i(int bid, int param, int value1, int value2, int value3)  {

    final long __addr_ = alProcAddressTable._addressof_alBuffer3i;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alBuffer3i\" not available");
    }
        dispatch_alBuffer3i1(bid, param, value1, value2, value3, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alBuffer3i(ALuint bid, ALenum param, ALint value1, ALint value2, ALint value3); </code>    */
  public native void dispatch_alBuffer3i1(int bid, int param, int value1, int value2, int value3, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alBufferData(ALuint bid, ALenum format, const ALvoid *  data, ALsizei size, ALsizei freq); </code> 
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void alBufferData(int bid, int format, Buffer data, int size, int freq)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = alProcAddressTable._addressof_alBufferData;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alBufferData\" not available");
    }
        dispatch_alBufferData1(bid, format, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, size, freq, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alBufferData(ALuint bid, ALenum format, const ALvoid *  data, ALsizei size, ALsizei freq); </code> 
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_alBufferData1(int bid, int format, Object data, int data_byte_offset, boolean data_is_direct, int size, int freq, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alBufferf(ALuint bid, ALenum param, ALfloat value); </code>    */
  public void alBufferf(int bid, int param, float value)  {

    final long __addr_ = alProcAddressTable._addressof_alBufferf;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alBufferf\" not available");
    }
        dispatch_alBufferf1(bid, param, value, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alBufferf(ALuint bid, ALenum param, ALfloat value); </code>    */
  public native void dispatch_alBufferf1(int bid, int param, float value, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alBufferfv(ALuint bid, ALenum param, const ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void alBufferfv(int bid, int param, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alBufferfv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alBufferfv\" not available");
    }
        dispatch_alBufferfv1(bid, param, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alBufferfv(ALuint bid, ALenum param, const ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_alBufferfv1(int bid, int param, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alBufferfv(ALuint bid, ALenum param, const ALfloat *  values); </code>    */
  public void alBufferfv(int bid, int param, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alBufferfv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alBufferfv\" not available");
    }
        dispatch_alBufferfv1(bid, param, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alBufferi(ALuint bid, ALenum param, ALint value); </code>    */
  public void alBufferi(int bid, int param, int value)  {

    final long __addr_ = alProcAddressTable._addressof_alBufferi;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alBufferi\" not available");
    }
        dispatch_alBufferi1(bid, param, value, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alBufferi(ALuint bid, ALenum param, ALint value); </code>    */
  public native void dispatch_alBufferi1(int bid, int param, int value, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alBufferiv(ALuint bid, ALenum param, const ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alBufferiv(int bid, int param, IntBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alBufferiv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alBufferiv\" not available");
    }
        dispatch_alBufferiv1(bid, param, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alBufferiv(ALuint bid, ALenum param, const ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alBufferiv1(int bid, int param, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alBufferiv(ALuint bid, ALenum param, const ALint *  values); </code>    */
  public void alBufferiv(int bid, int param, int[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alBufferiv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alBufferiv\" not available");
    }
        dispatch_alBufferiv1(bid, param, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alDeleteAuxiliaryEffectSlots(ALsizei n, ALuint *  slots); </code> 
      @param slots a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alDeleteAuxiliaryEffectSlots(int n, IntBuffer slots)  {

    final boolean slots_is_direct = Buffers.isDirect(slots);
    final long __addr_ = alProcAddressTable._addressof_alDeleteAuxiliaryEffectSlots;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alDeleteAuxiliaryEffectSlots\" not available");
    }
        dispatch_alDeleteAuxiliaryEffectSlots1(n, slots_is_direct ? slots : Buffers.getArray(slots), slots_is_direct ? Buffers.getDirectBufferByteOffset(slots) : Buffers.getIndirectBufferByteOffset(slots), slots_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alDeleteAuxiliaryEffectSlots(ALsizei n, ALuint *  slots); </code> 
      @param slots a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alDeleteAuxiliaryEffectSlots1(int n, Object slots, int slots_byte_offset, boolean slots_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alDeleteAuxiliaryEffectSlots(ALsizei n, ALuint *  slots); </code>    */
  public void alDeleteAuxiliaryEffectSlots(int n, int[] slots, int slots_offset)  {

    if(slots != null && slots.length <= slots_offset)
      throw new ALException("array offset argument \"slots_offset\" (" + slots_offset + ") equals or exceeds array length (" + slots.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alDeleteAuxiliaryEffectSlots;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alDeleteAuxiliaryEffectSlots\" not available");
    }
        dispatch_alDeleteAuxiliaryEffectSlots1(n, slots, Buffers.SIZEOF_INT * slots_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alDeleteBuffers(ALsizei n, const ALuint *  buffers); </code> 
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alDeleteBuffers(int n, IntBuffer buffers)  {

    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final long __addr_ = alProcAddressTable._addressof_alDeleteBuffers;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alDeleteBuffers\" not available");
    }
        dispatch_alDeleteBuffers1(n, buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alDeleteBuffers(ALsizei n, const ALuint *  buffers); </code> 
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alDeleteBuffers1(int n, Object buffers, int buffers_byte_offset, boolean buffers_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alDeleteBuffers(ALsizei n, const ALuint *  buffers); </code>    */
  public void alDeleteBuffers(int n, int[] buffers, int buffers_offset)  {

    if(buffers != null && buffers.length <= buffers_offset)
      throw new ALException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alDeleteBuffers;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alDeleteBuffers\" not available");
    }
        dispatch_alDeleteBuffers1(n, buffers, Buffers.SIZEOF_INT * buffers_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alDeleteEffects(ALsizei n, ALuint *  effects); </code> 
      @param effects a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alDeleteEffects(int n, IntBuffer effects)  {

    final boolean effects_is_direct = Buffers.isDirect(effects);
    final long __addr_ = alProcAddressTable._addressof_alDeleteEffects;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alDeleteEffects\" not available");
    }
        dispatch_alDeleteEffects1(n, effects_is_direct ? effects : Buffers.getArray(effects), effects_is_direct ? Buffers.getDirectBufferByteOffset(effects) : Buffers.getIndirectBufferByteOffset(effects), effects_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alDeleteEffects(ALsizei n, ALuint *  effects); </code> 
      @param effects a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alDeleteEffects1(int n, Object effects, int effects_byte_offset, boolean effects_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alDeleteEffects(ALsizei n, ALuint *  effects); </code>    */
  public void alDeleteEffects(int n, int[] effects, int effects_offset)  {

    if(effects != null && effects.length <= effects_offset)
      throw new ALException("array offset argument \"effects_offset\" (" + effects_offset + ") equals or exceeds array length (" + effects.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alDeleteEffects;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alDeleteEffects\" not available");
    }
        dispatch_alDeleteEffects1(n, effects, Buffers.SIZEOF_INT * effects_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alDeleteFilters(ALsizei n, ALuint *  filters); </code> 
      @param filters a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alDeleteFilters(int n, IntBuffer filters)  {

    final boolean filters_is_direct = Buffers.isDirect(filters);
    final long __addr_ = alProcAddressTable._addressof_alDeleteFilters;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alDeleteFilters\" not available");
    }
        dispatch_alDeleteFilters1(n, filters_is_direct ? filters : Buffers.getArray(filters), filters_is_direct ? Buffers.getDirectBufferByteOffset(filters) : Buffers.getIndirectBufferByteOffset(filters), filters_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alDeleteFilters(ALsizei n, ALuint *  filters); </code> 
      @param filters a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alDeleteFilters1(int n, Object filters, int filters_byte_offset, boolean filters_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alDeleteFilters(ALsizei n, ALuint *  filters); </code>    */
  public void alDeleteFilters(int n, int[] filters, int filters_offset)  {

    if(filters != null && filters.length <= filters_offset)
      throw new ALException("array offset argument \"filters_offset\" (" + filters_offset + ") equals or exceeds array length (" + filters.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alDeleteFilters;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alDeleteFilters\" not available");
    }
        dispatch_alDeleteFilters1(n, filters, Buffers.SIZEOF_INT * filters_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alDeleteSources(ALsizei n, const ALuint *  sources); </code> 
      @param sources a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alDeleteSources(int n, IntBuffer sources)  {

    final boolean sources_is_direct = Buffers.isDirect(sources);
    final long __addr_ = alProcAddressTable._addressof_alDeleteSources;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alDeleteSources\" not available");
    }
        dispatch_alDeleteSources1(n, sources_is_direct ? sources : Buffers.getArray(sources), sources_is_direct ? Buffers.getDirectBufferByteOffset(sources) : Buffers.getIndirectBufferByteOffset(sources), sources_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alDeleteSources(ALsizei n, const ALuint *  sources); </code> 
      @param sources a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alDeleteSources1(int n, Object sources, int sources_byte_offset, boolean sources_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alDeleteSources(ALsizei n, const ALuint *  sources); </code>    */
  public void alDeleteSources(int n, int[] sources, int sources_offset)  {

    if(sources != null && sources.length <= sources_offset)
      throw new ALException("array offset argument \"sources_offset\" (" + sources_offset + ") equals or exceeds array length (" + sources.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alDeleteSources;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alDeleteSources\" not available");
    }
        dispatch_alDeleteSources1(n, sources, Buffers.SIZEOF_INT * sources_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alDisable(ALenum capability); </code>    */
  public void alDisable(int capability)  {

    final long __addr_ = alProcAddressTable._addressof_alDisable;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alDisable\" not available");
    }
        dispatch_alDisable1(capability, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alDisable(ALenum capability); </code>    */
  public native void dispatch_alDisable1(int capability, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alDistanceModel(ALenum distanceModel); </code>    */
  public void alDistanceModel(int distanceModel)  {

    final long __addr_ = alProcAddressTable._addressof_alDistanceModel;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alDistanceModel\" not available");
    }
        dispatch_alDistanceModel1(distanceModel, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alDistanceModel(ALenum distanceModel); </code>    */
  public native void dispatch_alDistanceModel1(int distanceModel, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alDopplerFactor(ALfloat value); </code>    */
  public void alDopplerFactor(float value)  {

    final long __addr_ = alProcAddressTable._addressof_alDopplerFactor;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alDopplerFactor\" not available");
    }
        dispatch_alDopplerFactor1(value, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alDopplerFactor(ALfloat value); </code>    */
  public native void dispatch_alDopplerFactor1(float value, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alDopplerVelocity(ALfloat value); </code>    */
  public void alDopplerVelocity(float value)  {

    final long __addr_ = alProcAddressTable._addressof_alDopplerVelocity;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alDopplerVelocity\" not available");
    }
        dispatch_alDopplerVelocity1(value, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alDopplerVelocity(ALfloat value); </code>    */
  public native void dispatch_alDopplerVelocity1(float value, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alEffectf(ALuint eid, ALenum param, ALfloat value); </code>    */
  public void alEffectf(int eid, int param, float value)  {

    final long __addr_ = alProcAddressTable._addressof_alEffectf;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alEffectf\" not available");
    }
        dispatch_alEffectf1(eid, param, value, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alEffectf(ALuint eid, ALenum param, ALfloat value); </code>    */
  public native void dispatch_alEffectf1(int eid, int param, float value, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alEffectfv(ALuint eid, ALenum param, ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void alEffectfv(int eid, int param, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alEffectfv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alEffectfv\" not available");
    }
        dispatch_alEffectfv1(eid, param, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alEffectfv(ALuint eid, ALenum param, ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_alEffectfv1(int eid, int param, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alEffectfv(ALuint eid, ALenum param, ALfloat *  values); </code>    */
  public void alEffectfv(int eid, int param, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alEffectfv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alEffectfv\" not available");
    }
        dispatch_alEffectfv1(eid, param, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alEffecti(ALuint eid, ALenum param, ALint value); </code>    */
  public void alEffecti(int eid, int param, int value)  {

    final long __addr_ = alProcAddressTable._addressof_alEffecti;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alEffecti\" not available");
    }
        dispatch_alEffecti1(eid, param, value, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alEffecti(ALuint eid, ALenum param, ALint value); </code>    */
  public native void dispatch_alEffecti1(int eid, int param, int value, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alEffectiv(ALuint eid, ALenum param, ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alEffectiv(int eid, int param, IntBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alEffectiv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alEffectiv\" not available");
    }
        dispatch_alEffectiv1(eid, param, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alEffectiv(ALuint eid, ALenum param, ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alEffectiv1(int eid, int param, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alEffectiv(ALuint eid, ALenum param, ALint *  values); </code>    */
  public void alEffectiv(int eid, int param, int[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alEffectiv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alEffectiv\" not available");
    }
        dispatch_alEffectiv1(eid, param, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alEnable(ALenum capability); </code>    */
  public void alEnable(int capability)  {

    final long __addr_ = alProcAddressTable._addressof_alEnable;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alEnable\" not available");
    }
        dispatch_alEnable1(capability, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alEnable(ALenum capability); </code>    */
  public native void dispatch_alEnable1(int capability, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alFilterf(ALuint fid, ALenum param, ALfloat value); </code>    */
  public void alFilterf(int fid, int param, float value)  {

    final long __addr_ = alProcAddressTable._addressof_alFilterf;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alFilterf\" not available");
    }
        dispatch_alFilterf1(fid, param, value, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alFilterf(ALuint fid, ALenum param, ALfloat value); </code>    */
  public native void dispatch_alFilterf1(int fid, int param, float value, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alFilterfv(ALuint fid, ALenum param, ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void alFilterfv(int fid, int param, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alFilterfv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alFilterfv\" not available");
    }
        dispatch_alFilterfv1(fid, param, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alFilterfv(ALuint fid, ALenum param, ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_alFilterfv1(int fid, int param, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alFilterfv(ALuint fid, ALenum param, ALfloat *  values); </code>    */
  public void alFilterfv(int fid, int param, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alFilterfv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alFilterfv\" not available");
    }
        dispatch_alFilterfv1(fid, param, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alFilteri(ALuint fid, ALenum param, ALint value); </code>    */
  public void alFilteri(int fid, int param, int value)  {

    final long __addr_ = alProcAddressTable._addressof_alFilteri;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alFilteri\" not available");
    }
        dispatch_alFilteri1(fid, param, value, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alFilteri(ALuint fid, ALenum param, ALint value); </code>    */
  public native void dispatch_alFilteri1(int fid, int param, int value, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alFilteriv(ALuint fid, ALenum param, ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alFilteriv(int fid, int param, IntBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alFilteriv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alFilteriv\" not available");
    }
        dispatch_alFilteriv1(fid, param, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alFilteriv(ALuint fid, ALenum param, ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alFilteriv1(int fid, int param, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alFilteriv(ALuint fid, ALenum param, ALint *  values); </code>    */
  public void alFilteriv(int fid, int param, int[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alFilteriv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alFilteriv\" not available");
    }
        dispatch_alFilteriv1(fid, param, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGenAuxiliaryEffectSlots(ALsizei n, ALuint *  slots); </code> 
      @param slots a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alGenAuxiliaryEffectSlots(int n, IntBuffer slots)  {

    final boolean slots_is_direct = Buffers.isDirect(slots);
    final long __addr_ = alProcAddressTable._addressof_alGenAuxiliaryEffectSlots;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGenAuxiliaryEffectSlots\" not available");
    }
        dispatch_alGenAuxiliaryEffectSlots1(n, slots_is_direct ? slots : Buffers.getArray(slots), slots_is_direct ? Buffers.getDirectBufferByteOffset(slots) : Buffers.getIndirectBufferByteOffset(slots), slots_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGenAuxiliaryEffectSlots(ALsizei n, ALuint *  slots); </code> 
      @param slots a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alGenAuxiliaryEffectSlots1(int n, Object slots, int slots_byte_offset, boolean slots_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGenAuxiliaryEffectSlots(ALsizei n, ALuint *  slots); </code>    */
  public void alGenAuxiliaryEffectSlots(int n, int[] slots, int slots_offset)  {

    if(slots != null && slots.length <= slots_offset)
      throw new ALException("array offset argument \"slots_offset\" (" + slots_offset + ") equals or exceeds array length (" + slots.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGenAuxiliaryEffectSlots;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGenAuxiliaryEffectSlots\" not available");
    }
        dispatch_alGenAuxiliaryEffectSlots1(n, slots, Buffers.SIZEOF_INT * slots_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGenBuffers(ALsizei n, ALuint *  buffers); </code> 
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alGenBuffers(int n, IntBuffer buffers)  {

    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final long __addr_ = alProcAddressTable._addressof_alGenBuffers;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGenBuffers\" not available");
    }
        dispatch_alGenBuffers1(n, buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGenBuffers(ALsizei n, ALuint *  buffers); </code> 
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alGenBuffers1(int n, Object buffers, int buffers_byte_offset, boolean buffers_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGenBuffers(ALsizei n, ALuint *  buffers); </code>    */
  public void alGenBuffers(int n, int[] buffers, int buffers_offset)  {

    if(buffers != null && buffers.length <= buffers_offset)
      throw new ALException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGenBuffers;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGenBuffers\" not available");
    }
        dispatch_alGenBuffers1(n, buffers, Buffers.SIZEOF_INT * buffers_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGenEffects(ALsizei n, ALuint *  effects); </code> 
      @param effects a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alGenEffects(int n, IntBuffer effects)  {

    final boolean effects_is_direct = Buffers.isDirect(effects);
    final long __addr_ = alProcAddressTable._addressof_alGenEffects;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGenEffects\" not available");
    }
        dispatch_alGenEffects1(n, effects_is_direct ? effects : Buffers.getArray(effects), effects_is_direct ? Buffers.getDirectBufferByteOffset(effects) : Buffers.getIndirectBufferByteOffset(effects), effects_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGenEffects(ALsizei n, ALuint *  effects); </code> 
      @param effects a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alGenEffects1(int n, Object effects, int effects_byte_offset, boolean effects_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGenEffects(ALsizei n, ALuint *  effects); </code>    */
  public void alGenEffects(int n, int[] effects, int effects_offset)  {

    if(effects != null && effects.length <= effects_offset)
      throw new ALException("array offset argument \"effects_offset\" (" + effects_offset + ") equals or exceeds array length (" + effects.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGenEffects;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGenEffects\" not available");
    }
        dispatch_alGenEffects1(n, effects, Buffers.SIZEOF_INT * effects_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGenFilters(ALsizei n, ALuint *  filters); </code> 
      @param filters a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alGenFilters(int n, IntBuffer filters)  {

    final boolean filters_is_direct = Buffers.isDirect(filters);
    final long __addr_ = alProcAddressTable._addressof_alGenFilters;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGenFilters\" not available");
    }
        dispatch_alGenFilters1(n, filters_is_direct ? filters : Buffers.getArray(filters), filters_is_direct ? Buffers.getDirectBufferByteOffset(filters) : Buffers.getIndirectBufferByteOffset(filters), filters_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGenFilters(ALsizei n, ALuint *  filters); </code> 
      @param filters a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alGenFilters1(int n, Object filters, int filters_byte_offset, boolean filters_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGenFilters(ALsizei n, ALuint *  filters); </code>    */
  public void alGenFilters(int n, int[] filters, int filters_offset)  {

    if(filters != null && filters.length <= filters_offset)
      throw new ALException("array offset argument \"filters_offset\" (" + filters_offset + ") equals or exceeds array length (" + filters.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGenFilters;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGenFilters\" not available");
    }
        dispatch_alGenFilters1(n, filters, Buffers.SIZEOF_INT * filters_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGenSources(ALsizei n, ALuint *  sources); </code> 
      @param sources a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alGenSources(int n, IntBuffer sources)  {

    final boolean sources_is_direct = Buffers.isDirect(sources);
    final long __addr_ = alProcAddressTable._addressof_alGenSources;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGenSources\" not available");
    }
        dispatch_alGenSources1(n, sources_is_direct ? sources : Buffers.getArray(sources), sources_is_direct ? Buffers.getDirectBufferByteOffset(sources) : Buffers.getIndirectBufferByteOffset(sources), sources_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGenSources(ALsizei n, ALuint *  sources); </code> 
      @param sources a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alGenSources1(int n, Object sources, int sources_byte_offset, boolean sources_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGenSources(ALsizei n, ALuint *  sources); </code>    */
  public void alGenSources(int n, int[] sources, int sources_offset)  {

    if(sources != null && sources.length <= sources_offset)
      throw new ALException("array offset argument \"sources_offset\" (" + sources_offset + ") equals or exceeds array length (" + sources.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGenSources;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGenSources\" not available");
    }
        dispatch_alGenSources1(n, sources, Buffers.SIZEOF_INT * sources_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetAuxiliaryEffectSlotf(ALuint asid, ALenum pname, ALfloat *  value); </code> 
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void alGetAuxiliaryEffectSlotf(int asid, int pname, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = alProcAddressTable._addressof_alGetAuxiliaryEffectSlotf;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetAuxiliaryEffectSlotf\" not available");
    }
        dispatch_alGetAuxiliaryEffectSlotf1(asid, pname, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetAuxiliaryEffectSlotf(ALuint asid, ALenum pname, ALfloat *  value); </code> 
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_alGetAuxiliaryEffectSlotf1(int asid, int pname, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetAuxiliaryEffectSlotf(ALuint asid, ALenum pname, ALfloat *  value); </code>    */
  public void alGetAuxiliaryEffectSlotf(int asid, int pname, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new ALException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetAuxiliaryEffectSlotf;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetAuxiliaryEffectSlotf\" not available");
    }
        dispatch_alGetAuxiliaryEffectSlotf1(asid, pname, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetAuxiliaryEffectSlotfv(ALuint asid, ALenum pname, ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void alGetAuxiliaryEffectSlotfv(int asid, int pname, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alGetAuxiliaryEffectSlotfv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetAuxiliaryEffectSlotfv\" not available");
    }
        dispatch_alGetAuxiliaryEffectSlotfv1(asid, pname, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetAuxiliaryEffectSlotfv(ALuint asid, ALenum pname, ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_alGetAuxiliaryEffectSlotfv1(int asid, int pname, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetAuxiliaryEffectSlotfv(ALuint asid, ALenum pname, ALfloat *  values); </code>    */
  public void alGetAuxiliaryEffectSlotfv(int asid, int pname, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetAuxiliaryEffectSlotfv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetAuxiliaryEffectSlotfv\" not available");
    }
        dispatch_alGetAuxiliaryEffectSlotfv1(asid, pname, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetAuxiliaryEffectSloti(ALuint asid, ALenum pname, ALint *  value); </code> 
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alGetAuxiliaryEffectSloti(int asid, int pname, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = alProcAddressTable._addressof_alGetAuxiliaryEffectSloti;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetAuxiliaryEffectSloti\" not available");
    }
        dispatch_alGetAuxiliaryEffectSloti1(asid, pname, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetAuxiliaryEffectSloti(ALuint asid, ALenum pname, ALint *  value); </code> 
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alGetAuxiliaryEffectSloti1(int asid, int pname, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetAuxiliaryEffectSloti(ALuint asid, ALenum pname, ALint *  value); </code>    */
  public void alGetAuxiliaryEffectSloti(int asid, int pname, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new ALException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetAuxiliaryEffectSloti;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetAuxiliaryEffectSloti\" not available");
    }
        dispatch_alGetAuxiliaryEffectSloti1(asid, pname, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetAuxiliaryEffectSlotiv(ALuint asid, ALenum pname, ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alGetAuxiliaryEffectSlotiv(int asid, int pname, IntBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alGetAuxiliaryEffectSlotiv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetAuxiliaryEffectSlotiv\" not available");
    }
        dispatch_alGetAuxiliaryEffectSlotiv1(asid, pname, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetAuxiliaryEffectSlotiv(ALuint asid, ALenum pname, ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alGetAuxiliaryEffectSlotiv1(int asid, int pname, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetAuxiliaryEffectSlotiv(ALuint asid, ALenum pname, ALint *  values); </code>    */
  public void alGetAuxiliaryEffectSlotiv(int asid, int pname, int[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetAuxiliaryEffectSlotiv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetAuxiliaryEffectSlotiv\" not available");
    }
        dispatch_alGetAuxiliaryEffectSlotiv1(asid, pname, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALboolean alGetBoolean(ALenum param); </code>    */
  public boolean alGetBoolean(int param)  {

    final long __addr_ = alProcAddressTable._addressof_alGetBoolean;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetBoolean\" not available");
    }
        return dispatch_alGetBoolean1(param, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALboolean alGetBoolean(ALenum param); </code>    */
  public native boolean dispatch_alGetBoolean1(int param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetBooleanv(ALenum param, ALboolean *  data); </code> 
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void alGetBooleanv(int param, ByteBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = alProcAddressTable._addressof_alGetBooleanv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetBooleanv\" not available");
    }
        dispatch_alGetBooleanv1(param, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetBooleanv(ALenum param, ALboolean *  data); </code> 
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_alGetBooleanv1(int param, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetBooleanv(ALenum param, ALboolean *  data); </code>    */
  public void alGetBooleanv(int param, byte[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new ALException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetBooleanv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetBooleanv\" not available");
    }
        dispatch_alGetBooleanv1(param, data, data_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetBuffer3f(ALuint bid, ALenum param, ALfloat *  value1, ALfloat *  value2, ALfloat *  value3); </code> 
      @param value1 a direct or array-backed {@link java.nio.FloatBuffer}
      @param value2 a direct or array-backed {@link java.nio.FloatBuffer}
      @param value3 a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void alGetBuffer3f(int bid, int param, FloatBuffer value1, FloatBuffer value2, FloatBuffer value3)  {

    final boolean value1_is_direct = Buffers.isDirect(value1);
    final boolean value2_is_direct = Buffers.isDirect(value2);
    final boolean value3_is_direct = Buffers.isDirect(value3);
    final long __addr_ = alProcAddressTable._addressof_alGetBuffer3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetBuffer3f\" not available");
    }
        dispatch_alGetBuffer3f1(bid, param, value1_is_direct ? value1 : Buffers.getArray(value1), value1_is_direct ? Buffers.getDirectBufferByteOffset(value1) : Buffers.getIndirectBufferByteOffset(value1), value1_is_direct, value2_is_direct ? value2 : Buffers.getArray(value2), value2_is_direct ? Buffers.getDirectBufferByteOffset(value2) : Buffers.getIndirectBufferByteOffset(value2), value2_is_direct, value3_is_direct ? value3 : Buffers.getArray(value3), value3_is_direct ? Buffers.getDirectBufferByteOffset(value3) : Buffers.getIndirectBufferByteOffset(value3), value3_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetBuffer3f(ALuint bid, ALenum param, ALfloat *  value1, ALfloat *  value2, ALfloat *  value3); </code> 
      @param value1 a direct or array-backed {@link java.nio.FloatBuffer}
      @param value2 a direct or array-backed {@link java.nio.FloatBuffer}
      @param value3 a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_alGetBuffer3f1(int bid, int param, Object value1, int value1_byte_offset, boolean value1_is_direct, Object value2, int value2_byte_offset, boolean value2_is_direct, Object value3, int value3_byte_offset, boolean value3_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetBuffer3f(ALuint bid, ALenum param, ALfloat *  value1, ALfloat *  value2, ALfloat *  value3); </code>    */
  public void alGetBuffer3f(int bid, int param, float[] value1, int value1_offset, float[] value2, int value2_offset, float[] value3, int value3_offset)  {

    if(value1 != null && value1.length <= value1_offset)
      throw new ALException("array offset argument \"value1_offset\" (" + value1_offset + ") equals or exceeds array length (" + value1.length + ")");
    if(value2 != null && value2.length <= value2_offset)
      throw new ALException("array offset argument \"value2_offset\" (" + value2_offset + ") equals or exceeds array length (" + value2.length + ")");
    if(value3 != null && value3.length <= value3_offset)
      throw new ALException("array offset argument \"value3_offset\" (" + value3_offset + ") equals or exceeds array length (" + value3.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetBuffer3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetBuffer3f\" not available");
    }
        dispatch_alGetBuffer3f1(bid, param, value1, Buffers.SIZEOF_FLOAT * value1_offset, false, value2, Buffers.SIZEOF_FLOAT * value2_offset, false, value3, Buffers.SIZEOF_FLOAT * value3_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetBuffer3i(ALuint bid, ALenum param, ALint *  value1, ALint *  value2, ALint *  value3); </code> 
      @param value1 a direct or array-backed {@link java.nio.IntBuffer}
      @param value2 a direct or array-backed {@link java.nio.IntBuffer}
      @param value3 a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alGetBuffer3i(int bid, int param, IntBuffer value1, IntBuffer value2, IntBuffer value3)  {

    final boolean value1_is_direct = Buffers.isDirect(value1);
    final boolean value2_is_direct = Buffers.isDirect(value2);
    final boolean value3_is_direct = Buffers.isDirect(value3);
    final long __addr_ = alProcAddressTable._addressof_alGetBuffer3i;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetBuffer3i\" not available");
    }
        dispatch_alGetBuffer3i1(bid, param, value1_is_direct ? value1 : Buffers.getArray(value1), value1_is_direct ? Buffers.getDirectBufferByteOffset(value1) : Buffers.getIndirectBufferByteOffset(value1), value1_is_direct, value2_is_direct ? value2 : Buffers.getArray(value2), value2_is_direct ? Buffers.getDirectBufferByteOffset(value2) : Buffers.getIndirectBufferByteOffset(value2), value2_is_direct, value3_is_direct ? value3 : Buffers.getArray(value3), value3_is_direct ? Buffers.getDirectBufferByteOffset(value3) : Buffers.getIndirectBufferByteOffset(value3), value3_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetBuffer3i(ALuint bid, ALenum param, ALint *  value1, ALint *  value2, ALint *  value3); </code> 
      @param value1 a direct or array-backed {@link java.nio.IntBuffer}
      @param value2 a direct or array-backed {@link java.nio.IntBuffer}
      @param value3 a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alGetBuffer3i1(int bid, int param, Object value1, int value1_byte_offset, boolean value1_is_direct, Object value2, int value2_byte_offset, boolean value2_is_direct, Object value3, int value3_byte_offset, boolean value3_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetBuffer3i(ALuint bid, ALenum param, ALint *  value1, ALint *  value2, ALint *  value3); </code>    */
  public void alGetBuffer3i(int bid, int param, int[] value1, int value1_offset, int[] value2, int value2_offset, int[] value3, int value3_offset)  {

    if(value1 != null && value1.length <= value1_offset)
      throw new ALException("array offset argument \"value1_offset\" (" + value1_offset + ") equals or exceeds array length (" + value1.length + ")");
    if(value2 != null && value2.length <= value2_offset)
      throw new ALException("array offset argument \"value2_offset\" (" + value2_offset + ") equals or exceeds array length (" + value2.length + ")");
    if(value3 != null && value3.length <= value3_offset)
      throw new ALException("array offset argument \"value3_offset\" (" + value3_offset + ") equals or exceeds array length (" + value3.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetBuffer3i;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetBuffer3i\" not available");
    }
        dispatch_alGetBuffer3i1(bid, param, value1, Buffers.SIZEOF_INT * value1_offset, false, value2, Buffers.SIZEOF_INT * value2_offset, false, value3, Buffers.SIZEOF_INT * value3_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetBufferf(ALuint bid, ALenum param, ALfloat *  value); </code> 
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void alGetBufferf(int bid, int param, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = alProcAddressTable._addressof_alGetBufferf;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetBufferf\" not available");
    }
        dispatch_alGetBufferf1(bid, param, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetBufferf(ALuint bid, ALenum param, ALfloat *  value); </code> 
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_alGetBufferf1(int bid, int param, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetBufferf(ALuint bid, ALenum param, ALfloat *  value); </code>    */
  public void alGetBufferf(int bid, int param, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new ALException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetBufferf;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetBufferf\" not available");
    }
        dispatch_alGetBufferf1(bid, param, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetBufferfv(ALuint bid, ALenum param, ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void alGetBufferfv(int bid, int param, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alGetBufferfv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetBufferfv\" not available");
    }
        dispatch_alGetBufferfv1(bid, param, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetBufferfv(ALuint bid, ALenum param, ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_alGetBufferfv1(int bid, int param, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetBufferfv(ALuint bid, ALenum param, ALfloat *  values); </code>    */
  public void alGetBufferfv(int bid, int param, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetBufferfv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetBufferfv\" not available");
    }
        dispatch_alGetBufferfv1(bid, param, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetBufferi(ALuint bid, ALenum param, ALint *  value); </code> 
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alGetBufferi(int bid, int param, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = alProcAddressTable._addressof_alGetBufferi;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetBufferi\" not available");
    }
        dispatch_alGetBufferi1(bid, param, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetBufferi(ALuint bid, ALenum param, ALint *  value); </code> 
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alGetBufferi1(int bid, int param, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetBufferi(ALuint bid, ALenum param, ALint *  value); </code>    */
  public void alGetBufferi(int bid, int param, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new ALException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetBufferi;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetBufferi\" not available");
    }
        dispatch_alGetBufferi1(bid, param, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetBufferiv(ALuint bid, ALenum param, ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alGetBufferiv(int bid, int param, IntBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alGetBufferiv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetBufferiv\" not available");
    }
        dispatch_alGetBufferiv1(bid, param, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetBufferiv(ALuint bid, ALenum param, ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alGetBufferiv1(int bid, int param, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetBufferiv(ALuint bid, ALenum param, ALint *  values); </code>    */
  public void alGetBufferiv(int bid, int param, int[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetBufferiv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetBufferiv\" not available");
    }
        dispatch_alGetBufferiv1(bid, param, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALdouble alGetDouble(ALenum param); </code>    */
  public double alGetDouble(int param)  {

    final long __addr_ = alProcAddressTable._addressof_alGetDouble;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetDouble\" not available");
    }
        return dispatch_alGetDouble1(param, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALdouble alGetDouble(ALenum param); </code>    */
  public native double dispatch_alGetDouble1(int param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetDoublev(ALenum param, ALdouble *  data); </code> 
      @param data a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void alGetDoublev(int param, DoubleBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = alProcAddressTable._addressof_alGetDoublev;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetDoublev\" not available");
    }
        dispatch_alGetDoublev1(param, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetDoublev(ALenum param, ALdouble *  data); </code> 
      @param data a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_alGetDoublev1(int param, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetDoublev(ALenum param, ALdouble *  data); </code>    */
  public void alGetDoublev(int param, double[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new ALException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetDoublev;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetDoublev\" not available");
    }
        dispatch_alGetDoublev1(param, data, Buffers.SIZEOF_DOUBLE * data_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetEffectf(ALuint eid, ALenum pname, ALfloat *  value); </code> 
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void alGetEffectf(int eid, int pname, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = alProcAddressTable._addressof_alGetEffectf;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetEffectf\" not available");
    }
        dispatch_alGetEffectf1(eid, pname, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetEffectf(ALuint eid, ALenum pname, ALfloat *  value); </code> 
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_alGetEffectf1(int eid, int pname, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetEffectf(ALuint eid, ALenum pname, ALfloat *  value); </code>    */
  public void alGetEffectf(int eid, int pname, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new ALException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetEffectf;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetEffectf\" not available");
    }
        dispatch_alGetEffectf1(eid, pname, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetEffectfv(ALuint eid, ALenum pname, ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void alGetEffectfv(int eid, int pname, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alGetEffectfv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetEffectfv\" not available");
    }
        dispatch_alGetEffectfv1(eid, pname, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetEffectfv(ALuint eid, ALenum pname, ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_alGetEffectfv1(int eid, int pname, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetEffectfv(ALuint eid, ALenum pname, ALfloat *  values); </code>    */
  public void alGetEffectfv(int eid, int pname, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetEffectfv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetEffectfv\" not available");
    }
        dispatch_alGetEffectfv1(eid, pname, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetEffecti(ALuint eid, ALenum pname, ALint *  value); </code> 
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alGetEffecti(int eid, int pname, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = alProcAddressTable._addressof_alGetEffecti;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetEffecti\" not available");
    }
        dispatch_alGetEffecti1(eid, pname, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetEffecti(ALuint eid, ALenum pname, ALint *  value); </code> 
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alGetEffecti1(int eid, int pname, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetEffecti(ALuint eid, ALenum pname, ALint *  value); </code>    */
  public void alGetEffecti(int eid, int pname, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new ALException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetEffecti;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetEffecti\" not available");
    }
        dispatch_alGetEffecti1(eid, pname, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetEffectiv(ALuint eid, ALenum pname, ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alGetEffectiv(int eid, int pname, IntBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alGetEffectiv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetEffectiv\" not available");
    }
        dispatch_alGetEffectiv1(eid, pname, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetEffectiv(ALuint eid, ALenum pname, ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alGetEffectiv1(int eid, int pname, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetEffectiv(ALuint eid, ALenum pname, ALint *  values); </code>    */
  public void alGetEffectiv(int eid, int pname, int[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetEffectiv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetEffectiv\" not available");
    }
        dispatch_alGetEffectiv1(eid, pname, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALenum alGetEnumValue(const ALchar *  ename); </code>    */
  public int alGetEnumValue(String ename)  {

    final long __addr_ = alProcAddressTable._addressof_alGetEnumValue;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetEnumValue\" not available");
    }
        return dispatch_alGetEnumValue1(ename, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALenum alGetEnumValue(const ALchar *  ename); </code>    */
  public native int dispatch_alGetEnumValue1(String ename, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> ALenum alGetError(void); </code>    */
  public int alGetError()  {

    final long __addr_ = alProcAddressTable._addressof_alGetError;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetError\" not available");
    }
        return dispatch_alGetError1(__addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALenum alGetError(void); </code>    */
  public native int dispatch_alGetError1(long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetFilterf(ALuint fid, ALenum pname, ALfloat *  value); </code> 
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void alGetFilterf(int fid, int pname, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = alProcAddressTable._addressof_alGetFilterf;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetFilterf\" not available");
    }
        dispatch_alGetFilterf1(fid, pname, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetFilterf(ALuint fid, ALenum pname, ALfloat *  value); </code> 
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_alGetFilterf1(int fid, int pname, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetFilterf(ALuint fid, ALenum pname, ALfloat *  value); </code>    */
  public void alGetFilterf(int fid, int pname, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new ALException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetFilterf;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetFilterf\" not available");
    }
        dispatch_alGetFilterf1(fid, pname, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetFilterfv(ALuint fid, ALenum pname, ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void alGetFilterfv(int fid, int pname, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alGetFilterfv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetFilterfv\" not available");
    }
        dispatch_alGetFilterfv1(fid, pname, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetFilterfv(ALuint fid, ALenum pname, ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_alGetFilterfv1(int fid, int pname, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetFilterfv(ALuint fid, ALenum pname, ALfloat *  values); </code>    */
  public void alGetFilterfv(int fid, int pname, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetFilterfv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetFilterfv\" not available");
    }
        dispatch_alGetFilterfv1(fid, pname, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetFilteri(ALuint fid, ALenum pname, ALint *  value); </code> 
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alGetFilteri(int fid, int pname, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = alProcAddressTable._addressof_alGetFilteri;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetFilteri\" not available");
    }
        dispatch_alGetFilteri1(fid, pname, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetFilteri(ALuint fid, ALenum pname, ALint *  value); </code> 
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alGetFilteri1(int fid, int pname, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetFilteri(ALuint fid, ALenum pname, ALint *  value); </code>    */
  public void alGetFilteri(int fid, int pname, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new ALException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetFilteri;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetFilteri\" not available");
    }
        dispatch_alGetFilteri1(fid, pname, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetFilteriv(ALuint fid, ALenum pname, ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alGetFilteriv(int fid, int pname, IntBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alGetFilteriv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetFilteriv\" not available");
    }
        dispatch_alGetFilteriv1(fid, pname, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetFilteriv(ALuint fid, ALenum pname, ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alGetFilteriv1(int fid, int pname, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetFilteriv(ALuint fid, ALenum pname, ALint *  values); </code>    */
  public void alGetFilteriv(int fid, int pname, int[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetFilteriv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetFilteriv\" not available");
    }
        dispatch_alGetFilteriv1(fid, pname, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALfloat alGetFloat(ALenum param); </code>    */
  public float alGetFloat(int param)  {

    final long __addr_ = alProcAddressTable._addressof_alGetFloat;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetFloat\" not available");
    }
        return dispatch_alGetFloat1(param, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALfloat alGetFloat(ALenum param); </code>    */
  public native float dispatch_alGetFloat1(int param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetFloatv(ALenum param, ALfloat *  data); </code> 
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void alGetFloatv(int param, FloatBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = alProcAddressTable._addressof_alGetFloatv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetFloatv\" not available");
    }
        dispatch_alGetFloatv1(param, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetFloatv(ALenum param, ALfloat *  data); </code> 
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_alGetFloatv1(int param, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetFloatv(ALenum param, ALfloat *  data); </code>    */
  public void alGetFloatv(int param, float[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new ALException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetFloatv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetFloatv\" not available");
    }
        dispatch_alGetFloatv1(param, data, Buffers.SIZEOF_FLOAT * data_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALint alGetInteger(ALenum param); </code>    */
  public int alGetInteger(int param)  {

    final long __addr_ = alProcAddressTable._addressof_alGetInteger;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetInteger\" not available");
    }
        return dispatch_alGetInteger1(param, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALint alGetInteger(ALenum param); </code>    */
  public native int dispatch_alGetInteger1(int param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetIntegerv(ALenum param, ALint *  data); </code> 
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alGetIntegerv(int param, IntBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = alProcAddressTable._addressof_alGetIntegerv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetIntegerv\" not available");
    }
        dispatch_alGetIntegerv1(param, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetIntegerv(ALenum param, ALint *  data); </code> 
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alGetIntegerv1(int param, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetIntegerv(ALenum param, ALint *  data); </code>    */
  public void alGetIntegerv(int param, int[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new ALException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetIntegerv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetIntegerv\" not available");
    }
        dispatch_alGetIntegerv1(param, data, Buffers.SIZEOF_INT * data_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetListener3f(ALenum param, ALfloat *  value1, ALfloat *  value2, ALfloat *  value3); </code> 
      @param value1 a direct or array-backed {@link java.nio.FloatBuffer}
      @param value2 a direct or array-backed {@link java.nio.FloatBuffer}
      @param value3 a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void alGetListener3f(int param, FloatBuffer value1, FloatBuffer value2, FloatBuffer value3)  {

    final boolean value1_is_direct = Buffers.isDirect(value1);
    final boolean value2_is_direct = Buffers.isDirect(value2);
    final boolean value3_is_direct = Buffers.isDirect(value3);
    final long __addr_ = alProcAddressTable._addressof_alGetListener3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetListener3f\" not available");
    }
        dispatch_alGetListener3f1(param, value1_is_direct ? value1 : Buffers.getArray(value1), value1_is_direct ? Buffers.getDirectBufferByteOffset(value1) : Buffers.getIndirectBufferByteOffset(value1), value1_is_direct, value2_is_direct ? value2 : Buffers.getArray(value2), value2_is_direct ? Buffers.getDirectBufferByteOffset(value2) : Buffers.getIndirectBufferByteOffset(value2), value2_is_direct, value3_is_direct ? value3 : Buffers.getArray(value3), value3_is_direct ? Buffers.getDirectBufferByteOffset(value3) : Buffers.getIndirectBufferByteOffset(value3), value3_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetListener3f(ALenum param, ALfloat *  value1, ALfloat *  value2, ALfloat *  value3); </code> 
      @param value1 a direct or array-backed {@link java.nio.FloatBuffer}
      @param value2 a direct or array-backed {@link java.nio.FloatBuffer}
      @param value3 a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_alGetListener3f1(int param, Object value1, int value1_byte_offset, boolean value1_is_direct, Object value2, int value2_byte_offset, boolean value2_is_direct, Object value3, int value3_byte_offset, boolean value3_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetListener3f(ALenum param, ALfloat *  value1, ALfloat *  value2, ALfloat *  value3); </code>    */
  public void alGetListener3f(int param, float[] value1, int value1_offset, float[] value2, int value2_offset, float[] value3, int value3_offset)  {

    if(value1 != null && value1.length <= value1_offset)
      throw new ALException("array offset argument \"value1_offset\" (" + value1_offset + ") equals or exceeds array length (" + value1.length + ")");
    if(value2 != null && value2.length <= value2_offset)
      throw new ALException("array offset argument \"value2_offset\" (" + value2_offset + ") equals or exceeds array length (" + value2.length + ")");
    if(value3 != null && value3.length <= value3_offset)
      throw new ALException("array offset argument \"value3_offset\" (" + value3_offset + ") equals or exceeds array length (" + value3.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetListener3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetListener3f\" not available");
    }
        dispatch_alGetListener3f1(param, value1, Buffers.SIZEOF_FLOAT * value1_offset, false, value2, Buffers.SIZEOF_FLOAT * value2_offset, false, value3, Buffers.SIZEOF_FLOAT * value3_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetListener3i(ALenum param, ALint *  value1, ALint *  value2, ALint *  value3); </code> 
      @param value1 a direct or array-backed {@link java.nio.IntBuffer}
      @param value2 a direct or array-backed {@link java.nio.IntBuffer}
      @param value3 a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alGetListener3i(int param, IntBuffer value1, IntBuffer value2, IntBuffer value3)  {

    final boolean value1_is_direct = Buffers.isDirect(value1);
    final boolean value2_is_direct = Buffers.isDirect(value2);
    final boolean value3_is_direct = Buffers.isDirect(value3);
    final long __addr_ = alProcAddressTable._addressof_alGetListener3i;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetListener3i\" not available");
    }
        dispatch_alGetListener3i1(param, value1_is_direct ? value1 : Buffers.getArray(value1), value1_is_direct ? Buffers.getDirectBufferByteOffset(value1) : Buffers.getIndirectBufferByteOffset(value1), value1_is_direct, value2_is_direct ? value2 : Buffers.getArray(value2), value2_is_direct ? Buffers.getDirectBufferByteOffset(value2) : Buffers.getIndirectBufferByteOffset(value2), value2_is_direct, value3_is_direct ? value3 : Buffers.getArray(value3), value3_is_direct ? Buffers.getDirectBufferByteOffset(value3) : Buffers.getIndirectBufferByteOffset(value3), value3_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetListener3i(ALenum param, ALint *  value1, ALint *  value2, ALint *  value3); </code> 
      @param value1 a direct or array-backed {@link java.nio.IntBuffer}
      @param value2 a direct or array-backed {@link java.nio.IntBuffer}
      @param value3 a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alGetListener3i1(int param, Object value1, int value1_byte_offset, boolean value1_is_direct, Object value2, int value2_byte_offset, boolean value2_is_direct, Object value3, int value3_byte_offset, boolean value3_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetListener3i(ALenum param, ALint *  value1, ALint *  value2, ALint *  value3); </code>    */
  public void alGetListener3i(int param, int[] value1, int value1_offset, int[] value2, int value2_offset, int[] value3, int value3_offset)  {

    if(value1 != null && value1.length <= value1_offset)
      throw new ALException("array offset argument \"value1_offset\" (" + value1_offset + ") equals or exceeds array length (" + value1.length + ")");
    if(value2 != null && value2.length <= value2_offset)
      throw new ALException("array offset argument \"value2_offset\" (" + value2_offset + ") equals or exceeds array length (" + value2.length + ")");
    if(value3 != null && value3.length <= value3_offset)
      throw new ALException("array offset argument \"value3_offset\" (" + value3_offset + ") equals or exceeds array length (" + value3.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetListener3i;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetListener3i\" not available");
    }
        dispatch_alGetListener3i1(param, value1, Buffers.SIZEOF_INT * value1_offset, false, value2, Buffers.SIZEOF_INT * value2_offset, false, value3, Buffers.SIZEOF_INT * value3_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetListenerf(ALenum param, ALfloat *  value); </code> 
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void alGetListenerf(int param, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = alProcAddressTable._addressof_alGetListenerf;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetListenerf\" not available");
    }
        dispatch_alGetListenerf1(param, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetListenerf(ALenum param, ALfloat *  value); </code> 
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_alGetListenerf1(int param, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetListenerf(ALenum param, ALfloat *  value); </code>    */
  public void alGetListenerf(int param, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new ALException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetListenerf;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetListenerf\" not available");
    }
        dispatch_alGetListenerf1(param, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetListenerfv(ALenum param, ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void alGetListenerfv(int param, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alGetListenerfv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetListenerfv\" not available");
    }
        dispatch_alGetListenerfv1(param, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetListenerfv(ALenum param, ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_alGetListenerfv1(int param, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetListenerfv(ALenum param, ALfloat *  values); </code>    */
  public void alGetListenerfv(int param, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetListenerfv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetListenerfv\" not available");
    }
        dispatch_alGetListenerfv1(param, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetListeneri(ALenum param, ALint *  value); </code> 
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alGetListeneri(int param, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = alProcAddressTable._addressof_alGetListeneri;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetListeneri\" not available");
    }
        dispatch_alGetListeneri1(param, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetListeneri(ALenum param, ALint *  value); </code> 
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alGetListeneri1(int param, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetListeneri(ALenum param, ALint *  value); </code>    */
  public void alGetListeneri(int param, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new ALException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetListeneri;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetListeneri\" not available");
    }
        dispatch_alGetListeneri1(param, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetListeneriv(ALenum param, ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alGetListeneriv(int param, IntBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alGetListeneriv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetListeneriv\" not available");
    }
        dispatch_alGetListeneriv1(param, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetListeneriv(ALenum param, ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alGetListeneriv1(int param, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetListeneriv(ALenum param, ALint *  values); </code>    */
  public void alGetListeneriv(int param, int[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetListeneriv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetListeneriv\" not available");
    }
        dispatch_alGetListeneriv1(param, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALproc alGetProcAddress(const ALchar *  fname); </code>    */
  long alGetProcAddress(String fname)  {

    final long __addr_ = alProcAddressTable._addressof_alGetProcAddress;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetProcAddress\" not available");
    }
        return dispatch_alGetProcAddress1(fname, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALproc alGetProcAddress(const ALchar *  fname); </code>    */
  native long dispatch_alGetProcAddress1(String fname, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetSource3f(ALuint sid, ALenum param, ALfloat *  value1, ALfloat *  value2, ALfloat *  value3); </code> 
      @param value1 a direct or array-backed {@link java.nio.FloatBuffer}
      @param value2 a direct or array-backed {@link java.nio.FloatBuffer}
      @param value3 a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void alGetSource3f(int sid, int param, FloatBuffer value1, FloatBuffer value2, FloatBuffer value3)  {

    final boolean value1_is_direct = Buffers.isDirect(value1);
    final boolean value2_is_direct = Buffers.isDirect(value2);
    final boolean value3_is_direct = Buffers.isDirect(value3);
    final long __addr_ = alProcAddressTable._addressof_alGetSource3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetSource3f\" not available");
    }
        dispatch_alGetSource3f1(sid, param, value1_is_direct ? value1 : Buffers.getArray(value1), value1_is_direct ? Buffers.getDirectBufferByteOffset(value1) : Buffers.getIndirectBufferByteOffset(value1), value1_is_direct, value2_is_direct ? value2 : Buffers.getArray(value2), value2_is_direct ? Buffers.getDirectBufferByteOffset(value2) : Buffers.getIndirectBufferByteOffset(value2), value2_is_direct, value3_is_direct ? value3 : Buffers.getArray(value3), value3_is_direct ? Buffers.getDirectBufferByteOffset(value3) : Buffers.getIndirectBufferByteOffset(value3), value3_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetSource3f(ALuint sid, ALenum param, ALfloat *  value1, ALfloat *  value2, ALfloat *  value3); </code> 
      @param value1 a direct or array-backed {@link java.nio.FloatBuffer}
      @param value2 a direct or array-backed {@link java.nio.FloatBuffer}
      @param value3 a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_alGetSource3f1(int sid, int param, Object value1, int value1_byte_offset, boolean value1_is_direct, Object value2, int value2_byte_offset, boolean value2_is_direct, Object value3, int value3_byte_offset, boolean value3_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetSource3f(ALuint sid, ALenum param, ALfloat *  value1, ALfloat *  value2, ALfloat *  value3); </code>    */
  public void alGetSource3f(int sid, int param, float[] value1, int value1_offset, float[] value2, int value2_offset, float[] value3, int value3_offset)  {

    if(value1 != null && value1.length <= value1_offset)
      throw new ALException("array offset argument \"value1_offset\" (" + value1_offset + ") equals or exceeds array length (" + value1.length + ")");
    if(value2 != null && value2.length <= value2_offset)
      throw new ALException("array offset argument \"value2_offset\" (" + value2_offset + ") equals or exceeds array length (" + value2.length + ")");
    if(value3 != null && value3.length <= value3_offset)
      throw new ALException("array offset argument \"value3_offset\" (" + value3_offset + ") equals or exceeds array length (" + value3.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetSource3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetSource3f\" not available");
    }
        dispatch_alGetSource3f1(sid, param, value1, Buffers.SIZEOF_FLOAT * value1_offset, false, value2, Buffers.SIZEOF_FLOAT * value2_offset, false, value3, Buffers.SIZEOF_FLOAT * value3_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetSource3i(ALuint sid, ALenum param, ALint *  value1, ALint *  value2, ALint *  value3); </code> 
      @param value1 a direct or array-backed {@link java.nio.IntBuffer}
      @param value2 a direct or array-backed {@link java.nio.IntBuffer}
      @param value3 a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alGetSource3i(int sid, int param, IntBuffer value1, IntBuffer value2, IntBuffer value3)  {

    final boolean value1_is_direct = Buffers.isDirect(value1);
    final boolean value2_is_direct = Buffers.isDirect(value2);
    final boolean value3_is_direct = Buffers.isDirect(value3);
    final long __addr_ = alProcAddressTable._addressof_alGetSource3i;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetSource3i\" not available");
    }
        dispatch_alGetSource3i1(sid, param, value1_is_direct ? value1 : Buffers.getArray(value1), value1_is_direct ? Buffers.getDirectBufferByteOffset(value1) : Buffers.getIndirectBufferByteOffset(value1), value1_is_direct, value2_is_direct ? value2 : Buffers.getArray(value2), value2_is_direct ? Buffers.getDirectBufferByteOffset(value2) : Buffers.getIndirectBufferByteOffset(value2), value2_is_direct, value3_is_direct ? value3 : Buffers.getArray(value3), value3_is_direct ? Buffers.getDirectBufferByteOffset(value3) : Buffers.getIndirectBufferByteOffset(value3), value3_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetSource3i(ALuint sid, ALenum param, ALint *  value1, ALint *  value2, ALint *  value3); </code> 
      @param value1 a direct or array-backed {@link java.nio.IntBuffer}
      @param value2 a direct or array-backed {@link java.nio.IntBuffer}
      @param value3 a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alGetSource3i1(int sid, int param, Object value1, int value1_byte_offset, boolean value1_is_direct, Object value2, int value2_byte_offset, boolean value2_is_direct, Object value3, int value3_byte_offset, boolean value3_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetSource3i(ALuint sid, ALenum param, ALint *  value1, ALint *  value2, ALint *  value3); </code>    */
  public void alGetSource3i(int sid, int param, int[] value1, int value1_offset, int[] value2, int value2_offset, int[] value3, int value3_offset)  {

    if(value1 != null && value1.length <= value1_offset)
      throw new ALException("array offset argument \"value1_offset\" (" + value1_offset + ") equals or exceeds array length (" + value1.length + ")");
    if(value2 != null && value2.length <= value2_offset)
      throw new ALException("array offset argument \"value2_offset\" (" + value2_offset + ") equals or exceeds array length (" + value2.length + ")");
    if(value3 != null && value3.length <= value3_offset)
      throw new ALException("array offset argument \"value3_offset\" (" + value3_offset + ") equals or exceeds array length (" + value3.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetSource3i;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetSource3i\" not available");
    }
        dispatch_alGetSource3i1(sid, param, value1, Buffers.SIZEOF_INT * value1_offset, false, value2, Buffers.SIZEOF_INT * value2_offset, false, value3, Buffers.SIZEOF_INT * value3_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetSourcef(ALuint sid, ALenum param, ALfloat *  value); </code> 
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void alGetSourcef(int sid, int param, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = alProcAddressTable._addressof_alGetSourcef;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetSourcef\" not available");
    }
        dispatch_alGetSourcef1(sid, param, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetSourcef(ALuint sid, ALenum param, ALfloat *  value); </code> 
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_alGetSourcef1(int sid, int param, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetSourcef(ALuint sid, ALenum param, ALfloat *  value); </code>    */
  public void alGetSourcef(int sid, int param, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new ALException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetSourcef;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetSourcef\" not available");
    }
        dispatch_alGetSourcef1(sid, param, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetSourcefv(ALuint sid, ALenum param, ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void alGetSourcefv(int sid, int param, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alGetSourcefv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetSourcefv\" not available");
    }
        dispatch_alGetSourcefv1(sid, param, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetSourcefv(ALuint sid, ALenum param, ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_alGetSourcefv1(int sid, int param, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetSourcefv(ALuint sid, ALenum param, ALfloat *  values); </code>    */
  public void alGetSourcefv(int sid, int param, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetSourcefv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetSourcefv\" not available");
    }
        dispatch_alGetSourcefv1(sid, param, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetSourcei(ALuint sid, ALenum param, ALint *  value); </code> 
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alGetSourcei(int sid, int param, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = alProcAddressTable._addressof_alGetSourcei;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetSourcei\" not available");
    }
        dispatch_alGetSourcei1(sid, param, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetSourcei(ALuint sid, ALenum param, ALint *  value); </code> 
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alGetSourcei1(int sid, int param, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetSourcei(ALuint sid, ALenum param, ALint *  value); </code>    */
  public void alGetSourcei(int sid, int param, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new ALException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetSourcei;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetSourcei\" not available");
    }
        dispatch_alGetSourcei1(sid, param, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetSourceiv(ALuint sid, ALenum param, ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alGetSourceiv(int sid, int param, IntBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alGetSourceiv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetSourceiv\" not available");
    }
        dispatch_alGetSourceiv1(sid, param, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetSourceiv(ALuint sid, ALenum param, ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alGetSourceiv1(int sid, int param, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alGetSourceiv(ALuint sid, ALenum param, ALint *  values); </code>    */
  public void alGetSourceiv(int sid, int param, int[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alGetSourceiv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetSourceiv\" not available");
    }
        dispatch_alGetSourceiv1(sid, param, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> const ALchar *  alGetString(ALenum param); </code>    */
  public String alGetString(int param)  {

    final long __addr_ = alProcAddressTable._addressof_alGetString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alGetString\" not available");
    }
        return dispatch_alGetString1(param, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> const ALchar *  alGetString(ALenum param); </code>    */
  public native String dispatch_alGetString1(int param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> ALboolean alIsAuxiliaryEffectSlot(ALuint slot); </code>    */
  public boolean alIsAuxiliaryEffectSlot(int slot)  {

    final long __addr_ = alProcAddressTable._addressof_alIsAuxiliaryEffectSlot;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alIsAuxiliaryEffectSlot\" not available");
    }
        return dispatch_alIsAuxiliaryEffectSlot1(slot, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALboolean alIsAuxiliaryEffectSlot(ALuint slot); </code>    */
  public native boolean dispatch_alIsAuxiliaryEffectSlot1(int slot, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> ALboolean alIsBuffer(ALuint bid); </code>    */
  public boolean alIsBuffer(int bid)  {

    final long __addr_ = alProcAddressTable._addressof_alIsBuffer;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alIsBuffer\" not available");
    }
        return dispatch_alIsBuffer1(bid, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALboolean alIsBuffer(ALuint bid); </code>    */
  public native boolean dispatch_alIsBuffer1(int bid, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> ALboolean alIsEffect(ALuint eid); </code>    */
  public boolean alIsEffect(int eid)  {

    final long __addr_ = alProcAddressTable._addressof_alIsEffect;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alIsEffect\" not available");
    }
        return dispatch_alIsEffect1(eid, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALboolean alIsEffect(ALuint eid); </code>    */
  public native boolean dispatch_alIsEffect1(int eid, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> ALboolean alIsEnabled(ALenum capability); </code>    */
  public boolean alIsEnabled(int capability)  {

    final long __addr_ = alProcAddressTable._addressof_alIsEnabled;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alIsEnabled\" not available");
    }
        return dispatch_alIsEnabled1(capability, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALboolean alIsEnabled(ALenum capability); </code>    */
  public native boolean dispatch_alIsEnabled1(int capability, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> ALboolean alIsExtensionPresent(const ALchar *  extname); </code>    */
  public boolean alIsExtensionPresent(String extname)  {

    final long __addr_ = alProcAddressTable._addressof_alIsExtensionPresent;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alIsExtensionPresent\" not available");
    }
        return dispatch_alIsExtensionPresent1(extname, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALboolean alIsExtensionPresent(const ALchar *  extname); </code>    */
  public native boolean dispatch_alIsExtensionPresent1(String extname, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> ALboolean alIsFilter(ALuint fid); </code>    */
  public boolean alIsFilter(int fid)  {

    final long __addr_ = alProcAddressTable._addressof_alIsFilter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alIsFilter\" not available");
    }
        return dispatch_alIsFilter1(fid, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALboolean alIsFilter(ALuint fid); </code>    */
  public native boolean dispatch_alIsFilter1(int fid, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> ALboolean alIsSource(ALuint sid); </code>    */
  public boolean alIsSource(int sid)  {

    final long __addr_ = alProcAddressTable._addressof_alIsSource;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alIsSource\" not available");
    }
        return dispatch_alIsSource1(sid, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALboolean alIsSource(ALuint sid); </code>    */
  public native boolean dispatch_alIsSource1(int sid, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alListener3f(ALenum param, ALfloat value1, ALfloat value2, ALfloat value3); </code>    */
  public void alListener3f(int param, float value1, float value2, float value3)  {

    final long __addr_ = alProcAddressTable._addressof_alListener3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alListener3f\" not available");
    }
        dispatch_alListener3f1(param, value1, value2, value3, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alListener3f(ALenum param, ALfloat value1, ALfloat value2, ALfloat value3); </code>    */
  public native void dispatch_alListener3f1(int param, float value1, float value2, float value3, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alListener3i(ALenum param, ALint value1, ALint value2, ALint value3); </code>    */
  public void alListener3i(int param, int value1, int value2, int value3)  {

    final long __addr_ = alProcAddressTable._addressof_alListener3i;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alListener3i\" not available");
    }
        dispatch_alListener3i1(param, value1, value2, value3, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alListener3i(ALenum param, ALint value1, ALint value2, ALint value3); </code>    */
  public native void dispatch_alListener3i1(int param, int value1, int value2, int value3, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alListenerf(ALenum param, ALfloat value); </code>    */
  public void alListenerf(int param, float value)  {

    final long __addr_ = alProcAddressTable._addressof_alListenerf;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alListenerf\" not available");
    }
        dispatch_alListenerf1(param, value, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alListenerf(ALenum param, ALfloat value); </code>    */
  public native void dispatch_alListenerf1(int param, float value, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alListenerfv(ALenum param, const ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void alListenerfv(int param, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alListenerfv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alListenerfv\" not available");
    }
        dispatch_alListenerfv1(param, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alListenerfv(ALenum param, const ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_alListenerfv1(int param, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alListenerfv(ALenum param, const ALfloat *  values); </code>    */
  public void alListenerfv(int param, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alListenerfv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alListenerfv\" not available");
    }
        dispatch_alListenerfv1(param, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alListeneri(ALenum param, ALint value); </code>    */
  public void alListeneri(int param, int value)  {

    final long __addr_ = alProcAddressTable._addressof_alListeneri;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alListeneri\" not available");
    }
        dispatch_alListeneri1(param, value, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alListeneri(ALenum param, ALint value); </code>    */
  public native void dispatch_alListeneri1(int param, int value, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alListeneriv(ALenum param, const ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alListeneriv(int param, IntBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alListeneriv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alListeneriv\" not available");
    }
        dispatch_alListeneriv1(param, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alListeneriv(ALenum param, const ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alListeneriv1(int param, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alListeneriv(ALenum param, const ALint *  values); </code>    */
  public void alListeneriv(int param, int[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alListeneriv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alListeneriv\" not available");
    }
        dispatch_alListeneriv1(param, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSource3f(ALuint sid, ALenum param, ALfloat value1, ALfloat value2, ALfloat value3); </code>    */
  public void alSource3f(int sid, int param, float value1, float value2, float value3)  {

    final long __addr_ = alProcAddressTable._addressof_alSource3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSource3f\" not available");
    }
        dispatch_alSource3f1(sid, param, value1, value2, value3, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSource3f(ALuint sid, ALenum param, ALfloat value1, ALfloat value2, ALfloat value3); </code>    */
  public native void dispatch_alSource3f1(int sid, int param, float value1, float value2, float value3, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alSource3i(ALuint sid, ALenum param, ALint value1, ALint value2, ALint value3); </code>    */
  public void alSource3i(int sid, int param, int value1, int value2, int value3)  {

    final long __addr_ = alProcAddressTable._addressof_alSource3i;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSource3i\" not available");
    }
        dispatch_alSource3i1(sid, param, value1, value2, value3, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSource3i(ALuint sid, ALenum param, ALint value1, ALint value2, ALint value3); </code>    */
  public native void dispatch_alSource3i1(int sid, int param, int value1, int value2, int value3, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourcePause(ALuint sid); </code>    */
  public void alSourcePause(int sid)  {

    final long __addr_ = alProcAddressTable._addressof_alSourcePause;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSourcePause\" not available");
    }
        dispatch_alSourcePause1(sid, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourcePause(ALuint sid); </code>    */
  public native void dispatch_alSourcePause1(int sid, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourcePausev(ALsizei ns, const ALuint *  sids); </code> 
      @param sids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alSourcePausev(int ns, IntBuffer sids)  {

    final boolean sids_is_direct = Buffers.isDirect(sids);
    final long __addr_ = alProcAddressTable._addressof_alSourcePausev;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSourcePausev\" not available");
    }
        dispatch_alSourcePausev1(ns, sids_is_direct ? sids : Buffers.getArray(sids), sids_is_direct ? Buffers.getDirectBufferByteOffset(sids) : Buffers.getIndirectBufferByteOffset(sids), sids_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourcePausev(ALsizei ns, const ALuint *  sids); </code> 
      @param sids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alSourcePausev1(int ns, Object sids, int sids_byte_offset, boolean sids_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourcePausev(ALsizei ns, const ALuint *  sids); </code>    */
  public void alSourcePausev(int ns, int[] sids, int sids_offset)  {

    if(sids != null && sids.length <= sids_offset)
      throw new ALException("array offset argument \"sids_offset\" (" + sids_offset + ") equals or exceeds array length (" + sids.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alSourcePausev;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSourcePausev\" not available");
    }
        dispatch_alSourcePausev1(ns, sids, Buffers.SIZEOF_INT * sids_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourcePlay(ALuint sid); </code>    */
  public void alSourcePlay(int sid)  {

    final long __addr_ = alProcAddressTable._addressof_alSourcePlay;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSourcePlay\" not available");
    }
        dispatch_alSourcePlay1(sid, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourcePlay(ALuint sid); </code>    */
  public native void dispatch_alSourcePlay1(int sid, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourcePlayv(ALsizei ns, const ALuint *  sids); </code> 
      @param sids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alSourcePlayv(int ns, IntBuffer sids)  {

    final boolean sids_is_direct = Buffers.isDirect(sids);
    final long __addr_ = alProcAddressTable._addressof_alSourcePlayv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSourcePlayv\" not available");
    }
        dispatch_alSourcePlayv1(ns, sids_is_direct ? sids : Buffers.getArray(sids), sids_is_direct ? Buffers.getDirectBufferByteOffset(sids) : Buffers.getIndirectBufferByteOffset(sids), sids_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourcePlayv(ALsizei ns, const ALuint *  sids); </code> 
      @param sids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alSourcePlayv1(int ns, Object sids, int sids_byte_offset, boolean sids_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourcePlayv(ALsizei ns, const ALuint *  sids); </code>    */
  public void alSourcePlayv(int ns, int[] sids, int sids_offset)  {

    if(sids != null && sids.length <= sids_offset)
      throw new ALException("array offset argument \"sids_offset\" (" + sids_offset + ") equals or exceeds array length (" + sids.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alSourcePlayv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSourcePlayv\" not available");
    }
        dispatch_alSourcePlayv1(ns, sids, Buffers.SIZEOF_INT * sids_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourceQueueBuffers(ALuint sid, ALsizei numEntries, const ALuint *  bids); </code> 
      @param bids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alSourceQueueBuffers(int sid, int numEntries, IntBuffer bids)  {

    final boolean bids_is_direct = Buffers.isDirect(bids);
    final long __addr_ = alProcAddressTable._addressof_alSourceQueueBuffers;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSourceQueueBuffers\" not available");
    }
        dispatch_alSourceQueueBuffers1(sid, numEntries, bids_is_direct ? bids : Buffers.getArray(bids), bids_is_direct ? Buffers.getDirectBufferByteOffset(bids) : Buffers.getIndirectBufferByteOffset(bids), bids_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourceQueueBuffers(ALuint sid, ALsizei numEntries, const ALuint *  bids); </code> 
      @param bids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alSourceQueueBuffers1(int sid, int numEntries, Object bids, int bids_byte_offset, boolean bids_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourceQueueBuffers(ALuint sid, ALsizei numEntries, const ALuint *  bids); </code>    */
  public void alSourceQueueBuffers(int sid, int numEntries, int[] bids, int bids_offset)  {

    if(bids != null && bids.length <= bids_offset)
      throw new ALException("array offset argument \"bids_offset\" (" + bids_offset + ") equals or exceeds array length (" + bids.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alSourceQueueBuffers;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSourceQueueBuffers\" not available");
    }
        dispatch_alSourceQueueBuffers1(sid, numEntries, bids, Buffers.SIZEOF_INT * bids_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourceRewind(ALuint sid); </code>    */
  public void alSourceRewind(int sid)  {

    final long __addr_ = alProcAddressTable._addressof_alSourceRewind;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSourceRewind\" not available");
    }
        dispatch_alSourceRewind1(sid, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourceRewind(ALuint sid); </code>    */
  public native void dispatch_alSourceRewind1(int sid, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourceRewindv(ALsizei ns, const ALuint *  sids); </code> 
      @param sids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alSourceRewindv(int ns, IntBuffer sids)  {

    final boolean sids_is_direct = Buffers.isDirect(sids);
    final long __addr_ = alProcAddressTable._addressof_alSourceRewindv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSourceRewindv\" not available");
    }
        dispatch_alSourceRewindv1(ns, sids_is_direct ? sids : Buffers.getArray(sids), sids_is_direct ? Buffers.getDirectBufferByteOffset(sids) : Buffers.getIndirectBufferByteOffset(sids), sids_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourceRewindv(ALsizei ns, const ALuint *  sids); </code> 
      @param sids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alSourceRewindv1(int ns, Object sids, int sids_byte_offset, boolean sids_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourceRewindv(ALsizei ns, const ALuint *  sids); </code>    */
  public void alSourceRewindv(int ns, int[] sids, int sids_offset)  {

    if(sids != null && sids.length <= sids_offset)
      throw new ALException("array offset argument \"sids_offset\" (" + sids_offset + ") equals or exceeds array length (" + sids.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alSourceRewindv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSourceRewindv\" not available");
    }
        dispatch_alSourceRewindv1(ns, sids, Buffers.SIZEOF_INT * sids_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourceStop(ALuint sid); </code>    */
  public void alSourceStop(int sid)  {

    final long __addr_ = alProcAddressTable._addressof_alSourceStop;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSourceStop\" not available");
    }
        dispatch_alSourceStop1(sid, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourceStop(ALuint sid); </code>    */
  public native void dispatch_alSourceStop1(int sid, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourceStopv(ALsizei ns, const ALuint *  sids); </code> 
      @param sids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alSourceStopv(int ns, IntBuffer sids)  {

    final boolean sids_is_direct = Buffers.isDirect(sids);
    final long __addr_ = alProcAddressTable._addressof_alSourceStopv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSourceStopv\" not available");
    }
        dispatch_alSourceStopv1(ns, sids_is_direct ? sids : Buffers.getArray(sids), sids_is_direct ? Buffers.getDirectBufferByteOffset(sids) : Buffers.getIndirectBufferByteOffset(sids), sids_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourceStopv(ALsizei ns, const ALuint *  sids); </code> 
      @param sids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alSourceStopv1(int ns, Object sids, int sids_byte_offset, boolean sids_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourceStopv(ALsizei ns, const ALuint *  sids); </code>    */
  public void alSourceStopv(int ns, int[] sids, int sids_offset)  {

    if(sids != null && sids.length <= sids_offset)
      throw new ALException("array offset argument \"sids_offset\" (" + sids_offset + ") equals or exceeds array length (" + sids.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alSourceStopv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSourceStopv\" not available");
    }
        dispatch_alSourceStopv1(ns, sids, Buffers.SIZEOF_INT * sids_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourceUnqueueBuffers(ALuint sid, ALsizei numEntries, ALuint *  bids); </code> 
      @param bids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alSourceUnqueueBuffers(int sid, int numEntries, IntBuffer bids)  {

    final boolean bids_is_direct = Buffers.isDirect(bids);
    final long __addr_ = alProcAddressTable._addressof_alSourceUnqueueBuffers;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSourceUnqueueBuffers\" not available");
    }
        dispatch_alSourceUnqueueBuffers1(sid, numEntries, bids_is_direct ? bids : Buffers.getArray(bids), bids_is_direct ? Buffers.getDirectBufferByteOffset(bids) : Buffers.getIndirectBufferByteOffset(bids), bids_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourceUnqueueBuffers(ALuint sid, ALsizei numEntries, ALuint *  bids); </code> 
      @param bids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alSourceUnqueueBuffers1(int sid, int numEntries, Object bids, int bids_byte_offset, boolean bids_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourceUnqueueBuffers(ALuint sid, ALsizei numEntries, ALuint *  bids); </code>    */
  public void alSourceUnqueueBuffers(int sid, int numEntries, int[] bids, int bids_offset)  {

    if(bids != null && bids.length <= bids_offset)
      throw new ALException("array offset argument \"bids_offset\" (" + bids_offset + ") equals or exceeds array length (" + bids.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alSourceUnqueueBuffers;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSourceUnqueueBuffers\" not available");
    }
        dispatch_alSourceUnqueueBuffers1(sid, numEntries, bids, Buffers.SIZEOF_INT * bids_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourcef(ALuint sid, ALenum param, ALfloat value); </code>    */
  public void alSourcef(int sid, int param, float value)  {

    final long __addr_ = alProcAddressTable._addressof_alSourcef;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSourcef\" not available");
    }
        dispatch_alSourcef1(sid, param, value, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourcef(ALuint sid, ALenum param, ALfloat value); </code>    */
  public native void dispatch_alSourcef1(int sid, int param, float value, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourcefv(ALuint sid, ALenum param, const ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void alSourcefv(int sid, int param, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alSourcefv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSourcefv\" not available");
    }
        dispatch_alSourcefv1(sid, param, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourcefv(ALuint sid, ALenum param, const ALfloat *  values); </code> 
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_alSourcefv1(int sid, int param, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourcefv(ALuint sid, ALenum param, const ALfloat *  values); </code>    */
  public void alSourcefv(int sid, int param, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alSourcefv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSourcefv\" not available");
    }
        dispatch_alSourcefv1(sid, param, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourcei(ALuint sid, ALenum param, ALint value); </code>    */
  public void alSourcei(int sid, int param, int value)  {

    final long __addr_ = alProcAddressTable._addressof_alSourcei;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSourcei\" not available");
    }
        dispatch_alSourcei1(sid, param, value, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourcei(ALuint sid, ALenum param, ALint value); </code>    */
  public native void dispatch_alSourcei1(int sid, int param, int value, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourceiv(ALuint sid, ALenum param, const ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alSourceiv(int sid, int param, IntBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alProcAddressTable._addressof_alSourceiv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSourceiv\" not available");
    }
        dispatch_alSourceiv1(sid, param, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourceiv(ALuint sid, ALenum param, const ALint *  values); </code> 
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alSourceiv1(int sid, int param, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alSourceiv(ALuint sid, ALenum param, const ALint *  values); </code>    */
  public void alSourceiv(int sid, int param, int[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alProcAddressTable._addressof_alSourceiv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSourceiv\" not available");
    }
        dispatch_alSourceiv1(sid, param, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSpeedOfSound(ALfloat value); </code>    */
  public void alSpeedOfSound(float value)  {

    final long __addr_ = alProcAddressTable._addressof_alSpeedOfSound;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alSpeedOfSound\" not available");
    }
        dispatch_alSpeedOfSound1(value, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alSpeedOfSound(ALfloat value); </code>    */
  public native void dispatch_alSpeedOfSound1(float value, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
  static final DynamicLibraryBundle alDynamicLookupHelper;
  private static final ALProcAddressTable alProcAddressTable;
  
  static {
      alProcAddressTable = new ALProcAddressTable();
      if(null==alProcAddressTable) {
        throw new RuntimeException("Couldn't instantiate ALProcAddressTable");
      }
  
      alDynamicLookupHelper = (DynamicLibraryBundle) 
          AccessController.doPrivileged(new PrivilegedAction() {
              public Object run() {
                  return new DynamicLibraryBundle(new ALDynamicLibraryBundleInfo());
              }
          });
      if(null==alDynamicLookupHelper) {
        throw new RuntimeException("Null ALDynamicLookupHelper");
      }
      if(!alDynamicLookupHelper.isToolLibLoaded()) {
        throw new RuntimeException("Couln't load native AL library");
      }
      if(!alDynamicLookupHelper.isLibComplete()) {
        throw new RuntimeException("Couln't load native AL/JNI glue library");
      }
      alProcAddressTable.reset(alDynamicLookupHelper);
  }
  
  public static ALProcAddressTable getALProcAddressTable() { return alProcAddressTable; }
  
  static long alGetProcAddress(long alGetProcAddressHandle, java.lang.String procname)
  {
      if (alGetProcAddressHandle == 0) {
          throw new RuntimeException("Passed null pointer for method \"alGetProcAddress\"");
      }
      return dispatch_alGetProcAddressStatic(procname, alGetProcAddressHandle);
  }
  
  static native long dispatch_alGetProcAddressStatic(String fname, long procAddress);
  
  // ---- End CustomJavaCode .cfg declarations

} // end of class ALImpl
