/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/procaddress/ProcAddressEmitter.java on Thu Jul 26 21:47:16 CEST 2012 ----! */

package jogamp.openal;

import java.io.UnsupportedEncodingException;
import java.util.*;
import com.jogamp.openal.*;
import jogamp.openal.*;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public abstract class ALCAbstractImpl implements ALC{
  /** Entry point (through function pointer) to C language function: <br> <code> ALCboolean alcCaptureCloseDevice(ALCdevice *  device); </code>    */
  public boolean alcCaptureCloseDevice(ALCdevice device)  {

    final long __addr_ = alcProcAddressTable._addressof_alcCaptureCloseDevice;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alcCaptureCloseDevice\" not available");
    }
        return dispatch_alcCaptureCloseDevice1(((device == null) ? null : device.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALCboolean alcCaptureCloseDevice(ALCdevice *  device); </code>    */
  private native boolean dispatch_alcCaptureCloseDevice1(ByteBuffer device, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> ALCdevice *  alcCaptureOpenDevice(const ALCchar *  devicename, ALCuint frequency, ALCenum format, ALCsizei buffersize); </code> 
      @param devicename a direct or array-backed {@link java.nio.ByteBuffer}   */
  public ALCdevice alcCaptureOpenDevice(ByteBuffer devicename, int frequency, int format, int buffersize)  {

    final boolean devicename_is_direct = Buffers.isDirect(devicename);
    final long __addr_ = alcProcAddressTable._addressof_alcCaptureOpenDevice;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alcCaptureOpenDevice\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_alcCaptureOpenDevice1(devicename_is_direct ? devicename : Buffers.getArray(devicename), devicename_is_direct ? Buffers.getDirectBufferByteOffset(devicename) : Buffers.getIndirectBufferByteOffset(devicename), devicename_is_direct, frequency, format, buffersize, __addr_);
    if (_res == null) return null;
    return ALCdevice.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALCdevice *  alcCaptureOpenDevice(const ALCchar *  devicename, ALCuint frequency, ALCenum format, ALCsizei buffersize); </code> 
      @param devicename a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native ByteBuffer dispatch_alcCaptureOpenDevice1(Object devicename, int devicename_byte_offset, boolean devicename_is_direct, int frequency, int format, int buffersize, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> ALCdevice *  alcCaptureOpenDevice(const ALCchar *  devicename, ALCuint frequency, ALCenum format, ALCsizei buffersize); </code>    */
  public ALCdevice alcCaptureOpenDevice(byte[] devicename, int devicename_offset, int frequency, int format, int buffersize)  {

    if(devicename != null && devicename.length <= devicename_offset)
      throw new ALException("array offset argument \"devicename_offset\" (" + devicename_offset + ") equals or exceeds array length (" + devicename.length + ")");
    final long __addr_ = alcProcAddressTable._addressof_alcCaptureOpenDevice;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alcCaptureOpenDevice\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_alcCaptureOpenDevice1(devicename, devicename_offset, false, frequency, format, buffersize, __addr_);
    if (_res == null) return null;
    return ALCdevice.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alcCaptureSamples(ALCdevice *  device, ALCvoid *  buffer, ALCsizei samples); </code> 
      @param buffer a direct or array-backed {@link java.nio.Buffer}   */
  public void alcCaptureSamples(ALCdevice device, Buffer buffer, int samples)  {

    final boolean buffer_is_direct = Buffers.isDirect(buffer);
    final long __addr_ = alcProcAddressTable._addressof_alcCaptureSamples;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alcCaptureSamples\" not available");
    }
        dispatch_alcCaptureSamples1(((device == null) ? null : device.getBuffer()), buffer_is_direct ? buffer : Buffers.getArray(buffer), buffer_is_direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), buffer_is_direct, samples, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alcCaptureSamples(ALCdevice *  device, ALCvoid *  buffer, ALCsizei samples); </code> 
      @param buffer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_alcCaptureSamples1(ByteBuffer device, Object buffer, int buffer_byte_offset, boolean buffer_is_direct, int samples, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alcCaptureStart(ALCdevice *  device); </code>    */
  public void alcCaptureStart(ALCdevice device)  {

    final long __addr_ = alcProcAddressTable._addressof_alcCaptureStart;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alcCaptureStart\" not available");
    }
        dispatch_alcCaptureStart1(((device == null) ? null : device.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alcCaptureStart(ALCdevice *  device); </code>    */
  private native void dispatch_alcCaptureStart1(ByteBuffer device, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alcCaptureStop(ALCdevice *  device); </code>    */
  public void alcCaptureStop(ALCdevice device)  {

    final long __addr_ = alcProcAddressTable._addressof_alcCaptureStop;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alcCaptureStop\" not available");
    }
        dispatch_alcCaptureStop1(((device == null) ? null : device.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alcCaptureStop(ALCdevice *  device); </code>    */
  private native void dispatch_alcCaptureStop1(ByteBuffer device, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> ALCboolean alcCloseDevice(ALCdevice *  device); </code>    */
  public boolean alcCloseDevice(ALCdevice device)  {

    final long __addr_ = alcProcAddressTable._addressof_alcCloseDevice;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alcCloseDevice\" not available");
    }
        return dispatch_alcCloseDevice1(((device == null) ? null : device.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALCboolean alcCloseDevice(ALCdevice *  device); </code>    */
  private native boolean dispatch_alcCloseDevice1(ByteBuffer device, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> ALCcontext *  alcCreateContext(ALCdevice *  device, const ALCint *  attrlist); </code> 
      @param attrlist a direct or array-backed {@link java.nio.IntBuffer}   */
  public ALCcontext alcCreateContext(ALCdevice device, IntBuffer attrlist)  {

    final boolean attrlist_is_direct = Buffers.isDirect(attrlist);
    final long __addr_ = alcProcAddressTable._addressof_alcCreateContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alcCreateContext\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_alcCreateContext1(((device == null) ? null : device.getBuffer()), attrlist_is_direct ? attrlist : Buffers.getArray(attrlist), attrlist_is_direct ? Buffers.getDirectBufferByteOffset(attrlist) : Buffers.getIndirectBufferByteOffset(attrlist), attrlist_is_direct, __addr_);
    if (_res == null) return null;
    return ALCcontext.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALCcontext *  alcCreateContext(ALCdevice *  device, const ALCint *  attrlist); </code> 
      @param attrlist a direct or array-backed {@link java.nio.IntBuffer}   */
  private native ByteBuffer dispatch_alcCreateContext1(ByteBuffer device, Object attrlist, int attrlist_byte_offset, boolean attrlist_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> ALCcontext *  alcCreateContext(ALCdevice *  device, const ALCint *  attrlist); </code>    */
  public ALCcontext alcCreateContext(ALCdevice device, int[] attrlist, int attrlist_offset)  {

    if(attrlist != null && attrlist.length <= attrlist_offset)
      throw new ALException("array offset argument \"attrlist_offset\" (" + attrlist_offset + ") equals or exceeds array length (" + attrlist.length + ")");
    final long __addr_ = alcProcAddressTable._addressof_alcCreateContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alcCreateContext\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_alcCreateContext1(((device == null) ? null : device.getBuffer()), attrlist, Buffers.SIZEOF_INT * attrlist_offset, false, __addr_);
    if (_res == null) return null;
    return ALCcontext.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alcDestroyContext(ALCcontext *  context); </code>    */
  public void alcDestroyContext(ALCcontext context)  {

    final long __addr_ = alcProcAddressTable._addressof_alcDestroyContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alcDestroyContext\" not available");
    }
        dispatch_alcDestroyContext1(((context == null) ? null : context.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alcDestroyContext(ALCcontext *  context); </code>    */
  private native void dispatch_alcDestroyContext1(ByteBuffer context, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> ALCdevice *  alcGetContextsDevice(ALCcontext *  context); </code>    */
  public ALCdevice alcGetContextsDevice(ALCcontext context)  {

    final long __addr_ = alcProcAddressTable._addressof_alcGetContextsDevice;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alcGetContextsDevice\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_alcGetContextsDevice1(((context == null) ? null : context.getBuffer()), __addr_);
    if (_res == null) return null;
    return ALCdevice.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALCdevice *  alcGetContextsDevice(ALCcontext *  context); </code>    */
  private native ByteBuffer dispatch_alcGetContextsDevice1(ByteBuffer context, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> ALCcontext *  alcGetCurrentContext(ALCvoid); </code>    */
  public ALCcontext alcGetCurrentContext()  {

    final long __addr_ = alcProcAddressTable._addressof_alcGetCurrentContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alcGetCurrentContext\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_alcGetCurrentContext1(__addr_);
    if (_res == null) return null;
    return ALCcontext.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALCcontext *  alcGetCurrentContext(ALCvoid); </code>    */
  private native ByteBuffer dispatch_alcGetCurrentContext1(long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> ALCenum alcGetEnumValue(ALCdevice *  device, const ALCchar *  enumname); </code> 
      @param enumname a direct or array-backed {@link java.nio.ByteBuffer}   */
  public int alcGetEnumValue(ALCdevice device, ByteBuffer enumname)  {

    final boolean enumname_is_direct = Buffers.isDirect(enumname);
    final long __addr_ = alcProcAddressTable._addressof_alcGetEnumValue;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alcGetEnumValue\" not available");
    }
        return dispatch_alcGetEnumValue1(((device == null) ? null : device.getBuffer()), enumname_is_direct ? enumname : Buffers.getArray(enumname), enumname_is_direct ? Buffers.getDirectBufferByteOffset(enumname) : Buffers.getIndirectBufferByteOffset(enumname), enumname_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALCenum alcGetEnumValue(ALCdevice *  device, const ALCchar *  enumname); </code> 
      @param enumname a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native int dispatch_alcGetEnumValue1(ByteBuffer device, Object enumname, int enumname_byte_offset, boolean enumname_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> ALCenum alcGetEnumValue(ALCdevice *  device, const ALCchar *  enumname); </code>    */
  public int alcGetEnumValue(ALCdevice device, byte[] enumname, int enumname_offset)  {

    if(enumname != null && enumname.length <= enumname_offset)
      throw new ALException("array offset argument \"enumname_offset\" (" + enumname_offset + ") equals or exceeds array length (" + enumname.length + ")");
    final long __addr_ = alcProcAddressTable._addressof_alcGetEnumValue;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alcGetEnumValue\" not available");
    }
        return dispatch_alcGetEnumValue1(((device == null) ? null : device.getBuffer()), enumname, enumname_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALCenum alcGetError(ALCdevice *  device); </code>    */
  public int alcGetError(ALCdevice device)  {

    final long __addr_ = alcProcAddressTable._addressof_alcGetError;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alcGetError\" not available");
    }
        return dispatch_alcGetError1(((device == null) ? null : device.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALCenum alcGetError(ALCdevice *  device); </code>    */
  private native int dispatch_alcGetError1(ByteBuffer device, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alcGetIntegerv(ALCdevice *  device, ALCenum param, ALCsizei size, ALCint *  data); </code> 
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alcGetIntegerv(ALCdevice device, int param, int size, IntBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = alcProcAddressTable._addressof_alcGetIntegerv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alcGetIntegerv\" not available");
    }
        dispatch_alcGetIntegerv1(((device == null) ? null : device.getBuffer()), param, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alcGetIntegerv(ALCdevice *  device, ALCenum param, ALCsizei size, ALCint *  data); </code> 
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alcGetIntegerv1(ByteBuffer device, int param, int size, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alcGetIntegerv(ALCdevice *  device, ALCenum param, ALCsizei size, ALCint *  data); </code>    */
  public void alcGetIntegerv(ALCdevice device, int param, int size, int[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new ALException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = alcProcAddressTable._addressof_alcGetIntegerv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alcGetIntegerv\" not available");
    }
        dispatch_alcGetIntegerv1(((device == null) ? null : device.getBuffer()), param, size, data, Buffers.SIZEOF_INT * data_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALCboolean alcIsExtensionPresent(ALCdevice *  device, const ALCchar *  extname); </code>    */
  public boolean alcIsExtensionPresent(ALCdevice device, String extname)  {

    final long __addr_ = alcProcAddressTable._addressof_alcIsExtensionPresent;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alcIsExtensionPresent\" not available");
    }
        return dispatch_alcIsExtensionPresent1(((device == null) ? null : device.getBuffer()), extname, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALCboolean alcIsExtensionPresent(ALCdevice *  device, const ALCchar *  extname); </code>    */
  private native boolean dispatch_alcIsExtensionPresent1(ByteBuffer device, String extname, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> ALCboolean alcMakeContextCurrent(ALCcontext *  context); </code>    */
  public boolean alcMakeContextCurrent(ALCcontext context)  {

    final long __addr_ = alcProcAddressTable._addressof_alcMakeContextCurrent;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alcMakeContextCurrent\" not available");
    }
        return dispatch_alcMakeContextCurrent1(((context == null) ? null : context.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALCboolean alcMakeContextCurrent(ALCcontext *  context); </code>    */
  private native boolean dispatch_alcMakeContextCurrent1(ByteBuffer context, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> ALCdevice *  alcOpenDevice(const ALCchar *  devicename); </code>    */
  public ALCdevice alcOpenDevice(String devicename)  {

    final long __addr_ = alcProcAddressTable._addressof_alcOpenDevice;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alcOpenDevice\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_alcOpenDevice1(devicename, __addr_);
    if (_res == null) return null;
    return ALCdevice.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> ALCdevice *  alcOpenDevice(const ALCchar *  devicename); </code>    */
  private native ByteBuffer dispatch_alcOpenDevice1(String devicename, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alcProcessContext(ALCcontext *  context); </code>    */
  public void alcProcessContext(ALCcontext context)  {

    final long __addr_ = alcProcAddressTable._addressof_alcProcessContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alcProcessContext\" not available");
    }
        dispatch_alcProcessContext1(((context == null) ? null : context.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alcProcessContext(ALCcontext *  context); </code>    */
  private native void dispatch_alcProcessContext1(ByteBuffer context, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void alcSuspendContext(ALCcontext *  context); </code>    */
  public void alcSuspendContext(ALCcontext context)  {

    final long __addr_ = alcProcAddressTable._addressof_alcSuspendContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"alcSuspendContext\" not available");
    }
        dispatch_alcSuspendContext1(((context == null) ? null : context.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void alcSuspendContext(ALCcontext *  context); </code>    */
  private native void dispatch_alcSuspendContext1(ByteBuffer context, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
  private static final ALCProcAddressTable alcProcAddressTable;
  
  static {
      alcProcAddressTable = new ALCProcAddressTable();
      if(null==alcProcAddressTable) {
        throw new RuntimeException("Couldn't instantiate ALCProcAddressTable");
      }
      alcProcAddressTable.reset(ALImpl.alDynamicLookupHelper);
  }
  
  public static ALCProcAddressTable getALCProcAddressTable() { return alcProcAddressTable; }
  
  // ---- End CustomJavaCode .cfg declarations

} // end of class ALCAbstractImpl
