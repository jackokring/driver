/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Fri Aug 03 06:28:30 CEST 2012 ----! */

package jogamp.opengl.egl;

import java.util.*;
import javax.media.opengl.*;
import javax.media.opengl.fixedfunc.*;
import jogamp.opengl.*;
import com.jogamp.gluegen.runtime.opengl.GLProcAddressResolver;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class EGL {

  /** Part of khronos_boolean_enum_t<br>Defined as part of enum type "khronos_boolean_enum_t" */
  public static final int KHRONOS_FALSE = 0;
  /** Part of khronos_boolean_enum_t<br>Defined as part of enum type "khronos_boolean_enum_t" */
  public static final int KHRONOS_TRUE = 1;
  /** Part of khronos_boolean_enum_t<br>Defined as part of enum type "khronos_boolean_enum_t" */
  public static final long KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = 2147483647;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_FALSE = 0;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_TRUE = 1;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_SUCCESS = 0x3000;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_NOT_INITIALIZED = 0x3001;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_ACCESS = 0x3002;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_ALLOC = 0x3003;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_ATTRIBUTE = 0x3004;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_CONFIG = 0x3005;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_CONTEXT = 0x3006;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_CURRENT_SURFACE = 0x3007;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_DISPLAY = 0x3008;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_MATCH = 0x3009;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_NATIVE_PIXMAP = 0x300A;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_NATIVE_WINDOW = 0x300B;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_PARAMETER = 0x300C;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_SURFACE = 0x300D;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_CONTEXT_LOST = 0x300E;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BUFFER_SIZE = 0x3020;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_ALPHA_SIZE = 0x3021;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BLUE_SIZE = 0x3022;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_GREEN_SIZE = 0x3023;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_RED_SIZE = 0x3024;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_DEPTH_SIZE = 0x3025;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_STENCIL_SIZE = 0x3026;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_CONFIG_CAVEAT = 0x3027;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_CONFIG_ID = 0x3028;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_LEVEL = 0x3029;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MAX_PBUFFER_HEIGHT = 0x302A;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MAX_PBUFFER_PIXELS = 0x302B;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MAX_PBUFFER_WIDTH = 0x302C;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_NATIVE_RENDERABLE = 0x302D;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_NATIVE_VISUAL_ID = 0x302E;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_NATIVE_VISUAL_TYPE = 0x302F;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_SAMPLES = 0x3031;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_SAMPLE_BUFFERS = 0x3032;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_SURFACE_TYPE = 0x3033;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_TRANSPARENT_TYPE = 0x3034;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_TRANSPARENT_BLUE_VALUE = 0x3035;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_TRANSPARENT_GREEN_VALUE = 0x3036;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_TRANSPARENT_RED_VALUE = 0x3037;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_NONE = 0x3038;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BIND_TO_TEXTURE_RGB = 0x3039;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BIND_TO_TEXTURE_RGBA = 0x303A;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MIN_SWAP_INTERVAL = 0x303B;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MAX_SWAP_INTERVAL = 0x303C;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_LUMINANCE_SIZE = 0x303D;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_ALPHA_MASK_SIZE = 0x303E;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_COLOR_BUFFER_TYPE = 0x303F;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_RENDERABLE_TYPE = 0x3040;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MATCH_NATIVE_PIXMAP = 0x3041;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_CONFORMANT = 0x3042;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_SLOW_CONFIG = 0x3050;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_NON_CONFORMANT_CONFIG = 0x3051;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_TRANSPARENT_RGB = 0x3052;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_RGB_BUFFER = 0x308E;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_LUMINANCE_BUFFER = 0x308F;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_NO_TEXTURE = 0x305C;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_TEXTURE_RGB = 0x305D;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_TEXTURE_RGBA = 0x305E;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_TEXTURE_2D = 0x305F;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_PBUFFER_BIT = 0x0001;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_PIXMAP_BIT = 0x0002;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_WINDOW_BIT = 0x0004;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_VG_COLORSPACE_LINEAR_BIT = 0x0020;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_VG_ALPHA_FORMAT_PRE_BIT = 0x0040;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MULTISAMPLE_RESOLVE_BOX_BIT = 0x0200;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_SWAP_BEHAVIOR_PRESERVED_BIT = 0x0400;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_OPENGL_ES_BIT = 0x0001;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_OPENVG_BIT = 0x0002;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_OPENGL_ES2_BIT = 0x0004;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_OPENGL_BIT = 0x0008;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_VENDOR = 0x3053;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_VERSION = 0x3054;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_EXTENSIONS = 0x3055;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_CLIENT_APIS = 0x308D;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_HEIGHT = 0x3056;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_WIDTH = 0x3057;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_LARGEST_PBUFFER = 0x3058;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_TEXTURE_FORMAT = 0x3080;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_TEXTURE_TARGET = 0x3081;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MIPMAP_TEXTURE = 0x3082;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MIPMAP_LEVEL = 0x3083;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_RENDER_BUFFER = 0x3086;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_VG_COLORSPACE = 0x3087;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_VG_ALPHA_FORMAT = 0x3088;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_HORIZONTAL_RESOLUTION = 0x3090;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_VERTICAL_RESOLUTION = 0x3091;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_PIXEL_ASPECT_RATIO = 0x3092;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_SWAP_BEHAVIOR = 0x3093;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MULTISAMPLE_RESOLVE = 0x3099;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BACK_BUFFER = 0x3084;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_SINGLE_BUFFER = 0x3085;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_VG_COLORSPACE_sRGB = 0x3089;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_VG_COLORSPACE_LINEAR = 0x308A;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_VG_ALPHA_FORMAT_NONPRE = 0x308B;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_VG_ALPHA_FORMAT_PRE = 0x308C;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_DISPLAY_SCALING = 10000;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BUFFER_PRESERVED = 0x3094;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BUFFER_DESTROYED = 0x3095;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_OPENVG_IMAGE = 0x3096;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_CONTEXT_CLIENT_TYPE = 0x3097;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MULTISAMPLE_RESOLVE_DEFAULT = 0x309A;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MULTISAMPLE_RESOLVE_BOX = 0x309B;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_OPENGL_ES_API = 0x30A0;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_OPENVG_API = 0x30A1;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_OPENGL_API = 0x30A2;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_DRAW = 0x3059;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_READ = 0x305A;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_CORE_NATIVE_ENGINE = 0x305B;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_COLORSPACE = 0x3087;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_ALPHA_FORMAT = 0x3088;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_COLORSPACE_sRGB = 0x3089;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_COLORSPACE_LINEAR = 0x308A;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_ALPHA_FORMAT_NONPRE = 0x308B;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_ALPHA_FORMAT_PRE = 0x308C;

  /** Entry point to C language function: <code> EGLBoolean eglBindAPI(EGLenum api); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglBindAPI(int api)  {

    final long __addr_ = _table._addressof_eglBindAPI;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglBindAPI\" not available");
    }
        return dispatch_eglBindAPI1(api, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglBindAPI(EGLenum api); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglBindAPI1(int api, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglBindTexImage(long dpy, long surface, int buffer)  {

    final long __addr_ = _table._addressof_eglBindTexImage;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglBindTexImage\" not available");
    }
        return dispatch_eglBindTexImage1(dpy, surface, buffer, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglBindTexImage1(long dpy, long surface, int buffer, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglChooseConfig(EGLDisplay dpy, const EGLint *  attrib_list, EGLConfig *  configs, EGLint config_size, EGLint *  num_config); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}
      @param configs a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param num_config a direct or array-backed {@link java.nio.IntBuffer}   */
  public static boolean eglChooseConfig(long dpy, IntBuffer attrib_list, PointerBuffer configs, int config_size, IntBuffer num_config)  {

    final boolean attrib_list_is_direct = Buffers.isDirect(attrib_list);
    final boolean configs_is_direct = Buffers.isDirect(configs);
    final boolean num_config_is_direct = Buffers.isDirect(num_config);
    final long __addr_ = _table._addressof_eglChooseConfig;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglChooseConfig\" not available");
    }
        return dispatch_eglChooseConfig1(dpy, attrib_list_is_direct ? attrib_list : Buffers.getArray(attrib_list), attrib_list_is_direct ? Buffers.getDirectBufferByteOffset(attrib_list) : Buffers.getIndirectBufferByteOffset(attrib_list), attrib_list_is_direct, configs_is_direct ? ( configs != null ? configs.getBuffer() : null ) : Buffers.getArray(configs), configs_is_direct ? Buffers.getDirectBufferByteOffset(configs) : Buffers.getIndirectBufferByteOffset(configs), configs_is_direct, config_size, num_config_is_direct ? num_config : Buffers.getArray(num_config), num_config_is_direct ? Buffers.getDirectBufferByteOffset(num_config) : Buffers.getIndirectBufferByteOffset(num_config), num_config_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglChooseConfig(EGLDisplay dpy, const EGLint *  attrib_list, EGLConfig *  configs, EGLint config_size, EGLint *  num_config); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}
      @param configs a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param num_config a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_eglChooseConfig1(long dpy, Object attrib_list, int attrib_list_byte_offset, boolean attrib_list_is_direct, Object configs, int configs_byte_offset, boolean configs_is_direct, int config_size, Object num_config, int num_config_byte_offset, boolean num_config_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglChooseConfig(EGLDisplay dpy, const EGLint *  attrib_list, EGLConfig *  configs, EGLint config_size, EGLint *  num_config); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param configs a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static boolean eglChooseConfig(long dpy, int[] attrib_list, int attrib_list_offset, PointerBuffer configs, int config_size, int[] num_config, int num_config_offset)  {

    if(attrib_list != null && attrib_list.length <= attrib_list_offset)
      throw new RuntimeException("array offset argument \"attrib_list_offset\" (" + attrib_list_offset + ") equals or exceeds array length (" + attrib_list.length + ")");
    final boolean configs_is_direct = Buffers.isDirect(configs);
    if(num_config != null && num_config.length <= num_config_offset)
      throw new RuntimeException("array offset argument \"num_config_offset\" (" + num_config_offset + ") equals or exceeds array length (" + num_config.length + ")");
    final long __addr_ = _table._addressof_eglChooseConfig;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglChooseConfig\" not available");
    }
        return dispatch_eglChooseConfig1(dpy, attrib_list, Buffers.SIZEOF_INT * attrib_list_offset, false, configs_is_direct ? ( configs != null ? configs.getBuffer() : null ) : Buffers.getArray(configs), configs_is_direct ? Buffers.getDirectBufferByteOffset(configs) : Buffers.getIndirectBufferByteOffset(configs), configs_is_direct, config_size, num_config, Buffers.SIZEOF_INT * num_config_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglCopyBuffers(long dpy, long surface, long target)  {

    final long __addr_ = _table._addressof_eglCopyBuffers;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCopyBuffers\" not available");
    }
        return dispatch_eglCopyBuffers1(dpy, surface, target, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglCopyBuffers1(long dpy, long surface, long target, long procAddress);

  /** Entry point to C language function: <code> EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  public static long eglCreateContext(long dpy, long config, long share_context, IntBuffer attrib_list)  {

    final boolean attrib_list_is_direct = Buffers.isDirect(attrib_list);
    final long __addr_ = _table._addressof_eglCreateContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreateContext\" not available");
    }
        return dispatch_eglCreateContext1(dpy, config, share_context, attrib_list_is_direct ? attrib_list : Buffers.getArray(attrib_list), attrib_list_is_direct ? Buffers.getDirectBufferByteOffset(attrib_list) : Buffers.getIndirectBufferByteOffset(attrib_list), attrib_list_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native long dispatch_eglCreateContext1(long dpy, long config, long share_context, Object attrib_list, int attrib_list_byte_offset, boolean attrib_list_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static long eglCreateContext(long dpy, long config, long share_context, int[] attrib_list, int attrib_list_offset)  {

    if(attrib_list != null && attrib_list.length <= attrib_list_offset)
      throw new RuntimeException("array offset argument \"attrib_list_offset\" (" + attrib_list_offset + ") equals or exceeds array length (" + attrib_list.length + ")");
    final long __addr_ = _table._addressof_eglCreateContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreateContext\" not available");
    }
        return dispatch_eglCreateContext1(dpy, config, share_context, attrib_list, Buffers.SIZEOF_INT * attrib_list_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePbufferFromClientBuffer(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param buffer a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public static long eglCreatePbufferFromClientBuffer(long dpy, int buftype, Buffer buffer, long config, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(buffer))
      throw new RuntimeException("Argument \"buffer\" is not a direct buffer");
    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreatePbufferFromClientBuffer;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreatePbufferFromClientBuffer\" not available");
    }
        return dispatch_eglCreatePbufferFromClientBuffer0(dpy, buftype, buffer, Buffers.getDirectBufferByteOffset(buffer), config, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePbufferFromClientBuffer(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param buffer a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private static native long dispatch_eglCreatePbufferFromClientBuffer0(long dpy, int buftype, Object buffer, int buffer_byte_offset, long config, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  public static long eglCreatePbufferSurface(long dpy, long config, IntBuffer attrib_list)  {

    final boolean attrib_list_is_direct = Buffers.isDirect(attrib_list);
    final long __addr_ = _table._addressof_eglCreatePbufferSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreatePbufferSurface\" not available");
    }
        return dispatch_eglCreatePbufferSurface1(dpy, config, attrib_list_is_direct ? attrib_list : Buffers.getArray(attrib_list), attrib_list_is_direct ? Buffers.getDirectBufferByteOffset(attrib_list) : Buffers.getIndirectBufferByteOffset(attrib_list), attrib_list_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native long dispatch_eglCreatePbufferSurface1(long dpy, long config, Object attrib_list, int attrib_list_byte_offset, boolean attrib_list_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static long eglCreatePbufferSurface(long dpy, long config, int[] attrib_list, int attrib_list_offset)  {

    if(attrib_list != null && attrib_list.length <= attrib_list_offset)
      throw new RuntimeException("array offset argument \"attrib_list_offset\" (" + attrib_list_offset + ") equals or exceeds array length (" + attrib_list.length + ")");
    final long __addr_ = _table._addressof_eglCreatePbufferSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreatePbufferSurface\" not available");
    }
        return dispatch_eglCreatePbufferSurface1(dpy, config, attrib_list, Buffers.SIZEOF_INT * attrib_list_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  public static long eglCreatePixmapSurface(long dpy, long config, long pixmap, IntBuffer attrib_list)  {

    final boolean attrib_list_is_direct = Buffers.isDirect(attrib_list);
    final long __addr_ = _table._addressof_eglCreatePixmapSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreatePixmapSurface\" not available");
    }
        return dispatch_eglCreatePixmapSurface1(dpy, config, pixmap, attrib_list_is_direct ? attrib_list : Buffers.getArray(attrib_list), attrib_list_is_direct ? Buffers.getDirectBufferByteOffset(attrib_list) : Buffers.getIndirectBufferByteOffset(attrib_list), attrib_list_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native long dispatch_eglCreatePixmapSurface1(long dpy, long config, long pixmap, Object attrib_list, int attrib_list_byte_offset, boolean attrib_list_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static long eglCreatePixmapSurface(long dpy, long config, long pixmap, int[] attrib_list, int attrib_list_offset)  {

    if(attrib_list != null && attrib_list.length <= attrib_list_offset)
      throw new RuntimeException("array offset argument \"attrib_list_offset\" (" + attrib_list_offset + ") equals or exceeds array length (" + attrib_list.length + ")");
    final long __addr_ = _table._addressof_eglCreatePixmapSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreatePixmapSurface\" not available");
    }
        return dispatch_eglCreatePixmapSurface1(dpy, config, pixmap, attrib_list, Buffers.SIZEOF_INT * attrib_list_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreateWindowSurface(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  public static long eglCreateWindowSurface(long dpy, long config, long win, IntBuffer attrib_list)  {

    final boolean attrib_list_is_direct = Buffers.isDirect(attrib_list);
    final long __addr_ = _table._addressof_eglCreateWindowSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreateWindowSurface\" not available");
    }
        return dispatch_eglCreateWindowSurface1(dpy, config, win, attrib_list_is_direct ? attrib_list : Buffers.getArray(attrib_list), attrib_list_is_direct ? Buffers.getDirectBufferByteOffset(attrib_list) : Buffers.getIndirectBufferByteOffset(attrib_list), attrib_list_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreateWindowSurface(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native long dispatch_eglCreateWindowSurface1(long dpy, long config, long win, Object attrib_list, int attrib_list_byte_offset, boolean attrib_list_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreateWindowSurface(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static long eglCreateWindowSurface(long dpy, long config, long win, int[] attrib_list, int attrib_list_offset)  {

    if(attrib_list != null && attrib_list.length <= attrib_list_offset)
      throw new RuntimeException("array offset argument \"attrib_list_offset\" (" + attrib_list_offset + ") equals or exceeds array length (" + attrib_list.length + ")");
    final long __addr_ = _table._addressof_eglCreateWindowSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreateWindowSurface\" not available");
    }
        return dispatch_eglCreateWindowSurface1(dpy, config, win, attrib_list, Buffers.SIZEOF_INT * attrib_list_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroyContext(EGLDisplay dpy, EGLContext ctx); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglDestroyContext(long dpy, long ctx)  {

    final long __addr_ = _table._addressof_eglDestroyContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglDestroyContext\" not available");
    }
        return dispatch_eglDestroyContext1(dpy, ctx, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroyContext(EGLDisplay dpy, EGLContext ctx); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglDestroyContext1(long dpy, long ctx, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglDestroySurface(EGLDisplay dpy, EGLSurface surface); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglDestroySurface(long dpy, long surface)  {

    final long __addr_ = _table._addressof_eglDestroySurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglDestroySurface\" not available");
    }
        return dispatch_eglDestroySurface1(dpy, surface, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroySurface(EGLDisplay dpy, EGLSurface surface); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglDestroySurface1(long dpy, long surface, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public static boolean eglGetConfigAttrib(long dpy, long config, int attribute, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _table._addressof_eglGetConfigAttrib;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetConfigAttrib\" not available");
    }
        return dispatch_eglGetConfigAttrib1(dpy, config, attribute, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_eglGetConfigAttrib1(long dpy, long config, int attribute, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglGetConfigAttrib(long dpy, long config, int attribute, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new RuntimeException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _table._addressof_eglGetConfigAttrib;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetConfigAttrib\" not available");
    }
        return dispatch_eglGetConfigAttrib1(dpy, config, attribute, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigs(EGLDisplay dpy, EGLConfig *  configs, EGLint config_size, EGLint *  num_config); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param configs a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param num_config a direct or array-backed {@link java.nio.IntBuffer}   */
  public static boolean eglGetConfigs(long dpy, PointerBuffer configs, int config_size, IntBuffer num_config)  {

    final boolean configs_is_direct = Buffers.isDirect(configs);
    final boolean num_config_is_direct = Buffers.isDirect(num_config);
    final long __addr_ = _table._addressof_eglGetConfigs;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetConfigs\" not available");
    }
        return dispatch_eglGetConfigs1(dpy, configs_is_direct ? ( configs != null ? configs.getBuffer() : null ) : Buffers.getArray(configs), configs_is_direct ? Buffers.getDirectBufferByteOffset(configs) : Buffers.getIndirectBufferByteOffset(configs), configs_is_direct, config_size, num_config_is_direct ? num_config : Buffers.getArray(num_config), num_config_is_direct ? Buffers.getDirectBufferByteOffset(num_config) : Buffers.getIndirectBufferByteOffset(num_config), num_config_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigs(EGLDisplay dpy, EGLConfig *  configs, EGLint config_size, EGLint *  num_config); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param configs a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param num_config a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_eglGetConfigs1(long dpy, Object configs, int configs_byte_offset, boolean configs_is_direct, int config_size, Object num_config, int num_config_byte_offset, boolean num_config_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigs(EGLDisplay dpy, EGLConfig *  configs, EGLint config_size, EGLint *  num_config); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param configs a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static boolean eglGetConfigs(long dpy, PointerBuffer configs, int config_size, int[] num_config, int num_config_offset)  {

    final boolean configs_is_direct = Buffers.isDirect(configs);
    if(num_config != null && num_config.length <= num_config_offset)
      throw new RuntimeException("array offset argument \"num_config_offset\" (" + num_config_offset + ") equals or exceeds array length (" + num_config.length + ")");
    final long __addr_ = _table._addressof_eglGetConfigs;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetConfigs\" not available");
    }
        return dispatch_eglGetConfigs1(dpy, configs_is_direct ? ( configs != null ? configs.getBuffer() : null ) : Buffers.getArray(configs), configs_is_direct ? Buffers.getDirectBufferByteOffset(configs) : Buffers.getIndirectBufferByteOffset(configs), configs_is_direct, config_size, num_config, Buffers.SIZEOF_INT * num_config_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLContext eglGetCurrentContext(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static long eglGetCurrentContext()  {

    final long __addr_ = _table._addressof_eglGetCurrentContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetCurrentContext\" not available");
    }
        return dispatch_eglGetCurrentContext1(__addr_);
  }

  /** Entry point to C language function: <code> EGLContext eglGetCurrentContext(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native long dispatch_eglGetCurrentContext1(long procAddress);

  /** Entry point to C language function: <code> EGLDisplay eglGetCurrentDisplay(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static long eglGetCurrentDisplay()  {

    final long __addr_ = _table._addressof_eglGetCurrentDisplay;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetCurrentDisplay\" not available");
    }
        return dispatch_eglGetCurrentDisplay1(__addr_);
  }

  /** Entry point to C language function: <code> EGLDisplay eglGetCurrentDisplay(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native long dispatch_eglGetCurrentDisplay1(long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglGetCurrentSurface(EGLint readdraw); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static long eglGetCurrentSurface(int readdraw)  {

    final long __addr_ = _table._addressof_eglGetCurrentSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetCurrentSurface\" not available");
    }
        return dispatch_eglGetCurrentSurface1(readdraw, __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglGetCurrentSurface(EGLint readdraw); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native long dispatch_eglGetCurrentSurface1(int readdraw, long procAddress);

  /** Entry point to C language function: <code> EGLDisplay eglGetDisplay(EGLNativeDisplayType display_id); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static long eglGetDisplay(long display_id)  {

    final long __addr_ = _table._addressof_eglGetDisplay;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetDisplay\" not available");
    }
        return dispatch_eglGetDisplay1(display_id, __addr_);
  }

  /** Entry point to C language function: <code> EGLDisplay eglGetDisplay(EGLNativeDisplayType display_id); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native long dispatch_eglGetDisplay1(long display_id, long procAddress);

  /** Entry point to C language function: <code> EGLint eglGetError(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static int eglGetError()  {

    final long __addr_ = _table._addressof_eglGetError;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetError\" not available");
    }
        return dispatch_eglGetError1(__addr_);
  }

  /** Entry point to C language function: <code> EGLint eglGetError(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native int dispatch_eglGetError1(long procAddress);

  /** Entry point to C language function: <code> __EGLFuncPtr eglGetProcAddress(const char *  procname); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static long eglGetProcAddress(String procname)  {

    final long __addr_ = _table._addressof_eglGetProcAddress;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetProcAddress\" not available");
    }
        return dispatch_eglGetProcAddress1(procname, __addr_);
  }

  /** Entry point to C language function: <code> __EGLFuncPtr eglGetProcAddress(const char *  procname); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native long dispatch_eglGetProcAddress1(String procname, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglInitialize(EGLDisplay dpy, EGLint *  major, EGLint *  minor); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param major a direct or array-backed {@link java.nio.IntBuffer}
      @param minor a direct or array-backed {@link java.nio.IntBuffer}   */
  public static boolean eglInitialize(long dpy, IntBuffer major, IntBuffer minor)  {

    final boolean major_is_direct = Buffers.isDirect(major);
    final boolean minor_is_direct = Buffers.isDirect(minor);
    final long __addr_ = _table._addressof_eglInitialize;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglInitialize\" not available");
    }
        return dispatch_eglInitialize1(dpy, major_is_direct ? major : Buffers.getArray(major), major_is_direct ? Buffers.getDirectBufferByteOffset(major) : Buffers.getIndirectBufferByteOffset(major), major_is_direct, minor_is_direct ? minor : Buffers.getArray(minor), minor_is_direct ? Buffers.getDirectBufferByteOffset(minor) : Buffers.getIndirectBufferByteOffset(minor), minor_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglInitialize(EGLDisplay dpy, EGLint *  major, EGLint *  minor); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param major a direct or array-backed {@link java.nio.IntBuffer}
      @param minor a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_eglInitialize1(long dpy, Object major, int major_byte_offset, boolean major_is_direct, Object minor, int minor_byte_offset, boolean minor_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglInitialize(EGLDisplay dpy, EGLint *  major, EGLint *  minor); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglInitialize(long dpy, int[] major, int major_offset, int[] minor, int minor_offset)  {

    if(major != null && major.length <= major_offset)
      throw new RuntimeException("array offset argument \"major_offset\" (" + major_offset + ") equals or exceeds array length (" + major.length + ")");
    if(minor != null && minor.length <= minor_offset)
      throw new RuntimeException("array offset argument \"minor_offset\" (" + minor_offset + ") equals or exceeds array length (" + minor.length + ")");
    final long __addr_ = _table._addressof_eglInitialize;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglInitialize\" not available");
    }
        return dispatch_eglInitialize1(dpy, major, Buffers.SIZEOF_INT * major_offset, false, minor, Buffers.SIZEOF_INT * minor_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglMakeCurrent(long dpy, long draw, long read, long ctx)  {

    final long __addr_ = _table._addressof_eglMakeCurrent;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglMakeCurrent\" not available");
    }
        return dispatch_eglMakeCurrent1(dpy, draw, read, ctx, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglMakeCurrent1(long dpy, long draw, long read, long ctx, long procAddress);

  /** Entry point to C language function: <code> EGLenum eglQueryAPI(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static int eglQueryAPI()  {

    final long __addr_ = _table._addressof_eglQueryAPI;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglQueryAPI\" not available");
    }
        return dispatch_eglQueryAPI1(__addr_);
  }

  /** Entry point to C language function: <code> EGLenum eglQueryAPI(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native int dispatch_eglQueryAPI1(long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public static boolean eglQueryContext(long dpy, long ctx, int attribute, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _table._addressof_eglQueryContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglQueryContext\" not available");
    }
        return dispatch_eglQueryContext1(dpy, ctx, attribute, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_eglQueryContext1(long dpy, long ctx, int attribute, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglQueryContext(long dpy, long ctx, int attribute, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new RuntimeException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _table._addressof_eglQueryContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglQueryContext\" not available");
    }
        return dispatch_eglQueryContext1(dpy, ctx, attribute, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> const char *  eglQueryString(EGLDisplay dpy, EGLint name); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static String eglQueryString(long dpy, int name)  {

    final long __addr_ = _table._addressof_eglQueryString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglQueryString\" not available");
    }
        return dispatch_eglQueryString1(dpy, name, __addr_);
  }

  /** Entry point to C language function: <code> const char *  eglQueryString(EGLDisplay dpy, EGLint name); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native String dispatch_eglQueryString1(long dpy, int name, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQuerySurface(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public static boolean eglQuerySurface(long dpy, long surface, int attribute, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _table._addressof_eglQuerySurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglQuerySurface\" not available");
    }
        return dispatch_eglQuerySurface1(dpy, surface, attribute, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQuerySurface(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_eglQuerySurface1(long dpy, long surface, int attribute, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQuerySurface(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglQuerySurface(long dpy, long surface, int attribute, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new RuntimeException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _table._addressof_eglQuerySurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglQuerySurface\" not available");
    }
        return dispatch_eglQuerySurface1(dpy, surface, attribute, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglReleaseTexImage(long dpy, long surface, int buffer)  {

    final long __addr_ = _table._addressof_eglReleaseTexImage;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglReleaseTexImage\" not available");
    }
        return dispatch_eglReleaseTexImage1(dpy, surface, buffer, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglReleaseTexImage1(long dpy, long surface, int buffer, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglReleaseThread(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglReleaseThread()  {

    final long __addr_ = _table._addressof_eglReleaseThread;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglReleaseThread\" not available");
    }
        return dispatch_eglReleaseThread1(__addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglReleaseThread(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglReleaseThread1(long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSurfaceAttrib(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglSurfaceAttrib(long dpy, long surface, int attribute, int value)  {

    final long __addr_ = _table._addressof_eglSurfaceAttrib;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglSurfaceAttrib\" not available");
    }
        return dispatch_eglSurfaceAttrib1(dpy, surface, attribute, value, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSurfaceAttrib(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglSurfaceAttrib1(long dpy, long surface, int attribute, int value, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface surface); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglSwapBuffers(long dpy, long surface)  {

    final long __addr_ = _table._addressof_eglSwapBuffers;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglSwapBuffers\" not available");
    }
        return dispatch_eglSwapBuffers1(dpy, surface, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface surface); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglSwapBuffers1(long dpy, long surface, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSwapInterval(EGLDisplay dpy, EGLint interval); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglSwapInterval(long dpy, int interval)  {

    final long __addr_ = _table._addressof_eglSwapInterval;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglSwapInterval\" not available");
    }
        return dispatch_eglSwapInterval1(dpy, interval, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSwapInterval(EGLDisplay dpy, EGLint interval); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglSwapInterval1(long dpy, int interval, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglTerminate(EGLDisplay dpy); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglTerminate(long dpy)  {

    final long __addr_ = _table._addressof_eglTerminate;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglTerminate\" not available");
    }
        return dispatch_eglTerminate1(dpy, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglTerminate(EGLDisplay dpy); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglTerminate1(long dpy, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglWaitClient(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglWaitClient()  {

    final long __addr_ = _table._addressof_eglWaitClient;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglWaitClient\" not available");
    }
        return dispatch_eglWaitClient1(__addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglWaitClient(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglWaitClient1(long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglWaitGL(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglWaitGL()  {

    final long __addr_ = _table._addressof_eglWaitGL;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglWaitGL\" not available");
    }
        return dispatch_eglWaitGL1(__addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglWaitGL(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglWaitGL1(long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglWaitNative(EGLint engine); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglWaitNative(int engine)  {

    final long __addr_ = _table._addressof_eglWaitNative;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglWaitNative\" not available");
    }
        return dispatch_eglWaitNative1(engine, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglWaitNative(EGLint engine); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglWaitNative1(int engine, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
  private static EGLProcAddressTable _table = new EGLProcAddressTable(new GLProcAddressResolver());
  public static void resetProcAddressTable(DynamicLookupHelper lookup) {
      _table.reset(lookup);
  }
  public static final long EGL_DEFAULT_DISPLAY = 0;
  public static final long EGL_NO_CONTEXT = 0;
  public static final long EGL_NO_DISPLAY = 0;
  public static final long EGL_NO_SURFACE = 0;
  public static final int  EGL_DONT_CARE  = -1;
  public static final int  EGL_UNKNOWN    = -1;
 
  protected static long eglGetProcAddress(long eglGetProcAddressHandle, java.lang.String procname)
  {
    if (eglGetProcAddressHandle == 0) {
      throw new GLException("Passed null pointer for method \"eglGetProcAddress\"");
    }
    return dispatch_eglGetProcAddress1(procname, eglGetProcAddressHandle);
  }
  // ---- End CustomJavaCode .cfg declarations

} // end of class EGL
