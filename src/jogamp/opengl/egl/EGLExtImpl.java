/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Fri Aug 03 06:28:32 CEST 2012 ----! */

package jogamp.opengl.egl;

import java.util.*;
import javax.media.opengl.*;
import javax.media.opengl.fixedfunc.*;
import jogamp.opengl.*;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class EGLExtImpl implements EGLExt{
  /** Entry point to C language function: <code> EGLBoolean eglBindAPI(EGLenum api); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public boolean eglBindAPI(int api)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglBindAPI;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglBindAPI\" not available");
    }
        return dispatch_eglBindAPI1(api, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglBindAPI(EGLenum api); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public native boolean dispatch_eglBindAPI1(int api, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public boolean eglBindTexImage(long dpy, long surface, int buffer)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglBindTexImage;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglBindTexImage\" not available");
    }
        return dispatch_eglBindTexImage1(dpy, surface, buffer, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public native boolean dispatch_eglBindTexImage1(long dpy, long surface, int buffer, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglChooseConfig(EGLDisplay dpy, const EGLint *  attrib_list, EGLConfig *  configs, EGLint config_size, EGLint *  num_config); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}
      @param configs a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param num_config a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean eglChooseConfig(long dpy, IntBuffer attrib_list, PointerBuffer configs, int config_size, IntBuffer num_config)  {

    final boolean attrib_list_is_direct = Buffers.isDirect(attrib_list);
    final boolean configs_is_direct = Buffers.isDirect(configs);
    final boolean num_config_is_direct = Buffers.isDirect(num_config);
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglChooseConfig;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglChooseConfig\" not available");
    }
        return dispatch_eglChooseConfig1(dpy, attrib_list_is_direct ? attrib_list : Buffers.getArray(attrib_list), attrib_list_is_direct ? Buffers.getDirectBufferByteOffset(attrib_list) : Buffers.getIndirectBufferByteOffset(attrib_list), attrib_list_is_direct, configs_is_direct ? ( configs != null ? configs.getBuffer() : null ) : Buffers.getArray(configs), configs_is_direct ? Buffers.getDirectBufferByteOffset(configs) : Buffers.getIndirectBufferByteOffset(configs), configs_is_direct, config_size, num_config_is_direct ? num_config : Buffers.getArray(num_config), num_config_is_direct ? Buffers.getDirectBufferByteOffset(num_config) : Buffers.getIndirectBufferByteOffset(num_config), num_config_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglChooseConfig(EGLDisplay dpy, const EGLint *  attrib_list, EGLConfig *  configs, EGLint config_size, EGLint *  num_config); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}
      @param configs a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param num_config a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglChooseConfig1(long dpy, Object attrib_list, int attrib_list_byte_offset, boolean attrib_list_is_direct, Object configs, int configs_byte_offset, boolean configs_is_direct, int config_size, Object num_config, int num_config_byte_offset, boolean num_config_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglChooseConfig(EGLDisplay dpy, const EGLint *  attrib_list, EGLConfig *  configs, EGLint config_size, EGLint *  num_config); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param configs a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public boolean eglChooseConfig(long dpy, int[] attrib_list, int attrib_list_offset, PointerBuffer configs, int config_size, int[] num_config, int num_config_offset)  {

    if(attrib_list != null && attrib_list.length <= attrib_list_offset)
      throw new RuntimeException("array offset argument \"attrib_list_offset\" (" + attrib_list_offset + ") equals or exceeds array length (" + attrib_list.length + ")");
    final boolean configs_is_direct = Buffers.isDirect(configs);
    if(num_config != null && num_config.length <= num_config_offset)
      throw new RuntimeException("array offset argument \"num_config_offset\" (" + num_config_offset + ") equals or exceeds array length (" + num_config.length + ")");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglChooseConfig;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglChooseConfig\" not available");
    }
        return dispatch_eglChooseConfig1(dpy, attrib_list, Buffers.SIZEOF_INT * attrib_list_offset, false, configs_is_direct ? ( configs != null ? configs.getBuffer() : null ) : Buffers.getArray(configs), configs_is_direct ? Buffers.getDirectBufferByteOffset(configs) : Buffers.getIndirectBufferByteOffset(configs), configs_is_direct, config_size, num_config, Buffers.SIZEOF_INT * num_config_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLint eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags, EGLTimeKHR timeout); </code> <br>Part of <code>EGL_KHR_reusable_sync</code>   */
  public int eglClientWaitSyncKHR(long dpy, long sync, int flags, long timeout)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglClientWaitSyncKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglClientWaitSyncKHR\" not available");
    }
        return dispatch_eglClientWaitSyncKHR1(dpy, sync, flags, timeout, __addr_);
  }

  /** Entry point to C language function: <code> EGLint eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags, EGLTimeKHR timeout); </code> <br>Part of <code>EGL_KHR_reusable_sync</code>   */
  public native int dispatch_eglClientWaitSyncKHR1(long dpy, long sync, int flags, long timeout, long procAddress);

  /** Entry point to C language function: <code> EGLint eglClientWaitSyncNV(EGLClientBuffer sync, EGLint flags, EGLTimeNV timeout); </code> <br>Part of <code>EGL_NV_sync</code>
      @param sync a direct or array-backed {@link java.nio.Buffer}   */
  public int eglClientWaitSyncNV(Buffer sync, int flags, long timeout)  {

    final boolean sync_is_direct = Buffers.isDirect(sync);
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglClientWaitSyncNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglClientWaitSyncNV\" not available");
    }
        return dispatch_eglClientWaitSyncNV1(sync_is_direct ? sync : Buffers.getArray(sync), sync_is_direct ? Buffers.getDirectBufferByteOffset(sync) : Buffers.getIndirectBufferByteOffset(sync), sync_is_direct, flags, timeout, __addr_);
  }

  /** Entry point to C language function: <code> EGLint eglClientWaitSyncNV(EGLClientBuffer sync, EGLint flags, EGLTimeNV timeout); </code> <br>Part of <code>EGL_NV_sync</code>
      @param sync a direct or array-backed {@link java.nio.Buffer}   */
  private native int dispatch_eglClientWaitSyncNV1(Object sync, int sync_byte_offset, boolean sync_is_direct, int flags, long timeout, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public boolean eglCopyBuffers(long dpy, long surface, long target)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCopyBuffers;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCopyBuffers\" not available");
    }
        return dispatch_eglCopyBuffers1(dpy, surface, target, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public native boolean dispatch_eglCopyBuffers1(long dpy, long surface, long target, long procAddress);

  /** Entry point to C language function: <code> EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  public long eglCreateContext(long dpy, long config, long share_context, IntBuffer attrib_list)  {

    final boolean attrib_list_is_direct = Buffers.isDirect(attrib_list);
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreateContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreateContext\" not available");
    }
        return dispatch_eglCreateContext1(dpy, config, share_context, attrib_list_is_direct ? attrib_list : Buffers.getArray(attrib_list), attrib_list_is_direct ? Buffers.getDirectBufferByteOffset(attrib_list) : Buffers.getIndirectBufferByteOffset(attrib_list), attrib_list_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreateContext1(long dpy, long config, long share_context, Object attrib_list, int attrib_list_byte_offset, boolean attrib_list_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public long eglCreateContext(long dpy, long config, long share_context, int[] attrib_list, int attrib_list_offset)  {

    if(attrib_list != null && attrib_list.length <= attrib_list_offset)
      throw new RuntimeException("array offset argument \"attrib_list_offset\" (" + attrib_list_offset + ") equals or exceeds array length (" + attrib_list.length + ")");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreateContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreateContext\" not available");
    }
        return dispatch_eglCreateContext1(dpy, config, share_context, attrib_list, Buffers.SIZEOF_INT * attrib_list_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLImageKHR eglCreateDRMImageMESA(EGLDisplay dpy, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_MESA_drm_image</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  public long eglCreateDRMImageMESA(long dpy, IntBuffer attrib_list)  {

    final boolean attrib_list_is_direct = Buffers.isDirect(attrib_list);
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreateDRMImageMESA;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreateDRMImageMESA\" not available");
    }
        return dispatch_eglCreateDRMImageMESA1(dpy, attrib_list_is_direct ? attrib_list : Buffers.getArray(attrib_list), attrib_list_is_direct ? Buffers.getDirectBufferByteOffset(attrib_list) : Buffers.getIndirectBufferByteOffset(attrib_list), attrib_list_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLImageKHR eglCreateDRMImageMESA(EGLDisplay dpy, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_MESA_drm_image</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreateDRMImageMESA1(long dpy, Object attrib_list, int attrib_list_byte_offset, boolean attrib_list_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLImageKHR eglCreateDRMImageMESA(EGLDisplay dpy, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_MESA_drm_image</code>   */
  public long eglCreateDRMImageMESA(long dpy, int[] attrib_list, int attrib_list_offset)  {

    if(attrib_list != null && attrib_list.length <= attrib_list_offset)
      throw new RuntimeException("array offset argument \"attrib_list_offset\" (" + attrib_list_offset + ") equals or exceeds array length (" + attrib_list.length + ")");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreateDRMImageMESA;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreateDRMImageMESA\" not available");
    }
        return dispatch_eglCreateDRMImageMESA1(dpy, attrib_list, Buffers.SIZEOF_INT * attrib_list_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLClientBuffer eglCreateFenceSyncNV(EGLDisplay dpy, EGLenum condition, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_NV_sync</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  public ByteBuffer eglCreateFenceSyncNV(long dpy, int condition, IntBuffer attrib_list)  {

    final boolean attrib_list_is_direct = Buffers.isDirect(attrib_list);
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreateFenceSyncNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreateFenceSyncNV\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_eglCreateFenceSyncNV1(dpy, condition, attrib_list_is_direct ? attrib_list : Buffers.getArray(attrib_list), attrib_list_is_direct ? Buffers.getDirectBufferByteOffset(attrib_list) : Buffers.getIndirectBufferByteOffset(attrib_list), attrib_list_is_direct, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> EGLClientBuffer eglCreateFenceSyncNV(EGLDisplay dpy, EGLenum condition, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_NV_sync</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  private native ByteBuffer dispatch_eglCreateFenceSyncNV1(long dpy, int condition, Object attrib_list, int attrib_list_byte_offset, boolean attrib_list_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLClientBuffer eglCreateFenceSyncNV(EGLDisplay dpy, EGLenum condition, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_NV_sync</code>   */
  public ByteBuffer eglCreateFenceSyncNV(long dpy, int condition, int[] attrib_list, int attrib_list_offset)  {

    if(attrib_list != null && attrib_list.length <= attrib_list_offset)
      throw new RuntimeException("array offset argument \"attrib_list_offset\" (" + attrib_list_offset + ") equals or exceeds array length (" + attrib_list.length + ")");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreateFenceSyncNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreateFenceSyncNV\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_eglCreateFenceSyncNV1(dpy, condition, attrib_list, Buffers.SIZEOF_INT * attrib_list_offset, false, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> EGLImageKHR eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_KHR_image</code>
      @param buffer a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public long eglCreateImageKHR(long dpy, long ctx, int target, Buffer buffer, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(buffer))
      throw new RuntimeException("Argument \"buffer\" is not a direct buffer");
    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreateImageKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreateImageKHR\" not available");
    }
        return dispatch_eglCreateImageKHR0(dpy, ctx, target, buffer, Buffers.getDirectBufferByteOffset(buffer), attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLImageKHR eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_KHR_image</code>
      @param buffer a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreateImageKHR0(long dpy, long ctx, int target, Object buffer, int buffer_byte_offset, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePbufferFromClientBuffer(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param buffer a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public long eglCreatePbufferFromClientBuffer(long dpy, int buftype, Buffer buffer, long config, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(buffer))
      throw new RuntimeException("Argument \"buffer\" is not a direct buffer");
    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreatePbufferFromClientBuffer;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreatePbufferFromClientBuffer\" not available");
    }
        return dispatch_eglCreatePbufferFromClientBuffer0(dpy, buftype, buffer, Buffers.getDirectBufferByteOffset(buffer), config, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePbufferFromClientBuffer(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param buffer a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreatePbufferFromClientBuffer0(long dpy, int buftype, Object buffer, int buffer_byte_offset, long config, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  public long eglCreatePbufferSurface(long dpy, long config, IntBuffer attrib_list)  {

    final boolean attrib_list_is_direct = Buffers.isDirect(attrib_list);
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreatePbufferSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreatePbufferSurface\" not available");
    }
        return dispatch_eglCreatePbufferSurface1(dpy, config, attrib_list_is_direct ? attrib_list : Buffers.getArray(attrib_list), attrib_list_is_direct ? Buffers.getDirectBufferByteOffset(attrib_list) : Buffers.getIndirectBufferByteOffset(attrib_list), attrib_list_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreatePbufferSurface1(long dpy, long config, Object attrib_list, int attrib_list_byte_offset, boolean attrib_list_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public long eglCreatePbufferSurface(long dpy, long config, int[] attrib_list, int attrib_list_offset)  {

    if(attrib_list != null && attrib_list.length <= attrib_list_offset)
      throw new RuntimeException("array offset argument \"attrib_list_offset\" (" + attrib_list_offset + ") equals or exceeds array length (" + attrib_list.length + ")");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreatePbufferSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreatePbufferSurface\" not available");
    }
        return dispatch_eglCreatePbufferSurface1(dpy, config, attrib_list, Buffers.SIZEOF_INT * attrib_list_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  public long eglCreatePixmapSurface(long dpy, long config, long pixmap, IntBuffer attrib_list)  {

    final boolean attrib_list_is_direct = Buffers.isDirect(attrib_list);
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreatePixmapSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreatePixmapSurface\" not available");
    }
        return dispatch_eglCreatePixmapSurface1(dpy, config, pixmap, attrib_list_is_direct ? attrib_list : Buffers.getArray(attrib_list), attrib_list_is_direct ? Buffers.getDirectBufferByteOffset(attrib_list) : Buffers.getIndirectBufferByteOffset(attrib_list), attrib_list_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreatePixmapSurface1(long dpy, long config, long pixmap, Object attrib_list, int attrib_list_byte_offset, boolean attrib_list_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public long eglCreatePixmapSurface(long dpy, long config, long pixmap, int[] attrib_list, int attrib_list_offset)  {

    if(attrib_list != null && attrib_list.length <= attrib_list_offset)
      throw new RuntimeException("array offset argument \"attrib_list_offset\" (" + attrib_list_offset + ") equals or exceeds array length (" + attrib_list.length + ")");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreatePixmapSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreatePixmapSurface\" not available");
    }
        return dispatch_eglCreatePixmapSurface1(dpy, config, pixmap, attrib_list, Buffers.SIZEOF_INT * attrib_list_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePixmapSurfaceHI(EGLDisplay dpy, EGLConfig config, EGLClientPixmapHI *  pixmap); </code> <br>Part of <code>EGL_HI_clientpixmap</code>   */
  public long eglCreatePixmapSurfaceHI(long dpy, long config, EGLClientPixmapHI pixmap)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreatePixmapSurfaceHI;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreatePixmapSurfaceHI\" not available");
    }
        return dispatch_eglCreatePixmapSurfaceHI1(dpy, config, ((pixmap == null) ? null : pixmap.getBuffer()), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePixmapSurfaceHI(EGLDisplay dpy, EGLConfig config, EGLClientPixmapHI *  pixmap); </code> <br>Part of <code>EGL_HI_clientpixmap</code>   */
  private native long dispatch_eglCreatePixmapSurfaceHI1(long dpy, long config, ByteBuffer pixmap, long procAddress);

  /** Entry point to C language function: <code> EGLSyncKHR eglCreateSyncKHR(EGLDisplay dpy, EGLenum type, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_KHR_reusable_sync</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  public long eglCreateSyncKHR(long dpy, int type, IntBuffer attrib_list)  {

    final boolean attrib_list_is_direct = Buffers.isDirect(attrib_list);
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreateSyncKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreateSyncKHR\" not available");
    }
        return dispatch_eglCreateSyncKHR1(dpy, type, attrib_list_is_direct ? attrib_list : Buffers.getArray(attrib_list), attrib_list_is_direct ? Buffers.getDirectBufferByteOffset(attrib_list) : Buffers.getIndirectBufferByteOffset(attrib_list), attrib_list_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLSyncKHR eglCreateSyncKHR(EGLDisplay dpy, EGLenum type, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_KHR_reusable_sync</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreateSyncKHR1(long dpy, int type, Object attrib_list, int attrib_list_byte_offset, boolean attrib_list_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLSyncKHR eglCreateSyncKHR(EGLDisplay dpy, EGLenum type, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_KHR_reusable_sync</code>   */
  public long eglCreateSyncKHR(long dpy, int type, int[] attrib_list, int attrib_list_offset)  {

    if(attrib_list != null && attrib_list.length <= attrib_list_offset)
      throw new RuntimeException("array offset argument \"attrib_list_offset\" (" + attrib_list_offset + ") equals or exceeds array length (" + attrib_list.length + ")");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreateSyncKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreateSyncKHR\" not available");
    }
        return dispatch_eglCreateSyncKHR1(dpy, type, attrib_list, Buffers.SIZEOF_INT * attrib_list_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreateWindowSurface(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  public long eglCreateWindowSurface(long dpy, long config, long win, IntBuffer attrib_list)  {

    final boolean attrib_list_is_direct = Buffers.isDirect(attrib_list);
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreateWindowSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreateWindowSurface\" not available");
    }
        return dispatch_eglCreateWindowSurface1(dpy, config, win, attrib_list_is_direct ? attrib_list : Buffers.getArray(attrib_list), attrib_list_is_direct ? Buffers.getDirectBufferByteOffset(attrib_list) : Buffers.getIndirectBufferByteOffset(attrib_list), attrib_list_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreateWindowSurface(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreateWindowSurface1(long dpy, long config, long win, Object attrib_list, int attrib_list_byte_offset, boolean attrib_list_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreateWindowSurface(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public long eglCreateWindowSurface(long dpy, long config, long win, int[] attrib_list, int attrib_list_offset)  {

    if(attrib_list != null && attrib_list.length <= attrib_list_offset)
      throw new RuntimeException("array offset argument \"attrib_list_offset\" (" + attrib_list_offset + ") equals or exceeds array length (" + attrib_list.length + ")");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreateWindowSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreateWindowSurface\" not available");
    }
        return dispatch_eglCreateWindowSurface1(dpy, config, win, attrib_list, Buffers.SIZEOF_INT * attrib_list_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroyContext(EGLDisplay dpy, EGLContext ctx); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public boolean eglDestroyContext(long dpy, long ctx)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglDestroyContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglDestroyContext\" not available");
    }
        return dispatch_eglDestroyContext1(dpy, ctx, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroyContext(EGLDisplay dpy, EGLContext ctx); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public native boolean dispatch_eglDestroyContext1(long dpy, long ctx, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR image); </code> <br>Part of <code>EGL_KHR_image</code>   */
  public boolean eglDestroyImageKHR(long dpy, long image)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglDestroyImageKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglDestroyImageKHR\" not available");
    }
        return dispatch_eglDestroyImageKHR1(dpy, image, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR image); </code> <br>Part of <code>EGL_KHR_image</code>   */
  public native boolean dispatch_eglDestroyImageKHR1(long dpy, long image, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglDestroySurface(EGLDisplay dpy, EGLSurface surface); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public boolean eglDestroySurface(long dpy, long surface)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglDestroySurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglDestroySurface\" not available");
    }
        return dispatch_eglDestroySurface1(dpy, surface, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroySurface(EGLDisplay dpy, EGLSurface surface); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public native boolean dispatch_eglDestroySurface1(long dpy, long surface, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglDestroySyncKHR(EGLDisplay dpy, EGLSyncKHR sync); </code> <br>Part of <code>EGL_KHR_reusable_sync</code>   */
  public boolean eglDestroySyncKHR(long dpy, long sync)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglDestroySyncKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglDestroySyncKHR\" not available");
    }
        return dispatch_eglDestroySyncKHR1(dpy, sync, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroySyncKHR(EGLDisplay dpy, EGLSyncKHR sync); </code> <br>Part of <code>EGL_KHR_reusable_sync</code>   */
  public native boolean dispatch_eglDestroySyncKHR1(long dpy, long sync, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglDestroySyncNV(EGLClientBuffer sync); </code> <br>Part of <code>EGL_NV_sync</code>
      @param sync a direct or array-backed {@link java.nio.Buffer}   */
  public boolean eglDestroySyncNV(Buffer sync)  {

    final boolean sync_is_direct = Buffers.isDirect(sync);
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglDestroySyncNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglDestroySyncNV\" not available");
    }
        return dispatch_eglDestroySyncNV1(sync_is_direct ? sync : Buffers.getArray(sync), sync_is_direct ? Buffers.getDirectBufferByteOffset(sync) : Buffers.getIndirectBufferByteOffset(sync), sync_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroySyncNV(EGLClientBuffer sync); </code> <br>Part of <code>EGL_NV_sync</code>
      @param sync a direct or array-backed {@link java.nio.Buffer}   */
  private native boolean dispatch_eglDestroySyncNV1(Object sync, int sync_byte_offset, boolean sync_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglExportDRMImageMESA(EGLDisplay dpy, EGLImageKHR image, EGLint *  name, EGLint *  handle, EGLint *  stride); </code> <br>Part of <code>EGL_MESA_drm_image</code>
      @param name a direct or array-backed {@link java.nio.IntBuffer}
      @param handle a direct or array-backed {@link java.nio.IntBuffer}
      @param stride a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean eglExportDRMImageMESA(long dpy, long image, IntBuffer name, IntBuffer handle, IntBuffer stride)  {

    final boolean name_is_direct = Buffers.isDirect(name);
    final boolean handle_is_direct = Buffers.isDirect(handle);
    final boolean stride_is_direct = Buffers.isDirect(stride);
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglExportDRMImageMESA;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglExportDRMImageMESA\" not available");
    }
        return dispatch_eglExportDRMImageMESA1(dpy, image, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, handle_is_direct ? handle : Buffers.getArray(handle), handle_is_direct ? Buffers.getDirectBufferByteOffset(handle) : Buffers.getIndirectBufferByteOffset(handle), handle_is_direct, stride_is_direct ? stride : Buffers.getArray(stride), stride_is_direct ? Buffers.getDirectBufferByteOffset(stride) : Buffers.getIndirectBufferByteOffset(stride), stride_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglExportDRMImageMESA(EGLDisplay dpy, EGLImageKHR image, EGLint *  name, EGLint *  handle, EGLint *  stride); </code> <br>Part of <code>EGL_MESA_drm_image</code>
      @param name a direct or array-backed {@link java.nio.IntBuffer}
      @param handle a direct or array-backed {@link java.nio.IntBuffer}
      @param stride a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglExportDRMImageMESA1(long dpy, long image, Object name, int name_byte_offset, boolean name_is_direct, Object handle, int handle_byte_offset, boolean handle_is_direct, Object stride, int stride_byte_offset, boolean stride_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglExportDRMImageMESA(EGLDisplay dpy, EGLImageKHR image, EGLint *  name, EGLint *  handle, EGLint *  stride); </code> <br>Part of <code>EGL_MESA_drm_image</code>   */
  public boolean eglExportDRMImageMESA(long dpy, long image, int[] name, int name_offset, int[] handle, int handle_offset, int[] stride, int stride_offset)  {

    if(name != null && name.length <= name_offset)
      throw new RuntimeException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    if(handle != null && handle.length <= handle_offset)
      throw new RuntimeException("array offset argument \"handle_offset\" (" + handle_offset + ") equals or exceeds array length (" + handle.length + ")");
    if(stride != null && stride.length <= stride_offset)
      throw new RuntimeException("array offset argument \"stride_offset\" (" + stride_offset + ") equals or exceeds array length (" + stride.length + ")");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglExportDRMImageMESA;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglExportDRMImageMESA\" not available");
    }
        return dispatch_eglExportDRMImageMESA1(dpy, image, name, Buffers.SIZEOF_INT * name_offset, false, handle, Buffers.SIZEOF_INT * handle_offset, false, stride, Buffers.SIZEOF_INT * stride_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglFenceNV(EGLClientBuffer sync); </code> <br>Part of <code>EGL_NV_sync</code>
      @param sync a direct or array-backed {@link java.nio.Buffer}   */
  public boolean eglFenceNV(Buffer sync)  {

    final boolean sync_is_direct = Buffers.isDirect(sync);
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglFenceNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglFenceNV\" not available");
    }
        return dispatch_eglFenceNV1(sync_is_direct ? sync : Buffers.getArray(sync), sync_is_direct ? Buffers.getDirectBufferByteOffset(sync) : Buffers.getIndirectBufferByteOffset(sync), sync_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglFenceNV(EGLClientBuffer sync); </code> <br>Part of <code>EGL_NV_sync</code>
      @param sync a direct or array-backed {@link java.nio.Buffer}   */
  private native boolean dispatch_eglFenceNV1(Object sync, int sync_byte_offset, boolean sync_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean eglGetConfigAttrib(long dpy, long config, int attribute, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglGetConfigAttrib;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetConfigAttrib\" not available");
    }
        return dispatch_eglGetConfigAttrib1(dpy, config, attribute, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglGetConfigAttrib1(long dpy, long config, int attribute, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public boolean eglGetConfigAttrib(long dpy, long config, int attribute, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new RuntimeException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglGetConfigAttrib;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetConfigAttrib\" not available");
    }
        return dispatch_eglGetConfigAttrib1(dpy, config, attribute, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigs(EGLDisplay dpy, EGLConfig *  configs, EGLint config_size, EGLint *  num_config); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param configs a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param num_config a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean eglGetConfigs(long dpy, PointerBuffer configs, int config_size, IntBuffer num_config)  {

    final boolean configs_is_direct = Buffers.isDirect(configs);
    final boolean num_config_is_direct = Buffers.isDirect(num_config);
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglGetConfigs;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetConfigs\" not available");
    }
        return dispatch_eglGetConfigs1(dpy, configs_is_direct ? ( configs != null ? configs.getBuffer() : null ) : Buffers.getArray(configs), configs_is_direct ? Buffers.getDirectBufferByteOffset(configs) : Buffers.getIndirectBufferByteOffset(configs), configs_is_direct, config_size, num_config_is_direct ? num_config : Buffers.getArray(num_config), num_config_is_direct ? Buffers.getDirectBufferByteOffset(num_config) : Buffers.getIndirectBufferByteOffset(num_config), num_config_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigs(EGLDisplay dpy, EGLConfig *  configs, EGLint config_size, EGLint *  num_config); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param configs a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param num_config a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglGetConfigs1(long dpy, Object configs, int configs_byte_offset, boolean configs_is_direct, int config_size, Object num_config, int num_config_byte_offset, boolean num_config_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigs(EGLDisplay dpy, EGLConfig *  configs, EGLint config_size, EGLint *  num_config); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param configs a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public boolean eglGetConfigs(long dpy, PointerBuffer configs, int config_size, int[] num_config, int num_config_offset)  {

    final boolean configs_is_direct = Buffers.isDirect(configs);
    if(num_config != null && num_config.length <= num_config_offset)
      throw new RuntimeException("array offset argument \"num_config_offset\" (" + num_config_offset + ") equals or exceeds array length (" + num_config.length + ")");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglGetConfigs;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetConfigs\" not available");
    }
        return dispatch_eglGetConfigs1(dpy, configs_is_direct ? ( configs != null ? configs.getBuffer() : null ) : Buffers.getArray(configs), configs_is_direct ? Buffers.getDirectBufferByteOffset(configs) : Buffers.getIndirectBufferByteOffset(configs), configs_is_direct, config_size, num_config, Buffers.SIZEOF_INT * num_config_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLContext eglGetCurrentContext(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public long eglGetCurrentContext()  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglGetCurrentContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetCurrentContext\" not available");
    }
        return dispatch_eglGetCurrentContext1(__addr_);
  }

  /** Entry point to C language function: <code> EGLContext eglGetCurrentContext(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public native long dispatch_eglGetCurrentContext1(long procAddress);

  /** Entry point to C language function: <code> EGLDisplay eglGetCurrentDisplay(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public long eglGetCurrentDisplay()  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglGetCurrentDisplay;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetCurrentDisplay\" not available");
    }
        return dispatch_eglGetCurrentDisplay1(__addr_);
  }

  /** Entry point to C language function: <code> EGLDisplay eglGetCurrentDisplay(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public native long dispatch_eglGetCurrentDisplay1(long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglGetCurrentSurface(EGLint readdraw); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public long eglGetCurrentSurface(int readdraw)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglGetCurrentSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetCurrentSurface\" not available");
    }
        return dispatch_eglGetCurrentSurface1(readdraw, __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglGetCurrentSurface(EGLint readdraw); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public native long dispatch_eglGetCurrentSurface1(int readdraw, long procAddress);

  /** Entry point to C language function: <code> EGLDisplay eglGetDisplay(EGLNativeDisplayType display_id); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public long eglGetDisplay(long display_id)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglGetDisplay;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetDisplay\" not available");
    }
        return dispatch_eglGetDisplay1(display_id, __addr_);
  }

  /** Entry point to C language function: <code> EGLDisplay eglGetDisplay(EGLNativeDisplayType display_id); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public native long dispatch_eglGetDisplay1(long display_id, long procAddress);

  /** Entry point to C language function: <code> EGLint eglGetError(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public int eglGetError()  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglGetError;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetError\" not available");
    }
        return dispatch_eglGetError1(__addr_);
  }

  /** Entry point to C language function: <code> EGLint eglGetError(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public native int dispatch_eglGetError1(long procAddress);

  /** Entry point to C language function: <code> __EGLFuncPtr eglGetProcAddress(const char *  procname); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public long eglGetProcAddress(String procname)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglGetProcAddress;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetProcAddress\" not available");
    }
        return dispatch_eglGetProcAddress1(procname, __addr_);
  }

  /** Entry point to C language function: <code> __EGLFuncPtr eglGetProcAddress(const char *  procname); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public native long dispatch_eglGetProcAddress1(String procname, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_KHR_reusable_sync</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean eglGetSyncAttribKHR(long dpy, long sync, int attribute, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglGetSyncAttribKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetSyncAttribKHR\" not available");
    }
        return dispatch_eglGetSyncAttribKHR1(dpy, sync, attribute, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_KHR_reusable_sync</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglGetSyncAttribKHR1(long dpy, long sync, int attribute, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_KHR_reusable_sync</code>   */
  public boolean eglGetSyncAttribKHR(long dpy, long sync, int attribute, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new RuntimeException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglGetSyncAttribKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetSyncAttribKHR\" not available");
    }
        return dispatch_eglGetSyncAttribKHR1(dpy, sync, attribute, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglGetSyncAttribNV(EGLClientBuffer sync, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_NV_sync</code>
      @param sync a direct or array-backed {@link java.nio.Buffer}
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean eglGetSyncAttribNV(Buffer sync, int attribute, IntBuffer value)  {

    final boolean sync_is_direct = Buffers.isDirect(sync);
    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglGetSyncAttribNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetSyncAttribNV\" not available");
    }
        return dispatch_eglGetSyncAttribNV1(sync_is_direct ? sync : Buffers.getArray(sync), sync_is_direct ? Buffers.getDirectBufferByteOffset(sync) : Buffers.getIndirectBufferByteOffset(sync), sync_is_direct, attribute, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglGetSyncAttribNV(EGLClientBuffer sync, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_NV_sync</code>
      @param sync a direct or array-backed {@link java.nio.Buffer}
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglGetSyncAttribNV1(Object sync, int sync_byte_offset, boolean sync_is_direct, int attribute, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglGetSyncAttribNV(EGLClientBuffer sync, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_NV_sync</code>
      @param sync a direct or array-backed {@link java.nio.Buffer}   */
  public boolean eglGetSyncAttribNV(Buffer sync, int attribute, int[] value, int value_offset)  {

    final boolean sync_is_direct = Buffers.isDirect(sync);
    if(value != null && value.length <= value_offset)
      throw new RuntimeException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglGetSyncAttribNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetSyncAttribNV\" not available");
    }
        return dispatch_eglGetSyncAttribNV1(sync_is_direct ? sync : Buffers.getArray(sync), sync_is_direct ? Buffers.getDirectBufferByteOffset(sync) : Buffers.getIndirectBufferByteOffset(sync), sync_is_direct, attribute, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLuint64 eglGetSystemTimeFrequencyNV(void); </code> <br>Part of <code>EGL_NV_system_time</code>   */
  public long eglGetSystemTimeFrequencyNV()  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglGetSystemTimeFrequencyNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetSystemTimeFrequencyNV\" not available");
    }
        return dispatch_eglGetSystemTimeFrequencyNV1(__addr_);
  }

  /** Entry point to C language function: <code> EGLuint64 eglGetSystemTimeFrequencyNV(void); </code> <br>Part of <code>EGL_NV_system_time</code>   */
  public native long dispatch_eglGetSystemTimeFrequencyNV1(long procAddress);

  /** Entry point to C language function: <code> EGLuint64 eglGetSystemTimeNV(void); </code> <br>Part of <code>EGL_NV_system_time</code>   */
  public long eglGetSystemTimeNV()  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglGetSystemTimeNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetSystemTimeNV\" not available");
    }
        return dispatch_eglGetSystemTimeNV1(__addr_);
  }

  /** Entry point to C language function: <code> EGLuint64 eglGetSystemTimeNV(void); </code> <br>Part of <code>EGL_NV_system_time</code>   */
  public native long dispatch_eglGetSystemTimeNV1(long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglInitialize(EGLDisplay dpy, EGLint *  major, EGLint *  minor); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param major a direct or array-backed {@link java.nio.IntBuffer}
      @param minor a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean eglInitialize(long dpy, IntBuffer major, IntBuffer minor)  {

    final boolean major_is_direct = Buffers.isDirect(major);
    final boolean minor_is_direct = Buffers.isDirect(minor);
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglInitialize;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglInitialize\" not available");
    }
        return dispatch_eglInitialize1(dpy, major_is_direct ? major : Buffers.getArray(major), major_is_direct ? Buffers.getDirectBufferByteOffset(major) : Buffers.getIndirectBufferByteOffset(major), major_is_direct, minor_is_direct ? minor : Buffers.getArray(minor), minor_is_direct ? Buffers.getDirectBufferByteOffset(minor) : Buffers.getIndirectBufferByteOffset(minor), minor_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglInitialize(EGLDisplay dpy, EGLint *  major, EGLint *  minor); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param major a direct or array-backed {@link java.nio.IntBuffer}
      @param minor a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglInitialize1(long dpy, Object major, int major_byte_offset, boolean major_is_direct, Object minor, int minor_byte_offset, boolean minor_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglInitialize(EGLDisplay dpy, EGLint *  major, EGLint *  minor); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public boolean eglInitialize(long dpy, int[] major, int major_offset, int[] minor, int minor_offset)  {

    if(major != null && major.length <= major_offset)
      throw new RuntimeException("array offset argument \"major_offset\" (" + major_offset + ") equals or exceeds array length (" + major.length + ")");
    if(minor != null && minor.length <= minor_offset)
      throw new RuntimeException("array offset argument \"minor_offset\" (" + minor_offset + ") equals or exceeds array length (" + minor.length + ")");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglInitialize;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglInitialize\" not available");
    }
        return dispatch_eglInitialize1(dpy, major, Buffers.SIZEOF_INT * major_offset, false, minor, Buffers.SIZEOF_INT * minor_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglLockSurfaceKHR(EGLDisplay display, EGLSurface surface, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_KHR_lock_surface</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean eglLockSurfaceKHR(long display, long surface, IntBuffer attrib_list)  {

    final boolean attrib_list_is_direct = Buffers.isDirect(attrib_list);
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglLockSurfaceKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglLockSurfaceKHR\" not available");
    }
        return dispatch_eglLockSurfaceKHR1(display, surface, attrib_list_is_direct ? attrib_list : Buffers.getArray(attrib_list), attrib_list_is_direct ? Buffers.getDirectBufferByteOffset(attrib_list) : Buffers.getIndirectBufferByteOffset(attrib_list), attrib_list_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglLockSurfaceKHR(EGLDisplay display, EGLSurface surface, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_KHR_lock_surface</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglLockSurfaceKHR1(long display, long surface, Object attrib_list, int attrib_list_byte_offset, boolean attrib_list_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglLockSurfaceKHR(EGLDisplay display, EGLSurface surface, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_KHR_lock_surface</code>   */
  public boolean eglLockSurfaceKHR(long display, long surface, int[] attrib_list, int attrib_list_offset)  {

    if(attrib_list != null && attrib_list.length <= attrib_list_offset)
      throw new RuntimeException("array offset argument \"attrib_list_offset\" (" + attrib_list_offset + ") equals or exceeds array length (" + attrib_list.length + ")");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglLockSurfaceKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglLockSurfaceKHR\" not available");
    }
        return dispatch_eglLockSurfaceKHR1(display, surface, attrib_list, Buffers.SIZEOF_INT * attrib_list_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public boolean eglMakeCurrent(long dpy, long draw, long read, long ctx)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglMakeCurrent;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglMakeCurrent\" not available");
    }
        return dispatch_eglMakeCurrent1(dpy, draw, read, ctx, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public native boolean dispatch_eglMakeCurrent1(long dpy, long draw, long read, long ctx, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglPostSubBufferNV(EGLDisplay dpy, EGLSurface surface, EGLint x, EGLint y, EGLint width, EGLint height); </code> <br>Part of <code>EGL_NV_post_sub_buffer</code>   */
  public boolean eglPostSubBufferNV(long dpy, long surface, int x, int y, int width, int height)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglPostSubBufferNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglPostSubBufferNV\" not available");
    }
        return dispatch_eglPostSubBufferNV1(dpy, surface, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglPostSubBufferNV(EGLDisplay dpy, EGLSurface surface, EGLint x, EGLint y, EGLint width, EGLint height); </code> <br>Part of <code>EGL_NV_post_sub_buffer</code>   */
  public native boolean dispatch_eglPostSubBufferNV1(long dpy, long surface, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> EGLenum eglQueryAPI(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public int eglQueryAPI()  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglQueryAPI;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglQueryAPI\" not available");
    }
        return dispatch_eglQueryAPI1(__addr_);
  }

  /** Entry point to C language function: <code> EGLenum eglQueryAPI(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public native int dispatch_eglQueryAPI1(long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean eglQueryContext(long dpy, long ctx, int attribute, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglQueryContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglQueryContext\" not available");
    }
        return dispatch_eglQueryContext1(dpy, ctx, attribute, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglQueryContext1(long dpy, long ctx, int attribute, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public boolean eglQueryContext(long dpy, long ctx, int attribute, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new RuntimeException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglQueryContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglQueryContext\" not available");
    }
        return dispatch_eglQueryContext1(dpy, ctx, attribute, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> const char *  eglQueryString(EGLDisplay dpy, EGLint name); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public String eglQueryString(long dpy, int name)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglQueryString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglQueryString\" not available");
    }
        return dispatch_eglQueryString1(dpy, name, __addr_);
  }

  /** Entry point to C language function: <code> const char *  eglQueryString(EGLDisplay dpy, EGLint name); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public native String dispatch_eglQueryString1(long dpy, int name, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQuerySurface(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean eglQuerySurface(long dpy, long surface, int attribute, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglQuerySurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglQuerySurface\" not available");
    }
        return dispatch_eglQuerySurface1(dpy, surface, attribute, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQuerySurface(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglQuerySurface1(long dpy, long surface, int attribute, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQuerySurface(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public boolean eglQuerySurface(long dpy, long surface, int attribute, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new RuntimeException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglQuerySurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglQuerySurface\" not available");
    }
        return dispatch_eglQuerySurface1(dpy, surface, attribute, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQuerySurfacePointerANGLE(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLClientBuffer *  value); </code> <br>Part of <code>EGL_ANGLE_query_surface_pointer</code>
      @param value a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public boolean eglQuerySurfacePointerANGLE(long dpy, long surface, int attribute, PointerBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglQuerySurfacePointerANGLE;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglQuerySurfacePointerANGLE\" not available");
    }
        return dispatch_eglQuerySurfacePointerANGLE1(dpy, surface, attribute, value_is_direct ? ( value != null ? value.getBuffer() : null ) : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQuerySurfacePointerANGLE(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLClientBuffer *  value); </code> <br>Part of <code>EGL_ANGLE_query_surface_pointer</code>
      @param value a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private native boolean dispatch_eglQuerySurfacePointerANGLE1(long dpy, long surface, int attribute, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public boolean eglReleaseTexImage(long dpy, long surface, int buffer)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglReleaseTexImage;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglReleaseTexImage\" not available");
    }
        return dispatch_eglReleaseTexImage1(dpy, surface, buffer, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public native boolean dispatch_eglReleaseTexImage1(long dpy, long surface, int buffer, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglReleaseThread(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public boolean eglReleaseThread()  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglReleaseThread;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglReleaseThread\" not available");
    }
        return dispatch_eglReleaseThread1(__addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglReleaseThread(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public native boolean dispatch_eglReleaseThread1(long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSignalSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLenum mode); </code> <br>Part of <code>EGL_KHR_reusable_sync</code>   */
  public boolean eglSignalSyncKHR(long dpy, long sync, int mode)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglSignalSyncKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglSignalSyncKHR\" not available");
    }
        return dispatch_eglSignalSyncKHR1(dpy, sync, mode, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSignalSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLenum mode); </code> <br>Part of <code>EGL_KHR_reusable_sync</code>   */
  public native boolean dispatch_eglSignalSyncKHR1(long dpy, long sync, int mode, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSignalSyncNV(EGLClientBuffer sync, EGLenum mode); </code> <br>Part of <code>EGL_NV_sync</code>
      @param sync a direct or array-backed {@link java.nio.Buffer}   */
  public boolean eglSignalSyncNV(Buffer sync, int mode)  {

    final boolean sync_is_direct = Buffers.isDirect(sync);
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglSignalSyncNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglSignalSyncNV\" not available");
    }
        return dispatch_eglSignalSyncNV1(sync_is_direct ? sync : Buffers.getArray(sync), sync_is_direct ? Buffers.getDirectBufferByteOffset(sync) : Buffers.getIndirectBufferByteOffset(sync), sync_is_direct, mode, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSignalSyncNV(EGLClientBuffer sync, EGLenum mode); </code> <br>Part of <code>EGL_NV_sync</code>
      @param sync a direct or array-backed {@link java.nio.Buffer}   */
  private native boolean dispatch_eglSignalSyncNV1(Object sync, int sync_byte_offset, boolean sync_is_direct, int mode, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSurfaceAttrib(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public boolean eglSurfaceAttrib(long dpy, long surface, int attribute, int value)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglSurfaceAttrib;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglSurfaceAttrib\" not available");
    }
        return dispatch_eglSurfaceAttrib1(dpy, surface, attribute, value, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSurfaceAttrib(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public native boolean dispatch_eglSurfaceAttrib1(long dpy, long surface, int attribute, int value, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface surface); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public boolean eglSwapBuffers(long dpy, long surface)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglSwapBuffers;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglSwapBuffers\" not available");
    }
        return dispatch_eglSwapBuffers1(dpy, surface, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface surface); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public native boolean dispatch_eglSwapBuffers1(long dpy, long surface, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSwapInterval(EGLDisplay dpy, EGLint interval); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public boolean eglSwapInterval(long dpy, int interval)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglSwapInterval;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglSwapInterval\" not available");
    }
        return dispatch_eglSwapInterval1(dpy, interval, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSwapInterval(EGLDisplay dpy, EGLint interval); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public native boolean dispatch_eglSwapInterval1(long dpy, int interval, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglTerminate(EGLDisplay dpy); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public boolean eglTerminate(long dpy)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglTerminate;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglTerminate\" not available");
    }
        return dispatch_eglTerminate1(dpy, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglTerminate(EGLDisplay dpy); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public native boolean dispatch_eglTerminate1(long dpy, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglUnlockSurfaceKHR(EGLDisplay display, EGLSurface surface); </code> <br>Part of <code>EGL_KHR_lock_surface</code>   */
  public boolean eglUnlockSurfaceKHR(long display, long surface)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglUnlockSurfaceKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglUnlockSurfaceKHR\" not available");
    }
        return dispatch_eglUnlockSurfaceKHR1(display, surface, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglUnlockSurfaceKHR(EGLDisplay display, EGLSurface surface); </code> <br>Part of <code>EGL_KHR_lock_surface</code>   */
  public native boolean dispatch_eglUnlockSurfaceKHR1(long display, long surface, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglWaitClient(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public boolean eglWaitClient()  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglWaitClient;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglWaitClient\" not available");
    }
        return dispatch_eglWaitClient1(__addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglWaitClient(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public native boolean dispatch_eglWaitClient1(long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglWaitGL(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public boolean eglWaitGL()  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglWaitGL;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglWaitGL\" not available");
    }
        return dispatch_eglWaitGL1(__addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglWaitGL(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public native boolean dispatch_eglWaitGL1(long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglWaitNative(EGLint engine); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public boolean eglWaitNative(int engine)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglWaitNative;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglWaitNative\" not available");
    }
        return dispatch_eglWaitNative1(engine, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglWaitNative(EGLint engine); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public native boolean dispatch_eglWaitNative1(int engine, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
  public EGLExtImpl(EGLContext context) {
    this._context = context; 
  }
  public boolean isFunctionAvailable(String glFunctionName)
  {
    return _context.isFunctionAvailable(glFunctionName);
  }
  public boolean isExtensionAvailable(String glExtensionName)
  {
    return _context.isExtensionAvailable(glExtensionName);
  }
  private EGLContext _context;
  // ---- End CustomJavaCode .cfg declarations

} // end of class EGLExtImpl
