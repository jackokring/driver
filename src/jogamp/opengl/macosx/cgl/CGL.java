/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Fri Aug 03 06:29:06 CEST 2012 ----! */

package jogamp.opengl.macosx.cgl;

import java.util.*;
import javax.media.opengl.*;
import javax.media.opengl.fixedfunc.*;
import jogamp.opengl.*;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

 /**
  * Provides access to the MacOSX-specific OpenGL vendor extensions.
  * See {@link GLBase} for more information.
  */
public class CGL {

  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFAAllRenderers = 1;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFADoubleBuffer = 5;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFAStereo = 6;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFAAuxBuffers = 7;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFAColorSize = 8;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFAAlphaSize = 11;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFADepthSize = 12;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFAStencilSize = 13;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFAAccumSize = 14;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFAMinimumPolicy = 51;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFAMaximumPolicy = 52;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFAOffScreen = 53;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFAFullScreen = 54;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFASampleBuffers = 55;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFASamples = 56;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFAAuxDepthStencil = 57;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFAColorFloat = 58;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFAMultisample = 59;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFASupersample = 60;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFASampleAlpha = 61;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFARendererID = 70;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFASingleRenderer = 71;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFANoRecovery = 72;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFAAccelerated = 73;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFAClosestPolicy = 74;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFARobust = 75;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFABackingStore = 76;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFAMPSafe = 78;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFAWindow = 80;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFAMultiScreen = 81;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFACompliant = 83;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFAScreenMask = 84;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFAPixelBuffer = 90;
  /** Part of NSOpenGLPixelFormatAttribute<br>Defined as part of enum type "NSOpenGLPixelFormatAttribute" */
  public static final int NSOpenGLPFAVirtualScreenCount = 128;
  /** Part of CGLContextParameter<br>Defined as part of enum type "CGLContextParameter" */
  public static final int kCGLCPSwapRectangle = 200;
  /** Part of CGLContextParameter<br>Defined as part of enum type "CGLContextParameter" */
  public static final int kCGLCPSwapInterval = 222;
  /** Part of CGLContextParameter<br>Defined as part of enum type "CGLContextParameter" */
  public static final int kCGLCPDispatchTableSize = 224;
  /** Part of CGLContextParameter<br>Defined as part of enum type "CGLContextParameter" */
  public static final int kCGLCPClientStorage = 226;
  /** Part of CGLContextParameter<br>Defined as part of enum type "CGLContextParameter" */
  public static final int kCGLCPSurfaceTexture = 228;
  /** Part of CGLContextParameter<br>Defined as part of enum type "CGLContextParameter" */
  public static final int kCGLCPSurfaceOrder = 235;
  /** Part of CGLContextParameter<br>Defined as part of enum type "CGLContextParameter" */
  public static final int kCGLCPSurfaceOpacity = 236;
  /** Part of CGLContextParameter<br>Defined as part of enum type "CGLContextParameter" */
  public static final int kCGLCPSurfaceBackingSize = 304;
  /** Part of CGLContextParameter<br>Defined as part of enum type "CGLContextParameter" */
  public static final int kCGLCPSurfaceSurfaceVolatile = 306;
  /** Part of CGLContextParameter<br>Defined as part of enum type "CGLContextParameter" */
  public static final int kCGLCPReclaimResources = 308;
  /** Part of CGLContextParameter<br>Defined as part of enum type "CGLContextParameter" */
  public static final int kCGLCPCurrentRendererID = 309;
  /** Part of CGLContextParameter<br>Defined as part of enum type "CGLContextParameter" */
  public static final int kCGLCPGPUVertexProcessing = 310;
  /** Part of CGLContextParameter<br>Defined as part of enum type "CGLContextParameter" */
  public static final int kCGLCPGPUFragmentProcessing = 311;
  /** Part of CGLContextParameter<br>Defined as part of enum type "CGLContextParameter" */
  public static final int kCGLCPHasDrawable = 314;
  /** Part of CGLContextParameter<br>Defined as part of enum type "CGLContextParameter" */
  public static final int kCGLCPMPSwapsInFlight = 315;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFAAllRenderers = 1;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFADoubleBuffer = 5;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFAStereo = 6;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFAAuxBuffers = 7;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFAColorSize = 8;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFAAlphaSize = 11;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFADepthSize = 12;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFAStencilSize = 13;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFAAccumSize = 14;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFAMinimumPolicy = 51;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFAMaximumPolicy = 52;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFAOffScreen = 53;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFAFullScreen = 54;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFASampleBuffers = 55;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFASamples = 56;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFAAuxDepthStencil = 57;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFAColorFloat = 58;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFAMultisample = 59;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFASupersample = 60;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFASampleAlpha = 61;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFARendererID = 70;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFASingleRenderer = 71;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFANoRecovery = 72;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFAAccelerated = 73;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFAClosestPolicy = 74;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFARobust = 75;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFABackingStore = 76;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFAMPSafe = 78;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFAWindow = 80;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFAMultiScreen = 81;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFACompliant = 83;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFADisplayMask = 84;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFAPBuffer = 90;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFARemotePBuffer = 91;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFAAcceleratedCompute = 97;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFAOpenGLProfile = 99;
  /** Part of CGLPixelFormatAttribute<br>Defined as part of enum type "CGLPixelFormatAttribute" */
  public static final int kCGLPFAVirtualScreenCount = 128;
  /** Part of CGLError<br>Defined as part of enum type "CGLError" */
  public static final int kCGLNoError = 0;
  /** Part of CGLError<br>Defined as part of enum type "CGLError" */
  public static final int kCGLBadAttribute = 10000;
  /** Part of CGLError<br>Defined as part of enum type "CGLError" */
  public static final int kCGLBadProperty = 10001;
  /** Part of CGLError<br>Defined as part of enum type "CGLError" */
  public static final int kCGLBadPixelFormat = 10002;
  /** Part of CGLError<br>Defined as part of enum type "CGLError" */
  public static final int kCGLBadRendererInfo = 10003;
  /** Part of CGLError<br>Defined as part of enum type "CGLError" */
  public static final int kCGLBadContext = 10004;
  /** Part of CGLError<br>Defined as part of enum type "CGLError" */
  public static final int kCGLBadDrawable = 10005;
  /** Part of CGLError<br>Defined as part of enum type "CGLError" */
  public static final int kCGLBadDisplay = 10006;
  /** Part of CGLError<br>Defined as part of enum type "CGLError" */
  public static final int kCGLBadState = 10007;
  /** Part of CGLError<br>Defined as part of enum type "CGLError" */
  public static final int kCGLBadValue = 10008;
  /** Part of CGLError<br>Defined as part of enum type "CGLError" */
  public static final int kCGLBadMatch = 10009;
  /** Part of CGLError<br>Defined as part of enum type "CGLError" */
  public static final int kCGLBadEnumeration = 10010;
  /** Part of CGLError<br>Defined as part of enum type "CGLError" */
  public static final int kCGLBadOffScreen = 10011;
  /** Part of CGLError<br>Defined as part of enum type "CGLError" */
  public static final int kCGLBadFullScreen = 10012;
  /** Part of CGLError<br>Defined as part of enum type "CGLError" */
  public static final int kCGLBadWindow = 10013;
  /** Part of CGLError<br>Defined as part of enum type "CGLError" */
  public static final int kCGLBadAddress = 10014;
  /** Part of CGLError<br>Defined as part of enum type "CGLError" */
  public static final int kCGLBadCodeModule = 10015;
  /** Part of CGLError<br>Defined as part of enum type "CGLError" */
  public static final int kCGLBadAlloc = 10016;
  /** Part of CGLError<br>Defined as part of enum type "CGLError" */
  public static final int kCGLBadConnection = 10017;
  /** Part of CGLOpenGLProfile<br>Defined as part of enum type "CGLOpenGLProfile" */
  public static final int kCGLOGLPVersion_Legacy = 4096;
  /** Part of CGLOpenGLProfile<br>Defined as part of enum type "CGLOpenGLProfile" */
  public static final int kCGLOGLPVersion_3_2_Core = 12800;

  /** Interface to C language function: <br> <code> CGLError CGLChoosePixelFormat(CGLPixelFormatAttribute *  attribs, CGLPixelFormatObj *  pix, GLint *  npix); </code> 
      @param attribs a direct or array-backed {@link java.nio.IntBuffer}
      @param pix a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param npix a direct or array-backed {@link java.nio.IntBuffer}   */
  public static int CGLChoosePixelFormat(IntBuffer attribs, PointerBuffer pix, IntBuffer npix)  {

    final boolean attribs_is_direct = Buffers.isDirect(attribs);
    final boolean pix_is_direct = Buffers.isDirect(pix);
    final boolean npix_is_direct = Buffers.isDirect(npix);
        return CGLChoosePixelFormat1(attribs_is_direct ? attribs : Buffers.getArray(attribs), attribs_is_direct ? Buffers.getDirectBufferByteOffset(attribs) : Buffers.getIndirectBufferByteOffset(attribs), attribs_is_direct, pix_is_direct ? ( pix != null ? pix.getBuffer() : null ) : Buffers.getArray(pix), pix_is_direct ? Buffers.getDirectBufferByteOffset(pix) : Buffers.getIndirectBufferByteOffset(pix), pix_is_direct, npix_is_direct ? npix : Buffers.getArray(npix), npix_is_direct ? Buffers.getDirectBufferByteOffset(npix) : Buffers.getIndirectBufferByteOffset(npix), npix_is_direct);
  }

  /** Entry point to C language function: <code> CGLError CGLChoosePixelFormat(CGLPixelFormatAttribute *  attribs, CGLPixelFormatObj *  pix, GLint *  npix); </code> 
      @param attribs a direct or array-backed {@link java.nio.IntBuffer}
      @param pix a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param npix a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native int CGLChoosePixelFormat1(Object attribs, int attribs_byte_offset, boolean attribs_is_direct, Object pix, int pix_byte_offset, boolean pix_is_direct, Object npix, int npix_byte_offset, boolean npix_is_direct);

  /** Interface to C language function: <br> <code> CGLError CGLChoosePixelFormat(CGLPixelFormatAttribute *  attribs, CGLPixelFormatObj *  pix, GLint *  npix); </code> 
      @param pix a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static int CGLChoosePixelFormat(int[] attribs, int attribs_offset, PointerBuffer pix, int[] npix, int npix_offset)  {

    if(attribs != null && attribs.length <= attribs_offset)
      throw new GLException("array offset argument \"attribs_offset\" (" + attribs_offset + ") equals or exceeds array length (" + attribs.length + ")");
    final boolean pix_is_direct = Buffers.isDirect(pix);
    if(npix != null && npix.length <= npix_offset)
      throw new GLException("array offset argument \"npix_offset\" (" + npix_offset + ") equals or exceeds array length (" + npix.length + ")");
        return CGLChoosePixelFormat1(attribs, Buffers.SIZEOF_INT * attribs_offset, false, pix_is_direct ? ( pix != null ? pix.getBuffer() : null ) : Buffers.getArray(pix), pix_is_direct ? Buffers.getDirectBufferByteOffset(pix) : Buffers.getIndirectBufferByteOffset(pix), pix_is_direct, npix, Buffers.SIZEOF_INT * npix_offset, false);
  }

  /** Interface to C language function: <br> <code> CGLError CGLCopyContext(CGLContextObj src, CGLContextObj dst, int mask); </code>    */
  public static native int CGLCopyContext(long src, long dst, int mask);

  /** Interface to C language function: <br> <code> CGLError CGLCreateContext(CGLPixelFormatObj pix, CGLContextObj share, CGLContextObj *  ctx); </code> 
      @param ctx a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static int CGLCreateContext(long pix, long share, PointerBuffer ctx)  {

    final boolean ctx_is_direct = Buffers.isDirect(ctx);
        return CGLCreateContext1(pix, share, ctx_is_direct ? ( ctx != null ? ctx.getBuffer() : null ) : Buffers.getArray(ctx), ctx_is_direct ? Buffers.getDirectBufferByteOffset(ctx) : Buffers.getIndirectBufferByteOffset(ctx), ctx_is_direct);
  }

  /** Entry point to C language function: <code> CGLError CGLCreateContext(CGLPixelFormatObj pix, CGLContextObj share, CGLContextObj *  ctx); </code> 
      @param ctx a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native int CGLCreateContext1(long pix, long share, Object ctx, int ctx_byte_offset, boolean ctx_is_direct);

  /** Interface to C language function: <br> <code> CGLError CGLCreatePBuffer(GLsizei width, GLsizei height, GLenum target, GLenum internalFormat, GLint max_level, CGLPBufferObj *  pbuffer); </code> 
      @param pbuffer a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static int CGLCreatePBuffer(int width, int height, int target, int internalFormat, int max_level, PointerBuffer pbuffer)  {

    final boolean pbuffer_is_direct = Buffers.isDirect(pbuffer);
        return CGLCreatePBuffer1(width, height, target, internalFormat, max_level, pbuffer_is_direct ? ( pbuffer != null ? pbuffer.getBuffer() : null ) : Buffers.getArray(pbuffer), pbuffer_is_direct ? Buffers.getDirectBufferByteOffset(pbuffer) : Buffers.getIndirectBufferByteOffset(pbuffer), pbuffer_is_direct);
  }

  /** Entry point to C language function: <code> CGLError CGLCreatePBuffer(GLsizei width, GLsizei height, GLenum target, GLenum internalFormat, GLint max_level, CGLPBufferObj *  pbuffer); </code> 
      @param pbuffer a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native int CGLCreatePBuffer1(int width, int height, int target, int internalFormat, int max_level, Object pbuffer, int pbuffer_byte_offset, boolean pbuffer_is_direct);

  /** Interface to C language function: <br> <code> CGLError CGLDestroyContext(CGLContextObj ctx); </code>    */
  public static native int CGLDestroyContext(long ctx);

  /** Interface to C language function: <br> <code> CGLError CGLDestroyPBuffer(CGLPBufferObj pbuffer); </code>    */
  public static native int CGLDestroyPBuffer(long pbuffer);

  /** Interface to C language function: <br> <code> CGLError CGLDestroyPixelFormat(CGLPixelFormatObj pix); </code>    */
  public static native int CGLDestroyPixelFormat(long pix);

  /** Interface to C language function: <br> <code> CGLError CGLFlushDrawable(CGLContextObj ctx); </code>    */
  public static native int CGLFlushDrawable(long ctx);

  /** Interface to C language function: <br> <code> CGLContextObj CGLGetCurrentContext(void); </code>    */
  public static native long CGLGetCurrentContext();

  /** Interface to C language function: <br> <code> CGLPixelFormatObj CGLGetPixelFormat(CGLContextObj ctx); </code>    */
  public static native long CGLGetPixelFormat(long ctx);

  /** Interface to C language function: <br> <code> CGLShareGroupObj CGLGetShareGroup(CGLContextObj ctx); </code>    */
  public static native long CGLGetShareGroup(long ctx);

  /** Interface to C language function: <br> <code> CGLError CGLLockContext(CGLContextObj ctx); </code>    */
  public static native int CGLLockContext(long ctx);

  /** Interface to C language function: <br> <code> void CGLQueryPixelFormat(CGLPixelFormatObj fmt, int *  iattrs, int niattrs, int *  ivalues); </code> 
      @param iattrs a direct or array-backed {@link java.nio.IntBuffer}
      @param ivalues a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void CGLQueryPixelFormat(long fmt, IntBuffer iattrs, int niattrs, IntBuffer ivalues)  {

    final boolean iattrs_is_direct = Buffers.isDirect(iattrs);
    final boolean ivalues_is_direct = Buffers.isDirect(ivalues);
        CGLQueryPixelFormat1(fmt, iattrs_is_direct ? iattrs : Buffers.getArray(iattrs), iattrs_is_direct ? Buffers.getDirectBufferByteOffset(iattrs) : Buffers.getIndirectBufferByteOffset(iattrs), iattrs_is_direct, niattrs, ivalues_is_direct ? ivalues : Buffers.getArray(ivalues), ivalues_is_direct ? Buffers.getDirectBufferByteOffset(ivalues) : Buffers.getIndirectBufferByteOffset(ivalues), ivalues_is_direct);
  }

  /** Entry point to C language function: <code> void CGLQueryPixelFormat(CGLPixelFormatObj fmt, int *  iattrs, int niattrs, int *  ivalues); </code> 
      @param iattrs a direct or array-backed {@link java.nio.IntBuffer}
      @param ivalues a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void CGLQueryPixelFormat1(long fmt, Object iattrs, int iattrs_byte_offset, boolean iattrs_is_direct, int niattrs, Object ivalues, int ivalues_byte_offset, boolean ivalues_is_direct);

  /** Interface to C language function: <br> <code> void CGLQueryPixelFormat(CGLPixelFormatObj fmt, int *  iattrs, int niattrs, int *  ivalues); </code>    */
  public static void CGLQueryPixelFormat(long fmt, int[] iattrs, int iattrs_offset, int niattrs, int[] ivalues, int ivalues_offset)  {

    if(iattrs != null && iattrs.length <= iattrs_offset)
      throw new GLException("array offset argument \"iattrs_offset\" (" + iattrs_offset + ") equals or exceeds array length (" + iattrs.length + ")");
    if(ivalues != null && ivalues.length <= ivalues_offset)
      throw new GLException("array offset argument \"ivalues_offset\" (" + ivalues_offset + ") equals or exceeds array length (" + ivalues.length + ")");
        CGLQueryPixelFormat1(fmt, iattrs, Buffers.SIZEOF_INT * iattrs_offset, false, niattrs, ivalues, Buffers.SIZEOF_INT * ivalues_offset, false);
  }

  /** Interface to C language function: <br> <code> void CGLReleaseContext(CGLContextObj ctx); </code>    */
  public static native void CGLReleaseContext(long ctx);

  /** Interface to C language function: <br> <code> CGLError CGLSetCurrentContext(CGLContextObj ctx); </code>    */
  public static native int CGLSetCurrentContext(long ctx);

  /** Interface to C language function: <br> <code> CGLError CGLSetPBuffer(CGLContextObj ctx, CGLPBufferObj pbuffer, GLenum face, GLint level, GLint screen); </code>    */
  public static native int CGLSetPBuffer(long ctx, long pbuffer, int face, int level, int screen);

  /** Interface to C language function: <br> <code> CGLError CGLSetParameter(CGLContextObj ctx, CGLContextParameter pname, const int *  params); </code> 
      @param pname valid values are: <code>kCGLCPSwapRectangle, kCGLCPSwapInterval, kCGLCPDispatchTableSize, kCGLCPClientStorage, kCGLCPSurfaceTexture, kCGLCPSurfaceOrder, kCGLCPSurfaceOpacity, kCGLCPSurfaceBackingSize, kCGLCPSurfaceSurfaceVolatile, kCGLCPReclaimResources, kCGLCPCurrentRendererID, kCGLCPGPUVertexProcessing, kCGLCPGPUFragmentProcessing, kCGLCPHasDrawable, kCGLCPMPSwapsInFlight</code>

      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public static int CGLSetParameter(long ctx, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
        return CGLSetParameter1(ctx, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct);
  }

  /** Entry point to C language function: <code> CGLError CGLSetParameter(CGLContextObj ctx, CGLContextParameter pname, const int *  params); </code> 
      @param pname valid values are: <code>kCGLCPSwapRectangle, kCGLCPSwapInterval, kCGLCPDispatchTableSize, kCGLCPClientStorage, kCGLCPSurfaceTexture, kCGLCPSurfaceOrder, kCGLCPSurfaceOpacity, kCGLCPSurfaceBackingSize, kCGLCPSurfaceSurfaceVolatile, kCGLCPReclaimResources, kCGLCPCurrentRendererID, kCGLCPGPUVertexProcessing, kCGLCPGPUFragmentProcessing, kCGLCPHasDrawable, kCGLCPMPSwapsInFlight</code>

      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native int CGLSetParameter1(long ctx, int pname, Object params, int params_byte_offset, boolean params_is_direct);

  /** Interface to C language function: <br> <code> CGLError CGLSetParameter(CGLContextObj ctx, CGLContextParameter pname, const int *  params); </code> 
      @param pname valid values are: <code>kCGLCPSwapRectangle, kCGLCPSwapInterval, kCGLCPDispatchTableSize, kCGLCPClientStorage, kCGLCPSurfaceTexture, kCGLCPSurfaceOrder, kCGLCPSurfaceOpacity, kCGLCPSurfaceBackingSize, kCGLCPSurfaceSurfaceVolatile, kCGLCPReclaimResources, kCGLCPCurrentRendererID, kCGLCPGPUVertexProcessing, kCGLCPGPUFragmentProcessing, kCGLCPHasDrawable, kCGLCPMPSwapsInFlight</code>
   */
  public static int CGLSetParameter(long ctx, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
        return CGLSetParameter1(ctx, pname, params, Buffers.SIZEOF_INT * params_offset, false);
  }

  /** Interface to C language function: <br> <code> CGLError CGLUnlockContext(CGLContextObj ctx); </code>    */
  public static native int CGLUnlockContext(long ctx);

  /** Interface to C language function: <br> <code> Bool clearCurrentContext(NSOpenGLContext *  ctx); </code>    */
  public static native boolean clearCurrentContext(long ctx);

  /** Interface to C language function: <br> <code> void copyContext(NSOpenGLContext *  dest, NSOpenGLContext *  src, int mask); </code>    */
  public static native void copyContext(long dest, long src, int mask);

  /** Interface to C language function: <br> <code> NSOpenGLContext *  createContext(NSOpenGLContext *  shareContext, NSView *  nsView, Bool allowIncompleteView, NSOpenGLPixelFormat *  pixelFormat, Bool opaque, int *  viewNotReady); </code> 
      @param viewNotReady a direct or array-backed {@link java.nio.IntBuffer}   */
  public static long createContext(long shareContext, long nsView, boolean allowIncompleteView, long pixelFormat, boolean opaque, IntBuffer viewNotReady)  {

    final boolean viewNotReady_is_direct = Buffers.isDirect(viewNotReady);
        return createContext1(shareContext, nsView, allowIncompleteView, pixelFormat, opaque, viewNotReady_is_direct ? viewNotReady : Buffers.getArray(viewNotReady), viewNotReady_is_direct ? Buffers.getDirectBufferByteOffset(viewNotReady) : Buffers.getIndirectBufferByteOffset(viewNotReady), viewNotReady_is_direct);
  }

  /** Entry point to C language function: <code> NSOpenGLContext *  createContext(NSOpenGLContext *  shareContext, NSView *  nsView, Bool allowIncompleteView, NSOpenGLPixelFormat *  pixelFormat, Bool opaque, int *  viewNotReady); </code> 
      @param viewNotReady a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native long createContext1(long shareContext, long nsView, boolean allowIncompleteView, long pixelFormat, boolean opaque, Object viewNotReady, int viewNotReady_byte_offset, boolean viewNotReady_is_direct);

  /** Interface to C language function: <br> <code> NSOpenGLContext *  createContext(NSOpenGLContext *  shareContext, NSView *  nsView, Bool allowIncompleteView, NSOpenGLPixelFormat *  pixelFormat, Bool opaque, int *  viewNotReady); </code>    */
  public static long createContext(long shareContext, long nsView, boolean allowIncompleteView, long pixelFormat, boolean opaque, int[] viewNotReady, int viewNotReady_offset)  {

    if(viewNotReady != null && viewNotReady.length <= viewNotReady_offset)
      throw new GLException("array offset argument \"viewNotReady_offset\" (" + viewNotReady_offset + ") equals or exceeds array length (" + viewNotReady.length + ")");
        return createContext1(shareContext, nsView, allowIncompleteView, pixelFormat, opaque, viewNotReady, Buffers.SIZEOF_INT * viewNotReady_offset, false);
  }

  /** Interface to C language function: <br> <code> NSOpenGLLayer *  createNSOpenGLLayer(NSOpenGLContext *  ctx, NSOpenGLPixelFormat *  fmt, NSOpenGLPixelBuffer *  pbuffer, Bool opaque, int texWidth, int texHeight); </code>    */
  public static native long createNSOpenGLLayer(long ctx, long fmt, long pbuffer, boolean opaque, int texWidth, int texHeight);

  /** Interface to C language function: <br> <code> NSOpenGLPixelBuffer *  createPBuffer(int renderTarget, int internalFormat, int width, int height); </code>    */
  public static native long createPBuffer(int renderTarget, int internalFormat, int width, int height);

  /** Interface to C language function: <br> <code> NSOpenGLPixelFormat *  createPixelFormat(int *  iattrs, int niattrs, int *  ivalues); </code> 
      @param iattrs a direct or array-backed {@link java.nio.IntBuffer}
      @param ivalues a direct or array-backed {@link java.nio.IntBuffer}   */
  public static long createPixelFormat(IntBuffer iattrs, int niattrs, IntBuffer ivalues)  {

    final boolean iattrs_is_direct = Buffers.isDirect(iattrs);
    final boolean ivalues_is_direct = Buffers.isDirect(ivalues);
        return createPixelFormat1(iattrs_is_direct ? iattrs : Buffers.getArray(iattrs), iattrs_is_direct ? Buffers.getDirectBufferByteOffset(iattrs) : Buffers.getIndirectBufferByteOffset(iattrs), iattrs_is_direct, niattrs, ivalues_is_direct ? ivalues : Buffers.getArray(ivalues), ivalues_is_direct ? Buffers.getDirectBufferByteOffset(ivalues) : Buffers.getIndirectBufferByteOffset(ivalues), ivalues_is_direct);
  }

  /** Entry point to C language function: <code> NSOpenGLPixelFormat *  createPixelFormat(int *  iattrs, int niattrs, int *  ivalues); </code> 
      @param iattrs a direct or array-backed {@link java.nio.IntBuffer}
      @param ivalues a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native long createPixelFormat1(Object iattrs, int iattrs_byte_offset, boolean iattrs_is_direct, int niattrs, Object ivalues, int ivalues_byte_offset, boolean ivalues_is_direct);

  /** Interface to C language function: <br> <code> NSOpenGLPixelFormat *  createPixelFormat(int *  iattrs, int niattrs, int *  ivalues); </code>    */
  public static long createPixelFormat(int[] iattrs, int iattrs_offset, int niattrs, int[] ivalues, int ivalues_offset)  {

    if(iattrs != null && iattrs.length <= iattrs_offset)
      throw new GLException("array offset argument \"iattrs_offset\" (" + iattrs_offset + ") equals or exceeds array length (" + iattrs.length + ")");
    if(ivalues != null && ivalues.length <= ivalues_offset)
      throw new GLException("array offset argument \"ivalues_offset\" (" + ivalues_offset + ") equals or exceeds array length (" + ivalues.length + ")");
        return createPixelFormat1(iattrs, Buffers.SIZEOF_INT * iattrs_offset, false, niattrs, ivalues, Buffers.SIZEOF_INT * ivalues_offset, false);
  }

  /** Interface to C language function: <br> <code> Bool deleteContext(NSOpenGLContext *  ctx, Bool releaseOnMainThread); </code>    */
  public static native boolean deleteContext(long ctx, boolean releaseOnMainThread);

  /** Interface to C language function: <br> <code> void deletePixelFormat(NSOpenGLPixelFormat *  fmt); </code>    */
  public static native void deletePixelFormat(long fmt);

  /** Interface to C language function: <br> <code> Bool destroyPBuffer(NSOpenGLPixelBuffer *  pBuffer); </code>    */
  public static native boolean destroyPBuffer(long pBuffer);

  /** Interface to C language function: <br> <code> Bool flushBuffer(NSOpenGLContext *  ctx); </code>    */
  public static native boolean flushBuffer(long ctx);

  /** Interface to C language function: <br> <code> CGLContextObj getCGLContext(NSOpenGLContext *  ctx); </code>    */
  public static native long getCGLContext(long ctx);

  /** Interface to C language function: <br> <code> NSOpenGLContext *  getCurrentContext(void); </code>    */
  public static native long getCurrentContext();

  /** Interface to C language function: <br> <code> NSView *  getNSView(NSOpenGLContext *  ctx); </code>    */
  public static native long getNSView(long ctx);

  /** Interface to C language function: <br> <code> void *  getProcAddress(const char *  procName); </code>    */
  public static native long getProcAddress(String procName);

  /** Interface to C language function: <br> <code> int getScreenRefreshRate(int scrn_idx); </code>    */
  public static native int getScreenRefreshRate(int scrn_idx);

  /** Interface to C language function: <br> <code> Bool makeCurrentContext(NSOpenGLContext *  ctx); </code>    */
  public static native boolean makeCurrentContext(long ctx);

  /** Interface to C language function: <br> <code> void queryPixelFormat(NSOpenGLPixelFormat *  fmt, int *  iattrs, int niattrs, int *  ivalues); </code> 
      @param iattrs a direct or array-backed {@link java.nio.IntBuffer}
      @param ivalues a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void queryPixelFormat(long fmt, IntBuffer iattrs, int niattrs, IntBuffer ivalues)  {

    final boolean iattrs_is_direct = Buffers.isDirect(iattrs);
    final boolean ivalues_is_direct = Buffers.isDirect(ivalues);
        queryPixelFormat1(fmt, iattrs_is_direct ? iattrs : Buffers.getArray(iattrs), iattrs_is_direct ? Buffers.getDirectBufferByteOffset(iattrs) : Buffers.getIndirectBufferByteOffset(iattrs), iattrs_is_direct, niattrs, ivalues_is_direct ? ivalues : Buffers.getArray(ivalues), ivalues_is_direct ? Buffers.getDirectBufferByteOffset(ivalues) : Buffers.getIndirectBufferByteOffset(ivalues), ivalues_is_direct);
  }

  /** Entry point to C language function: <code> void queryPixelFormat(NSOpenGLPixelFormat *  fmt, int *  iattrs, int niattrs, int *  ivalues); </code> 
      @param iattrs a direct or array-backed {@link java.nio.IntBuffer}
      @param ivalues a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void queryPixelFormat1(long fmt, Object iattrs, int iattrs_byte_offset, boolean iattrs_is_direct, int niattrs, Object ivalues, int ivalues_byte_offset, boolean ivalues_is_direct);

  /** Interface to C language function: <br> <code> void queryPixelFormat(NSOpenGLPixelFormat *  fmt, int *  iattrs, int niattrs, int *  ivalues); </code>    */
  public static void queryPixelFormat(long fmt, int[] iattrs, int iattrs_offset, int niattrs, int[] ivalues, int ivalues_offset)  {

    if(iattrs != null && iattrs.length <= iattrs_offset)
      throw new GLException("array offset argument \"iattrs_offset\" (" + iattrs_offset + ") equals or exceeds array length (" + iattrs.length + ")");
    if(ivalues != null && ivalues.length <= ivalues_offset)
      throw new GLException("array offset argument \"ivalues_offset\" (" + ivalues_offset + ") equals or exceeds array length (" + ivalues.length + ")");
        queryPixelFormat1(fmt, iattrs, Buffers.SIZEOF_INT * iattrs_offset, false, niattrs, ivalues, Buffers.SIZEOF_INT * ivalues_offset, false);
  }

  /** Interface to C language function: <br> <code> void releaseNSOpenGLLayer(NSOpenGLLayer *  glLayer); </code>    */
  public static native void releaseNSOpenGLLayer(long glLayer);

  /** Interface to C language function: <br> <code> void resetGammaRamp(); </code>    */
  public static native void resetGammaRamp();

  /** Interface to C language function: <br> <code> void setContextOpacity(NSOpenGLContext *  ctx, int opacity); </code>    */
  public static native void setContextOpacity(long ctx, int opacity);

  /** Interface to C language function: <br> <code> void setContextPBuffer(NSOpenGLContext *  ctx, NSOpenGLPixelBuffer *  pBuffer); </code>    */
  public static native void setContextPBuffer(long ctx, long pBuffer);

  /** Interface to C language function: <br> <code> void setContextTextureImageToPBuffer(NSOpenGLContext *  ctx, NSOpenGLPixelBuffer *  pBuffer, GLenum colorBuffer); </code>    */
  public static native void setContextTextureImageToPBuffer(long ctx, long pBuffer, int colorBuffer);

  /** Interface to C language function: <br> <code> Bool setGammaRamp(int tableSize, float *  redRamp, float *  greenRamp, float *  blueRamp); </code> 
      @param redRamp a direct or array-backed {@link java.nio.FloatBuffer}
      @param greenRamp a direct or array-backed {@link java.nio.FloatBuffer}
      @param blueRamp a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static boolean setGammaRamp(int tableSize, FloatBuffer redRamp, FloatBuffer greenRamp, FloatBuffer blueRamp)  {

    final boolean redRamp_is_direct = Buffers.isDirect(redRamp);
    final boolean greenRamp_is_direct = Buffers.isDirect(greenRamp);
    final boolean blueRamp_is_direct = Buffers.isDirect(blueRamp);
        return setGammaRamp1(tableSize, redRamp_is_direct ? redRamp : Buffers.getArray(redRamp), redRamp_is_direct ? Buffers.getDirectBufferByteOffset(redRamp) : Buffers.getIndirectBufferByteOffset(redRamp), redRamp_is_direct, greenRamp_is_direct ? greenRamp : Buffers.getArray(greenRamp), greenRamp_is_direct ? Buffers.getDirectBufferByteOffset(greenRamp) : Buffers.getIndirectBufferByteOffset(greenRamp), greenRamp_is_direct, blueRamp_is_direct ? blueRamp : Buffers.getArray(blueRamp), blueRamp_is_direct ? Buffers.getDirectBufferByteOffset(blueRamp) : Buffers.getIndirectBufferByteOffset(blueRamp), blueRamp_is_direct);
  }

  /** Entry point to C language function: <code> Bool setGammaRamp(int tableSize, float *  redRamp, float *  greenRamp, float *  blueRamp); </code> 
      @param redRamp a direct or array-backed {@link java.nio.FloatBuffer}
      @param greenRamp a direct or array-backed {@link java.nio.FloatBuffer}
      @param blueRamp a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native boolean setGammaRamp1(int tableSize, Object redRamp, int redRamp_byte_offset, boolean redRamp_is_direct, Object greenRamp, int greenRamp_byte_offset, boolean greenRamp_is_direct, Object blueRamp, int blueRamp_byte_offset, boolean blueRamp_is_direct);

  /** Interface to C language function: <br> <code> Bool setGammaRamp(int tableSize, float *  redRamp, float *  greenRamp, float *  blueRamp); </code>    */
  public static boolean setGammaRamp(int tableSize, float[] redRamp, int redRamp_offset, float[] greenRamp, int greenRamp_offset, float[] blueRamp, int blueRamp_offset)  {

    if(redRamp != null && redRamp.length <= redRamp_offset)
      throw new GLException("array offset argument \"redRamp_offset\" (" + redRamp_offset + ") equals or exceeds array length (" + redRamp.length + ")");
    if(greenRamp != null && greenRamp.length <= greenRamp_offset)
      throw new GLException("array offset argument \"greenRamp_offset\" (" + greenRamp_offset + ") equals or exceeds array length (" + greenRamp.length + ")");
    if(blueRamp != null && blueRamp.length <= blueRamp_offset)
      throw new GLException("array offset argument \"blueRamp_offset\" (" + blueRamp_offset + ") equals or exceeds array length (" + blueRamp.length + ")");
        return setGammaRamp1(tableSize, redRamp, Buffers.SIZEOF_FLOAT * redRamp_offset, false, greenRamp, Buffers.SIZEOF_FLOAT * greenRamp_offset, false, blueRamp, Buffers.SIZEOF_FLOAT * blueRamp_offset, false);
  }

  /** Interface to C language function: <br> <code> void setNSOpenGLLayerNeedsDisplay(NSOpenGLLayer *  glLayer); </code>    */
  public static native void setNSOpenGLLayerNeedsDisplay(long glLayer);

  /** Interface to C language function: <br> <code> void setNSOpenGLLayerSwapInterval(NSOpenGLLayer *  layer, int interval); </code>    */
  public static native void setNSOpenGLLayerSwapInterval(long layer, int interval);

  /** Interface to C language function: <br> <code> void setSwapInterval(NSOpenGLContext *  ctx, int interval); </code>    */
  public static native void setSwapInterval(long ctx, int interval);

  /** Interface to C language function: <br> <code> void updateContext(NSOpenGLContext *  ctx); </code>    */
  public static native void updateContext(long ctx);

  /** Interface to C language function: <br> <code> Bool updateContextNeedsUpdate(void *  updater); </code>    */
  public static native boolean updateContextNeedsUpdate(long updater);

  /** Interface to C language function: <br> <code> void *  updateContextRegister(NSOpenGLContext *  ctx, NSView *  view); </code>    */
  public static native long updateContextRegister(long ctx, long view);

  /** Interface to C language function: <br> <code> void updateContextUnregister(void *  updater); </code>    */
  public static native void updateContextUnregister(long updater);

  /** Interface to C language function: <br> <code> void waitUntilNSOpenGLLayerIsReady(NSOpenGLLayer *  layer, long to_micros); </code>    */
  public static native void waitUntilNSOpenGLLayerIsReady(long layer, long to_micros);


} // end of class CGL
