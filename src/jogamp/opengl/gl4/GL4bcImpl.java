/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Fri Aug 03 06:28:15 CEST 2012 ----! */

package jogamp.opengl.gl4;

import java.util.*;
import javax.media.opengl.*;
import javax.media.opengl.fixedfunc.*;
import jogamp.opengl.*;
import javax.media.opengl.GLES1;
import javax.media.opengl.GLES2;
import javax.media.opengl.GL2GL3;
import javax.media.opengl.GL2;
import javax.media.opengl.GL3;
import javax.media.opengl.GL3bc;
import javax.media.opengl.GL4;
import com.jogamp.common.nio.Buffers;
import com.jogamp.opengl.util.GLBuffers;
import java.io.PrintStream;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class GL4bcImpl implements GLBase, GL, GL2ES1, GL2ES2, GL2GL3, GL2, GL3, GL3bc, GL4, GL4bc{
  /** Entry point to C language function: <code> void {@native glAccum}(GLenum op, GLfloat value); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glAccum(int op, float value)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glAccum;
    if (__addr_ == 0) {
      throw new GLException("Method \"glAccum\" not available");
    }
        dispatch_glAccum1(op, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glAccum}(GLenum op, GLfloat value); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glAccum1(int op, float value, long procAddress);

  /** Entry point to C language function: <code> void {@native glActiveShaderProgram}(GLuint pipeline, GLuint program); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glActiveShaderProgram(int pipeline, int program)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glActiveShaderProgram;
    if (__addr_ == 0) {
      throw new GLException("Method \"glActiveShaderProgram\" not available");
    }
        dispatch_glActiveShaderProgram1(pipeline, program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glActiveShaderProgram}(GLuint pipeline, GLuint program); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public native void dispatch_glActiveShaderProgram1(int pipeline, int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glActiveStencilFaceEXT}(GLenum face); </code> <br>Part of <code>GL_EXT_stencil_two_side</code>   */
  public void glActiveStencilFaceEXT(int face)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glActiveStencilFaceEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glActiveStencilFaceEXT\" not available");
    }
        dispatch_glActiveStencilFaceEXT1(face, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glActiveStencilFaceEXT}(GLenum face); </code> <br>Part of <code>GL_EXT_stencil_two_side</code>   */
  public native void dispatch_glActiveStencilFaceEXT1(int face, long procAddress);

  /** Entry point to C language function: <code> void {@native glActiveTexture}(GLenum texture); </code> <br>Part of <code>GL_VERSION_1_3</code>   */
  public void glActiveTexture(int texture)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glActiveTexture;
    if (__addr_ == 0) {
      throw new GLException("Method \"glActiveTexture\" not available");
    }
        dispatch_glActiveTexture1(texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glActiveTexture}(GLenum texture); </code> <br>Part of <code>GL_VERSION_1_3</code>   */
  public native void dispatch_glActiveTexture1(int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glAlphaFunc}(GLenum func, GLclampf ref); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glAlphaFunc(int func, float ref)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glAlphaFunc;
    if (__addr_ == 0) {
      throw new GLException("Method \"glAlphaFunc\" not available");
    }
        dispatch_glAlphaFunc1(func, ref, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glAlphaFunc}(GLenum func, GLclampf ref); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glAlphaFunc1(int func, float ref, long procAddress);

  /** Entry point to C language function: <code> void {@native glApplyTextureEXT}(GLenum mode); </code> <br>Part of <code>GL_EXT_light_texture</code>   */
  public void glApplyTextureEXT(int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glApplyTextureEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glApplyTextureEXT\" not available");
    }
        dispatch_glApplyTextureEXT1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glApplyTextureEXT}(GLenum mode); </code> <br>Part of <code>GL_EXT_light_texture</code>   */
  public native void dispatch_glApplyTextureEXT1(int mode, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glAreTexturesResident}(GLsizei n, const GLuint *  textures, GLboolean *  residences); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}
      @param residences a direct or array-backed {@link java.nio.ByteBuffer}   */
  public boolean glAreTexturesResident(int n, IntBuffer textures, ByteBuffer residences)  {

    final boolean textures_is_direct = Buffers.isDirect(textures);
    final boolean residences_is_direct = Buffers.isDirect(residences);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glAreTexturesResident;
    if (__addr_ == 0) {
      throw new GLException("Method \"glAreTexturesResident\" not available");
    }
        return dispatch_glAreTexturesResident1(n, textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, residences_is_direct ? residences : Buffers.getArray(residences), residences_is_direct ? Buffers.getDirectBufferByteOffset(residences) : Buffers.getIndirectBufferByteOffset(residences), residences_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glAreTexturesResident}(GLsizei n, const GLuint *  textures, GLboolean *  residences); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}
      @param residences a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native boolean dispatch_glAreTexturesResident1(int n, Object textures, int textures_byte_offset, boolean textures_is_direct, Object residences, int residences_byte_offset, boolean residences_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glAreTexturesResident}(GLsizei n, const GLuint *  textures, GLboolean *  residences); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public boolean glAreTexturesResident(int n, int[] textures, int textures_offset, byte[] residences, int residences_offset)  {

    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    if(residences != null && residences.length <= residences_offset)
      throw new GLException("array offset argument \"residences_offset\" (" + residences_offset + ") equals or exceeds array length (" + residences.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glAreTexturesResident;
    if (__addr_ == 0) {
      throw new GLException("Method \"glAreTexturesResident\" not available");
    }
        return dispatch_glAreTexturesResident1(n, textures, Buffers.SIZEOF_INT * textures_offset, false, residences, residences_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glArrayElement}(GLint i); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public void glArrayElement(int i)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glArrayElement;
    if (__addr_ == 0) {
      throw new GLException("Method \"glArrayElement\" not available");
    }
        dispatch_glArrayElement1(i, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glArrayElement}(GLint i); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public native void dispatch_glArrayElement1(int i, long procAddress);

  /** Entry point to C language function: <code> void {@native glAttachObjectARB}(GLhandleARB containerObj, GLhandleARB obj); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glAttachObjectARB(int containerObj, int obj)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glAttachObjectARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glAttachObjectARB\" not available");
    }
        dispatch_glAttachObjectARB1(containerObj, obj, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glAttachObjectARB}(GLhandleARB containerObj, GLhandleARB obj); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public native void dispatch_glAttachObjectARB1(int containerObj, int obj, long procAddress);

  /** Entry point to C language function: <code> void {@native glAttachShader}(GLuint program, GLuint shader); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glAttachShader(int program, int shader)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glAttachShader;
    if (__addr_ == 0) {
      throw new GLException("Method \"glAttachShader\" not available");
    }
        dispatch_glAttachShader1(program, shader, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glAttachShader}(GLuint program, GLuint shader); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glAttachShader1(int program, int shader, long procAddress);

  /** Entry point to C language function: <code> void {@native glBegin}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glBegin(int mode)  {

    inBeginEndPair = true;
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBegin;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBegin\" not available");
    }
        dispatch_glBegin1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBegin}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  private native void dispatch_glBegin1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glBeginConditionalRender}(GLuint id, GLenum mode); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_NV_conditional_render</code>   */
  public void glBeginConditionalRender(int id, int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBeginConditionalRender;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBeginConditionalRender\" not available");
    }
        dispatch_glBeginConditionalRender1(id, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginConditionalRender}(GLuint id, GLenum mode); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_NV_conditional_render</code>   */
  public native void dispatch_glBeginConditionalRender1(int id, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glBeginOcclusionQueryNV}(GLuint id); </code> <br>Part of <code>GL_NV_occlusion_query</code>   */
  public void glBeginOcclusionQueryNV(int id)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBeginOcclusionQueryNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBeginOcclusionQueryNV\" not available");
    }
        dispatch_glBeginOcclusionQueryNV1(id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginOcclusionQueryNV}(GLuint id); </code> <br>Part of <code>GL_NV_occlusion_query</code>   */
  public native void dispatch_glBeginOcclusionQueryNV1(int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glBeginPerfMonitorAMD}(GLuint monitor); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glBeginPerfMonitorAMD(int monitor)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBeginPerfMonitorAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBeginPerfMonitorAMD\" not available");
    }
        dispatch_glBeginPerfMonitorAMD1(monitor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginPerfMonitorAMD}(GLuint monitor); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public native void dispatch_glBeginPerfMonitorAMD1(int monitor, long procAddress);

  /** Entry point to C language function: <code> void {@native glBeginQuery}(GLenum target, GLuint id); </code> <br>Part of <code>GL_VERSION_1_5</code>   */
  public void glBeginQuery(int target, int id)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBeginQuery;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBeginQuery\" not available");
    }
        dispatch_glBeginQuery1(target, id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginQuery}(GLenum target, GLuint id); </code> <br>Part of <code>GL_VERSION_1_5</code>   */
  public native void dispatch_glBeginQuery1(int target, int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glBeginQueryIndexed}(GLenum target, GLuint index, GLuint id); </code> <br>Part of <code>GL_ARB_transform_feedback3</code>   */
  public void glBeginQueryIndexed(int target, int index, int id)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBeginQueryIndexed;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBeginQueryIndexed\" not available");
    }
        dispatch_glBeginQueryIndexed1(target, index, id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginQueryIndexed}(GLenum target, GLuint index, GLuint id); </code> <br>Part of <code>GL_ARB_transform_feedback3</code>   */
  public native void dispatch_glBeginQueryIndexed1(int target, int index, int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glBeginTransformFeedback}(GLenum primitiveMode); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_transform_feedback</code>   */
  public void glBeginTransformFeedback(int primitiveMode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBeginTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBeginTransformFeedback\" not available");
    }
        dispatch_glBeginTransformFeedback1(primitiveMode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginTransformFeedback}(GLenum primitiveMode); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_transform_feedback</code>   */
  public native void dispatch_glBeginTransformFeedback1(int primitiveMode, long procAddress);

  /** Entry point to C language function: <code> void {@native glBeginVertexShaderEXT}(void); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glBeginVertexShaderEXT()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBeginVertexShaderEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBeginVertexShaderEXT\" not available");
    }
        dispatch_glBeginVertexShaderEXT1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginVertexShaderEXT}(void); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public native void dispatch_glBeginVertexShaderEXT1(long procAddress);

  /** Entry point to C language function: <code> void {@native glBeginVideoCaptureNV}(GLuint video_capture_slot); </code> <br>Part of <code>GL_NV_video_capture</code>   */
  public void glBeginVideoCaptureNV(int video_capture_slot)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBeginVideoCaptureNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBeginVideoCaptureNV\" not available");
    }
        dispatch_glBeginVideoCaptureNV1(video_capture_slot, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginVideoCaptureNV}(GLuint video_capture_slot); </code> <br>Part of <code>GL_NV_video_capture</code>   */
  public native void dispatch_glBeginVideoCaptureNV1(int video_capture_slot, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindAttribLocation}(GLuint program, GLuint index, const GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glBindAttribLocation(int program, int index, String name)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindAttribLocation;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindAttribLocation\" not available");
    }
        dispatch_glBindAttribLocation1(program, index, name, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindAttribLocation}(GLuint program, GLuint index, const GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glBindAttribLocation1(int program, int index, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindBuffer}(GLenum target, GLuint buffer); </code> <br>Part of <code>GL_VERSION_1_5</code>   */
  public void glBindBuffer(int target, int buffer)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindBuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindBuffer\" not available");
    }
        dispatch_glBindBuffer1(target, buffer, __addr_);
    bufferStateTracker.setBoundBufferObject(target, buffer);
  }

  /** Entry point to C language function: <code> void {@native glBindBuffer}(GLenum target, GLuint buffer); </code> <br>Part of <code>GL_VERSION_1_5</code>   */
  private native void dispatch_glBindBuffer1(int target, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindBufferBase}(GLenum target, GLuint index, GLuint buffer); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_transform_feedback</code>   */
  public void glBindBufferBase(int target, int index, int buffer)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindBufferBase;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindBufferBase\" not available");
    }
        dispatch_glBindBufferBase1(target, index, buffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindBufferBase}(GLenum target, GLuint index, GLuint buffer); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_transform_feedback</code>   */
  public native void dispatch_glBindBufferBase1(int target, int index, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindBufferOffsetEXT}(GLenum target, GLuint index, GLuint buffer, GLintptr offset); </code> <br>Part of <code>GL_EXT_transform_feedback</code>   */
  public void glBindBufferOffset(int target, int index, int buffer, long offset)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindBufferOffset;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindBufferOffset\" not available");
    }
        dispatch_glBindBufferOffset1(target, index, buffer, offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindBufferOffsetEXT}(GLenum target, GLuint index, GLuint buffer, GLintptr offset); </code> <br>Part of <code>GL_EXT_transform_feedback</code>   */
  public native void dispatch_glBindBufferOffset1(int target, int index, int buffer, long offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindBufferRange}(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_transform_feedback</code>   */
  public void glBindBufferRange(int target, int index, int buffer, long offset, long size)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindBufferRange;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindBufferRange\" not available");
    }
        dispatch_glBindBufferRange1(target, index, buffer, offset, size, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindBufferRange}(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_transform_feedback</code>   */
  public native void dispatch_glBindBufferRange1(int target, int index, int buffer, long offset, long size, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindFragDataLocation}(GLuint program, GLuint color, const GLchar *  name); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public void glBindFragDataLocation(int program, int color, String name)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindFragDataLocation;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindFragDataLocation\" not available");
    }
        dispatch_glBindFragDataLocation1(program, color, name, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindFragDataLocation}(GLuint program, GLuint color, const GLchar *  name); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public native void dispatch_glBindFragDataLocation1(int program, int color, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindFragDataLocationIndexed}(GLuint program, GLuint colorNumber, GLuint index, const GLchar *  name); </code> <br>Part of <code>GL_ARB_blend_func_extended</code>   */
  public void glBindFragDataLocationIndexed(int program, int colorNumber, int index, String name)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindFragDataLocationIndexed;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindFragDataLocationIndexed\" not available");
    }
        dispatch_glBindFragDataLocationIndexed1(program, colorNumber, index, name, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindFragDataLocationIndexed}(GLuint program, GLuint colorNumber, GLuint index, const GLchar *  name); </code> <br>Part of <code>GL_ARB_blend_func_extended</code>   */
  public native void dispatch_glBindFragDataLocationIndexed1(int program, int colorNumber, int index, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindFramebuffer}(GLenum target, GLuint framebuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public void glBindFramebuffer(int target, int framebuffer)  {

    if( 0 == framebuffer ) {
    if( GL_FRAMEBUFFER == target || 0x8CA9 /* GL_DRAW_FRAMEBUFFER */ == target ) {
    framebuffer = _context.getDefaultDrawFramebuffer();
    } else if( 0x8CA8 /* GL_READ_FRAMEBUFFER */ == target ) {
    framebuffer = _context.getDefaultReadFramebuffer();
    }
    }
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindFramebuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindFramebuffer\" not available");
    }
        dispatch_glBindFramebuffer1(target, framebuffer, __addr_);
    _context.setBoundFramebuffer(target, framebuffer);
  }

  /** Entry point to C language function: <code> void {@native glBindFramebuffer}(GLenum target, GLuint framebuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  private native void dispatch_glBindFramebuffer1(int target, int framebuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindImageTexture}(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format); </code> <br>Part of <code>GL_ARB_shader_image_load_store</code>   */
  public void glBindImageTexture(int unit, int texture, int level, boolean layered, int layer, int access, int format)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindImageTexture;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindImageTexture\" not available");
    }
        dispatch_glBindImageTexture1(unit, texture, level, layered, layer, access, format, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindImageTexture}(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format); </code> <br>Part of <code>GL_ARB_shader_image_load_store</code>   */
  public native void dispatch_glBindImageTexture1(int unit, int texture, int level, boolean layered, int layer, int access, int format, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glBindLightParameterEXT}(GLenum light, GLenum value); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public int glBindLightParameterEXT(int light, int value)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindLightParameterEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindLightParameterEXT\" not available");
    }
        return dispatch_glBindLightParameterEXT1(light, value, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glBindLightParameterEXT}(GLenum light, GLenum value); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public native int dispatch_glBindLightParameterEXT1(int light, int value, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glBindMaterialParameterEXT}(GLenum face, GLenum value); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public int glBindMaterialParameterEXT(int face, int value)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindMaterialParameterEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindMaterialParameterEXT\" not available");
    }
        return dispatch_glBindMaterialParameterEXT1(face, value, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glBindMaterialParameterEXT}(GLenum face, GLenum value); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public native int dispatch_glBindMaterialParameterEXT1(int face, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindMultiTextureEXT}(GLenum texunit, GLenum target, GLuint texture); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glBindMultiTextureEXT(int texunit, int target, int texture)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindMultiTextureEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindMultiTextureEXT\" not available");
    }
        dispatch_glBindMultiTextureEXT1(texunit, target, texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindMultiTextureEXT}(GLenum texunit, GLenum target, GLuint texture); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glBindMultiTextureEXT1(int texunit, int target, int texture, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glBindParameterEXT}(GLenum value); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public int glBindParameterEXT(int value)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindParameterEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindParameterEXT\" not available");
    }
        return dispatch_glBindParameterEXT1(value, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glBindParameterEXT}(GLenum value); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public native int dispatch_glBindParameterEXT1(int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindProgramARB}(GLenum target, GLuint program); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glBindProgramARB(int target, int program)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindProgramARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindProgramARB\" not available");
    }
        dispatch_glBindProgramARB1(target, program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindProgramARB}(GLenum target, GLuint program); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public native void dispatch_glBindProgramARB1(int target, int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindProgramPipeline}(GLuint pipeline); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glBindProgramPipeline(int pipeline)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindProgramPipeline;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindProgramPipeline\" not available");
    }
        dispatch_glBindProgramPipeline1(pipeline, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindProgramPipeline}(GLuint pipeline); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public native void dispatch_glBindProgramPipeline1(int pipeline, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindRenderbuffer}(GLenum target, GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public void glBindRenderbuffer(int target, int renderbuffer)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindRenderbuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindRenderbuffer\" not available");
    }
        dispatch_glBindRenderbuffer1(target, renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindRenderbuffer}(GLenum target, GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public native void dispatch_glBindRenderbuffer1(int target, int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindSampler}(GLuint unit, GLuint sampler); </code> <br>Part of <code>GL_ARB_sampler_objects</code>   */
  public void glBindSampler(int unit, int sampler)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindSampler;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindSampler\" not available");
    }
        dispatch_glBindSampler1(unit, sampler, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindSampler}(GLuint unit, GLuint sampler); </code> <br>Part of <code>GL_ARB_sampler_objects</code>   */
  public native void dispatch_glBindSampler1(int unit, int sampler, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glBindTexGenParameterEXT}(GLenum unit, GLenum coord, GLenum value); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public int glBindTexGenParameterEXT(int unit, int coord, int value)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindTexGenParameterEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindTexGenParameterEXT\" not available");
    }
        return dispatch_glBindTexGenParameterEXT1(unit, coord, value, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glBindTexGenParameterEXT}(GLenum unit, GLenum coord, GLenum value); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public native int dispatch_glBindTexGenParameterEXT1(int unit, int coord, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindTexture}(GLenum target, GLuint texture); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public void glBindTexture(int target, int texture)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindTexture;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindTexture\" not available");
    }
        dispatch_glBindTexture1(target, texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindTexture}(GLenum target, GLuint texture); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public native void dispatch_glBindTexture1(int target, int texture, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glBindTextureUnitParameterEXT}(GLenum unit, GLenum value); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public int glBindTextureUnitParameterEXT(int unit, int value)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindTextureUnitParameterEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindTextureUnitParameterEXT\" not available");
    }
        return dispatch_glBindTextureUnitParameterEXT1(unit, value, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glBindTextureUnitParameterEXT}(GLenum unit, GLenum value); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public native int dispatch_glBindTextureUnitParameterEXT1(int unit, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindTransformFeedback}(GLenum target, GLuint id); </code> <br>Part of <code>GL_ARB_transform_feedback2</code>   */
  public void glBindTransformFeedback(int target, int id)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindTransformFeedback\" not available");
    }
        dispatch_glBindTransformFeedback1(target, id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindTransformFeedback}(GLenum target, GLuint id); </code> <br>Part of <code>GL_ARB_transform_feedback2</code>   */
  public native void dispatch_glBindTransformFeedback1(int target, int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindTransformFeedbackNV}(GLenum target, GLuint id); </code> <br>Part of <code>GL_NV_transform_feedback2</code>   */
  public void glBindTransformFeedbackNV(int target, int id)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindTransformFeedbackNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindTransformFeedbackNV\" not available");
    }
        dispatch_glBindTransformFeedbackNV1(target, id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindTransformFeedbackNV}(GLenum target, GLuint id); </code> <br>Part of <code>GL_NV_transform_feedback2</code>   */
  public native void dispatch_glBindTransformFeedbackNV1(int target, int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindVertexArray}(GLuint array); </code> <br>Part of <code>GL_ARB_vertex_array_object</code>   */
  public void glBindVertexArray(int array)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindVertexArray;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindVertexArray\" not available");
    }
        dispatch_glBindVertexArray1(array, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindVertexArray}(GLuint array); </code> <br>Part of <code>GL_ARB_vertex_array_object</code>   */
  public native void dispatch_glBindVertexArray1(int array, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindVertexShaderEXT}(GLuint id); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glBindVertexShaderEXT(int id)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindVertexShaderEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindVertexShaderEXT\" not available");
    }
        dispatch_glBindVertexShaderEXT1(id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindVertexShaderEXT}(GLuint id); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public native void dispatch_glBindVertexShaderEXT1(int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindVideoCaptureStreamBufferNV}(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset); </code> <br>Part of <code>GL_NV_video_capture</code>   */
  public void glBindVideoCaptureStreamBufferNV(int video_capture_slot, int stream, int frame_region, long offset)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindVideoCaptureStreamBufferNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindVideoCaptureStreamBufferNV\" not available");
    }
        dispatch_glBindVideoCaptureStreamBufferNV1(video_capture_slot, stream, frame_region, offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindVideoCaptureStreamBufferNV}(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset); </code> <br>Part of <code>GL_NV_video_capture</code>   */
  public native void dispatch_glBindVideoCaptureStreamBufferNV1(int video_capture_slot, int stream, int frame_region, long offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindVideoCaptureStreamTextureNV}(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture); </code> <br>Part of <code>GL_NV_video_capture</code>   */
  public void glBindVideoCaptureStreamTextureNV(int video_capture_slot, int stream, int frame_region, int target, int texture)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindVideoCaptureStreamTextureNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindVideoCaptureStreamTextureNV\" not available");
    }
        dispatch_glBindVideoCaptureStreamTextureNV1(video_capture_slot, stream, frame_region, target, texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindVideoCaptureStreamTextureNV}(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture); </code> <br>Part of <code>GL_NV_video_capture</code>   */
  public native void dispatch_glBindVideoCaptureStreamTextureNV1(int video_capture_slot, int stream, int frame_region, int target, int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glBitmap}(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *  bitmap); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param bitmap a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glBitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, ByteBuffer bitmap)  {

    checkUnpackPBODisabled(true);
    final boolean bitmap_is_direct = Buffers.isDirect(bitmap);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBitmap;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBitmap\" not available");
    }
        dispatch_glBitmap1(width, height, xorig, yorig, xmove, ymove, bitmap_is_direct ? bitmap : Buffers.getArray(bitmap), bitmap_is_direct ? Buffers.getDirectBufferByteOffset(bitmap) : Buffers.getIndirectBufferByteOffset(bitmap), bitmap_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBitmap}(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *  bitmap); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param bitmap a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glBitmap1(int width, int height, float xorig, float yorig, float xmove, float ymove, Object bitmap, int bitmap_byte_offset, boolean bitmap_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glBitmap}(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *  bitmap); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glBitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, byte[] bitmap, int bitmap_offset)  {

    checkUnpackPBODisabled(true);
    if(bitmap != null && bitmap.length <= bitmap_offset)
      throw new GLException("array offset argument \"bitmap_offset\" (" + bitmap_offset + ") equals or exceeds array length (" + bitmap.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBitmap;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBitmap\" not available");
    }
        dispatch_glBitmap1(width, height, xorig, yorig, xmove, ymove, bitmap, bitmap_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBitmap}(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *  bitmap); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glBitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, long bitmap_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBitmap;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBitmap\" not available");
    }
        dispatch_glBitmap1(width, height, xorig, yorig, xmove, ymove, bitmap_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBitmap}(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *  bitmap); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  private native void dispatch_glBitmap1(int width, int height, float xorig, float yorig, float xmove, float ymove, long bitmap_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendColor}(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha); </code> <br>Part of <code>GL_VERSION_1_2</code>   */
  public void glBlendColor(float red, float green, float blue, float alpha)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendColor;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlendColor\" not available");
    }
        dispatch_glBlendColor1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendColor}(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha); </code> <br>Part of <code>GL_VERSION_1_2</code>   */
  public native void dispatch_glBlendColor1(float red, float green, float blue, float alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquation}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_2</code>   */
  public void glBlendEquation(int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendEquation;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlendEquation\" not available");
    }
        dispatch_glBlendEquation1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquation}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_2</code>   */
  public native void dispatch_glBlendEquation1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquationIndexedAMD}(GLuint buf, GLenum mode); </code> <br>Part of <code>GL_AMD_draw_buffers_blend</code>   */
  public void glBlendEquationIndexedAMD(int buf, int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendEquationIndexedAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlendEquationIndexedAMD\" not available");
    }
        dispatch_glBlendEquationIndexedAMD1(buf, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquationIndexedAMD}(GLuint buf, GLenum mode); </code> <br>Part of <code>GL_AMD_draw_buffers_blend</code>   */
  public native void dispatch_glBlendEquationIndexedAMD1(int buf, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparate}(GLenum modeRGB, GLenum modeAlpha); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glBlendEquationSeparate(int modeRGB, int modeAlpha)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendEquationSeparate;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlendEquationSeparate\" not available");
    }
        dispatch_glBlendEquationSeparate1(modeRGB, modeAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparate}(GLenum modeRGB, GLenum modeAlpha); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glBlendEquationSeparate1(int modeRGB, int modeAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparateIndexedAMD}(GLuint buf, GLenum modeRGB, GLenum modeAlpha); </code> <br>Part of <code>GL_AMD_draw_buffers_blend</code>   */
  public void glBlendEquationSeparateIndexedAMD(int buf, int modeRGB, int modeAlpha)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendEquationSeparateIndexedAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlendEquationSeparateIndexedAMD\" not available");
    }
        dispatch_glBlendEquationSeparateIndexedAMD1(buf, modeRGB, modeAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparateIndexedAMD}(GLuint buf, GLenum modeRGB, GLenum modeAlpha); </code> <br>Part of <code>GL_AMD_draw_buffers_blend</code>   */
  public native void dispatch_glBlendEquationSeparateIndexedAMD1(int buf, int modeRGB, int modeAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparateiARB}(GLuint buf, GLenum modeRGB, GLenum modeAlpha); </code> <br>Part of <code>GL_ARB_draw_buffers_blend</code>   */
  public void glBlendEquationSeparatei(int buf, int modeRGB, int modeAlpha)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendEquationSeparatei;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlendEquationSeparatei\" not available");
    }
        dispatch_glBlendEquationSeparatei1(buf, modeRGB, modeAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparateiARB}(GLuint buf, GLenum modeRGB, GLenum modeAlpha); </code> <br>Part of <code>GL_ARB_draw_buffers_blend</code>   */
  public native void dispatch_glBlendEquationSeparatei1(int buf, int modeRGB, int modeAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquationiARB}(GLuint buf, GLenum mode); </code> <br>Part of <code>GL_ARB_draw_buffers_blend</code>   */
  public void glBlendEquationi(int buf, int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendEquationi;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlendEquationi\" not available");
    }
        dispatch_glBlendEquationi1(buf, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquationiARB}(GLuint buf, GLenum mode); </code> <br>Part of <code>GL_ARB_draw_buffers_blend</code>   */
  public native void dispatch_glBlendEquationi1(int buf, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFunc}(GLenum sfactor, GLenum dfactor); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glBlendFunc(int sfactor, int dfactor)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendFunc;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlendFunc\" not available");
    }
        dispatch_glBlendFunc1(sfactor, dfactor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFunc}(GLenum sfactor, GLenum dfactor); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glBlendFunc1(int sfactor, int dfactor, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFuncIndexedAMD}(GLuint buf, GLenum src, GLenum dst); </code> <br>Part of <code>GL_AMD_draw_buffers_blend</code>   */
  public void glBlendFuncIndexedAMD(int buf, int src, int dst)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendFuncIndexedAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlendFuncIndexedAMD\" not available");
    }
        dispatch_glBlendFuncIndexedAMD1(buf, src, dst, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFuncIndexedAMD}(GLuint buf, GLenum src, GLenum dst); </code> <br>Part of <code>GL_AMD_draw_buffers_blend</code>   */
  public native void dispatch_glBlendFuncIndexedAMD1(int buf, int src, int dst, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparate}(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha); </code> <br>Part of <code>GL_VERSION_1_4</code>   */
  public void glBlendFuncSeparate(int sfactorRGB, int dfactorRGB, int sfactorAlpha, int dfactorAlpha)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendFuncSeparate;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlendFuncSeparate\" not available");
    }
        dispatch_glBlendFuncSeparate1(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparate}(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha); </code> <br>Part of <code>GL_VERSION_1_4</code>   */
  public native void dispatch_glBlendFuncSeparate1(int sfactorRGB, int dfactorRGB, int sfactorAlpha, int dfactorAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparateINGR}(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha); </code> <br>Part of <code>GL_INGR_blend_func_separate</code>   */
  public void glBlendFuncSeparateINGR(int sfactorRGB, int dfactorRGB, int sfactorAlpha, int dfactorAlpha)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendFuncSeparateINGR;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlendFuncSeparateINGR\" not available");
    }
        dispatch_glBlendFuncSeparateINGR1(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparateINGR}(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha); </code> <br>Part of <code>GL_INGR_blend_func_separate</code>   */
  public native void dispatch_glBlendFuncSeparateINGR1(int sfactorRGB, int dfactorRGB, int sfactorAlpha, int dfactorAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparateIndexedAMD}(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha); </code> <br>Part of <code>GL_AMD_draw_buffers_blend</code>   */
  public void glBlendFuncSeparateIndexedAMD(int buf, int srcRGB, int dstRGB, int srcAlpha, int dstAlpha)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendFuncSeparateIndexedAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlendFuncSeparateIndexedAMD\" not available");
    }
        dispatch_glBlendFuncSeparateIndexedAMD1(buf, srcRGB, dstRGB, srcAlpha, dstAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparateIndexedAMD}(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha); </code> <br>Part of <code>GL_AMD_draw_buffers_blend</code>   */
  public native void dispatch_glBlendFuncSeparateIndexedAMD1(int buf, int srcRGB, int dstRGB, int srcAlpha, int dstAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparateiARB}(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha); </code> <br>Part of <code>GL_ARB_draw_buffers_blend</code>   */
  public void glBlendFuncSeparatei(int buf, int srcRGB, int dstRGB, int srcAlpha, int dstAlpha)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendFuncSeparatei;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlendFuncSeparatei\" not available");
    }
        dispatch_glBlendFuncSeparatei1(buf, srcRGB, dstRGB, srcAlpha, dstAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparateiARB}(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha); </code> <br>Part of <code>GL_ARB_draw_buffers_blend</code>   */
  public native void dispatch_glBlendFuncSeparatei1(int buf, int srcRGB, int dstRGB, int srcAlpha, int dstAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFunciARB}(GLuint buf, GLenum src, GLenum dst); </code> <br>Part of <code>GL_ARB_draw_buffers_blend</code>   */
  public void glBlendFunci(int buf, int src, int dst)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendFunci;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlendFunci\" not available");
    }
        dispatch_glBlendFunci1(buf, src, dst, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFunciARB}(GLuint buf, GLenum src, GLenum dst); </code> <br>Part of <code>GL_ARB_draw_buffers_blend</code>   */
  public native void dispatch_glBlendFunci1(int buf, int src, int dst, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlitFramebuffer}(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_EXT_framebuffer_blit</code>   */
  public void glBlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlitFramebuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlitFramebuffer\" not available");
    }
        dispatch_glBlitFramebuffer1(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlitFramebuffer}(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_EXT_framebuffer_blit</code>   */
  public native void dispatch_glBlitFramebuffer1(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter, long procAddress);

  /** Entry point to C language function: <code> void {@native glBufferAddressRangeNV}(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public void glBufferAddressRangeNV(int pname, int index, long address, long length)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBufferAddressRangeNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBufferAddressRangeNV\" not available");
    }
        dispatch_glBufferAddressRangeNV1(pname, index, address, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBufferAddressRangeNV}(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public native void dispatch_glBufferAddressRangeNV1(int pname, int index, long address, long length, long procAddress);

  /** Entry point to C language function: <code> void {@native glBufferData}(GLenum target, GLsizeiptr size, const GLvoid *  data, GLenum usage); </code> <br>Part of <code>GL_VERSION_1_5</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glBufferData(int target, long size, Buffer data, int usage)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBufferData;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBufferData\" not available");
    }
        dispatch_glBufferData1(target, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, usage, __addr_);
    bufferSizeTracker.setBufferSize(bufferStateTracker, target, this, size);
  }

  /** Entry point to C language function: <code> void {@native glBufferData}(GLenum target, GLsizeiptr size, const GLvoid *  data, GLenum usage); </code> <br>Part of <code>GL_VERSION_1_5</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glBufferData1(int target, long size, Object data, int data_byte_offset, boolean data_is_direct, int usage, long procAddress);

  /** Entry point to C language function: <code> void {@native glBufferParameteriAPPLE}(GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_APPLE_flush_buffer_range</code>   */
  public void glBufferParameteri(int target, int pname, int param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBufferParameteri;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBufferParameteri\" not available");
    }
        dispatch_glBufferParameteri1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBufferParameteriAPPLE}(GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_APPLE_flush_buffer_range</code>   */
  public native void dispatch_glBufferParameteri1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glBufferSubData}(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_5</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glBufferSubData(int target, long offset, long size, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glBufferSubData;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBufferSubData\" not available");
    }
        dispatch_glBufferSubData1(target, offset, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBufferSubData}(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_5</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glBufferSubData1(int target, long offset, long size, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCallList}(GLuint list); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glCallList(int list)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCallList;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCallList\" not available");
    }
        dispatch_glCallList1(list, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCallList}(GLuint list); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glCallList1(int list, long procAddress);

  /** Entry point to C language function: <code> void {@native glCallLists}(GLsizei n, GLenum type, const GLvoid *  lists); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param lists a direct or array-backed {@link java.nio.Buffer}   */
  public void glCallLists(int n, int type, Buffer lists)  {

    final boolean lists_is_direct = Buffers.isDirect(lists);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCallLists;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCallLists\" not available");
    }
        dispatch_glCallLists1(n, type, lists_is_direct ? lists : Buffers.getArray(lists), lists_is_direct ? Buffers.getDirectBufferByteOffset(lists) : Buffers.getIndirectBufferByteOffset(lists), lists_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCallLists}(GLsizei n, GLenum type, const GLvoid *  lists); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param lists a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCallLists1(int n, int type, Object lists, int lists_byte_offset, boolean lists_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLenum {@native glCheckFramebufferStatus}(GLenum target); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public int glCheckFramebufferStatus(int target)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCheckFramebufferStatus;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCheckFramebufferStatus\" not available");
    }
        return dispatch_glCheckFramebufferStatus1(target, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glCheckFramebufferStatus}(GLenum target); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public native int dispatch_glCheckFramebufferStatus1(int target, long procAddress);

  /** Entry point to C language function: <code> GLenum {@native glCheckNamedFramebufferStatusEXT}(GLuint framebuffer, GLenum target); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public int glCheckNamedFramebufferStatusEXT(int framebuffer, int target)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCheckNamedFramebufferStatusEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCheckNamedFramebufferStatusEXT\" not available");
    }
        return dispatch_glCheckNamedFramebufferStatusEXT1(framebuffer, target, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glCheckNamedFramebufferStatusEXT}(GLuint framebuffer, GLenum target); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native int dispatch_glCheckNamedFramebufferStatusEXT1(int framebuffer, int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glClampColor}(GLenum target, GLenum clamp); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_ARB_color_buffer_float</code>   */
  public void glClampColor(int target, int clamp)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glClampColor;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClampColor\" not available");
    }
        dispatch_glClampColor1(target, clamp, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClampColor}(GLenum target, GLenum clamp); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_ARB_color_buffer_float</code>   */
  public native void dispatch_glClampColor1(int target, int clamp, long procAddress);

  /** Entry point to C language function: <code> void {@native glClear}(GLbitfield mask); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glClear(int mask)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glClear;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClear\" not available");
    }
        dispatch_glClear1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClear}(GLbitfield mask); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glClear1(int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearAccum}(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glClearAccum(float red, float green, float blue, float alpha)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearAccum;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClearAccum\" not available");
    }
        dispatch_glClearAccum1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearAccum}(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glClearAccum1(float red, float green, float blue, float alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearBufferfi}(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glClearBufferfi(int buffer, int drawbuffer, float depth, int stencil)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearBufferfi;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClearBufferfi\" not available");
    }
        dispatch_glClearBufferfi1(buffer, drawbuffer, depth, stencil, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferfi}(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public native void dispatch_glClearBufferfi1(int buffer, int drawbuffer, float depth, int stencil, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearBufferfv}(GLenum buffer, GLint drawbuffer, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glClearBufferfv(int buffer, int drawbuffer, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearBufferfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClearBufferfv\" not available");
    }
        dispatch_glClearBufferfv1(buffer, drawbuffer, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferfv}(GLenum buffer, GLint drawbuffer, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glClearBufferfv1(int buffer, int drawbuffer, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearBufferfv}(GLenum buffer, GLint drawbuffer, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glClearBufferfv(int buffer, int drawbuffer, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearBufferfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClearBufferfv\" not available");
    }
        dispatch_glClearBufferfv1(buffer, drawbuffer, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferiv}(GLenum buffer, GLint drawbuffer, const GLint *  value); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glClearBufferiv(int buffer, int drawbuffer, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearBufferiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClearBufferiv\" not available");
    }
        dispatch_glClearBufferiv1(buffer, drawbuffer, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferiv}(GLenum buffer, GLint drawbuffer, const GLint *  value); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glClearBufferiv1(int buffer, int drawbuffer, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearBufferiv}(GLenum buffer, GLint drawbuffer, const GLint *  value); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glClearBufferiv(int buffer, int drawbuffer, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearBufferiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClearBufferiv\" not available");
    }
        dispatch_glClearBufferiv1(buffer, drawbuffer, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferuiv}(GLenum buffer, GLint drawbuffer, const GLuint *  value); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glClearBufferuiv(int buffer, int drawbuffer, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearBufferuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClearBufferuiv\" not available");
    }
        dispatch_glClearBufferuiv1(buffer, drawbuffer, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferuiv}(GLenum buffer, GLint drawbuffer, const GLuint *  value); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glClearBufferuiv1(int buffer, int drawbuffer, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearBufferuiv}(GLenum buffer, GLint drawbuffer, const GLuint *  value); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glClearBufferuiv(int buffer, int drawbuffer, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearBufferuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClearBufferuiv\" not available");
    }
        dispatch_glClearBufferuiv1(buffer, drawbuffer, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearColor}(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glClearColor(float red, float green, float blue, float alpha)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearColor;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClearColor\" not available");
    }
        dispatch_glClearColor1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearColor}(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glClearColor1(float red, float green, float blue, float alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearColorIiEXT}(GLint red, GLint green, GLint blue, GLint alpha); </code> <br>Part of <code>GL_EXT_texture_integer</code>   */
  public void glClearColorIi(int red, int green, int blue, int alpha)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearColorIi;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClearColorIi\" not available");
    }
        dispatch_glClearColorIi1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearColorIiEXT}(GLint red, GLint green, GLint blue, GLint alpha); </code> <br>Part of <code>GL_EXT_texture_integer</code>   */
  public native void dispatch_glClearColorIi1(int red, int green, int blue, int alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearColorIuiEXT}(GLuint red, GLuint green, GLuint blue, GLuint alpha); </code> <br>Part of <code>GL_EXT_texture_integer</code>   */
  public void glClearColorIui(int red, int green, int blue, int alpha)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearColorIui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClearColorIui\" not available");
    }
        dispatch_glClearColorIui1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearColorIuiEXT}(GLuint red, GLuint green, GLuint blue, GLuint alpha); </code> <br>Part of <code>GL_EXT_texture_integer</code>   */
  public native void dispatch_glClearColorIui1(int red, int green, int blue, int alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearDepth}(GLclampd depth); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glClearDepth(double depth)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearDepth;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClearDepth\" not available");
    }
        dispatch_glClearDepth1(depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearDepth}(GLclampd depth); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glClearDepth1(double depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearDepthf}(GLclampf depth); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>   */
  public void glClearDepthf(float depth)  {

    if ( !_context.isGLES2Compatible() ) {
    glClearDepth( (double)depth );
    return;
    }
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearDepthf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClearDepthf\" not available");
    }
        dispatch_glClearDepthf1(depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearDepthf}(GLclampf depth); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>   */
  private native void dispatch_glClearDepthf1(float depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearIndex}(GLfloat c); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glClearIndex(float c)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearIndex;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClearIndex\" not available");
    }
        dispatch_glClearIndex1(c, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearIndex}(GLfloat c); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glClearIndex1(float c, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearStencil}(GLint s); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glClearStencil(int s)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearStencil;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClearStencil\" not available");
    }
        dispatch_glClearStencil1(s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearStencil}(GLint s); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glClearStencil1(int s, long procAddress);

  /** Entry point to C language function: <code> void {@native glClientActiveTexture}(GLenum texture); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glClientActiveTexture(int texture)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glClientActiveTexture;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClientActiveTexture\" not available");
    }
        dispatch_glClientActiveTexture1(texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClientActiveTexture}(GLenum texture); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public native void dispatch_glClientActiveTexture1(int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glClientAttribDefaultEXT}(GLbitfield mask); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glClientAttribDefaultEXT(int mask)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glClientAttribDefaultEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClientAttribDefaultEXT\" not available");
    }
        dispatch_glClientAttribDefaultEXT1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClientAttribDefaultEXT}(GLbitfield mask); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glClientAttribDefaultEXT1(int mask, long procAddress);

  /** Entry point to C language function: <code> GLenum {@native glClientWaitSync}(GLsync sync, GLbitfield flags, GLuint64 timeout); </code> <br>Part of <code>GL_ARB_sync</code>   */
  public int glClientWaitSync(long sync, int flags, long timeout)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glClientWaitSync;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClientWaitSync\" not available");
    }
        return dispatch_glClientWaitSync1(sync, flags, timeout, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glClientWaitSync}(GLsync sync, GLbitfield flags, GLuint64 timeout); </code> <br>Part of <code>GL_ARB_sync</code>   */
  public native int dispatch_glClientWaitSync1(long sync, int flags, long timeout, long procAddress);

  /** Entry point to C language function: <code> void {@native glClipPlane}(GLenum plane, const GLdouble *  equation); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param equation a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glClipPlane(int plane, DoubleBuffer equation)  {

    final boolean equation_is_direct = Buffers.isDirect(equation);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glClipPlane;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClipPlane\" not available");
    }
        dispatch_glClipPlane1(plane, equation_is_direct ? equation : Buffers.getArray(equation), equation_is_direct ? Buffers.getDirectBufferByteOffset(equation) : Buffers.getIndirectBufferByteOffset(equation), equation_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClipPlane}(GLenum plane, const GLdouble *  equation); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param equation a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glClipPlane1(int plane, Object equation, int equation_byte_offset, boolean equation_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClipPlane}(GLenum plane, const GLdouble *  equation); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glClipPlane(int plane, double[] equation, int equation_offset)  {

    if(equation != null && equation.length <= equation_offset)
      throw new GLException("array offset argument \"equation_offset\" (" + equation_offset + ") equals or exceeds array length (" + equation.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glClipPlane;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClipPlane\" not available");
    }
        dispatch_glClipPlane1(plane, equation, Buffers.SIZEOF_DOUBLE * equation_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3b}(GLbyte red, GLbyte green, GLbyte blue); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor3b(byte red, byte green, byte blue)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3b;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3b\" not available");
    }
        dispatch_glColor3b1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3b}(GLbyte red, GLbyte green, GLbyte blue); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glColor3b1(byte red, byte green, byte blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3bv}(const GLbyte *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glColor3bv(ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3bv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3bv\" not available");
    }
        dispatch_glColor3bv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3bv}(const GLbyte *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glColor3bv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3bv}(const GLbyte *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor3bv(byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3bv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3bv\" not available");
    }
        dispatch_glColor3bv1(v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3d}(GLdouble red, GLdouble green, GLdouble blue); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor3d(double red, double green, double blue)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3d\" not available");
    }
        dispatch_glColor3d1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3d}(GLdouble red, GLdouble green, GLdouble blue); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glColor3d1(double red, double green, double blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glColor3dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3dv\" not available");
    }
        dispatch_glColor3dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glColor3dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor3dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3dv\" not available");
    }
        dispatch_glColor3dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3f}(GLfloat red, GLfloat green, GLfloat blue); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor3f(float red, float green, float blue)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3f\" not available");
    }
        dispatch_glColor3f1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3f}(GLfloat red, GLfloat green, GLfloat blue); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glColor3f1(float red, float green, float blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glColor3fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3fv\" not available");
    }
        dispatch_glColor3fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glColor3fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor3fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3fv\" not available");
    }
        dispatch_glColor3fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3hNV}(GLhalfNV red, GLhalfNV green, GLhalfNV blue); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glColor3h(short red, short green, short blue)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3h;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3h\" not available");
    }
        dispatch_glColor3h1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3hNV}(GLhalfNV red, GLhalfNV green, GLhalfNV blue); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public native void dispatch_glColor3h1(short red, short green, short blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glColor3hv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3hv\" not available");
    }
        dispatch_glColor3hv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glColor3hv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glColor3hv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3hv\" not available");
    }
        dispatch_glColor3hv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3i}(GLint red, GLint green, GLint blue); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor3i(int red, int green, int blue)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3i\" not available");
    }
        dispatch_glColor3i1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3i}(GLint red, GLint green, GLint blue); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glColor3i1(int red, int green, int blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glColor3iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3iv\" not available");
    }
        dispatch_glColor3iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glColor3iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor3iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3iv\" not available");
    }
        dispatch_glColor3iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3s}(GLshort red, GLshort green, GLshort blue); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor3s(short red, short green, short blue)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3s\" not available");
    }
        dispatch_glColor3s1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3s}(GLshort red, GLshort green, GLshort blue); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glColor3s1(short red, short green, short blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glColor3sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3sv\" not available");
    }
        dispatch_glColor3sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glColor3sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor3sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3sv\" not available");
    }
        dispatch_glColor3sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3ub}(GLubyte red, GLubyte green, GLubyte blue); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor3ub(byte red, byte green, byte blue)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3ub;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3ub\" not available");
    }
        dispatch_glColor3ub1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3ub}(GLubyte red, GLubyte green, GLubyte blue); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glColor3ub1(byte red, byte green, byte blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3ubv}(const GLubyte *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glColor3ubv(ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3ubv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3ubv\" not available");
    }
        dispatch_glColor3ubv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3ubv}(const GLubyte *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glColor3ubv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3ubv}(const GLubyte *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor3ubv(byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3ubv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3ubv\" not available");
    }
        dispatch_glColor3ubv1(v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3ui}(GLuint red, GLuint green, GLuint blue); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor3ui(int red, int green, int blue)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3ui\" not available");
    }
        dispatch_glColor3ui1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3ui}(GLuint red, GLuint green, GLuint blue); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glColor3ui1(int red, int green, int blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3uiv}(const GLuint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glColor3uiv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3uiv\" not available");
    }
        dispatch_glColor3uiv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3uiv}(const GLuint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glColor3uiv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3uiv}(const GLuint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor3uiv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3uiv\" not available");
    }
        dispatch_glColor3uiv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3us}(GLushort red, GLushort green, GLushort blue); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor3us(short red, short green, short blue)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3us;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3us\" not available");
    }
        dispatch_glColor3us1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3us}(GLushort red, GLushort green, GLushort blue); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glColor3us1(short red, short green, short blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3usv}(const GLushort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glColor3usv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3usv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3usv\" not available");
    }
        dispatch_glColor3usv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3usv}(const GLushort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glColor3usv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3usv}(const GLushort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor3usv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor3usv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor3usv\" not available");
    }
        dispatch_glColor3usv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4b}(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor4b(byte red, byte green, byte blue, byte alpha)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4b;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4b\" not available");
    }
        dispatch_glColor4b1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4b}(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glColor4b1(byte red, byte green, byte blue, byte alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4bv}(const GLbyte *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glColor4bv(ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4bv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4bv\" not available");
    }
        dispatch_glColor4bv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4bv}(const GLbyte *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glColor4bv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4bv}(const GLbyte *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor4bv(byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4bv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4bv\" not available");
    }
        dispatch_glColor4bv1(v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4d}(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor4d(double red, double green, double blue, double alpha)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4d\" not available");
    }
        dispatch_glColor4d1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4d}(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glColor4d1(double red, double green, double blue, double alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glColor4dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4dv\" not available");
    }
        dispatch_glColor4dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glColor4dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor4dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4dv\" not available");
    }
        dispatch_glColor4dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4f}(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor4f(float red, float green, float blue, float alpha)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4f\" not available");
    }
        dispatch_glColor4f1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4f}(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glColor4f1(float red, float green, float blue, float alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glColor4fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4fv\" not available");
    }
        dispatch_glColor4fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glColor4fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor4fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4fv\" not available");
    }
        dispatch_glColor4fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4hNV}(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glColor4h(short red, short green, short blue, short alpha)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4h;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4h\" not available");
    }
        dispatch_glColor4h1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4hNV}(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public native void dispatch_glColor4h1(short red, short green, short blue, short alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glColor4hv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4hv\" not available");
    }
        dispatch_glColor4hv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glColor4hv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glColor4hv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4hv\" not available");
    }
        dispatch_glColor4hv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4i}(GLint red, GLint green, GLint blue, GLint alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor4i(int red, int green, int blue, int alpha)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4i\" not available");
    }
        dispatch_glColor4i1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4i}(GLint red, GLint green, GLint blue, GLint alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glColor4i1(int red, int green, int blue, int alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glColor4iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4iv\" not available");
    }
        dispatch_glColor4iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glColor4iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor4iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4iv\" not available");
    }
        dispatch_glColor4iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4s}(GLshort red, GLshort green, GLshort blue, GLshort alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor4s(short red, short green, short blue, short alpha)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4s\" not available");
    }
        dispatch_glColor4s1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4s}(GLshort red, GLshort green, GLshort blue, GLshort alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glColor4s1(short red, short green, short blue, short alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glColor4sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4sv\" not available");
    }
        dispatch_glColor4sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glColor4sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor4sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4sv\" not available");
    }
        dispatch_glColor4sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4ub}(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor4ub(byte red, byte green, byte blue, byte alpha)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4ub;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4ub\" not available");
    }
        dispatch_glColor4ub1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4ub}(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glColor4ub1(byte red, byte green, byte blue, byte alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4ubv}(const GLubyte *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glColor4ubv(ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4ubv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4ubv\" not available");
    }
        dispatch_glColor4ubv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4ubv}(const GLubyte *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glColor4ubv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4ubv}(const GLubyte *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor4ubv(byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4ubv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4ubv\" not available");
    }
        dispatch_glColor4ubv1(v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4ui}(GLuint red, GLuint green, GLuint blue, GLuint alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor4ui(int red, int green, int blue, int alpha)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4ui\" not available");
    }
        dispatch_glColor4ui1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4ui}(GLuint red, GLuint green, GLuint blue, GLuint alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glColor4ui1(int red, int green, int blue, int alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4uiv}(const GLuint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glColor4uiv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4uiv\" not available");
    }
        dispatch_glColor4uiv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4uiv}(const GLuint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glColor4uiv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4uiv}(const GLuint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor4uiv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4uiv\" not available");
    }
        dispatch_glColor4uiv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4us}(GLushort red, GLushort green, GLushort blue, GLushort alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor4us(short red, short green, short blue, short alpha)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4us;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4us\" not available");
    }
        dispatch_glColor4us1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4us}(GLushort red, GLushort green, GLushort blue, GLushort alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glColor4us1(short red, short green, short blue, short alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4usv}(const GLushort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glColor4usv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4usv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4usv\" not available");
    }
        dispatch_glColor4usv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4usv}(const GLushort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glColor4usv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4usv}(const GLushort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColor4usv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4usv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4usv\" not available");
    }
        dispatch_glColor4usv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorFormatNV}(GLint size, GLenum type, GLsizei stride); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public void glColorFormatNV(int size, int type, int stride)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorFormatNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorFormatNV\" not available");
    }
        dispatch_glColorFormatNV1(size, type, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorFormatNV}(GLint size, GLenum type, GLsizei stride); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public native void dispatch_glColorFormatNV1(int size, int type, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorMask}(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColorMask(boolean red, boolean green, boolean blue, boolean alpha)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorMask;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorMask\" not available");
    }
        dispatch_glColorMask1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorMask}(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glColorMask1(boolean red, boolean green, boolean blue, boolean alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorMaskIndexedEXT}(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a); </code> <br>Part of <code>GL_EXT_draw_buffers2</code>   */
  public void glColorMaskIndexed(int index, boolean r, boolean g, boolean b, boolean a)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorMaskIndexed;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorMaskIndexed\" not available");
    }
        dispatch_glColorMaskIndexed1(index, r, g, b, a, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorMaskIndexedEXT}(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a); </code> <br>Part of <code>GL_EXT_draw_buffers2</code>   */
  public native void dispatch_glColorMaskIndexed1(int index, boolean r, boolean g, boolean b, boolean a, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorMaski}(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glColorMaski(int index, boolean r, boolean g, boolean b, boolean a)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorMaski;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorMaski\" not available");
    }
        dispatch_glColorMaski1(index, r, g, b, a, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorMaski}(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public native void dispatch_glColorMaski1(int index, boolean r, boolean g, boolean b, boolean a, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorMaterial}(GLenum face, GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glColorMaterial(int face, int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorMaterial;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorMaterial\" not available");
    }
        dispatch_glColorMaterial1(face, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorMaterial}(GLenum face, GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glColorMaterial1(int face, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorP3ui}(GLenum type, GLuint color); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glColorP3ui(int type, int color)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorP3ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorP3ui\" not available");
    }
        dispatch_glColorP3ui1(type, color, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorP3ui}(GLenum type, GLuint color); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public native void dispatch_glColorP3ui1(int type, int color, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorP3uiv}(GLenum type, const GLuint *  color); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param color a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glColorP3uiv(int type, IntBuffer color)  {

    final boolean color_is_direct = Buffers.isDirect(color);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorP3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorP3uiv\" not available");
    }
        dispatch_glColorP3uiv1(type, color_is_direct ? color : Buffers.getArray(color), color_is_direct ? Buffers.getDirectBufferByteOffset(color) : Buffers.getIndirectBufferByteOffset(color), color_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorP3uiv}(GLenum type, const GLuint *  color); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param color a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glColorP3uiv1(int type, Object color, int color_byte_offset, boolean color_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorP3uiv}(GLenum type, const GLuint *  color); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glColorP3uiv(int type, int[] color, int color_offset)  {

    if(color != null && color.length <= color_offset)
      throw new GLException("array offset argument \"color_offset\" (" + color_offset + ") equals or exceeds array length (" + color.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorP3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorP3uiv\" not available");
    }
        dispatch_glColorP3uiv1(type, color, Buffers.SIZEOF_INT * color_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorP4ui}(GLenum type, GLuint color); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glColorP4ui(int type, int color)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorP4ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorP4ui\" not available");
    }
        dispatch_glColorP4ui1(type, color, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorP4ui}(GLenum type, GLuint color); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public native void dispatch_glColorP4ui1(int type, int color, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorP4uiv}(GLenum type, const GLuint *  color); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param color a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glColorP4uiv(int type, IntBuffer color)  {

    final boolean color_is_direct = Buffers.isDirect(color);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorP4uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorP4uiv\" not available");
    }
        dispatch_glColorP4uiv1(type, color_is_direct ? color : Buffers.getArray(color), color_is_direct ? Buffers.getDirectBufferByteOffset(color) : Buffers.getIndirectBufferByteOffset(color), color_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorP4uiv}(GLenum type, const GLuint *  color); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param color a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glColorP4uiv1(int type, Object color, int color_byte_offset, boolean color_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorP4uiv}(GLenum type, const GLuint *  color); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glColorP4uiv(int type, int[] color, int color_offset)  {

    if(color != null && color.length <= color_offset)
      throw new GLException("array offset argument \"color_offset\" (" + color_offset + ") equals or exceeds array length (" + color.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorP4uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorP4uiv\" not available");
    }
        dispatch_glColorP4uiv1(type, color, Buffers.SIZEOF_INT * color_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}   */
  public void glColorPointer(int size, int type, int stride, Buffer ptr)  {

    checkArrayVBODisabled(true);
    Buffers.rangeCheck(ptr, 1);
    final boolean ptr_is_direct = Buffers.isDirect(ptr);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorPointer\" not available");
    }
        dispatch_glColorPointer1(size, type, stride, ptr_is_direct ? ptr : Buffers.getArray(ptr), ptr_is_direct ? Buffers.getDirectBufferByteOffset(ptr) : Buffers.getIndirectBufferByteOffset(ptr), ptr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glColorPointer1(int size, int type, int stride, Object ptr, int ptr_byte_offset, boolean ptr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public void glColorPointer(int size, int type, int stride, long ptr_buffer_offset)  {

    checkArrayVBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorPointer\" not available");
    }
        dispatch_glColorPointer1(size, type, stride, ptr_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  private native void dispatch_glColorPointer1(int size, int type, int stride, long ptr_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorSubTable}(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glColorSubTable(int target, int start, int count, int format, int type, Buffer data)  {

    checkUnpackPBODisabled(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorSubTable;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorSubTable\" not available");
    }
        dispatch_glColorSubTable1(target, start, count, format, type, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorSubTable}(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glColorSubTable1(int target, int start, int count, int format, int type, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorSubTable}(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glColorSubTable(int target, int start, int count, int format, int type, long data_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorSubTable;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorSubTable\" not available");
    }
        dispatch_glColorSubTable1(target, start, count, format, type, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorSubTable}(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  private native void dispatch_glColorSubTable1(int target, int start, int count, int format, int type, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorTable}(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *  table); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param table a direct or array-backed {@link java.nio.Buffer}   */
  public void glColorTable(int target, int internalformat, int width, int format, int type, Buffer table)  {

    checkUnpackPBODisabled(true);
    Buffers.rangeCheckBytes(table, imageSizeInBytes(format, type, width            , 1              , 1    , false));
    final boolean table_is_direct = Buffers.isDirect(table);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorTable;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorTable\" not available");
    }
        dispatch_glColorTable1(target, internalformat, width, format, type, table_is_direct ? table : Buffers.getArray(table), table_is_direct ? Buffers.getDirectBufferByteOffset(table) : Buffers.getIndirectBufferByteOffset(table), table_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorTable}(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *  table); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param table a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glColorTable1(int target, int internalformat, int width, int format, int type, Object table, int table_byte_offset, boolean table_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorTable}(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *  table); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glColorTable(int target, int internalformat, int width, int format, int type, long table_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorTable;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorTable\" not available");
    }
        dispatch_glColorTable1(target, internalformat, width, format, type, table_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorTable}(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *  table); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  private native void dispatch_glColorTable1(int target, int internalformat, int width, int format, int type, long table_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorTableParameterfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glColorTableParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorTableParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorTableParameterfv\" not available");
    }
        dispatch_glColorTableParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorTableParameterfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glColorTableParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorTableParameterfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glColorTableParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorTableParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorTableParameterfv\" not available");
    }
        dispatch_glColorTableParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorTableParameteriv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glColorTableParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorTableParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorTableParameteriv\" not available");
    }
        dispatch_glColorTableParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorTableParameteriv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glColorTableParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorTableParameteriv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glColorTableParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorTableParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorTableParameteriv\" not available");
    }
        dispatch_glColorTableParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompileShader}(GLuint shader); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glCompileShader(int shader)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompileShader;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompileShader\" not available");
    }
        dispatch_glCompileShader1(shader, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompileShader}(GLuint shader); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glCompileShader1(int shader, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompileShaderARB}(GLhandleARB shaderObj); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glCompileShaderARB(int shaderObj)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompileShaderARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompileShaderARB\" not available");
    }
        dispatch_glCompileShaderARB1(shaderObj, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompileShaderARB}(GLhandleARB shaderObj); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public native void dispatch_glCompileShaderARB1(int shaderObj, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompileShaderIncludeARB}(GLuint shader, GLsizei count, const GLchar *  *  path, const GLint *  length); </code> <br>Part of <code>GL_ARB_shading_language_include</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glCompileShaderIncludeARB(int shader, int count, String[] path, IntBuffer length)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompileShaderIncludeARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompileShaderIncludeARB\" not available");
    }
        dispatch_glCompileShaderIncludeARB1(shader, count, path, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompileShaderIncludeARB}(GLuint shader, GLsizei count, const GLchar *  *  path, const GLint *  length); </code> <br>Part of <code>GL_ARB_shading_language_include</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glCompileShaderIncludeARB1(int shader, int count, String[] path, Object length, int length_byte_offset, boolean length_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompileShaderIncludeARB}(GLuint shader, GLsizei count, const GLchar *  *  path, const GLint *  length); </code> <br>Part of <code>GL_ARB_shading_language_include</code>   */
  public void glCompileShaderIncludeARB(int shader, int count, String[] path, int[] length, int length_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompileShaderIncludeARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompileShaderIncludeARB\" not available");
    }
        dispatch_glCompileShaderIncludeARB1(shader, count, path, length, Buffers.SIZEOF_INT * length_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedMultiTexImage1DEXT(int texunit, int target, int level, int internalformat, int width, int border, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedMultiTexImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedMultiTexImage1DEXT\" not available");
    }
        dispatch_glCompressedMultiTexImage1DEXT1(texunit, target, level, internalformat, width, border, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedMultiTexImage1DEXT1(int texunit, int target, int level, int internalformat, int width, int border, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedMultiTexImage2DEXT(int texunit, int target, int level, int internalformat, int width, int height, int border, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedMultiTexImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedMultiTexImage2DEXT\" not available");
    }
        dispatch_glCompressedMultiTexImage2DEXT1(texunit, target, level, internalformat, width, height, border, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedMultiTexImage2DEXT1(int texunit, int target, int level, int internalformat, int width, int height, int border, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexImage3DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedMultiTexImage3DEXT(int texunit, int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedMultiTexImage3DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedMultiTexImage3DEXT\" not available");
    }
        dispatch_glCompressedMultiTexImage3DEXT1(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexImage3DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedMultiTexImage3DEXT1(int texunit, int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexSubImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedMultiTexSubImage1DEXT(int texunit, int target, int level, int xoffset, int width, int format, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedMultiTexSubImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedMultiTexSubImage1DEXT\" not available");
    }
        dispatch_glCompressedMultiTexSubImage1DEXT1(texunit, target, level, xoffset, width, format, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexSubImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedMultiTexSubImage1DEXT1(int texunit, int target, int level, int xoffset, int width, int format, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexSubImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedMultiTexSubImage2DEXT(int texunit, int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedMultiTexSubImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedMultiTexSubImage2DEXT\" not available");
    }
        dispatch_glCompressedMultiTexSubImage2DEXT1(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexSubImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedMultiTexSubImage2DEXT1(int texunit, int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexSubImage3DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedMultiTexSubImage3DEXT(int texunit, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedMultiTexSubImage3DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedMultiTexSubImage3DEXT\" not available");
    }
        dispatch_glCompressedMultiTexSubImage3DEXT1(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexSubImage3DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedMultiTexSubImage3DEXT1(int texunit, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage1D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexImage1D(int target, int level, int internalformat, int width, int border, int imageSize, Buffer data)  {

    checkUnpackPBODisabled(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexImage1D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexImage1D\" not available");
    }
        dispatch_glCompressedTexImage1D1(target, level, internalformat, width, border, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage1D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexImage1D1(int target, int level, int internalformat, int width, int border, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage1D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>   */
  public void glCompressedTexImage1D(int target, int level, int internalformat, int width, int border, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexImage1D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexImage1D\" not available");
    }
        dispatch_glCompressedTexImage1D1(target, level, internalformat, width, border, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage1D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>   */
  private native void dispatch_glCompressedTexImage1D1(int target, int level, int internalformat, int width, int border, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, Buffer data)  {

    checkUnpackPBODisabled(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexImage2D\" not available");
    }
        dispatch_glCompressedTexImage2D1(target, level, internalformat, width, height, border, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>   */
  public void glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexImage2D\" not available");
    }
        dispatch_glCompressedTexImage2D1(target, level, internalformat, width, height, border, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>   */
  private native void dispatch_glCompressedTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage3D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, Buffer data)  {

    checkUnpackPBODisabled(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexImage3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexImage3D\" not available");
    }
        dispatch_glCompressedTexImage3D1(target, level, internalformat, width, height, depth, border, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage3D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexImage3D1(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage3D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>   */
  public void glCompressedTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexImage3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexImage3D\" not available");
    }
        dispatch_glCompressedTexImage3D1(target, level, internalformat, width, height, depth, border, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage3D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>   */
  private native void dispatch_glCompressedTexImage3D1(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage1D}(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexSubImage1D(int target, int level, int xoffset, int width, int format, int imageSize, Buffer data)  {

    checkUnpackPBODisabled(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexSubImage1D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexSubImage1D\" not available");
    }
        dispatch_glCompressedTexSubImage1D1(target, level, xoffset, width, format, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage1D}(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexSubImage1D1(int target, int level, int xoffset, int width, int format, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage1D}(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>   */
  public void glCompressedTexSubImage1D(int target, int level, int xoffset, int width, int format, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexSubImage1D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexSubImage1D\" not available");
    }
        dispatch_glCompressedTexSubImage1D1(target, level, xoffset, width, format, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage1D}(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>   */
  private native void dispatch_glCompressedTexSubImage1D1(int target, int level, int xoffset, int width, int format, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Buffer data)  {

    checkUnpackPBODisabled(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexSubImage2D\" not available");
    }
        dispatch_glCompressedTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>   */
  public void glCompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexSubImage2D\" not available");
    }
        dispatch_glCompressedTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>   */
  private native void dispatch_glCompressedTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, Buffer data)  {

    checkUnpackPBODisabled(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexSubImage3D\" not available");
    }
        dispatch_glCompressedTexSubImage3D1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>   */
  public void glCompressedTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexSubImage3D\" not available");
    }
        dispatch_glCompressedTexSubImage3D1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>   */
  private native void dispatch_glCompressedTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTextureImage1DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTextureImage1DEXT(int texture, int target, int level, int internalformat, int width, int border, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTextureImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTextureImage1DEXT\" not available");
    }
        dispatch_glCompressedTextureImage1DEXT1(texture, target, level, internalformat, width, border, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTextureImage1DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTextureImage1DEXT1(int texture, int target, int level, int internalformat, int width, int border, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTextureImage2DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTextureImage2DEXT(int texture, int target, int level, int internalformat, int width, int height, int border, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTextureImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTextureImage2DEXT\" not available");
    }
        dispatch_glCompressedTextureImage2DEXT1(texture, target, level, internalformat, width, height, border, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTextureImage2DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTextureImage2DEXT1(int texture, int target, int level, int internalformat, int width, int height, int border, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTextureImage3DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTextureImage3DEXT(int texture, int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTextureImage3DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTextureImage3DEXT\" not available");
    }
        dispatch_glCompressedTextureImage3DEXT1(texture, target, level, internalformat, width, height, depth, border, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTextureImage3DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTextureImage3DEXT1(int texture, int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTextureSubImage1DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTextureSubImage1DEXT(int texture, int target, int level, int xoffset, int width, int format, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTextureSubImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTextureSubImage1DEXT\" not available");
    }
        dispatch_glCompressedTextureSubImage1DEXT1(texture, target, level, xoffset, width, format, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTextureSubImage1DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTextureSubImage1DEXT1(int texture, int target, int level, int xoffset, int width, int format, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTextureSubImage2DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTextureSubImage2DEXT(int texture, int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTextureSubImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTextureSubImage2DEXT\" not available");
    }
        dispatch_glCompressedTextureSubImage2DEXT1(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTextureSubImage2DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTextureSubImage2DEXT1(int texture, int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTextureSubImage3DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTextureSubImage3DEXT(int texture, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTextureSubImage3DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTextureSubImage3DEXT\" not available");
    }
        dispatch_glCompressedTextureSubImage3DEXT1(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTextureSubImage3DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *  bits); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTextureSubImage3DEXT1(int texture, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glConvolutionFilter1D}(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *  image); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param image a direct or array-backed {@link java.nio.Buffer}   */
  public void glConvolutionFilter1D(int target, int internalformat, int width, int format, int type, Buffer image)  {

    checkUnpackPBODisabled(true);
    Buffers.rangeCheckBytes(image, imageSizeInBytes(format, type, width            , 1              , 1    , false));
    final boolean image_is_direct = Buffers.isDirect(image);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glConvolutionFilter1D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glConvolutionFilter1D\" not available");
    }
        dispatch_glConvolutionFilter1D1(target, internalformat, width, format, type, image_is_direct ? image : Buffers.getArray(image), image_is_direct ? Buffers.getDirectBufferByteOffset(image) : Buffers.getIndirectBufferByteOffset(image), image_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glConvolutionFilter1D}(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *  image); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param image a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glConvolutionFilter1D1(int target, int internalformat, int width, int format, int type, Object image, int image_byte_offset, boolean image_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glConvolutionFilter1D}(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *  image); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glConvolutionFilter1D(int target, int internalformat, int width, int format, int type, long image_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glConvolutionFilter1D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glConvolutionFilter1D\" not available");
    }
        dispatch_glConvolutionFilter1D1(target, internalformat, width, format, type, image_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glConvolutionFilter1D}(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *  image); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  private native void dispatch_glConvolutionFilter1D1(int target, int internalformat, int width, int format, int type, long image_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glConvolutionFilter2D}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  image); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param image a direct or array-backed {@link java.nio.Buffer}   */
  public void glConvolutionFilter2D(int target, int internalformat, int width, int height, int format, int type, Buffer image)  {

    checkUnpackPBODisabled(true);
    Buffers.rangeCheckBytes(image, imageSizeInBytes(format, type, width            , height            , 1    , false));
    final boolean image_is_direct = Buffers.isDirect(image);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glConvolutionFilter2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glConvolutionFilter2D\" not available");
    }
        dispatch_glConvolutionFilter2D1(target, internalformat, width, height, format, type, image_is_direct ? image : Buffers.getArray(image), image_is_direct ? Buffers.getDirectBufferByteOffset(image) : Buffers.getIndirectBufferByteOffset(image), image_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glConvolutionFilter2D}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  image); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param image a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glConvolutionFilter2D1(int target, int internalformat, int width, int height, int format, int type, Object image, int image_byte_offset, boolean image_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glConvolutionFilter2D}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  image); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glConvolutionFilter2D(int target, int internalformat, int width, int height, int format, int type, long image_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glConvolutionFilter2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glConvolutionFilter2D\" not available");
    }
        dispatch_glConvolutionFilter2D1(target, internalformat, width, height, format, type, image_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glConvolutionFilter2D}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  image); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  private native void dispatch_glConvolutionFilter2D1(int target, int internalformat, int width, int height, int format, int type, long image_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glConvolutionParameterf}(GLenum target, GLenum pname, GLfloat params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glConvolutionParameterf(int target, int pname, float params)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glConvolutionParameterf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glConvolutionParameterf\" not available");
    }
        dispatch_glConvolutionParameterf1(target, pname, params, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glConvolutionParameterf}(GLenum target, GLenum pname, GLfloat params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public native void dispatch_glConvolutionParameterf1(int target, int pname, float params, long procAddress);

  /** Entry point to C language function: <code> void {@native glConvolutionParameterfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glConvolutionParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glConvolutionParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glConvolutionParameterfv\" not available");
    }
        dispatch_glConvolutionParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glConvolutionParameterfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glConvolutionParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glConvolutionParameterfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glConvolutionParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glConvolutionParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glConvolutionParameterfv\" not available");
    }
        dispatch_glConvolutionParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glConvolutionParameteri}(GLenum target, GLenum pname, GLint params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glConvolutionParameteri(int target, int pname, int params)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glConvolutionParameteri;
    if (__addr_ == 0) {
      throw new GLException("Method \"glConvolutionParameteri\" not available");
    }
        dispatch_glConvolutionParameteri1(target, pname, params, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glConvolutionParameteri}(GLenum target, GLenum pname, GLint params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public native void dispatch_glConvolutionParameteri1(int target, int pname, int params, long procAddress);

  /** Entry point to C language function: <code> void {@native glConvolutionParameteriv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glConvolutionParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glConvolutionParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glConvolutionParameteriv\" not available");
    }
        dispatch_glConvolutionParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glConvolutionParameteriv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glConvolutionParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glConvolutionParameteriv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glConvolutionParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glConvolutionParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glConvolutionParameteriv\" not available");
    }
        dispatch_glConvolutionParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyBufferSubData}(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size); </code> <br>Part of <code>GL_ARB_copy_buffer</code>   */
  public void glCopyBufferSubData(int readTarget, int writeTarget, long readOffset, long writeOffset, long size)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyBufferSubData;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyBufferSubData\" not available");
    }
        dispatch_glCopyBufferSubData1(readTarget, writeTarget, readOffset, writeOffset, size, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyBufferSubData}(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size); </code> <br>Part of <code>GL_ARB_copy_buffer</code>   */
  public native void dispatch_glCopyBufferSubData1(int readTarget, int writeTarget, long readOffset, long writeOffset, long size, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyColorSubTable}(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glCopyColorSubTable(int target, int start, int x, int y, int width)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyColorSubTable;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyColorSubTable\" not available");
    }
        dispatch_glCopyColorSubTable1(target, start, x, y, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyColorSubTable}(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public native void dispatch_glCopyColorSubTable1(int target, int start, int x, int y, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyColorTable}(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glCopyColorTable(int target, int internalformat, int x, int y, int width)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyColorTable;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyColorTable\" not available");
    }
        dispatch_glCopyColorTable1(target, internalformat, x, y, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyColorTable}(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public native void dispatch_glCopyColorTable1(int target, int internalformat, int x, int y, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyConvolutionFilter1D}(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glCopyConvolutionFilter1D(int target, int internalformat, int x, int y, int width)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyConvolutionFilter1D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyConvolutionFilter1D\" not available");
    }
        dispatch_glCopyConvolutionFilter1D1(target, internalformat, x, y, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyConvolutionFilter1D}(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public native void dispatch_glCopyConvolutionFilter1D1(int target, int internalformat, int x, int y, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyConvolutionFilter2D}(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glCopyConvolutionFilter2D(int target, int internalformat, int x, int y, int width, int height)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyConvolutionFilter2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyConvolutionFilter2D\" not available");
    }
        dispatch_glCopyConvolutionFilter2D1(target, internalformat, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyConvolutionFilter2D}(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public native void dispatch_glCopyConvolutionFilter2D1(int target, int internalformat, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyImageSubDataNV}(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth); </code> <br>Part of <code>GL_NV_copy_image</code>   */
  public void glCopyImageSubDataNV(int srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, int dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyImageSubDataNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyImageSubDataNV\" not available");
    }
        dispatch_glCopyImageSubDataNV1(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyImageSubDataNV}(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth); </code> <br>Part of <code>GL_NV_copy_image</code>   */
  public native void dispatch_glCopyImageSubDataNV1(int srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, int dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyMultiTexImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glCopyMultiTexImage1DEXT(int texunit, int target, int level, int internalformat, int x, int y, int width, int border)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyMultiTexImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyMultiTexImage1DEXT\" not available");
    }
        dispatch_glCopyMultiTexImage1DEXT1(texunit, target, level, internalformat, x, y, width, border, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyMultiTexImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glCopyMultiTexImage1DEXT1(int texunit, int target, int level, int internalformat, int x, int y, int width, int border, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyMultiTexImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glCopyMultiTexImage2DEXT(int texunit, int target, int level, int internalformat, int x, int y, int width, int height, int border)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyMultiTexImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyMultiTexImage2DEXT\" not available");
    }
        dispatch_glCopyMultiTexImage2DEXT1(texunit, target, level, internalformat, x, y, width, height, border, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyMultiTexImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glCopyMultiTexImage2DEXT1(int texunit, int target, int level, int internalformat, int x, int y, int width, int height, int border, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyMultiTexSubImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glCopyMultiTexSubImage1DEXT(int texunit, int target, int level, int xoffset, int x, int y, int width)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyMultiTexSubImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyMultiTexSubImage1DEXT\" not available");
    }
        dispatch_glCopyMultiTexSubImage1DEXT1(texunit, target, level, xoffset, x, y, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyMultiTexSubImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glCopyMultiTexSubImage1DEXT1(int texunit, int target, int level, int xoffset, int x, int y, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyMultiTexSubImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glCopyMultiTexSubImage2DEXT(int texunit, int target, int level, int xoffset, int yoffset, int x, int y, int width, int height)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyMultiTexSubImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyMultiTexSubImage2DEXT\" not available");
    }
        dispatch_glCopyMultiTexSubImage2DEXT1(texunit, target, level, xoffset, yoffset, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyMultiTexSubImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glCopyMultiTexSubImage2DEXT1(int texunit, int target, int level, int xoffset, int yoffset, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyMultiTexSubImage3DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glCopyMultiTexSubImage3DEXT(int texunit, int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyMultiTexSubImage3DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyMultiTexSubImage3DEXT\" not available");
    }
        dispatch_glCopyMultiTexSubImage3DEXT1(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyMultiTexSubImage3DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glCopyMultiTexSubImage3DEXT1(int texunit, int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glCopyPixels(int x, int y, int width, int height, int type)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyPixels;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyPixels\" not available");
    }
        dispatch_glCopyPixels1(x, y, width, height, type, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glCopyPixels1(int x, int y, int width, int height, int type, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTexImage1D}(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public void glCopyTexImage1D(int target, int level, int internalformat, int x, int y, int width, int border)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyTexImage1D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyTexImage1D\" not available");
    }
        dispatch_glCopyTexImage1D1(target, level, internalformat, x, y, width, border, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTexImage1D}(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public native void dispatch_glCopyTexImage1D1(int target, int level, int internalformat, int x, int y, int width, int border, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public void glCopyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyTexImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyTexImage2D\" not available");
    }
        dispatch_glCopyTexImage2D1(target, level, internalformat, x, y, width, height, border, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public native void dispatch_glCopyTexImage2D1(int target, int level, int internalformat, int x, int y, int width, int height, int border, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage1D}(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public void glCopyTexSubImage1D(int target, int level, int xoffset, int x, int y, int width)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyTexSubImage1D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyTexSubImage1D\" not available");
    }
        dispatch_glCopyTexSubImage1D1(target, level, xoffset, x, y, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage1D}(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public native void dispatch_glCopyTexSubImage1D1(int target, int level, int xoffset, int x, int y, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public void glCopyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyTexSubImage2D\" not available");
    }
        dispatch_glCopyTexSubImage2D1(target, level, xoffset, yoffset, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public native void dispatch_glCopyTexSubImage2D1(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_1_2</code>   */
  public void glCopyTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyTexSubImage3D\" not available");
    }
        dispatch_glCopyTexSubImage3D1(target, level, xoffset, yoffset, zoffset, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_1_2</code>   */
  public native void dispatch_glCopyTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTextureImage1DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glCopyTextureImage1DEXT(int texture, int target, int level, int internalformat, int x, int y, int width, int border)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyTextureImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyTextureImage1DEXT\" not available");
    }
        dispatch_glCopyTextureImage1DEXT1(texture, target, level, internalformat, x, y, width, border, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTextureImage1DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glCopyTextureImage1DEXT1(int texture, int target, int level, int internalformat, int x, int y, int width, int border, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTextureImage2DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glCopyTextureImage2DEXT(int texture, int target, int level, int internalformat, int x, int y, int width, int height, int border)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyTextureImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyTextureImage2DEXT\" not available");
    }
        dispatch_glCopyTextureImage2DEXT1(texture, target, level, internalformat, x, y, width, height, border, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTextureImage2DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glCopyTextureImage2DEXT1(int texture, int target, int level, int internalformat, int x, int y, int width, int height, int border, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTextureSubImage1DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glCopyTextureSubImage1DEXT(int texture, int target, int level, int xoffset, int x, int y, int width)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyTextureSubImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyTextureSubImage1DEXT\" not available");
    }
        dispatch_glCopyTextureSubImage1DEXT1(texture, target, level, xoffset, x, y, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTextureSubImage1DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glCopyTextureSubImage1DEXT1(int texture, int target, int level, int xoffset, int x, int y, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTextureSubImage2DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glCopyTextureSubImage2DEXT(int texture, int target, int level, int xoffset, int yoffset, int x, int y, int width, int height)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyTextureSubImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyTextureSubImage2DEXT\" not available");
    }
        dispatch_glCopyTextureSubImage2DEXT1(texture, target, level, xoffset, yoffset, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTextureSubImage2DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glCopyTextureSubImage2DEXT1(int texture, int target, int level, int xoffset, int yoffset, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTextureSubImage3DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glCopyTextureSubImage3DEXT(int texture, int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyTextureSubImage3DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyTextureSubImage3DEXT\" not available");
    }
        dispatch_glCopyTextureSubImage3DEXT1(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTextureSubImage3DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glCopyTextureSubImage3DEXT1(int texture, int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glCreateProgram}(void); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public int glCreateProgram()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCreateProgram;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCreateProgram\" not available");
    }
        return dispatch_glCreateProgram1(__addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glCreateProgram}(void); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native int dispatch_glCreateProgram1(long procAddress);

  /** Entry point to C language function: <code> GLhandleARB {@native glCreateProgramObjectARB}(void); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public int glCreateProgramObjectARB()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCreateProgramObjectARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCreateProgramObjectARB\" not available");
    }
        return dispatch_glCreateProgramObjectARB1(__addr_);
  }

  /** Entry point to C language function: <code> GLhandleARB {@native glCreateProgramObjectARB}(void); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public native int dispatch_glCreateProgramObjectARB1(long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glCreateShader}(GLenum type); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public int glCreateShader(int type)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCreateShader;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCreateShader\" not available");
    }
        return dispatch_glCreateShader1(type, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glCreateShader}(GLenum type); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native int dispatch_glCreateShader1(int type, long procAddress);

  /** Entry point to C language function: <code> GLhandleARB {@native glCreateShaderObjectARB}(GLenum shaderType); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public int glCreateShaderObjectARB(int shaderType)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCreateShaderObjectARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCreateShaderObjectARB\" not available");
    }
        return dispatch_glCreateShaderObjectARB1(shaderType, __addr_);
  }

  /** Entry point to C language function: <code> GLhandleARB {@native glCreateShaderObjectARB}(GLenum shaderType); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public native int dispatch_glCreateShaderObjectARB1(int shaderType, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glCreateShaderProgramv}(GLenum type, GLsizei count, const GLchar *  *  strings); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param strings a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public int glCreateShaderProgramv(int type, int count, PointerBuffer strings)  {

    final boolean strings_is_direct = Buffers.isDirect(strings);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCreateShaderProgramv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCreateShaderProgramv\" not available");
    }
        return dispatch_glCreateShaderProgramv1(type, count, strings_is_direct ? ( strings != null ? strings.getBuffer() : null ) : Buffers.getArray(strings), strings_is_direct ? Buffers.getDirectBufferByteOffset(strings) : Buffers.getIndirectBufferByteOffset(strings), strings_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glCreateShaderProgramv}(GLenum type, GLsizei count, const GLchar *  *  strings); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param strings a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private native int dispatch_glCreateShaderProgramv1(int type, int count, Object strings, int strings_byte_offset, boolean strings_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLsync {@native glCreateSyncFromCLeventARB}(void *  context, void *  event, GLbitfield flags); </code> <br>Part of <code>GL_ARB_cl_event</code>
      @param context a direct or array-backed {@link java.nio.Buffer}
      @param event a direct or array-backed {@link java.nio.Buffer}   */
  public long glCreateSyncFromCLeventARB(Buffer context, Buffer event, int flags)  {

    final boolean context_is_direct = Buffers.isDirect(context);
    final boolean event_is_direct = Buffers.isDirect(event);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCreateSyncFromCLeventARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCreateSyncFromCLeventARB\" not available");
    }
        return dispatch_glCreateSyncFromCLeventARB1(context_is_direct ? context : Buffers.getArray(context), context_is_direct ? Buffers.getDirectBufferByteOffset(context) : Buffers.getIndirectBufferByteOffset(context), context_is_direct, event_is_direct ? event : Buffers.getArray(event), event_is_direct ? Buffers.getDirectBufferByteOffset(event) : Buffers.getIndirectBufferByteOffset(event), event_is_direct, flags, __addr_);
  }

  /** Entry point to C language function: <code> GLsync {@native glCreateSyncFromCLeventARB}(void *  context, void *  event, GLbitfield flags); </code> <br>Part of <code>GL_ARB_cl_event</code>
      @param context a direct or array-backed {@link java.nio.Buffer}
      @param event a direct or array-backed {@link java.nio.Buffer}   */
  private native long dispatch_glCreateSyncFromCLeventARB1(Object context, int context_byte_offset, boolean context_is_direct, Object event, int event_byte_offset, boolean event_is_direct, int flags, long procAddress);

  /** Entry point to C language function: <code> void {@native glCullFace}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glCullFace(int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCullFace;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCullFace\" not available");
    }
        dispatch_glCullFace1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCullFace}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glCullFace1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glCullParameterdvEXT}(GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_EXT_cull_vertex</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glCullParameterdvEXT(int pname, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCullParameterdvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCullParameterdvEXT\" not available");
    }
        dispatch_glCullParameterdvEXT1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCullParameterdvEXT}(GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_EXT_cull_vertex</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glCullParameterdvEXT1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCullParameterdvEXT}(GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_EXT_cull_vertex</code>   */
  public void glCullParameterdvEXT(int pname, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCullParameterdvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCullParameterdvEXT\" not available");
    }
        dispatch_glCullParameterdvEXT1(pname, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCullParameterfvEXT}(GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_EXT_cull_vertex</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glCullParameterfvEXT(int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCullParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCullParameterfvEXT\" not available");
    }
        dispatch_glCullParameterfvEXT1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCullParameterfvEXT}(GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_EXT_cull_vertex</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glCullParameterfvEXT1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCullParameterfvEXT}(GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_EXT_cull_vertex</code>   */
  public void glCullParameterfvEXT(int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCullParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCullParameterfvEXT\" not available");
    }
        dispatch_glCullParameterfvEXT1(pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCurrentPaletteMatrixARB}(GLint index); </code> <br>Part of <code>GL_ARB_matrix_palette</code>   */
  public void glCurrentPaletteMatrix(int index)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glCurrentPaletteMatrix;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCurrentPaletteMatrix\" not available");
    }
        dispatch_glCurrentPaletteMatrix1(index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCurrentPaletteMatrixARB}(GLint index); </code> <br>Part of <code>GL_ARB_matrix_palette</code>   */
  public native void dispatch_glCurrentPaletteMatrix1(int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glDebugMessageControlARB}(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *  ids, GLboolean enabled); </code> <br>Part of <code>GL_ARB_debug_output</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDebugMessageControlARB(int source, int type, int severity, int count, IntBuffer ids, boolean enabled)  {

    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDebugMessageControlARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDebugMessageControlARB\" not available");
    }
        dispatch_glDebugMessageControlARB1(source, type, severity, count, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, enabled, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDebugMessageControlARB}(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *  ids, GLboolean enabled); </code> <br>Part of <code>GL_ARB_debug_output</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDebugMessageControlARB1(int source, int type, int severity, int count, Object ids, int ids_byte_offset, boolean ids_is_direct, boolean enabled, long procAddress);

  /** Entry point to C language function: <code> void {@native glDebugMessageControlARB}(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *  ids, GLboolean enabled); </code> <br>Part of <code>GL_ARB_debug_output</code>   */
  public void glDebugMessageControlARB(int source, int type, int severity, int count, int[] ids, int ids_offset, boolean enabled)  {

    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDebugMessageControlARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDebugMessageControlARB\" not available");
    }
        dispatch_glDebugMessageControlARB1(source, type, severity, count, ids, Buffers.SIZEOF_INT * ids_offset, false, enabled, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDebugMessageEnableAMD}(GLenum category, GLenum severity, GLsizei count, const GLuint *  ids, GLboolean enabled); </code> <br>Part of <code>GL_AMD_debug_output</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDebugMessageEnableAMD(int category, int severity, int count, IntBuffer ids, boolean enabled)  {

    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDebugMessageEnableAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDebugMessageEnableAMD\" not available");
    }
        dispatch_glDebugMessageEnableAMD1(category, severity, count, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, enabled, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDebugMessageEnableAMD}(GLenum category, GLenum severity, GLsizei count, const GLuint *  ids, GLboolean enabled); </code> <br>Part of <code>GL_AMD_debug_output</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDebugMessageEnableAMD1(int category, int severity, int count, Object ids, int ids_byte_offset, boolean ids_is_direct, boolean enabled, long procAddress);

  /** Entry point to C language function: <code> void {@native glDebugMessageEnableAMD}(GLenum category, GLenum severity, GLsizei count, const GLuint *  ids, GLboolean enabled); </code> <br>Part of <code>GL_AMD_debug_output</code>   */
  public void glDebugMessageEnableAMD(int category, int severity, int count, int[] ids, int ids_offset, boolean enabled)  {

    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDebugMessageEnableAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDebugMessageEnableAMD\" not available");
    }
        dispatch_glDebugMessageEnableAMD1(category, severity, count, ids, Buffers.SIZEOF_INT * ids_offset, false, enabled, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDebugMessageInsertAMD}(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar *  buf); </code> <br>Part of <code>GL_AMD_debug_output</code>   */
  public void glDebugMessageInsertAMD(int category, int severity, int id, int length, String buf)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDebugMessageInsertAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDebugMessageInsertAMD\" not available");
    }
        dispatch_glDebugMessageInsertAMD1(category, severity, id, length, buf, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDebugMessageInsertAMD}(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar *  buf); </code> <br>Part of <code>GL_AMD_debug_output</code>   */
  public native void dispatch_glDebugMessageInsertAMD1(int category, int severity, int id, int length, String buf, long procAddress);

  /** Entry point to C language function: <code> void {@native glDebugMessageInsertARB}(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *  buf); </code> <br>Part of <code>GL_ARB_debug_output</code>   */
  public void glDebugMessageInsertARB(int source, int type, int id, int severity, int length, String buf)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDebugMessageInsertARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDebugMessageInsertARB\" not available");
    }
        dispatch_glDebugMessageInsertARB1(source, type, id, severity, length, buf, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDebugMessageInsertARB}(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *  buf); </code> <br>Part of <code>GL_ARB_debug_output</code>   */
  public native void dispatch_glDebugMessageInsertARB1(int source, int type, int id, int severity, int length, String buf, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteBuffers}(GLsizei n, const GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_1_5</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteBuffers(int n, IntBuffer buffers)  {

    Buffers.rangeCheck(buffers, n);
    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteBuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteBuffers\" not available");
    }
        dispatch_glDeleteBuffers1(n, buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteBuffers}(GLsizei n, const GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_1_5</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteBuffers1(int n, Object buffers, int buffers_byte_offset, boolean buffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteBuffers}(GLsizei n, const GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_1_5</code>   */
  public void glDeleteBuffers(int n, int[] buffers, int buffers_offset)  {

    Buffers.rangeCheck(buffers, buffers_offset, n);
    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteBuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteBuffers\" not available");
    }
        dispatch_glDeleteBuffers1(n, buffers, Buffers.SIZEOF_INT * buffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteFencesAPPLE}(GLsizei n, const GLuint *  fences); </code> <br>Part of <code>GL_APPLE_fence</code>
      @param fences a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteFencesAPPLE(int n, IntBuffer fences)  {

    Buffers.rangeCheck(fences, n);
    final boolean fences_is_direct = Buffers.isDirect(fences);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteFencesAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteFencesAPPLE\" not available");
    }
        dispatch_glDeleteFencesAPPLE1(n, fences_is_direct ? fences : Buffers.getArray(fences), fences_is_direct ? Buffers.getDirectBufferByteOffset(fences) : Buffers.getIndirectBufferByteOffset(fences), fences_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteFencesAPPLE}(GLsizei n, const GLuint *  fences); </code> <br>Part of <code>GL_APPLE_fence</code>
      @param fences a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteFencesAPPLE1(int n, Object fences, int fences_byte_offset, boolean fences_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteFencesAPPLE}(GLsizei n, const GLuint *  fences); </code> <br>Part of <code>GL_APPLE_fence</code>   */
  public void glDeleteFencesAPPLE(int n, int[] fences, int fences_offset)  {

    Buffers.rangeCheck(fences, fences_offset, n);
    if(fences != null && fences.length <= fences_offset)
      throw new GLException("array offset argument \"fences_offset\" (" + fences_offset + ") equals or exceeds array length (" + fences.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteFencesAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteFencesAPPLE\" not available");
    }
        dispatch_glDeleteFencesAPPLE1(n, fences, Buffers.SIZEOF_INT * fences_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteFencesNV}(GLsizei n, const GLuint *  fences); </code> <br>Part of <code>GL_NV_fence</code>
      @param fences a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteFencesNV(int n, IntBuffer fences)  {

    Buffers.rangeCheck(fences, n);
    final boolean fences_is_direct = Buffers.isDirect(fences);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteFencesNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteFencesNV\" not available");
    }
        dispatch_glDeleteFencesNV1(n, fences_is_direct ? fences : Buffers.getArray(fences), fences_is_direct ? Buffers.getDirectBufferByteOffset(fences) : Buffers.getIndirectBufferByteOffset(fences), fences_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteFencesNV}(GLsizei n, const GLuint *  fences); </code> <br>Part of <code>GL_NV_fence</code>
      @param fences a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteFencesNV1(int n, Object fences, int fences_byte_offset, boolean fences_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteFencesNV}(GLsizei n, const GLuint *  fences); </code> <br>Part of <code>GL_NV_fence</code>   */
  public void glDeleteFencesNV(int n, int[] fences, int fences_offset)  {

    Buffers.rangeCheck(fences, fences_offset, n);
    if(fences != null && fences.length <= fences_offset)
      throw new GLException("array offset argument \"fences_offset\" (" + fences_offset + ") equals or exceeds array length (" + fences.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteFencesNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteFencesNV\" not available");
    }
        dispatch_glDeleteFencesNV1(n, fences, Buffers.SIZEOF_INT * fences_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteFramebuffers}(GLsizei n, const GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteFramebuffers(int n, IntBuffer framebuffers)  {

    final boolean framebuffers_is_direct = Buffers.isDirect(framebuffers);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteFramebuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteFramebuffers\" not available");
    }
        dispatch_glDeleteFramebuffers1(n, framebuffers_is_direct ? framebuffers : Buffers.getArray(framebuffers), framebuffers_is_direct ? Buffers.getDirectBufferByteOffset(framebuffers) : Buffers.getIndirectBufferByteOffset(framebuffers), framebuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteFramebuffers}(GLsizei n, const GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteFramebuffers1(int n, Object framebuffers, int framebuffers_byte_offset, boolean framebuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteFramebuffers}(GLsizei n, const GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public void glDeleteFramebuffers(int n, int[] framebuffers, int framebuffers_offset)  {

    if(framebuffers != null && framebuffers.length <= framebuffers_offset)
      throw new GLException("array offset argument \"framebuffers_offset\" (" + framebuffers_offset + ") equals or exceeds array length (" + framebuffers.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteFramebuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteFramebuffers\" not available");
    }
        dispatch_glDeleteFramebuffers1(n, framebuffers, Buffers.SIZEOF_INT * framebuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteLists}(GLuint list, GLsizei range); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glDeleteLists(int list, int range)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteLists;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteLists\" not available");
    }
        dispatch_glDeleteLists1(list, range, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteLists}(GLuint list, GLsizei range); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glDeleteLists1(int list, int range, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteNamedStringARB}(GLint namelen, const GLchar *  name); </code> <br>Part of <code>GL_ARB_shading_language_include</code>   */
  public void glDeleteNamedStringARB(int namelen, String name)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteNamedStringARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteNamedStringARB\" not available");
    }
        dispatch_glDeleteNamedStringARB1(namelen, name, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteNamedStringARB}(GLint namelen, const GLchar *  name); </code> <br>Part of <code>GL_ARB_shading_language_include</code>   */
  public native void dispatch_glDeleteNamedStringARB1(int namelen, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteNamesAMD}(GLenum identifier, GLuint num, const GLuint *  names); </code> <br>Part of <code>GL_AMD_name_gen_delete</code>
      @param names a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteNamesAMD(int identifier, int num, IntBuffer names)  {

    final boolean names_is_direct = Buffers.isDirect(names);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteNamesAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteNamesAMD\" not available");
    }
        dispatch_glDeleteNamesAMD1(identifier, num, names_is_direct ? names : Buffers.getArray(names), names_is_direct ? Buffers.getDirectBufferByteOffset(names) : Buffers.getIndirectBufferByteOffset(names), names_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteNamesAMD}(GLenum identifier, GLuint num, const GLuint *  names); </code> <br>Part of <code>GL_AMD_name_gen_delete</code>
      @param names a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteNamesAMD1(int identifier, int num, Object names, int names_byte_offset, boolean names_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteNamesAMD}(GLenum identifier, GLuint num, const GLuint *  names); </code> <br>Part of <code>GL_AMD_name_gen_delete</code>   */
  public void glDeleteNamesAMD(int identifier, int num, int[] names, int names_offset)  {

    if(names != null && names.length <= names_offset)
      throw new GLException("array offset argument \"names_offset\" (" + names_offset + ") equals or exceeds array length (" + names.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteNamesAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteNamesAMD\" not available");
    }
        dispatch_glDeleteNamesAMD1(identifier, num, names, Buffers.SIZEOF_INT * names_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteObjectARB}(GLhandleARB obj); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glDeleteObjectARB(int obj)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteObjectARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteObjectARB\" not available");
    }
        dispatch_glDeleteObjectARB1(obj, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteObjectARB}(GLhandleARB obj); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public native void dispatch_glDeleteObjectARB1(int obj, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteOcclusionQueriesNV}(GLsizei n, const GLuint *  ids); </code> <br>Part of <code>GL_NV_occlusion_query</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteOcclusionQueriesNV(int n, IntBuffer ids)  {

    Buffers.rangeCheck(ids, n);
    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteOcclusionQueriesNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteOcclusionQueriesNV\" not available");
    }
        dispatch_glDeleteOcclusionQueriesNV1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteOcclusionQueriesNV}(GLsizei n, const GLuint *  ids); </code> <br>Part of <code>GL_NV_occlusion_query</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteOcclusionQueriesNV1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteOcclusionQueriesNV}(GLsizei n, const GLuint *  ids); </code> <br>Part of <code>GL_NV_occlusion_query</code>   */
  public void glDeleteOcclusionQueriesNV(int n, int[] ids, int ids_offset)  {

    Buffers.rangeCheck(ids, ids_offset, n);
    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteOcclusionQueriesNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteOcclusionQueriesNV\" not available");
    }
        dispatch_glDeleteOcclusionQueriesNV1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeletePerfMonitorsAMD}(GLsizei n, GLuint *  monitors); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param monitors a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeletePerfMonitorsAMD(int n, IntBuffer monitors)  {

    final boolean monitors_is_direct = Buffers.isDirect(monitors);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeletePerfMonitorsAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeletePerfMonitorsAMD\" not available");
    }
        dispatch_glDeletePerfMonitorsAMD1(n, monitors_is_direct ? monitors : Buffers.getArray(monitors), monitors_is_direct ? Buffers.getDirectBufferByteOffset(monitors) : Buffers.getIndirectBufferByteOffset(monitors), monitors_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeletePerfMonitorsAMD}(GLsizei n, GLuint *  monitors); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param monitors a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeletePerfMonitorsAMD1(int n, Object monitors, int monitors_byte_offset, boolean monitors_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeletePerfMonitorsAMD}(GLsizei n, GLuint *  monitors); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glDeletePerfMonitorsAMD(int n, int[] monitors, int monitors_offset)  {

    if(monitors != null && monitors.length <= monitors_offset)
      throw new GLException("array offset argument \"monitors_offset\" (" + monitors_offset + ") equals or exceeds array length (" + monitors.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeletePerfMonitorsAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeletePerfMonitorsAMD\" not available");
    }
        dispatch_glDeletePerfMonitorsAMD1(n, monitors, Buffers.SIZEOF_INT * monitors_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteProgram}(GLuint program); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glDeleteProgram(int program)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteProgram;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteProgram\" not available");
    }
        dispatch_glDeleteProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteProgram}(GLuint program); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glDeleteProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteProgramPipelines}(GLsizei n, const GLuint *  pipelines); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param pipelines a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteProgramPipelines(int n, IntBuffer pipelines)  {

    final boolean pipelines_is_direct = Buffers.isDirect(pipelines);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteProgramPipelines;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteProgramPipelines\" not available");
    }
        dispatch_glDeleteProgramPipelines1(n, pipelines_is_direct ? pipelines : Buffers.getArray(pipelines), pipelines_is_direct ? Buffers.getDirectBufferByteOffset(pipelines) : Buffers.getIndirectBufferByteOffset(pipelines), pipelines_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteProgramPipelines}(GLsizei n, const GLuint *  pipelines); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param pipelines a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteProgramPipelines1(int n, Object pipelines, int pipelines_byte_offset, boolean pipelines_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteProgramPipelines}(GLsizei n, const GLuint *  pipelines); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glDeleteProgramPipelines(int n, int[] pipelines, int pipelines_offset)  {

    if(pipelines != null && pipelines.length <= pipelines_offset)
      throw new GLException("array offset argument \"pipelines_offset\" (" + pipelines_offset + ") equals or exceeds array length (" + pipelines.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteProgramPipelines;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteProgramPipelines\" not available");
    }
        dispatch_glDeleteProgramPipelines1(n, pipelines, Buffers.SIZEOF_INT * pipelines_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteProgramsARB}(GLsizei n, const GLuint *  programs); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param programs a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteProgramsARB(int n, IntBuffer programs)  {

    Buffers.rangeCheck(programs, n);
    final boolean programs_is_direct = Buffers.isDirect(programs);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteProgramsARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteProgramsARB\" not available");
    }
        dispatch_glDeleteProgramsARB1(n, programs_is_direct ? programs : Buffers.getArray(programs), programs_is_direct ? Buffers.getDirectBufferByteOffset(programs) : Buffers.getIndirectBufferByteOffset(programs), programs_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteProgramsARB}(GLsizei n, const GLuint *  programs); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param programs a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteProgramsARB1(int n, Object programs, int programs_byte_offset, boolean programs_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteProgramsARB}(GLsizei n, const GLuint *  programs); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glDeleteProgramsARB(int n, int[] programs, int programs_offset)  {

    Buffers.rangeCheck(programs, programs_offset, n);
    if(programs != null && programs.length <= programs_offset)
      throw new GLException("array offset argument \"programs_offset\" (" + programs_offset + ") equals or exceeds array length (" + programs.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteProgramsARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteProgramsARB\" not available");
    }
        dispatch_glDeleteProgramsARB1(n, programs, Buffers.SIZEOF_INT * programs_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteQueries}(GLsizei n, const GLuint *  ids); </code> <br>Part of <code>GL_VERSION_1_5</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteQueries(int n, IntBuffer ids)  {

    Buffers.rangeCheck(ids, n);
    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteQueries;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteQueries\" not available");
    }
        dispatch_glDeleteQueries1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteQueries}(GLsizei n, const GLuint *  ids); </code> <br>Part of <code>GL_VERSION_1_5</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteQueries1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteQueries}(GLsizei n, const GLuint *  ids); </code> <br>Part of <code>GL_VERSION_1_5</code>   */
  public void glDeleteQueries(int n, int[] ids, int ids_offset)  {

    Buffers.rangeCheck(ids, ids_offset, n);
    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteQueries;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteQueries\" not available");
    }
        dispatch_glDeleteQueries1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteRenderbuffers}(GLsizei n, const GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteRenderbuffers(int n, IntBuffer renderbuffers)  {

    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteRenderbuffers\" not available");
    }
        dispatch_glDeleteRenderbuffers1(n, renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteRenderbuffers}(GLsizei n, const GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteRenderbuffers1(int n, Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteRenderbuffers}(GLsizei n, const GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public void glDeleteRenderbuffers(int n, int[] renderbuffers, int renderbuffers_offset)  {

    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteRenderbuffers\" not available");
    }
        dispatch_glDeleteRenderbuffers1(n, renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteSamplers}(GLsizei count, const GLuint *  samplers); </code> <br>Part of <code>GL_ARB_sampler_objects</code>
      @param samplers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteSamplers(int count, IntBuffer samplers)  {

    final boolean samplers_is_direct = Buffers.isDirect(samplers);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteSamplers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteSamplers\" not available");
    }
        dispatch_glDeleteSamplers1(count, samplers_is_direct ? samplers : Buffers.getArray(samplers), samplers_is_direct ? Buffers.getDirectBufferByteOffset(samplers) : Buffers.getIndirectBufferByteOffset(samplers), samplers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteSamplers}(GLsizei count, const GLuint *  samplers); </code> <br>Part of <code>GL_ARB_sampler_objects</code>
      @param samplers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteSamplers1(int count, Object samplers, int samplers_byte_offset, boolean samplers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteSamplers}(GLsizei count, const GLuint *  samplers); </code> <br>Part of <code>GL_ARB_sampler_objects</code>   */
  public void glDeleteSamplers(int count, int[] samplers, int samplers_offset)  {

    if(samplers != null && samplers.length <= samplers_offset)
      throw new GLException("array offset argument \"samplers_offset\" (" + samplers_offset + ") equals or exceeds array length (" + samplers.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteSamplers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteSamplers\" not available");
    }
        dispatch_glDeleteSamplers1(count, samplers, Buffers.SIZEOF_INT * samplers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteShader}(GLuint shader); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glDeleteShader(int shader)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteShader;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteShader\" not available");
    }
        dispatch_glDeleteShader1(shader, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteShader}(GLuint shader); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glDeleteShader1(int shader, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteSync}(GLsync sync); </code> <br>Part of <code>GL_ARB_sync</code>   */
  public void glDeleteSync(long sync)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteSync;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteSync\" not available");
    }
        dispatch_glDeleteSync1(sync, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteSync}(GLsync sync); </code> <br>Part of <code>GL_ARB_sync</code>   */
  public native void dispatch_glDeleteSync1(long sync, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteTextures}(GLsizei n, const GLuint *  textures); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteTextures(int n, IntBuffer textures)  {

    Buffers.rangeCheck(textures, n);
    final boolean textures_is_direct = Buffers.isDirect(textures);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteTextures;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteTextures\" not available");
    }
        dispatch_glDeleteTextures1(n, textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteTextures}(GLsizei n, const GLuint *  textures); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteTextures1(int n, Object textures, int textures_byte_offset, boolean textures_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteTextures}(GLsizei n, const GLuint *  textures); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public void glDeleteTextures(int n, int[] textures, int textures_offset)  {

    Buffers.rangeCheck(textures, textures_offset, n);
    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteTextures;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteTextures\" not available");
    }
        dispatch_glDeleteTextures1(n, textures, Buffers.SIZEOF_INT * textures_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteTransformFeedbacks}(GLsizei n, const GLuint *  ids); </code> <br>Part of <code>GL_ARB_transform_feedback2</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteTransformFeedbacks(int n, IntBuffer ids)  {

    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteTransformFeedbacks;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteTransformFeedbacks\" not available");
    }
        dispatch_glDeleteTransformFeedbacks1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteTransformFeedbacks}(GLsizei n, const GLuint *  ids); </code> <br>Part of <code>GL_ARB_transform_feedback2</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteTransformFeedbacks1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteTransformFeedbacks}(GLsizei n, const GLuint *  ids); </code> <br>Part of <code>GL_ARB_transform_feedback2</code>   */
  public void glDeleteTransformFeedbacks(int n, int[] ids, int ids_offset)  {

    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteTransformFeedbacks;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteTransformFeedbacks\" not available");
    }
        dispatch_glDeleteTransformFeedbacks1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteTransformFeedbacksNV}(GLsizei n, const GLuint *  ids); </code> <br>Part of <code>GL_NV_transform_feedback2</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteTransformFeedbacksNV(int n, IntBuffer ids)  {

    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteTransformFeedbacksNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteTransformFeedbacksNV\" not available");
    }
        dispatch_glDeleteTransformFeedbacksNV1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteTransformFeedbacksNV}(GLsizei n, const GLuint *  ids); </code> <br>Part of <code>GL_NV_transform_feedback2</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteTransformFeedbacksNV1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteTransformFeedbacksNV}(GLsizei n, const GLuint *  ids); </code> <br>Part of <code>GL_NV_transform_feedback2</code>   */
  public void glDeleteTransformFeedbacksNV(int n, int[] ids, int ids_offset)  {

    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteTransformFeedbacksNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteTransformFeedbacksNV\" not available");
    }
        dispatch_glDeleteTransformFeedbacksNV1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteVertexArrays}(GLsizei n, const GLuint *  arrays); </code> <br>Part of <code>GL_ARB_vertex_array_object</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteVertexArrays(int n, IntBuffer arrays)  {

    final boolean arrays_is_direct = Buffers.isDirect(arrays);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteVertexArrays;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteVertexArrays\" not available");
    }
        dispatch_glDeleteVertexArrays1(n, arrays_is_direct ? arrays : Buffers.getArray(arrays), arrays_is_direct ? Buffers.getDirectBufferByteOffset(arrays) : Buffers.getIndirectBufferByteOffset(arrays), arrays_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteVertexArrays}(GLsizei n, const GLuint *  arrays); </code> <br>Part of <code>GL_ARB_vertex_array_object</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteVertexArrays1(int n, Object arrays, int arrays_byte_offset, boolean arrays_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteVertexArrays}(GLsizei n, const GLuint *  arrays); </code> <br>Part of <code>GL_ARB_vertex_array_object</code>   */
  public void glDeleteVertexArrays(int n, int[] arrays, int arrays_offset)  {

    if(arrays != null && arrays.length <= arrays_offset)
      throw new GLException("array offset argument \"arrays_offset\" (" + arrays_offset + ") equals or exceeds array length (" + arrays.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteVertexArrays;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteVertexArrays\" not available");
    }
        dispatch_glDeleteVertexArrays1(n, arrays, Buffers.SIZEOF_INT * arrays_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteVertexShaderEXT}(GLuint id); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glDeleteVertexShaderEXT(int id)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteVertexShaderEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteVertexShaderEXT\" not available");
    }
        dispatch_glDeleteVertexShaderEXT1(id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteVertexShaderEXT}(GLuint id); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public native void dispatch_glDeleteVertexShaderEXT1(int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthBoundsEXT}(GLclampd zmin, GLclampd zmax); </code> <br>Part of <code>GL_EXT_depth_bounds_test</code>   */
  public void glDepthBoundsEXT(double zmin, double zmax)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDepthBoundsEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDepthBoundsEXT\" not available");
    }
        dispatch_glDepthBoundsEXT1(zmin, zmax, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthBoundsEXT}(GLclampd zmin, GLclampd zmax); </code> <br>Part of <code>GL_EXT_depth_bounds_test</code>   */
  public native void dispatch_glDepthBoundsEXT1(double zmin, double zmax, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthFunc}(GLenum func); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glDepthFunc(int func)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDepthFunc;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDepthFunc\" not available");
    }
        dispatch_glDepthFunc1(func, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthFunc}(GLenum func); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glDepthFunc1(int func, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthMask}(GLboolean flag); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glDepthMask(boolean flag)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDepthMask;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDepthMask\" not available");
    }
        dispatch_glDepthMask1(flag, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthMask}(GLboolean flag); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glDepthMask1(boolean flag, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthRange}(GLclampd zNear, GLclampd zFar); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glDepthRange(double zNear, double zFar)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDepthRange;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDepthRange\" not available");
    }
        dispatch_glDepthRange1(zNear, zFar, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthRange}(GLclampd zNear, GLclampd zFar); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glDepthRange1(double zNear, double zFar, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthRangeArrayv}(GLuint first, GLsizei count, const GLclampd *  v); </code> <br>Part of <code>GL_ARB_viewport_array</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glDepthRangeArrayv(int first, int count, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDepthRangeArrayv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDepthRangeArrayv\" not available");
    }
        dispatch_glDepthRangeArrayv1(first, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthRangeArrayv}(GLuint first, GLsizei count, const GLclampd *  v); </code> <br>Part of <code>GL_ARB_viewport_array</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glDepthRangeArrayv1(int first, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthRangeArrayv}(GLuint first, GLsizei count, const GLclampd *  v); </code> <br>Part of <code>GL_ARB_viewport_array</code>   */
  public void glDepthRangeArrayv(int first, int count, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDepthRangeArrayv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDepthRangeArrayv\" not available");
    }
        dispatch_glDepthRangeArrayv1(first, count, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthRangeIndexed}(GLuint index, GLclampd n, GLclampd f); </code> <br>Part of <code>GL_ARB_viewport_array</code>   */
  public void glDepthRangeIndexed(int index, double n, double f)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDepthRangeIndexed;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDepthRangeIndexed\" not available");
    }
        dispatch_glDepthRangeIndexed1(index, n, f, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthRangeIndexed}(GLuint index, GLclampd n, GLclampd f); </code> <br>Part of <code>GL_ARB_viewport_array</code>   */
  public native void dispatch_glDepthRangeIndexed1(int index, double n, double f, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthRangef}(GLclampf zNear, GLclampf zFar); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>   */
  public void glDepthRangef(float zNear, float zFar)  {

    if ( !_context.isGLES2Compatible() ) {
    glDepthRange( (double)zNear, (double)zFar );
    return;
    }
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDepthRangef;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDepthRangef\" not available");
    }
        dispatch_glDepthRangef1(zNear, zFar, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthRangef}(GLclampf zNear, GLclampf zFar); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>   */
  private native void dispatch_glDepthRangef1(float zNear, float zFar, long procAddress);

  /** Entry point to C language function: <code> void {@native glDetachObjectARB}(GLhandleARB containerObj, GLhandleARB attachedObj); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glDetachObjectARB(int containerObj, int attachedObj)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDetachObjectARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDetachObjectARB\" not available");
    }
        dispatch_glDetachObjectARB1(containerObj, attachedObj, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDetachObjectARB}(GLhandleARB containerObj, GLhandleARB attachedObj); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public native void dispatch_glDetachObjectARB1(int containerObj, int attachedObj, long procAddress);

  /** Entry point to C language function: <code> void {@native glDetachShader}(GLuint program, GLuint shader); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glDetachShader(int program, int shader)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDetachShader;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDetachShader\" not available");
    }
        dispatch_glDetachShader1(program, shader, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDetachShader}(GLuint program, GLuint shader); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glDetachShader1(int program, int shader, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisable}(GLenum cap); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glDisable(int cap)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDisable;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDisable\" not available");
    }
        dispatch_glDisable1(cap, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisable}(GLenum cap); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glDisable1(int cap, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableClientState}(GLenum cap); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public void glDisableClientState(int cap)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDisableClientState;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDisableClientState\" not available");
    }
        dispatch_glDisableClientState1(cap, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableClientState}(GLenum cap); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public native void dispatch_glDisableClientState1(int cap, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableClientStateIndexedEXT}(GLenum array, GLuint index); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glDisableClientStateIndexedEXT(int array, int index)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDisableClientStateIndexedEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDisableClientStateIndexedEXT\" not available");
    }
        dispatch_glDisableClientStateIndexedEXT1(array, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableClientStateIndexedEXT}(GLenum array, GLuint index); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glDisableClientStateIndexedEXT1(int array, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableIndexedEXT}(GLenum target, GLuint index); </code> <br>Part of <code>GL_EXT_draw_buffers2</code>   */
  public void glDisableIndexed(int target, int index)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDisableIndexed;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDisableIndexed\" not available");
    }
        dispatch_glDisableIndexed1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableIndexedEXT}(GLenum target, GLuint index); </code> <br>Part of <code>GL_EXT_draw_buffers2</code>   */
  public native void dispatch_glDisableIndexed1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableVariantClientStateEXT}(GLuint id); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glDisableVariantClientStateEXT(int id)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDisableVariantClientStateEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDisableVariantClientStateEXT\" not available");
    }
        dispatch_glDisableVariantClientStateEXT1(id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableVariantClientStateEXT}(GLuint id); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public native void dispatch_glDisableVariantClientStateEXT1(int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableVertexAttribAPPLE}(GLuint index, GLenum pname); </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code>   */
  public void glDisableVertexAttribAPPLE(int index, int pname)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDisableVertexAttribAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDisableVertexAttribAPPLE\" not available");
    }
        dispatch_glDisableVertexAttribAPPLE1(index, pname, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableVertexAttribAPPLE}(GLuint index, GLenum pname); </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code>   */
  public native void dispatch_glDisableVertexAttribAPPLE1(int index, int pname, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableVertexAttribArray}(GLuint index); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glDisableVertexAttribArray(int index)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDisableVertexAttribArray;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDisableVertexAttribArray\" not available");
    }
        dispatch_glDisableVertexAttribArray1(index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableVertexAttribArray}(GLuint index); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glDisableVertexAttribArray1(int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableVertexAttribArrayARB}(GLuint index); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glDisableVertexAttribArrayARB(int index)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDisableVertexAttribArrayARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDisableVertexAttribArrayARB\" not available");
    }
        dispatch_glDisableVertexAttribArrayARB1(index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableVertexAttribArrayARB}(GLuint index); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public native void dispatch_glDisableVertexAttribArrayARB1(int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisablei}(GLenum target, GLuint index); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glDisablei(int target, int index)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDisablei;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDisablei\" not available");
    }
        dispatch_glDisablei1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisablei}(GLenum target, GLuint index); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public native void dispatch_glDisablei1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawArrays}(GLenum mode, GLint first, GLsizei count); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public void glDrawArrays(int mode, int first, int count)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawArrays;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawArrays\" not available");
    }
        dispatch_glDrawArrays1(mode, first, count, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArrays}(GLenum mode, GLint first, GLsizei count); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public native void dispatch_glDrawArrays1(int mode, int first, int count, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawArraysIndirect}(GLenum mode, const GLvoid *  indirect); </code> <br>Part of <code>GL_ARB_draw_indirect</code>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawArraysIndirect(int mode, Buffer indirect)  {

    final boolean indirect_is_direct = Buffers.isDirect(indirect);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawArraysIndirect;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawArraysIndirect\" not available");
    }
        dispatch_glDrawArraysIndirect1(mode, indirect_is_direct ? indirect : Buffers.getArray(indirect), indirect_is_direct ? Buffers.getDirectBufferByteOffset(indirect) : Buffers.getIndirectBufferByteOffset(indirect), indirect_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArraysIndirect}(GLenum mode, const GLvoid *  indirect); </code> <br>Part of <code>GL_ARB_draw_indirect</code>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawArraysIndirect1(int mode, Object indirect, int indirect_byte_offset, boolean indirect_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawArraysInstancedARB}(GLenum mode, GLint first, GLsizei count, GLsizei primcount); </code> <br>Part of <code>GL_ARB_draw_instanced</code>   */
  public void glDrawArraysInstanced(int mode, int first, int count, int primcount)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawArraysInstanced;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawArraysInstanced\" not available");
    }
        dispatch_glDrawArraysInstanced1(mode, first, count, primcount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArraysInstancedARB}(GLenum mode, GLint first, GLsizei count, GLsizei primcount); </code> <br>Part of <code>GL_ARB_draw_instanced</code>   */
  public native void dispatch_glDrawArraysInstanced1(int mode, int first, int count, int primcount, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawArraysInstancedBaseInstance}(GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance); </code> <br>Part of <code>GL_ARB_base_instance</code>   */
  public void glDrawArraysInstancedBaseInstance(int mode, int first, int count, int primcount, int baseinstance)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawArraysInstancedBaseInstance;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawArraysInstancedBaseInstance\" not available");
    }
        dispatch_glDrawArraysInstancedBaseInstance1(mode, first, count, primcount, baseinstance, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArraysInstancedBaseInstance}(GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance); </code> <br>Part of <code>GL_ARB_base_instance</code>   */
  public native void dispatch_glDrawArraysInstancedBaseInstance1(int mode, int first, int count, int primcount, int baseinstance, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawBuffer}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glDrawBuffer(int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawBuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawBuffer\" not available");
    }
        dispatch_glDrawBuffer1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawBuffer}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glDrawBuffer1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawBuffers}(GLsizei n, const GLenum *  bufs); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param bufs a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDrawBuffers(int n, IntBuffer bufs)  {

    final boolean bufs_is_direct = Buffers.isDirect(bufs);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawBuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawBuffers\" not available");
    }
        dispatch_glDrawBuffers1(n, bufs_is_direct ? bufs : Buffers.getArray(bufs), bufs_is_direct ? Buffers.getDirectBufferByteOffset(bufs) : Buffers.getIndirectBufferByteOffset(bufs), bufs_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawBuffers}(GLsizei n, const GLenum *  bufs); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param bufs a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDrawBuffers1(int n, Object bufs, int bufs_byte_offset, boolean bufs_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawBuffers}(GLsizei n, const GLenum *  bufs); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glDrawBuffers(int n, int[] bufs, int bufs_offset)  {

    if(bufs != null && bufs.length <= bufs_offset)
      throw new GLException("array offset argument \"bufs_offset\" (" + bufs_offset + ") equals or exceeds array length (" + bufs.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawBuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawBuffers\" not available");
    }
        dispatch_glDrawBuffers1(n, bufs, Buffers.SIZEOF_INT * bufs_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawBuffersATI}(GLsizei n, const GLenum *  bufs); </code> <br>Part of <code>GL_ATI_draw_buffers</code>
      @param bufs a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDrawBuffersATI(int n, IntBuffer bufs)  {

    final boolean bufs_is_direct = Buffers.isDirect(bufs);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawBuffersATI;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawBuffersATI\" not available");
    }
        dispatch_glDrawBuffersATI1(n, bufs_is_direct ? bufs : Buffers.getArray(bufs), bufs_is_direct ? Buffers.getDirectBufferByteOffset(bufs) : Buffers.getIndirectBufferByteOffset(bufs), bufs_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawBuffersATI}(GLsizei n, const GLenum *  bufs); </code> <br>Part of <code>GL_ATI_draw_buffers</code>
      @param bufs a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDrawBuffersATI1(int n, Object bufs, int bufs_byte_offset, boolean bufs_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawBuffersATI}(GLsizei n, const GLenum *  bufs); </code> <br>Part of <code>GL_ATI_draw_buffers</code>   */
  public void glDrawBuffersATI(int n, int[] bufs, int bufs_offset)  {

    if(bufs != null && bufs.length <= bufs_offset)
      throw new GLException("array offset argument \"bufs_offset\" (" + bufs_offset + ") equals or exceeds array length (" + bufs.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawBuffersATI;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawBuffersATI\" not available");
    }
        dispatch_glDrawBuffersATI1(n, bufs, Buffers.SIZEOF_INT * bufs_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElements(int mode, int count, int type, Buffer indices)  {

    checkElementVBODisabled(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawElements;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawElements\" not available");
    }
        dispatch_glDrawElements1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElements1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public void glDrawElements(int mode, int count, int type, long indices_buffer_offset)  {

    checkElementVBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawElements;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawElements\" not available");
    }
        dispatch_glDrawElements1(mode, count, type, indices_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  private native void dispatch_glDrawElements1(int mode, int count, int type, long indices_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsBaseVertex}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices, GLint basevertex); </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsBaseVertex(int mode, int count, int type, Buffer indices, int basevertex)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawElementsBaseVertex;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawElementsBaseVertex\" not available");
    }
        dispatch_glDrawElementsBaseVertex1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, basevertex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsBaseVertex}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices, GLint basevertex); </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsBaseVertex1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int basevertex, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsIndirect}(GLenum mode, GLenum type, const GLvoid *  indirect); </code> <br>Part of <code>GL_ARB_draw_indirect</code>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsIndirect(int mode, int type, Buffer indirect)  {

    final boolean indirect_is_direct = Buffers.isDirect(indirect);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawElementsIndirect;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawElementsIndirect\" not available");
    }
        dispatch_glDrawElementsIndirect1(mode, type, indirect_is_direct ? indirect : Buffers.getArray(indirect), indirect_is_direct ? Buffers.getDirectBufferByteOffset(indirect) : Buffers.getIndirectBufferByteOffset(indirect), indirect_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsIndirect}(GLenum mode, GLenum type, const GLvoid *  indirect); </code> <br>Part of <code>GL_ARB_draw_indirect</code>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsIndirect1(int mode, int type, Object indirect, int indirect_byte_offset, boolean indirect_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedARB}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices, GLsizei primcount); </code> <br>Part of <code>GL_ARB_draw_instanced</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsInstanced(int mode, int count, int type, Buffer indices, int primcount)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawElementsInstanced;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawElementsInstanced\" not available");
    }
        dispatch_glDrawElementsInstanced1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, primcount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedARB}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices, GLsizei primcount); </code> <br>Part of <code>GL_ARB_draw_instanced</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsInstanced1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int primcount, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseInstance}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei primcount, GLuint baseinstance); </code> <br>Part of <code>GL_ARB_base_instance</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsInstancedBaseInstance(int mode, int count, int type, Buffer indices, int primcount, int baseinstance)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawElementsInstancedBaseInstance;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawElementsInstancedBaseInstance\" not available");
    }
        dispatch_glDrawElementsInstancedBaseInstance1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, primcount, baseinstance, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseInstance}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei primcount, GLuint baseinstance); </code> <br>Part of <code>GL_ARB_base_instance</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsInstancedBaseInstance1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int primcount, int baseinstance, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertex}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices, GLsizei primcount, GLint basevertex); </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsInstancedBaseVertex(int mode, int count, int type, Buffer indices, int primcount, int basevertex)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawElementsInstancedBaseVertex;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawElementsInstancedBaseVertex\" not available");
    }
        dispatch_glDrawElementsInstancedBaseVertex1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, primcount, basevertex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertex}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices, GLsizei primcount, GLint basevertex); </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsInstancedBaseVertex1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int primcount, int basevertex, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertexBaseInstance}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei primcount, GLint basevertex, GLuint baseinstance); </code> <br>Part of <code>GL_ARB_base_instance</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsInstancedBaseVertexBaseInstance(int mode, int count, int type, Buffer indices, int primcount, int basevertex, int baseinstance)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawElementsInstancedBaseVertexBaseInstance;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawElementsInstancedBaseVertexBaseInstance\" not available");
    }
        dispatch_glDrawElementsInstancedBaseVertexBaseInstance1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, primcount, basevertex, baseinstance, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertexBaseInstance}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei primcount, GLint basevertex, GLuint baseinstance); </code> <br>Part of <code>GL_ARB_base_instance</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsInstancedBaseVertexBaseInstance1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int primcount, int basevertex, int baseinstance, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawPixels}(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawPixels(int width, int height, int format, int type, Buffer pixels)  {

    checkUnpackPBODisabled(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width            , height            , 1    , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawPixels;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawPixels\" not available");
    }
        dispatch_glDrawPixels1(width, height, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawPixels}(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawPixels1(int width, int height, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawPixels}(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glDrawPixels(int width, int height, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawPixels;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawPixels\" not available");
    }
        dispatch_glDrawPixels1(width, height, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawPixels}(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  private native void dispatch_glDrawPixels1(int width, int height, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawRangeElements}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_1_2</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawRangeElements(int mode, int start, int end, int count, int type, Buffer indices)  {

    checkElementVBODisabled(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawRangeElements;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawRangeElements\" not available");
    }
        dispatch_glDrawRangeElements1(mode, start, end, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawRangeElements}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_1_2</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawRangeElements1(int mode, int start, int end, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawRangeElements}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_1_2</code>   */
  public void glDrawRangeElements(int mode, int start, int end, int count, int type, long indices_buffer_offset)  {

    checkElementVBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawRangeElements;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawRangeElements\" not available");
    }
        dispatch_glDrawRangeElements1(mode, start, end, count, type, indices_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawRangeElements}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_1_2</code>   */
  private native void dispatch_glDrawRangeElements1(int mode, int start, int end, int count, int type, long indices_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawRangeElementsBaseVertex}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *  indices, GLint basevertex); </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawRangeElementsBaseVertex(int mode, int start, int end, int count, int type, Buffer indices, int basevertex)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawRangeElementsBaseVertex;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawRangeElementsBaseVertex\" not available");
    }
        dispatch_glDrawRangeElementsBaseVertex1(mode, start, end, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, basevertex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawRangeElementsBaseVertex}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *  indices, GLint basevertex); </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawRangeElementsBaseVertex1(int mode, int start, int end, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int basevertex, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTransformFeedback}(GLenum mode, GLuint id); </code> <br>Part of <code>GL_ARB_transform_feedback2</code>   */
  public void glDrawTransformFeedback(int mode, int id)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawTransformFeedback\" not available");
    }
        dispatch_glDrawTransformFeedback1(mode, id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTransformFeedback}(GLenum mode, GLuint id); </code> <br>Part of <code>GL_ARB_transform_feedback2</code>   */
  public native void dispatch_glDrawTransformFeedback1(int mode, int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTransformFeedbackInstanced}(GLenum mode, GLuint id, GLsizei primcount); </code> <br>Part of <code>GL_ARB_transform_feedback_instanced</code>   */
  public void glDrawTransformFeedbackInstanced(int mode, int id, int primcount)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawTransformFeedbackInstanced;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawTransformFeedbackInstanced\" not available");
    }
        dispatch_glDrawTransformFeedbackInstanced1(mode, id, primcount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTransformFeedbackInstanced}(GLenum mode, GLuint id, GLsizei primcount); </code> <br>Part of <code>GL_ARB_transform_feedback_instanced</code>   */
  public native void dispatch_glDrawTransformFeedbackInstanced1(int mode, int id, int primcount, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTransformFeedbackNV}(GLenum mode, GLuint id); </code> <br>Part of <code>GL_NV_transform_feedback2</code>   */
  public void glDrawTransformFeedbackNV(int mode, int id)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawTransformFeedbackNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawTransformFeedbackNV\" not available");
    }
        dispatch_glDrawTransformFeedbackNV1(mode, id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTransformFeedbackNV}(GLenum mode, GLuint id); </code> <br>Part of <code>GL_NV_transform_feedback2</code>   */
  public native void dispatch_glDrawTransformFeedbackNV1(int mode, int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTransformFeedbackStream}(GLenum mode, GLuint id, GLuint stream); </code> <br>Part of <code>GL_ARB_transform_feedback3</code>   */
  public void glDrawTransformFeedbackStream(int mode, int id, int stream)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawTransformFeedbackStream;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawTransformFeedbackStream\" not available");
    }
        dispatch_glDrawTransformFeedbackStream1(mode, id, stream, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTransformFeedbackStream}(GLenum mode, GLuint id, GLuint stream); </code> <br>Part of <code>GL_ARB_transform_feedback3</code>   */
  public native void dispatch_glDrawTransformFeedbackStream1(int mode, int id, int stream, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTransformFeedbackStreamInstanced}(GLenum mode, GLuint id, GLuint stream, GLsizei primcount); </code> <br>Part of <code>GL_ARB_transform_feedback_instanced</code>   */
  public void glDrawTransformFeedbackStreamInstanced(int mode, int id, int stream, int primcount)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawTransformFeedbackStreamInstanced;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawTransformFeedbackStreamInstanced\" not available");
    }
        dispatch_glDrawTransformFeedbackStreamInstanced1(mode, id, stream, primcount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTransformFeedbackStreamInstanced}(GLenum mode, GLuint id, GLuint stream, GLsizei primcount); </code> <br>Part of <code>GL_ARB_transform_feedback_instanced</code>   */
  public native void dispatch_glDrawTransformFeedbackStreamInstanced1(int mode, int id, int stream, int primcount, long procAddress);

  /** Entry point to C language function: <code> void {@native glEdgeFlag}(GLboolean flag); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glEdgeFlag(boolean flag)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEdgeFlag;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEdgeFlag\" not available");
    }
        dispatch_glEdgeFlag1(flag, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEdgeFlag}(GLboolean flag); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glEdgeFlag1(boolean flag, long procAddress);

  /** Entry point to C language function: <code> void {@native glEdgeFlagFormatNV}(GLsizei stride); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public void glEdgeFlagFormatNV(int stride)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEdgeFlagFormatNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEdgeFlagFormatNV\" not available");
    }
        dispatch_glEdgeFlagFormatNV1(stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEdgeFlagFormatNV}(GLsizei stride); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public native void dispatch_glEdgeFlagFormatNV1(int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glEdgeFlagPointer}(GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}   */
  public void glEdgeFlagPointer(int stride, Buffer ptr)  {

    checkArrayVBODisabled(true);
    Buffers.rangeCheck(ptr, 1);
    final boolean ptr_is_direct = Buffers.isDirect(ptr);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEdgeFlagPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEdgeFlagPointer\" not available");
    }
        dispatch_glEdgeFlagPointer1(stride, ptr_is_direct ? ptr : Buffers.getArray(ptr), ptr_is_direct ? Buffers.getDirectBufferByteOffset(ptr) : Buffers.getIndirectBufferByteOffset(ptr), ptr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEdgeFlagPointer}(GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glEdgeFlagPointer1(int stride, Object ptr, int ptr_byte_offset, boolean ptr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glEdgeFlagPointer}(GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public void glEdgeFlagPointer(int stride, long ptr_buffer_offset)  {

    checkArrayVBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEdgeFlagPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEdgeFlagPointer\" not available");
    }
        dispatch_glEdgeFlagPointer1(stride, ptr_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEdgeFlagPointer}(GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  private native void dispatch_glEdgeFlagPointer1(int stride, long ptr_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glEdgeFlagv}(const GLboolean *  flag); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param flag a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glEdgeFlagv(ByteBuffer flag)  {

    final boolean flag_is_direct = Buffers.isDirect(flag);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEdgeFlagv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEdgeFlagv\" not available");
    }
        dispatch_glEdgeFlagv1(flag_is_direct ? flag : Buffers.getArray(flag), flag_is_direct ? Buffers.getDirectBufferByteOffset(flag) : Buffers.getIndirectBufferByteOffset(flag), flag_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEdgeFlagv}(const GLboolean *  flag); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param flag a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glEdgeFlagv1(Object flag, int flag_byte_offset, boolean flag_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glEdgeFlagv}(const GLboolean *  flag); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glEdgeFlagv(byte[] flag, int flag_offset)  {

    if(flag != null && flag.length <= flag_offset)
      throw new GLException("array offset argument \"flag_offset\" (" + flag_offset + ") equals or exceeds array length (" + flag.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEdgeFlagv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEdgeFlagv\" not available");
    }
        dispatch_glEdgeFlagv1(flag, flag_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnable}(GLenum cap); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glEnable(int cap)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEnable;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEnable\" not available");
    }
        dispatch_glEnable1(cap, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnable}(GLenum cap); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glEnable1(int cap, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableClientState}(GLenum cap); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public void glEnableClientState(int cap)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEnableClientState;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEnableClientState\" not available");
    }
        dispatch_glEnableClientState1(cap, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableClientState}(GLenum cap); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public native void dispatch_glEnableClientState1(int cap, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableClientStateIndexedEXT}(GLenum array, GLuint index); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glEnableClientStateIndexedEXT(int array, int index)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEnableClientStateIndexedEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEnableClientStateIndexedEXT\" not available");
    }
        dispatch_glEnableClientStateIndexedEXT1(array, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableClientStateIndexedEXT}(GLenum array, GLuint index); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glEnableClientStateIndexedEXT1(int array, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableIndexedEXT}(GLenum target, GLuint index); </code> <br>Part of <code>GL_EXT_draw_buffers2</code>   */
  public void glEnableIndexed(int target, int index)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEnableIndexed;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEnableIndexed\" not available");
    }
        dispatch_glEnableIndexed1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableIndexedEXT}(GLenum target, GLuint index); </code> <br>Part of <code>GL_EXT_draw_buffers2</code>   */
  public native void dispatch_glEnableIndexed1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableVariantClientStateEXT}(GLuint id); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glEnableVariantClientStateEXT(int id)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEnableVariantClientStateEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEnableVariantClientStateEXT\" not available");
    }
        dispatch_glEnableVariantClientStateEXT1(id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableVariantClientStateEXT}(GLuint id); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public native void dispatch_glEnableVariantClientStateEXT1(int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableVertexAttribAPPLE}(GLuint index, GLenum pname); </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code>   */
  public void glEnableVertexAttribAPPLE(int index, int pname)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEnableVertexAttribAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEnableVertexAttribAPPLE\" not available");
    }
        dispatch_glEnableVertexAttribAPPLE1(index, pname, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableVertexAttribAPPLE}(GLuint index, GLenum pname); </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code>   */
  public native void dispatch_glEnableVertexAttribAPPLE1(int index, int pname, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableVertexAttribArray}(GLuint index); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glEnableVertexAttribArray(int index)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEnableVertexAttribArray;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEnableVertexAttribArray\" not available");
    }
        dispatch_glEnableVertexAttribArray1(index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableVertexAttribArray}(GLuint index); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glEnableVertexAttribArray1(int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableVertexAttribArrayARB}(GLuint index); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glEnableVertexAttribArrayARB(int index)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEnableVertexAttribArrayARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEnableVertexAttribArrayARB\" not available");
    }
        dispatch_glEnableVertexAttribArrayARB1(index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableVertexAttribArrayARB}(GLuint index); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public native void dispatch_glEnableVertexAttribArrayARB1(int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnablei}(GLenum target, GLuint index); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glEnablei(int target, int index)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEnablei;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEnablei\" not available");
    }
        dispatch_glEnablei1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnablei}(GLenum target, GLuint index); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public native void dispatch_glEnablei1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnd}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glEnd()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEnd;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEnd\" not available");
    }
        dispatch_glEnd1(__addr_);
    inBeginEndPair = false;
  }

  /** Entry point to C language function: <code> void {@native glEnd}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  private native void dispatch_glEnd1(long procAddress);

  /** Entry point to C language function: <code> void {@native glEndConditionalRender}(void); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_NV_conditional_render</code>   */
  public void glEndConditionalRender()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEndConditionalRender;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEndConditionalRender\" not available");
    }
        dispatch_glEndConditionalRender1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndConditionalRender}(void); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_NV_conditional_render</code>   */
  public native void dispatch_glEndConditionalRender1(long procAddress);

  /** Entry point to C language function: <code> void {@native glEndList}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glEndList()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEndList;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEndList\" not available");
    }
        dispatch_glEndList1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndList}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glEndList1(long procAddress);

  /** Entry point to C language function: <code> void {@native glEndOcclusionQueryNV}(void); </code> <br>Part of <code>GL_NV_occlusion_query</code>   */
  public void glEndOcclusionQueryNV()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEndOcclusionQueryNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEndOcclusionQueryNV\" not available");
    }
        dispatch_glEndOcclusionQueryNV1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndOcclusionQueryNV}(void); </code> <br>Part of <code>GL_NV_occlusion_query</code>   */
  public native void dispatch_glEndOcclusionQueryNV1(long procAddress);

  /** Entry point to C language function: <code> void {@native glEndPerfMonitorAMD}(GLuint monitor); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glEndPerfMonitorAMD(int monitor)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEndPerfMonitorAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEndPerfMonitorAMD\" not available");
    }
        dispatch_glEndPerfMonitorAMD1(monitor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndPerfMonitorAMD}(GLuint monitor); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public native void dispatch_glEndPerfMonitorAMD1(int monitor, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndQuery}(GLenum target); </code> <br>Part of <code>GL_VERSION_1_5</code>   */
  public void glEndQuery(int target)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEndQuery;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEndQuery\" not available");
    }
        dispatch_glEndQuery1(target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndQuery}(GLenum target); </code> <br>Part of <code>GL_VERSION_1_5</code>   */
  public native void dispatch_glEndQuery1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndQueryIndexed}(GLenum target, GLuint index); </code> <br>Part of <code>GL_ARB_transform_feedback3</code>   */
  public void glEndQueryIndexed(int target, int index)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEndQueryIndexed;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEndQueryIndexed\" not available");
    }
        dispatch_glEndQueryIndexed1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndQueryIndexed}(GLenum target, GLuint index); </code> <br>Part of <code>GL_ARB_transform_feedback3</code>   */
  public native void dispatch_glEndQueryIndexed1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndTransformFeedback}(void); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_transform_feedback</code>   */
  public void glEndTransformFeedback()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEndTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEndTransformFeedback\" not available");
    }
        dispatch_glEndTransformFeedback1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndTransformFeedback}(void); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_transform_feedback</code>   */
  public native void dispatch_glEndTransformFeedback1(long procAddress);

  /** Entry point to C language function: <code> void {@native glEndVertexShaderEXT}(void); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glEndVertexShaderEXT()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEndVertexShaderEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEndVertexShaderEXT\" not available");
    }
        dispatch_glEndVertexShaderEXT1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndVertexShaderEXT}(void); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public native void dispatch_glEndVertexShaderEXT1(long procAddress);

  /** Entry point to C language function: <code> void {@native glEndVideoCaptureNV}(GLuint video_capture_slot); </code> <br>Part of <code>GL_NV_video_capture</code>   */
  public void glEndVideoCaptureNV(int video_capture_slot)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEndVideoCaptureNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEndVideoCaptureNV\" not available");
    }
        dispatch_glEndVideoCaptureNV1(video_capture_slot, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndVideoCaptureNV}(GLuint video_capture_slot); </code> <br>Part of <code>GL_NV_video_capture</code>   */
  public native void dispatch_glEndVideoCaptureNV1(int video_capture_slot, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalCoord1d}(GLdouble u); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glEvalCoord1d(double u)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEvalCoord1d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEvalCoord1d\" not available");
    }
        dispatch_glEvalCoord1d1(u, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalCoord1d}(GLdouble u); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glEvalCoord1d1(double u, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalCoord1dv}(const GLdouble *  u); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param u a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glEvalCoord1dv(DoubleBuffer u)  {

    final boolean u_is_direct = Buffers.isDirect(u);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEvalCoord1dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEvalCoord1dv\" not available");
    }
        dispatch_glEvalCoord1dv1(u_is_direct ? u : Buffers.getArray(u), u_is_direct ? Buffers.getDirectBufferByteOffset(u) : Buffers.getIndirectBufferByteOffset(u), u_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalCoord1dv}(const GLdouble *  u); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param u a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glEvalCoord1dv1(Object u, int u_byte_offset, boolean u_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalCoord1dv}(const GLdouble *  u); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glEvalCoord1dv(double[] u, int u_offset)  {

    if(u != null && u.length <= u_offset)
      throw new GLException("array offset argument \"u_offset\" (" + u_offset + ") equals or exceeds array length (" + u.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEvalCoord1dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEvalCoord1dv\" not available");
    }
        dispatch_glEvalCoord1dv1(u, Buffers.SIZEOF_DOUBLE * u_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalCoord1f}(GLfloat u); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glEvalCoord1f(float u)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEvalCoord1f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEvalCoord1f\" not available");
    }
        dispatch_glEvalCoord1f1(u, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalCoord1f}(GLfloat u); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glEvalCoord1f1(float u, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalCoord1fv}(const GLfloat *  u); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param u a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glEvalCoord1fv(FloatBuffer u)  {

    final boolean u_is_direct = Buffers.isDirect(u);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEvalCoord1fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEvalCoord1fv\" not available");
    }
        dispatch_glEvalCoord1fv1(u_is_direct ? u : Buffers.getArray(u), u_is_direct ? Buffers.getDirectBufferByteOffset(u) : Buffers.getIndirectBufferByteOffset(u), u_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalCoord1fv}(const GLfloat *  u); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param u a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glEvalCoord1fv1(Object u, int u_byte_offset, boolean u_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalCoord1fv}(const GLfloat *  u); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glEvalCoord1fv(float[] u, int u_offset)  {

    if(u != null && u.length <= u_offset)
      throw new GLException("array offset argument \"u_offset\" (" + u_offset + ") equals or exceeds array length (" + u.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEvalCoord1fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEvalCoord1fv\" not available");
    }
        dispatch_glEvalCoord1fv1(u, Buffers.SIZEOF_FLOAT * u_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalCoord2d}(GLdouble u, GLdouble v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glEvalCoord2d(double u, double v)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEvalCoord2d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEvalCoord2d\" not available");
    }
        dispatch_glEvalCoord2d1(u, v, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalCoord2d}(GLdouble u, GLdouble v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glEvalCoord2d1(double u, double v, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalCoord2dv}(const GLdouble *  u); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param u a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glEvalCoord2dv(DoubleBuffer u)  {

    final boolean u_is_direct = Buffers.isDirect(u);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEvalCoord2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEvalCoord2dv\" not available");
    }
        dispatch_glEvalCoord2dv1(u_is_direct ? u : Buffers.getArray(u), u_is_direct ? Buffers.getDirectBufferByteOffset(u) : Buffers.getIndirectBufferByteOffset(u), u_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalCoord2dv}(const GLdouble *  u); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param u a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glEvalCoord2dv1(Object u, int u_byte_offset, boolean u_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalCoord2dv}(const GLdouble *  u); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glEvalCoord2dv(double[] u, int u_offset)  {

    if(u != null && u.length <= u_offset)
      throw new GLException("array offset argument \"u_offset\" (" + u_offset + ") equals or exceeds array length (" + u.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEvalCoord2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEvalCoord2dv\" not available");
    }
        dispatch_glEvalCoord2dv1(u, Buffers.SIZEOF_DOUBLE * u_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalCoord2f}(GLfloat u, GLfloat v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glEvalCoord2f(float u, float v)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEvalCoord2f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEvalCoord2f\" not available");
    }
        dispatch_glEvalCoord2f1(u, v, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalCoord2f}(GLfloat u, GLfloat v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glEvalCoord2f1(float u, float v, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalCoord2fv}(const GLfloat *  u); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param u a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glEvalCoord2fv(FloatBuffer u)  {

    final boolean u_is_direct = Buffers.isDirect(u);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEvalCoord2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEvalCoord2fv\" not available");
    }
        dispatch_glEvalCoord2fv1(u_is_direct ? u : Buffers.getArray(u), u_is_direct ? Buffers.getDirectBufferByteOffset(u) : Buffers.getIndirectBufferByteOffset(u), u_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalCoord2fv}(const GLfloat *  u); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param u a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glEvalCoord2fv1(Object u, int u_byte_offset, boolean u_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalCoord2fv}(const GLfloat *  u); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glEvalCoord2fv(float[] u, int u_offset)  {

    if(u != null && u.length <= u_offset)
      throw new GLException("array offset argument \"u_offset\" (" + u_offset + ") equals or exceeds array length (" + u.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEvalCoord2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEvalCoord2fv\" not available");
    }
        dispatch_glEvalCoord2fv1(u, Buffers.SIZEOF_FLOAT * u_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalMapsNV}(GLenum target, GLenum mode); </code> <br>Part of <code>GL_NV_evaluators</code>   */
  public void glEvalMapsNV(int target, int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEvalMapsNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEvalMapsNV\" not available");
    }
        dispatch_glEvalMapsNV1(target, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalMapsNV}(GLenum target, GLenum mode); </code> <br>Part of <code>GL_NV_evaluators</code>   */
  public native void dispatch_glEvalMapsNV1(int target, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalMesh1}(GLenum mode, GLint i1, GLint i2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glEvalMesh1(int mode, int i1, int i2)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEvalMesh1;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEvalMesh1\" not available");
    }
        dispatch_glEvalMesh11(mode, i1, i2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalMesh1}(GLenum mode, GLint i1, GLint i2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glEvalMesh11(int mode, int i1, int i2, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalMesh2}(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glEvalMesh2(int mode, int i1, int i2, int j1, int j2)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEvalMesh2;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEvalMesh2\" not available");
    }
        dispatch_glEvalMesh21(mode, i1, i2, j1, j2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalMesh2}(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glEvalMesh21(int mode, int i1, int i2, int j1, int j2, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalPoint1}(GLint i); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glEvalPoint1(int i)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEvalPoint1;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEvalPoint1\" not available");
    }
        dispatch_glEvalPoint11(i, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalPoint1}(GLint i); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glEvalPoint11(int i, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalPoint2}(GLint i, GLint j); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glEvalPoint2(int i, int j)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glEvalPoint2;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEvalPoint2\" not available");
    }
        dispatch_glEvalPoint21(i, j, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalPoint2}(GLint i, GLint j); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glEvalPoint21(int i, int j, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtractComponentEXT}(GLuint res, GLuint src, GLuint num); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glExtractComponentEXT(int res, int src, int num)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtractComponentEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtractComponentEXT\" not available");
    }
        dispatch_glExtractComponentEXT1(res, src, num, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtractComponentEXT}(GLuint res, GLuint src, GLuint num); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public native void dispatch_glExtractComponentEXT1(int res, int src, int num, long procAddress);

  /** Entry point to C language function: <code> void {@native glFeedbackBuffer}(GLsizei size, GLenum type, GLfloat *  buffer); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param buffer a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glFeedbackBuffer(int size, int type, FloatBuffer buffer)  {

    final boolean buffer_is_direct = Buffers.isDirect(buffer);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFeedbackBuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFeedbackBuffer\" not available");
    }
        dispatch_glFeedbackBuffer1(size, type, buffer_is_direct ? buffer : Buffers.getArray(buffer), buffer_is_direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), buffer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFeedbackBuffer}(GLsizei size, GLenum type, GLfloat *  buffer); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param buffer a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glFeedbackBuffer1(int size, int type, Object buffer, int buffer_byte_offset, boolean buffer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glFeedbackBuffer}(GLsizei size, GLenum type, GLfloat *  buffer); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glFeedbackBuffer(int size, int type, float[] buffer, int buffer_offset)  {

    if(buffer != null && buffer.length <= buffer_offset)
      throw new GLException("array offset argument \"buffer_offset\" (" + buffer_offset + ") equals or exceeds array length (" + buffer.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFeedbackBuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFeedbackBuffer\" not available");
    }
        dispatch_glFeedbackBuffer1(size, type, buffer, Buffers.SIZEOF_FLOAT * buffer_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLsync {@native glFenceSync}(GLenum condition, GLbitfield flags); </code> <br>Part of <code>GL_ARB_sync</code>   */
  public long glFenceSync(int condition, int flags)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFenceSync;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFenceSync\" not available");
    }
        return dispatch_glFenceSync1(condition, flags, __addr_);
  }

  /** Entry point to C language function: <code> GLsync {@native glFenceSync}(GLenum condition, GLbitfield flags); </code> <br>Part of <code>GL_ARB_sync</code>   */
  public native long dispatch_glFenceSync1(int condition, int flags, long procAddress);

  /** Entry point to C language function: <code> void {@native glFinish}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glFinish()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFinish;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFinish\" not available");
    }
        dispatch_glFinish1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glFinish}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glFinish1(long procAddress);

  /** Entry point to C language function: <code> void {@native glFinishFenceAPPLE}(GLuint fence); </code> <br>Part of <code>GL_APPLE_fence</code>   */
  public void glFinishFenceAPPLE(int fence)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFinishFenceAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFinishFenceAPPLE\" not available");
    }
        dispatch_glFinishFenceAPPLE1(fence, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFinishFenceAPPLE}(GLuint fence); </code> <br>Part of <code>GL_APPLE_fence</code>   */
  public native void dispatch_glFinishFenceAPPLE1(int fence, long procAddress);

  /** Entry point to C language function: <code> void {@native glFinishFenceNV}(GLuint fence); </code> <br>Part of <code>GL_NV_fence</code>   */
  public void glFinishFenceNV(int fence)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFinishFenceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFinishFenceNV\" not available");
    }
        dispatch_glFinishFenceNV1(fence, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFinishFenceNV}(GLuint fence); </code> <br>Part of <code>GL_NV_fence</code>   */
  public native void dispatch_glFinishFenceNV1(int fence, long procAddress);

  /** Entry point to C language function: <code> void {@native glFinishObjectAPPLE}(GLenum object, GLint name); </code> <br>Part of <code>GL_APPLE_fence</code>   */
  public void glFinishObjectAPPLE(int object, int name)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFinishObjectAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFinishObjectAPPLE\" not available");
    }
        dispatch_glFinishObjectAPPLE1(object, name, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFinishObjectAPPLE}(GLenum object, GLint name); </code> <br>Part of <code>GL_APPLE_fence</code>   */
  public native void dispatch_glFinishObjectAPPLE1(int object, int name, long procAddress);

  /** Entry point to C language function: <code> void {@native glFinishRenderAPPLE}(void); </code> <br>Part of <code>GL_APPLE_flush_render</code>   */
  public void glFinishRenderAPPLE()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFinishRenderAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFinishRenderAPPLE\" not available");
    }
        dispatch_glFinishRenderAPPLE1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glFinishRenderAPPLE}(void); </code> <br>Part of <code>GL_APPLE_flush_render</code>   */
  public native void dispatch_glFinishRenderAPPLE1(long procAddress);

  /** Entry point to C language function: <code> void {@native glFinishTextureSUNX}(void); </code> <br>Part of <code>GL_SUNX_constant_data</code>   */
  public void glFinishTextureSUNX()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFinishTextureSUNX;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFinishTextureSUNX\" not available");
    }
        dispatch_glFinishTextureSUNX1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glFinishTextureSUNX}(void); </code> <br>Part of <code>GL_SUNX_constant_data</code>   */
  public native void dispatch_glFinishTextureSUNX1(long procAddress);

  /** Entry point to C language function: <code> void {@native glFlush}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glFlush()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFlush;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFlush\" not available");
    }
        dispatch_glFlush1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glFlush}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glFlush1(long procAddress);

  /** Entry point to C language function: <code> void {@native glFlushMappedBufferRange}(GLenum target, GLintptr offset, GLsizeiptr length); </code> <br>Part of <code>GL_ARB_map_buffer_range</code>; <code>GL_APPLE_flush_buffer_range</code>   */
  public void glFlushMappedBufferRange(int target, long offset, long length)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFlushMappedBufferRange;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFlushMappedBufferRange\" not available");
    }
        dispatch_glFlushMappedBufferRange1(target, offset, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFlushMappedBufferRange}(GLenum target, GLintptr offset, GLsizeiptr length); </code> <br>Part of <code>GL_ARB_map_buffer_range</code>; <code>GL_APPLE_flush_buffer_range</code>   */
  public native void dispatch_glFlushMappedBufferRange1(int target, long offset, long length, long procAddress);

  /** Entry point to C language function: <code> void {@native glFlushMappedNamedBufferRangeEXT}(GLuint buffer, GLintptr offset, GLsizeiptr length); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glFlushMappedNamedBufferRangeEXT(int buffer, long offset, long length)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFlushMappedNamedBufferRangeEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFlushMappedNamedBufferRangeEXT\" not available");
    }
        dispatch_glFlushMappedNamedBufferRangeEXT1(buffer, offset, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFlushMappedNamedBufferRangeEXT}(GLuint buffer, GLintptr offset, GLsizeiptr length); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glFlushMappedNamedBufferRangeEXT1(int buffer, long offset, long length, long procAddress);

  /** Entry point to C language function: <code> void {@native glFlushPixelDataRangeNV}(GLenum target); </code> <br>Part of <code>GL_NV_pixel_data_range</code>   */
  public void glFlushPixelDataRangeNV(int target)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFlushPixelDataRangeNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFlushPixelDataRangeNV\" not available");
    }
        dispatch_glFlushPixelDataRangeNV1(target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFlushPixelDataRangeNV}(GLenum target); </code> <br>Part of <code>GL_NV_pixel_data_range</code>   */
  public native void dispatch_glFlushPixelDataRangeNV1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glFlushRenderAPPLE}(void); </code> <br>Part of <code>GL_APPLE_flush_render</code>   */
  public void glFlushRenderAPPLE()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFlushRenderAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFlushRenderAPPLE\" not available");
    }
        dispatch_glFlushRenderAPPLE1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glFlushRenderAPPLE}(void); </code> <br>Part of <code>GL_APPLE_flush_render</code>   */
  public native void dispatch_glFlushRenderAPPLE1(long procAddress);

  /** Entry point to C language function: <code> void {@native glFlushVertexArrayRangeAPPLE}(GLsizei length, GLvoid *  pointer); </code> <br>Part of <code>GL_APPLE_vertex_array_range</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glFlushVertexArrayRangeAPPLE(int length, Buffer pointer)  {

    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFlushVertexArrayRangeAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFlushVertexArrayRangeAPPLE\" not available");
    }
        dispatch_glFlushVertexArrayRangeAPPLE1(length, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFlushVertexArrayRangeAPPLE}(GLsizei length, GLvoid *  pointer); </code> <br>Part of <code>GL_APPLE_vertex_array_range</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glFlushVertexArrayRangeAPPLE1(int length, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glFlushVertexArrayRangeNV}(void); </code> <br>Part of <code>GL_NV_vertex_array_range</code>   */
  public void glFlushVertexArrayRangeNV()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFlushVertexArrayRangeNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFlushVertexArrayRangeNV\" not available");
    }
        dispatch_glFlushVertexArrayRangeNV1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glFlushVertexArrayRangeNV}(void); </code> <br>Part of <code>GL_NV_vertex_array_range</code>   */
  public native void dispatch_glFlushVertexArrayRangeNV1(long procAddress);

  /** Entry point to C language function: <code> void {@native glFogCoordFormatNV}(GLenum type, GLsizei stride); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public void glFogCoordFormatNV(int type, int stride)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogCoordFormatNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogCoordFormatNV\" not available");
    }
        dispatch_glFogCoordFormatNV1(type, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoordFormatNV}(GLenum type, GLsizei stride); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public native void dispatch_glFogCoordFormatNV1(int type, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogCoordPointer}(GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glFogCoordPointer(int type, int stride, Buffer pointer)  {

    checkArrayVBODisabled(true);
    Buffers.rangeCheck(pointer, 1);
    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogCoordPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogCoordPointer\" not available");
    }
        dispatch_glFogCoordPointer1(type, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoordPointer}(GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glFogCoordPointer1(int type, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogCoordPointer}(GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glFogCoordPointer(int type, int stride, long pointer_buffer_offset)  {

    checkArrayVBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogCoordPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogCoordPointer\" not available");
    }
        dispatch_glFogCoordPointer1(type, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoordPointer}(GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  private native void dispatch_glFogCoordPointer1(int type, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogCoordd}(GLdouble coord); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glFogCoordd(double coord)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogCoordd;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogCoordd\" not available");
    }
        dispatch_glFogCoordd1(coord, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoordd}(GLdouble coord); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public native void dispatch_glFogCoordd1(double coord, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogCoorddv}(const GLdouble *  coord); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param coord a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glFogCoorddv(DoubleBuffer coord)  {

    final boolean coord_is_direct = Buffers.isDirect(coord);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogCoorddv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogCoorddv\" not available");
    }
        dispatch_glFogCoorddv1(coord_is_direct ? coord : Buffers.getArray(coord), coord_is_direct ? Buffers.getDirectBufferByteOffset(coord) : Buffers.getIndirectBufferByteOffset(coord), coord_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoorddv}(const GLdouble *  coord); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param coord a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glFogCoorddv1(Object coord, int coord_byte_offset, boolean coord_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogCoorddv}(const GLdouble *  coord); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glFogCoorddv(double[] coord, int coord_offset)  {

    if(coord != null && coord.length <= coord_offset)
      throw new GLException("array offset argument \"coord_offset\" (" + coord_offset + ") equals or exceeds array length (" + coord.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogCoorddv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogCoorddv\" not available");
    }
        dispatch_glFogCoorddv1(coord, Buffers.SIZEOF_DOUBLE * coord_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoordf}(GLfloat coord); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glFogCoordf(float coord)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogCoordf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogCoordf\" not available");
    }
        dispatch_glFogCoordf1(coord, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoordf}(GLfloat coord); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public native void dispatch_glFogCoordf1(float coord, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogCoordfv}(const GLfloat *  coord); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param coord a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glFogCoordfv(FloatBuffer coord)  {

    final boolean coord_is_direct = Buffers.isDirect(coord);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogCoordfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogCoordfv\" not available");
    }
        dispatch_glFogCoordfv1(coord_is_direct ? coord : Buffers.getArray(coord), coord_is_direct ? Buffers.getDirectBufferByteOffset(coord) : Buffers.getIndirectBufferByteOffset(coord), coord_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoordfv}(const GLfloat *  coord); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param coord a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glFogCoordfv1(Object coord, int coord_byte_offset, boolean coord_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogCoordfv}(const GLfloat *  coord); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glFogCoordfv(float[] coord, int coord_offset)  {

    if(coord != null && coord.length <= coord_offset)
      throw new GLException("array offset argument \"coord_offset\" (" + coord_offset + ") equals or exceeds array length (" + coord.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogCoordfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogCoordfv\" not available");
    }
        dispatch_glFogCoordfv1(coord, Buffers.SIZEOF_FLOAT * coord_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoordhNV}(GLhalfNV fog); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glFogCoordh(short fog)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogCoordh;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogCoordh\" not available");
    }
        dispatch_glFogCoordh1(fog, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoordhNV}(GLhalfNV fog); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public native void dispatch_glFogCoordh1(short fog, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogCoordhvNV}(const GLhalfNV *  fog); </code> <br>Part of <code>GL_NV_half_float</code>
      @param fog a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glFogCoordhv(ShortBuffer fog)  {

    final boolean fog_is_direct = Buffers.isDirect(fog);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogCoordhv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogCoordhv\" not available");
    }
        dispatch_glFogCoordhv1(fog_is_direct ? fog : Buffers.getArray(fog), fog_is_direct ? Buffers.getDirectBufferByteOffset(fog) : Buffers.getIndirectBufferByteOffset(fog), fog_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoordhvNV}(const GLhalfNV *  fog); </code> <br>Part of <code>GL_NV_half_float</code>
      @param fog a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glFogCoordhv1(Object fog, int fog_byte_offset, boolean fog_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogCoordhvNV}(const GLhalfNV *  fog); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glFogCoordhv(short[] fog, int fog_offset)  {

    if(fog != null && fog.length <= fog_offset)
      throw new GLException("array offset argument \"fog_offset\" (" + fog_offset + ") equals or exceeds array length (" + fog.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogCoordhv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogCoordhv\" not available");
    }
        dispatch_glFogCoordhv1(fog, Buffers.SIZEOF_SHORT * fog_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogf}(GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glFogf(int pname, float param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogf\" not available");
    }
        dispatch_glFogf1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogf}(GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glFogf1(int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogfv}(GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glFogfv(int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogfv\" not available");
    }
        dispatch_glFogfv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogfv}(GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glFogfv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogfv}(GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glFogfv(int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogfv\" not available");
    }
        dispatch_glFogfv1(pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogi}(GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glFogi(int pname, int param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogi;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogi\" not available");
    }
        dispatch_glFogi1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogi}(GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glFogi1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogiv}(GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glFogiv(int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogiv\" not available");
    }
        dispatch_glFogiv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogiv}(GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glFogiv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogiv}(GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glFogiv(int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogiv\" not available");
    }
        dispatch_glFogiv1(pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFrameTerminatorGREMEDY}(void); </code> <br>Part of <code>GL_GREMEDY_frame_terminator</code>   */
  public void glFrameTerminatorGREMEDY()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFrameTerminatorGREMEDY;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFrameTerminatorGREMEDY\" not available");
    }
        dispatch_glFrameTerminatorGREMEDY1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glFrameTerminatorGREMEDY}(void); </code> <br>Part of <code>GL_GREMEDY_frame_terminator</code>   */
  public native void dispatch_glFrameTerminatorGREMEDY1(long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferDrawBufferEXT}(GLuint framebuffer, GLenum mode); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glFramebufferDrawBufferEXT(int framebuffer, int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferDrawBufferEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferDrawBufferEXT\" not available");
    }
        dispatch_glFramebufferDrawBufferEXT1(framebuffer, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferDrawBufferEXT}(GLuint framebuffer, GLenum mode); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glFramebufferDrawBufferEXT1(int framebuffer, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferDrawBuffersEXT}(GLuint framebuffer, GLsizei n, const GLenum *  bufs); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bufs a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glFramebufferDrawBuffersEXT(int framebuffer, int n, IntBuffer bufs)  {

    final boolean bufs_is_direct = Buffers.isDirect(bufs);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferDrawBuffersEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferDrawBuffersEXT\" not available");
    }
        dispatch_glFramebufferDrawBuffersEXT1(framebuffer, n, bufs_is_direct ? bufs : Buffers.getArray(bufs), bufs_is_direct ? Buffers.getDirectBufferByteOffset(bufs) : Buffers.getIndirectBufferByteOffset(bufs), bufs_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferDrawBuffersEXT}(GLuint framebuffer, GLsizei n, const GLenum *  bufs); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param bufs a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glFramebufferDrawBuffersEXT1(int framebuffer, int n, Object bufs, int bufs_byte_offset, boolean bufs_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferDrawBuffersEXT}(GLuint framebuffer, GLsizei n, const GLenum *  bufs); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glFramebufferDrawBuffersEXT(int framebuffer, int n, int[] bufs, int bufs_offset)  {

    if(bufs != null && bufs.length <= bufs_offset)
      throw new GLException("array offset argument \"bufs_offset\" (" + bufs_offset + ") equals or exceeds array length (" + bufs.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferDrawBuffersEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferDrawBuffersEXT\" not available");
    }
        dispatch_glFramebufferDrawBuffersEXT1(framebuffer, n, bufs, Buffers.SIZEOF_INT * bufs_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferReadBufferEXT}(GLuint framebuffer, GLenum mode); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glFramebufferReadBufferEXT(int framebuffer, int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferReadBufferEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferReadBufferEXT\" not available");
    }
        dispatch_glFramebufferReadBufferEXT1(framebuffer, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferReadBufferEXT}(GLuint framebuffer, GLenum mode); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glFramebufferReadBufferEXT1(int framebuffer, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferRenderbuffer}(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public void glFramebufferRenderbuffer(int target, int attachment, int renderbuffertarget, int renderbuffer)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferRenderbuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferRenderbuffer\" not available");
    }
        dispatch_glFramebufferRenderbuffer1(target, attachment, renderbuffertarget, renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferRenderbuffer}(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public native void dispatch_glFramebufferRenderbuffer1(int target, int attachment, int renderbuffertarget, int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture}(GLenum target, GLenum attachment, GLuint texture, GLint level); </code> <br>Part of <code>GL_VERSION_3_2</code>   */
  public void glFramebufferTexture(int target, int attachment, int texture, int level)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferTexture;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferTexture\" not available");
    }
        dispatch_glFramebufferTexture1(target, attachment, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture}(GLenum target, GLenum attachment, GLuint texture, GLint level); </code> <br>Part of <code>GL_VERSION_3_2</code>   */
  public native void dispatch_glFramebufferTexture1(int target, int attachment, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture1D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public void glFramebufferTexture1D(int target, int attachment, int textarget, int texture, int level)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferTexture1D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferTexture1D\" not available");
    }
        dispatch_glFramebufferTexture1D1(target, attachment, textarget, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture1D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public native void dispatch_glFramebufferTexture1D1(int target, int attachment, int textarget, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public void glFramebufferTexture2D(int target, int attachment, int textarget, int texture, int level)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferTexture2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferTexture2D\" not available");
    }
        dispatch_glFramebufferTexture2D1(target, attachment, textarget, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public native void dispatch_glFramebufferTexture2D1(int target, int attachment, int textarget, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture3D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public void glFramebufferTexture3D(int target, int attachment, int textarget, int texture, int level, int zoffset)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferTexture3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferTexture3D\" not available");
    }
        dispatch_glFramebufferTexture3D1(target, attachment, textarget, texture, level, zoffset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture3D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public native void dispatch_glFramebufferTexture3D1(int target, int attachment, int textarget, int texture, int level, int zoffset, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTextureARB}(GLenum target, GLenum attachment, GLuint texture, GLint level); </code> <br>Part of <code>GL_ARB_geometry_shader4</code>   */
  public void glFramebufferTextureARB(int target, int attachment, int texture, int level)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferTextureARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferTextureARB\" not available");
    }
        dispatch_glFramebufferTextureARB1(target, attachment, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTextureARB}(GLenum target, GLenum attachment, GLuint texture, GLint level); </code> <br>Part of <code>GL_ARB_geometry_shader4</code>   */
  public native void dispatch_glFramebufferTextureARB1(int target, int attachment, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTextureEXT}(GLenum target, GLenum attachment, GLuint texture, GLint level); </code> <br>Part of <code>GL_NV_geometry_program4</code>   */
  public void glFramebufferTextureEXT(int target, int attachment, int texture, int level)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferTextureEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferTextureEXT\" not available");
    }
        dispatch_glFramebufferTextureEXT1(target, attachment, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTextureEXT}(GLenum target, GLenum attachment, GLuint texture, GLint level); </code> <br>Part of <code>GL_NV_geometry_program4</code>   */
  public native void dispatch_glFramebufferTextureEXT1(int target, int attachment, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTextureFaceARB}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face); </code> <br>Part of <code>GL_ARB_geometry_shader4</code>   */
  public void glFramebufferTextureFaceARB(int target, int attachment, int texture, int level, int face)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferTextureFaceARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferTextureFaceARB\" not available");
    }
        dispatch_glFramebufferTextureFaceARB1(target, attachment, texture, level, face, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTextureFaceARB}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face); </code> <br>Part of <code>GL_ARB_geometry_shader4</code>   */
  public native void dispatch_glFramebufferTextureFaceARB1(int target, int attachment, int texture, int level, int face, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTextureFaceEXT}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face); </code> <br>Part of <code>GL_NV_geometry_program4</code>   */
  public void glFramebufferTextureFaceEXT(int target, int attachment, int texture, int level, int face)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferTextureFaceEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferTextureFaceEXT\" not available");
    }
        dispatch_glFramebufferTextureFaceEXT1(target, attachment, texture, level, face, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTextureFaceEXT}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face); </code> <br>Part of <code>GL_NV_geometry_program4</code>   */
  public native void dispatch_glFramebufferTextureFaceEXT1(int target, int attachment, int texture, int level, int face, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTextureLayer}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public void glFramebufferTextureLayer(int target, int attachment, int texture, int level, int layer)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferTextureLayer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferTextureLayer\" not available");
    }
        dispatch_glFramebufferTextureLayer1(target, attachment, texture, level, layer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTextureLayer}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public native void dispatch_glFramebufferTextureLayer1(int target, int attachment, int texture, int level, int layer, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTextureLayerARB}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer); </code> <br>Part of <code>GL_ARB_geometry_shader4</code>   */
  public void glFramebufferTextureLayerARB(int target, int attachment, int texture, int level, int layer)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferTextureLayerARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferTextureLayerARB\" not available");
    }
        dispatch_glFramebufferTextureLayerARB1(target, attachment, texture, level, layer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTextureLayerARB}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer); </code> <br>Part of <code>GL_ARB_geometry_shader4</code>   */
  public native void dispatch_glFramebufferTextureLayerARB1(int target, int attachment, int texture, int level, int layer, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTextureLayerEXT}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer); </code> <br>Part of <code>GL_NV_geometry_program4</code>   */
  public void glFramebufferTextureLayerEXT(int target, int attachment, int texture, int level, int layer)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferTextureLayerEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferTextureLayerEXT\" not available");
    }
        dispatch_glFramebufferTextureLayerEXT1(target, attachment, texture, level, layer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTextureLayerEXT}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer); </code> <br>Part of <code>GL_NV_geometry_program4</code>   */
  public native void dispatch_glFramebufferTextureLayerEXT1(int target, int attachment, int texture, int level, int layer, long procAddress);

  /** Entry point to C language function: <code> void {@native glFrontFace}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glFrontFace(int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFrontFace;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFrontFace\" not available");
    }
        dispatch_glFrontFace1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFrontFace}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glFrontFace1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glFrustum}(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glFrustum(double left, double right, double bottom, double top, double near_val, double far_val)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glFrustum;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFrustum\" not available");
    }
        dispatch_glFrustum1(left, right, bottom, top, near_val, far_val, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFrustum}(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glFrustum1(double left, double right, double bottom, double top, double near_val, double far_val, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenBuffers}(GLsizei n, GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_1_5</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenBuffers(int n, IntBuffer buffers)  {

    Buffers.rangeCheck(buffers, n);
    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenBuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenBuffers\" not available");
    }
        dispatch_glGenBuffers1(n, buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenBuffers}(GLsizei n, GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_1_5</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenBuffers1(int n, Object buffers, int buffers_byte_offset, boolean buffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenBuffers}(GLsizei n, GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_1_5</code>   */
  public void glGenBuffers(int n, int[] buffers, int buffers_offset)  {

    Buffers.rangeCheck(buffers, buffers_offset, n);
    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenBuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenBuffers\" not available");
    }
        dispatch_glGenBuffers1(n, buffers, Buffers.SIZEOF_INT * buffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenFencesAPPLE}(GLsizei n, GLuint *  fences); </code> <br>Part of <code>GL_APPLE_fence</code>
      @param fences a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenFencesAPPLE(int n, IntBuffer fences)  {

    Buffers.rangeCheck(fences, n);
    final boolean fences_is_direct = Buffers.isDirect(fences);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenFencesAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenFencesAPPLE\" not available");
    }
        dispatch_glGenFencesAPPLE1(n, fences_is_direct ? fences : Buffers.getArray(fences), fences_is_direct ? Buffers.getDirectBufferByteOffset(fences) : Buffers.getIndirectBufferByteOffset(fences), fences_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenFencesAPPLE}(GLsizei n, GLuint *  fences); </code> <br>Part of <code>GL_APPLE_fence</code>
      @param fences a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenFencesAPPLE1(int n, Object fences, int fences_byte_offset, boolean fences_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenFencesAPPLE}(GLsizei n, GLuint *  fences); </code> <br>Part of <code>GL_APPLE_fence</code>   */
  public void glGenFencesAPPLE(int n, int[] fences, int fences_offset)  {

    Buffers.rangeCheck(fences, fences_offset, n);
    if(fences != null && fences.length <= fences_offset)
      throw new GLException("array offset argument \"fences_offset\" (" + fences_offset + ") equals or exceeds array length (" + fences.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenFencesAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenFencesAPPLE\" not available");
    }
        dispatch_glGenFencesAPPLE1(n, fences, Buffers.SIZEOF_INT * fences_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenFencesNV}(GLsizei n, GLuint *  fences); </code> <br>Part of <code>GL_NV_fence</code>
      @param fences a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenFencesNV(int n, IntBuffer fences)  {

    Buffers.rangeCheck(fences, n);
    final boolean fences_is_direct = Buffers.isDirect(fences);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenFencesNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenFencesNV\" not available");
    }
        dispatch_glGenFencesNV1(n, fences_is_direct ? fences : Buffers.getArray(fences), fences_is_direct ? Buffers.getDirectBufferByteOffset(fences) : Buffers.getIndirectBufferByteOffset(fences), fences_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenFencesNV}(GLsizei n, GLuint *  fences); </code> <br>Part of <code>GL_NV_fence</code>
      @param fences a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenFencesNV1(int n, Object fences, int fences_byte_offset, boolean fences_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenFencesNV}(GLsizei n, GLuint *  fences); </code> <br>Part of <code>GL_NV_fence</code>   */
  public void glGenFencesNV(int n, int[] fences, int fences_offset)  {

    Buffers.rangeCheck(fences, fences_offset, n);
    if(fences != null && fences.length <= fences_offset)
      throw new GLException("array offset argument \"fences_offset\" (" + fences_offset + ") equals or exceeds array length (" + fences.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenFencesNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenFencesNV\" not available");
    }
        dispatch_glGenFencesNV1(n, fences, Buffers.SIZEOF_INT * fences_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenFramebuffers}(GLsizei n, GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenFramebuffers(int n, IntBuffer framebuffers)  {

    final boolean framebuffers_is_direct = Buffers.isDirect(framebuffers);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenFramebuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenFramebuffers\" not available");
    }
        dispatch_glGenFramebuffers1(n, framebuffers_is_direct ? framebuffers : Buffers.getArray(framebuffers), framebuffers_is_direct ? Buffers.getDirectBufferByteOffset(framebuffers) : Buffers.getIndirectBufferByteOffset(framebuffers), framebuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenFramebuffers}(GLsizei n, GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenFramebuffers1(int n, Object framebuffers, int framebuffers_byte_offset, boolean framebuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenFramebuffers}(GLsizei n, GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public void glGenFramebuffers(int n, int[] framebuffers, int framebuffers_offset)  {

    if(framebuffers != null && framebuffers.length <= framebuffers_offset)
      throw new GLException("array offset argument \"framebuffers_offset\" (" + framebuffers_offset + ") equals or exceeds array length (" + framebuffers.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenFramebuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenFramebuffers\" not available");
    }
        dispatch_glGenFramebuffers1(n, framebuffers, Buffers.SIZEOF_INT * framebuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGenLists}(GLsizei range); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public int glGenLists(int range)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenLists;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenLists\" not available");
    }
        return dispatch_glGenLists1(range, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGenLists}(GLsizei range); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native int dispatch_glGenLists1(int range, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenNamesAMD}(GLenum identifier, GLuint num, GLuint *  names); </code> <br>Part of <code>GL_AMD_name_gen_delete</code>
      @param names a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenNamesAMD(int identifier, int num, IntBuffer names)  {

    final boolean names_is_direct = Buffers.isDirect(names);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenNamesAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenNamesAMD\" not available");
    }
        dispatch_glGenNamesAMD1(identifier, num, names_is_direct ? names : Buffers.getArray(names), names_is_direct ? Buffers.getDirectBufferByteOffset(names) : Buffers.getIndirectBufferByteOffset(names), names_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenNamesAMD}(GLenum identifier, GLuint num, GLuint *  names); </code> <br>Part of <code>GL_AMD_name_gen_delete</code>
      @param names a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenNamesAMD1(int identifier, int num, Object names, int names_byte_offset, boolean names_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenNamesAMD}(GLenum identifier, GLuint num, GLuint *  names); </code> <br>Part of <code>GL_AMD_name_gen_delete</code>   */
  public void glGenNamesAMD(int identifier, int num, int[] names, int names_offset)  {

    if(names != null && names.length <= names_offset)
      throw new GLException("array offset argument \"names_offset\" (" + names_offset + ") equals or exceeds array length (" + names.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenNamesAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenNamesAMD\" not available");
    }
        dispatch_glGenNamesAMD1(identifier, num, names, Buffers.SIZEOF_INT * names_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenOcclusionQueriesNV}(GLsizei n, GLuint *  ids); </code> <br>Part of <code>GL_NV_occlusion_query</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenOcclusionQueriesNV(int n, IntBuffer ids)  {

    Buffers.rangeCheck(ids, n);
    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenOcclusionQueriesNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenOcclusionQueriesNV\" not available");
    }
        dispatch_glGenOcclusionQueriesNV1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenOcclusionQueriesNV}(GLsizei n, GLuint *  ids); </code> <br>Part of <code>GL_NV_occlusion_query</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenOcclusionQueriesNV1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenOcclusionQueriesNV}(GLsizei n, GLuint *  ids); </code> <br>Part of <code>GL_NV_occlusion_query</code>   */
  public void glGenOcclusionQueriesNV(int n, int[] ids, int ids_offset)  {

    Buffers.rangeCheck(ids, ids_offset, n);
    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenOcclusionQueriesNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenOcclusionQueriesNV\" not available");
    }
        dispatch_glGenOcclusionQueriesNV1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenPerfMonitorsAMD}(GLsizei n, GLuint *  monitors); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param monitors a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenPerfMonitorsAMD(int n, IntBuffer monitors)  {

    final boolean monitors_is_direct = Buffers.isDirect(monitors);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenPerfMonitorsAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenPerfMonitorsAMD\" not available");
    }
        dispatch_glGenPerfMonitorsAMD1(n, monitors_is_direct ? monitors : Buffers.getArray(monitors), monitors_is_direct ? Buffers.getDirectBufferByteOffset(monitors) : Buffers.getIndirectBufferByteOffset(monitors), monitors_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenPerfMonitorsAMD}(GLsizei n, GLuint *  monitors); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param monitors a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenPerfMonitorsAMD1(int n, Object monitors, int monitors_byte_offset, boolean monitors_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenPerfMonitorsAMD}(GLsizei n, GLuint *  monitors); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glGenPerfMonitorsAMD(int n, int[] monitors, int monitors_offset)  {

    if(monitors != null && monitors.length <= monitors_offset)
      throw new GLException("array offset argument \"monitors_offset\" (" + monitors_offset + ") equals or exceeds array length (" + monitors.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenPerfMonitorsAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenPerfMonitorsAMD\" not available");
    }
        dispatch_glGenPerfMonitorsAMD1(n, monitors, Buffers.SIZEOF_INT * monitors_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenProgramPipelines}(GLsizei n, GLuint *  pipelines); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param pipelines a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenProgramPipelines(int n, IntBuffer pipelines)  {

    final boolean pipelines_is_direct = Buffers.isDirect(pipelines);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenProgramPipelines;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenProgramPipelines\" not available");
    }
        dispatch_glGenProgramPipelines1(n, pipelines_is_direct ? pipelines : Buffers.getArray(pipelines), pipelines_is_direct ? Buffers.getDirectBufferByteOffset(pipelines) : Buffers.getIndirectBufferByteOffset(pipelines), pipelines_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenProgramPipelines}(GLsizei n, GLuint *  pipelines); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param pipelines a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenProgramPipelines1(int n, Object pipelines, int pipelines_byte_offset, boolean pipelines_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenProgramPipelines}(GLsizei n, GLuint *  pipelines); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glGenProgramPipelines(int n, int[] pipelines, int pipelines_offset)  {

    if(pipelines != null && pipelines.length <= pipelines_offset)
      throw new GLException("array offset argument \"pipelines_offset\" (" + pipelines_offset + ") equals or exceeds array length (" + pipelines.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenProgramPipelines;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenProgramPipelines\" not available");
    }
        dispatch_glGenProgramPipelines1(n, pipelines, Buffers.SIZEOF_INT * pipelines_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenProgramsARB}(GLsizei n, GLuint *  programs); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param programs a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenProgramsARB(int n, IntBuffer programs)  {

    Buffers.rangeCheck(programs, n);
    final boolean programs_is_direct = Buffers.isDirect(programs);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenProgramsARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenProgramsARB\" not available");
    }
        dispatch_glGenProgramsARB1(n, programs_is_direct ? programs : Buffers.getArray(programs), programs_is_direct ? Buffers.getDirectBufferByteOffset(programs) : Buffers.getIndirectBufferByteOffset(programs), programs_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenProgramsARB}(GLsizei n, GLuint *  programs); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param programs a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenProgramsARB1(int n, Object programs, int programs_byte_offset, boolean programs_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenProgramsARB}(GLsizei n, GLuint *  programs); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glGenProgramsARB(int n, int[] programs, int programs_offset)  {

    Buffers.rangeCheck(programs, programs_offset, n);
    if(programs != null && programs.length <= programs_offset)
      throw new GLException("array offset argument \"programs_offset\" (" + programs_offset + ") equals or exceeds array length (" + programs.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenProgramsARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenProgramsARB\" not available");
    }
        dispatch_glGenProgramsARB1(n, programs, Buffers.SIZEOF_INT * programs_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenQueries}(GLsizei n, GLuint *  ids); </code> <br>Part of <code>GL_VERSION_1_5</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenQueries(int n, IntBuffer ids)  {

    Buffers.rangeCheck(ids, n);
    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenQueries;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenQueries\" not available");
    }
        dispatch_glGenQueries1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenQueries}(GLsizei n, GLuint *  ids); </code> <br>Part of <code>GL_VERSION_1_5</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenQueries1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenQueries}(GLsizei n, GLuint *  ids); </code> <br>Part of <code>GL_VERSION_1_5</code>   */
  public void glGenQueries(int n, int[] ids, int ids_offset)  {

    Buffers.rangeCheck(ids, ids_offset, n);
    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenQueries;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenQueries\" not available");
    }
        dispatch_glGenQueries1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenRenderbuffers}(GLsizei n, GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenRenderbuffers(int n, IntBuffer renderbuffers)  {

    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenRenderbuffers\" not available");
    }
        dispatch_glGenRenderbuffers1(n, renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenRenderbuffers}(GLsizei n, GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenRenderbuffers1(int n, Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenRenderbuffers}(GLsizei n, GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public void glGenRenderbuffers(int n, int[] renderbuffers, int renderbuffers_offset)  {

    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenRenderbuffers\" not available");
    }
        dispatch_glGenRenderbuffers1(n, renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenSamplers}(GLsizei count, GLuint *  samplers); </code> <br>Part of <code>GL_ARB_sampler_objects</code>
      @param samplers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenSamplers(int count, IntBuffer samplers)  {

    final boolean samplers_is_direct = Buffers.isDirect(samplers);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenSamplers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenSamplers\" not available");
    }
        dispatch_glGenSamplers1(count, samplers_is_direct ? samplers : Buffers.getArray(samplers), samplers_is_direct ? Buffers.getDirectBufferByteOffset(samplers) : Buffers.getIndirectBufferByteOffset(samplers), samplers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenSamplers}(GLsizei count, GLuint *  samplers); </code> <br>Part of <code>GL_ARB_sampler_objects</code>
      @param samplers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenSamplers1(int count, Object samplers, int samplers_byte_offset, boolean samplers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenSamplers}(GLsizei count, GLuint *  samplers); </code> <br>Part of <code>GL_ARB_sampler_objects</code>   */
  public void glGenSamplers(int count, int[] samplers, int samplers_offset)  {

    if(samplers != null && samplers.length <= samplers_offset)
      throw new GLException("array offset argument \"samplers_offset\" (" + samplers_offset + ") equals or exceeds array length (" + samplers.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenSamplers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenSamplers\" not available");
    }
        dispatch_glGenSamplers1(count, samplers, Buffers.SIZEOF_INT * samplers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGenSymbolsEXT}(GLenum datatype, GLenum storagetype, GLenum range, GLuint components); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public int glGenSymbolsEXT(int datatype, int storagetype, int range, int components)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenSymbolsEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenSymbolsEXT\" not available");
    }
        return dispatch_glGenSymbolsEXT1(datatype, storagetype, range, components, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGenSymbolsEXT}(GLenum datatype, GLenum storagetype, GLenum range, GLuint components); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public native int dispatch_glGenSymbolsEXT1(int datatype, int storagetype, int range, int components, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenTextures}(GLsizei n, GLuint *  textures); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenTextures(int n, IntBuffer textures)  {

    Buffers.rangeCheck(textures, n);
    final boolean textures_is_direct = Buffers.isDirect(textures);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenTextures;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenTextures\" not available");
    }
        dispatch_glGenTextures1(n, textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTextures}(GLsizei n, GLuint *  textures); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenTextures1(int n, Object textures, int textures_byte_offset, boolean textures_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenTextures}(GLsizei n, GLuint *  textures); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public void glGenTextures(int n, int[] textures, int textures_offset)  {

    Buffers.rangeCheck(textures, textures_offset, n);
    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenTextures;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenTextures\" not available");
    }
        dispatch_glGenTextures1(n, textures, Buffers.SIZEOF_INT * textures_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTransformFeedbacks}(GLsizei n, GLuint *  ids); </code> <br>Part of <code>GL_ARB_transform_feedback2</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenTransformFeedbacks(int n, IntBuffer ids)  {

    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenTransformFeedbacks;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenTransformFeedbacks\" not available");
    }
        dispatch_glGenTransformFeedbacks1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTransformFeedbacks}(GLsizei n, GLuint *  ids); </code> <br>Part of <code>GL_ARB_transform_feedback2</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenTransformFeedbacks1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenTransformFeedbacks}(GLsizei n, GLuint *  ids); </code> <br>Part of <code>GL_ARB_transform_feedback2</code>   */
  public void glGenTransformFeedbacks(int n, int[] ids, int ids_offset)  {

    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenTransformFeedbacks;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenTransformFeedbacks\" not available");
    }
        dispatch_glGenTransformFeedbacks1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTransformFeedbacksNV}(GLsizei n, GLuint *  ids); </code> <br>Part of <code>GL_NV_transform_feedback2</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenTransformFeedbacksNV(int n, IntBuffer ids)  {

    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenTransformFeedbacksNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenTransformFeedbacksNV\" not available");
    }
        dispatch_glGenTransformFeedbacksNV1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTransformFeedbacksNV}(GLsizei n, GLuint *  ids); </code> <br>Part of <code>GL_NV_transform_feedback2</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenTransformFeedbacksNV1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenTransformFeedbacksNV}(GLsizei n, GLuint *  ids); </code> <br>Part of <code>GL_NV_transform_feedback2</code>   */
  public void glGenTransformFeedbacksNV(int n, int[] ids, int ids_offset)  {

    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenTransformFeedbacksNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenTransformFeedbacksNV\" not available");
    }
        dispatch_glGenTransformFeedbacksNV1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenVertexArrays}(GLsizei n, GLuint *  arrays); </code> <br>Part of <code>GL_ARB_vertex_array_object</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenVertexArrays(int n, IntBuffer arrays)  {

    final boolean arrays_is_direct = Buffers.isDirect(arrays);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenVertexArrays;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenVertexArrays\" not available");
    }
        dispatch_glGenVertexArrays1(n, arrays_is_direct ? arrays : Buffers.getArray(arrays), arrays_is_direct ? Buffers.getDirectBufferByteOffset(arrays) : Buffers.getIndirectBufferByteOffset(arrays), arrays_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenVertexArrays}(GLsizei n, GLuint *  arrays); </code> <br>Part of <code>GL_ARB_vertex_array_object</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenVertexArrays1(int n, Object arrays, int arrays_byte_offset, boolean arrays_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenVertexArrays}(GLsizei n, GLuint *  arrays); </code> <br>Part of <code>GL_ARB_vertex_array_object</code>   */
  public void glGenVertexArrays(int n, int[] arrays, int arrays_offset)  {

    if(arrays != null && arrays.length <= arrays_offset)
      throw new GLException("array offset argument \"arrays_offset\" (" + arrays_offset + ") equals or exceeds array length (" + arrays.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenVertexArrays;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenVertexArrays\" not available");
    }
        dispatch_glGenVertexArrays1(n, arrays, Buffers.SIZEOF_INT * arrays_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGenVertexShadersEXT}(GLuint range); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public int glGenVertexShadersEXT(int range)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenVertexShadersEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenVertexShadersEXT\" not available");
    }
        return dispatch_glGenVertexShadersEXT1(range, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGenVertexShadersEXT}(GLuint range); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public native int dispatch_glGenVertexShadersEXT1(int range, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenerateMipmap}(GLenum target); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public void glGenerateMipmap(int target)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenerateMipmap;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenerateMipmap\" not available");
    }
        dispatch_glGenerateMipmap1(target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenerateMipmap}(GLenum target); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public native void dispatch_glGenerateMipmap1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenerateMultiTexMipmapEXT}(GLenum texunit, GLenum target); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGenerateMultiTexMipmapEXT(int texunit, int target)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenerateMultiTexMipmapEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenerateMultiTexMipmapEXT\" not available");
    }
        dispatch_glGenerateMultiTexMipmapEXT1(texunit, target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenerateMultiTexMipmapEXT}(GLenum texunit, GLenum target); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glGenerateMultiTexMipmapEXT1(int texunit, int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenerateTextureMipmapEXT}(GLuint texture, GLenum target); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGenerateTextureMipmapEXT(int texture, int target)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenerateTextureMipmapEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenerateTextureMipmapEXT\" not available");
    }
        dispatch_glGenerateTextureMipmapEXT1(texture, target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenerateTextureMipmapEXT}(GLuint texture, GLenum target); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glGenerateTextureMipmapEXT1(int texture, int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveAtomicCounterBufferiv}(GLuint program, GLuint bufferIndex, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_shader_atomic_counters</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetActiveAtomicCounterBufferiv(int program, int bufferIndex, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveAtomicCounterBufferiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveAtomicCounterBufferiv\" not available");
    }
        dispatch_glGetActiveAtomicCounterBufferiv1(program, bufferIndex, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveAtomicCounterBufferiv}(GLuint program, GLuint bufferIndex, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_shader_atomic_counters</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetActiveAtomicCounterBufferiv1(int program, int bufferIndex, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveAtomicCounterBufferiv}(GLuint program, GLuint bufferIndex, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_shader_atomic_counters</code>   */
  public void glGetActiveAtomicCounterBufferiv(int program, int bufferIndex, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveAtomicCounterBufferiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveAtomicCounterBufferiv\" not available");
    }
        dispatch_glGetActiveAtomicCounterBufferiv1(program, bufferIndex, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveAttrib}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetActiveAttrib(int program, int index, int bufSize, IntBuffer length, IntBuffer size, IntBuffer type, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean size_is_direct = Buffers.isDirect(size);
    final boolean type_is_direct = Buffers.isDirect(type);
    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveAttrib;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveAttrib\" not available");
    }
        dispatch_glGetActiveAttrib1(program, index, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, size_is_direct ? size : Buffers.getArray(size), size_is_direct ? Buffers.getDirectBufferByteOffset(size) : Buffers.getIndirectBufferByteOffset(size), size_is_direct, type_is_direct ? type : Buffers.getArray(type), type_is_direct ? Buffers.getDirectBufferByteOffset(type) : Buffers.getIndirectBufferByteOffset(type), type_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveAttrib}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetActiveAttrib1(int program, int index, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object size, int size_byte_offset, boolean size_is_direct, Object type, int type_byte_offset, boolean type_is_direct, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveAttrib}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glGetActiveAttrib(int program, int index, int bufSize, int[] length, int length_offset, int[] size, int size_offset, int[] type, int type_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(size != null && size.length <= size_offset)
      throw new GLException("array offset argument \"size_offset\" (" + size_offset + ") equals or exceeds array length (" + size.length + ")");
    if(type != null && type.length <= type_offset)
      throw new GLException("array offset argument \"type_offset\" (" + type_offset + ") equals or exceeds array length (" + type.length + ")");
    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveAttrib;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveAttrib\" not available");
    }
        dispatch_glGetActiveAttrib1(program, index, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, size, Buffers.SIZEOF_INT * size_offset, false, type, Buffers.SIZEOF_INT * type_offset, false, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveSubroutineName}(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *  length, GLchar *  name); </code> <br>Part of <code>GL_ARB_shader_subroutine</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetActiveSubroutineName(int program, int shadertype, int index, int bufsize, IntBuffer length, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveSubroutineName;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveSubroutineName\" not available");
    }
        dispatch_glGetActiveSubroutineName1(program, shadertype, index, bufsize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveSubroutineName}(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *  length, GLchar *  name); </code> <br>Part of <code>GL_ARB_shader_subroutine</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetActiveSubroutineName1(int program, int shadertype, int index, int bufsize, Object length, int length_byte_offset, boolean length_is_direct, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveSubroutineName}(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *  length, GLchar *  name); </code> <br>Part of <code>GL_ARB_shader_subroutine</code>   */
  public void glGetActiveSubroutineName(int program, int shadertype, int index, int bufsize, int[] length, int length_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveSubroutineName;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveSubroutineName\" not available");
    }
        dispatch_glGetActiveSubroutineName1(program, shadertype, index, bufsize, length, Buffers.SIZEOF_INT * length_offset, false, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveSubroutineUniformName}(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *  length, GLchar *  name); </code> <br>Part of <code>GL_ARB_shader_subroutine</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetActiveSubroutineUniformName(int program, int shadertype, int index, int bufsize, IntBuffer length, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveSubroutineUniformName;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveSubroutineUniformName\" not available");
    }
        dispatch_glGetActiveSubroutineUniformName1(program, shadertype, index, bufsize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveSubroutineUniformName}(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *  length, GLchar *  name); </code> <br>Part of <code>GL_ARB_shader_subroutine</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetActiveSubroutineUniformName1(int program, int shadertype, int index, int bufsize, Object length, int length_byte_offset, boolean length_is_direct, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveSubroutineUniformName}(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *  length, GLchar *  name); </code> <br>Part of <code>GL_ARB_shader_subroutine</code>   */
  public void glGetActiveSubroutineUniformName(int program, int shadertype, int index, int bufsize, int[] length, int length_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveSubroutineUniformName;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveSubroutineUniformName\" not available");
    }
        dispatch_glGetActiveSubroutineUniformName1(program, shadertype, index, bufsize, length, Buffers.SIZEOF_INT * length_offset, false, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveSubroutineUniformiv}(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *  values); </code> <br>Part of <code>GL_ARB_shader_subroutine</code>
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetActiveSubroutineUniformiv(int program, int shadertype, int index, int pname, IntBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveSubroutineUniformiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveSubroutineUniformiv\" not available");
    }
        dispatch_glGetActiveSubroutineUniformiv1(program, shadertype, index, pname, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveSubroutineUniformiv}(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *  values); </code> <br>Part of <code>GL_ARB_shader_subroutine</code>
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetActiveSubroutineUniformiv1(int program, int shadertype, int index, int pname, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveSubroutineUniformiv}(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *  values); </code> <br>Part of <code>GL_ARB_shader_subroutine</code>   */
  public void glGetActiveSubroutineUniformiv(int program, int shadertype, int index, int pname, int[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveSubroutineUniformiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveSubroutineUniformiv\" not available");
    }
        dispatch_glGetActiveSubroutineUniformiv1(program, shadertype, index, pname, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniform}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetActiveUniform(int program, int index, int bufSize, IntBuffer length, IntBuffer size, IntBuffer type, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean size_is_direct = Buffers.isDirect(size);
    final boolean type_is_direct = Buffers.isDirect(type);
    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveUniform;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveUniform\" not available");
    }
        dispatch_glGetActiveUniform1(program, index, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, size_is_direct ? size : Buffers.getArray(size), size_is_direct ? Buffers.getDirectBufferByteOffset(size) : Buffers.getIndirectBufferByteOffset(size), size_is_direct, type_is_direct ? type : Buffers.getArray(type), type_is_direct ? Buffers.getDirectBufferByteOffset(type) : Buffers.getIndirectBufferByteOffset(type), type_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniform}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetActiveUniform1(int program, int index, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object size, int size_byte_offset, boolean size_is_direct, Object type, int type_byte_offset, boolean type_is_direct, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniform}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glGetActiveUniform(int program, int index, int bufSize, int[] length, int length_offset, int[] size, int size_offset, int[] type, int type_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(size != null && size.length <= size_offset)
      throw new GLException("array offset argument \"size_offset\" (" + size_offset + ") equals or exceeds array length (" + size.length + ")");
    if(type != null && type.length <= type_offset)
      throw new GLException("array offset argument \"type_offset\" (" + type_offset + ") equals or exceeds array length (" + type.length + ")");
    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveUniform;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveUniform\" not available");
    }
        dispatch_glGetActiveUniform1(program, index, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, size, Buffers.SIZEOF_INT * size_offset, false, type, Buffers.SIZEOF_INT * type_offset, false, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformARB}(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *  length, GLint *  size, GLenum *  type, GLcharARB *  name); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetActiveUniformARB(int programObj, int index, int maxLength, IntBuffer length, IntBuffer size, IntBuffer type, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean size_is_direct = Buffers.isDirect(size);
    final boolean type_is_direct = Buffers.isDirect(type);
    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveUniformARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveUniformARB\" not available");
    }
        dispatch_glGetActiveUniformARB1(programObj, index, maxLength, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, size_is_direct ? size : Buffers.getArray(size), size_is_direct ? Buffers.getDirectBufferByteOffset(size) : Buffers.getIndirectBufferByteOffset(size), size_is_direct, type_is_direct ? type : Buffers.getArray(type), type_is_direct ? Buffers.getDirectBufferByteOffset(type) : Buffers.getIndirectBufferByteOffset(type), type_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformARB}(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *  length, GLint *  size, GLenum *  type, GLcharARB *  name); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetActiveUniformARB1(int programObj, int index, int maxLength, Object length, int length_byte_offset, boolean length_is_direct, Object size, int size_byte_offset, boolean size_is_direct, Object type, int type_byte_offset, boolean type_is_direct, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniformARB}(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *  length, GLint *  size, GLenum *  type, GLcharARB *  name); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glGetActiveUniformARB(int programObj, int index, int maxLength, int[] length, int length_offset, int[] size, int size_offset, int[] type, int type_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(size != null && size.length <= size_offset)
      throw new GLException("array offset argument \"size_offset\" (" + size_offset + ") equals or exceeds array length (" + size.length + ")");
    if(type != null && type.length <= type_offset)
      throw new GLException("array offset argument \"type_offset\" (" + type_offset + ") equals or exceeds array length (" + type.length + ")");
    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveUniformARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveUniformARB\" not available");
    }
        dispatch_glGetActiveUniformARB1(programObj, index, maxLength, length, Buffers.SIZEOF_INT * length_offset, false, size, Buffers.SIZEOF_INT * size_offset, false, type, Buffers.SIZEOF_INT * type_offset, false, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockName}(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *  length, GLchar *  uniformBlockName); </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param uniformBlockName a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetActiveUniformBlockName(int program, int uniformBlockIndex, int bufSize, IntBuffer length, ByteBuffer uniformBlockName)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean uniformBlockName_is_direct = Buffers.isDirect(uniformBlockName);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveUniformBlockName;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveUniformBlockName\" not available");
    }
        dispatch_glGetActiveUniformBlockName1(program, uniformBlockIndex, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, uniformBlockName_is_direct ? uniformBlockName : Buffers.getArray(uniformBlockName), uniformBlockName_is_direct ? Buffers.getDirectBufferByteOffset(uniformBlockName) : Buffers.getIndirectBufferByteOffset(uniformBlockName), uniformBlockName_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockName}(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *  length, GLchar *  uniformBlockName); </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param uniformBlockName a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetActiveUniformBlockName1(int program, int uniformBlockIndex, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object uniformBlockName, int uniformBlockName_byte_offset, boolean uniformBlockName_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockName}(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *  length, GLchar *  uniformBlockName); </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>   */
  public void glGetActiveUniformBlockName(int program, int uniformBlockIndex, int bufSize, int[] length, int length_offset, byte[] uniformBlockName, int uniformBlockName_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(uniformBlockName != null && uniformBlockName.length <= uniformBlockName_offset)
      throw new GLException("array offset argument \"uniformBlockName_offset\" (" + uniformBlockName_offset + ") equals or exceeds array length (" + uniformBlockName.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveUniformBlockName;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveUniformBlockName\" not available");
    }
        dispatch_glGetActiveUniformBlockName1(program, uniformBlockIndex, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, uniformBlockName, uniformBlockName_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockiv}(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetActiveUniformBlockiv(int program, int uniformBlockIndex, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveUniformBlockiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveUniformBlockiv\" not available");
    }
        dispatch_glGetActiveUniformBlockiv1(program, uniformBlockIndex, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockiv}(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetActiveUniformBlockiv1(int program, int uniformBlockIndex, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockiv}(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>   */
  public void glGetActiveUniformBlockiv(int program, int uniformBlockIndex, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveUniformBlockiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveUniformBlockiv\" not available");
    }
        dispatch_glGetActiveUniformBlockiv1(program, uniformBlockIndex, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformName}(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *  length, GLchar *  uniformName); </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param uniformName a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetActiveUniformName(int program, int uniformIndex, int bufSize, IntBuffer length, ByteBuffer uniformName)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean uniformName_is_direct = Buffers.isDirect(uniformName);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveUniformName;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveUniformName\" not available");
    }
        dispatch_glGetActiveUniformName1(program, uniformIndex, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, uniformName_is_direct ? uniformName : Buffers.getArray(uniformName), uniformName_is_direct ? Buffers.getDirectBufferByteOffset(uniformName) : Buffers.getIndirectBufferByteOffset(uniformName), uniformName_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformName}(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *  length, GLchar *  uniformName); </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param uniformName a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetActiveUniformName1(int program, int uniformIndex, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object uniformName, int uniformName_byte_offset, boolean uniformName_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniformName}(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *  length, GLchar *  uniformName); </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>   */
  public void glGetActiveUniformName(int program, int uniformIndex, int bufSize, int[] length, int length_offset, byte[] uniformName, int uniformName_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(uniformName != null && uniformName.length <= uniformName_offset)
      throw new GLException("array offset argument \"uniformName_offset\" (" + uniformName_offset + ") equals or exceeds array length (" + uniformName.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveUniformName;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveUniformName\" not available");
    }
        dispatch_glGetActiveUniformName1(program, uniformIndex, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, uniformName, uniformName_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformsiv}(GLuint program, GLsizei uniformCount, const GLuint *  uniformIndices, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>
      @param uniformIndices a direct or array-backed {@link java.nio.IntBuffer}
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetActiveUniformsiv(int program, int uniformCount, IntBuffer uniformIndices, int pname, IntBuffer params)  {

    final boolean uniformIndices_is_direct = Buffers.isDirect(uniformIndices);
    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveUniformsiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveUniformsiv\" not available");
    }
        dispatch_glGetActiveUniformsiv1(program, uniformCount, uniformIndices_is_direct ? uniformIndices : Buffers.getArray(uniformIndices), uniformIndices_is_direct ? Buffers.getDirectBufferByteOffset(uniformIndices) : Buffers.getIndirectBufferByteOffset(uniformIndices), uniformIndices_is_direct, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformsiv}(GLuint program, GLsizei uniformCount, const GLuint *  uniformIndices, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>
      @param uniformIndices a direct or array-backed {@link java.nio.IntBuffer}
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetActiveUniformsiv1(int program, int uniformCount, Object uniformIndices, int uniformIndices_byte_offset, boolean uniformIndices_is_direct, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniformsiv}(GLuint program, GLsizei uniformCount, const GLuint *  uniformIndices, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>   */
  public void glGetActiveUniformsiv(int program, int uniformCount, int[] uniformIndices, int uniformIndices_offset, int pname, int[] params, int params_offset)  {

    if(uniformIndices != null && uniformIndices.length <= uniformIndices_offset)
      throw new GLException("array offset argument \"uniformIndices_offset\" (" + uniformIndices_offset + ") equals or exceeds array length (" + uniformIndices.length + ")");
    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveUniformsiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveUniformsiv\" not available");
    }
        dispatch_glGetActiveUniformsiv1(program, uniformCount, uniformIndices, Buffers.SIZEOF_INT * uniformIndices_offset, false, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetAttachedObjectsARB}(GLhandleARB containerObj, GLsizei maxCount, GLsizei *  count, GLhandleARB *  obj); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param count a direct or array-backed {@link java.nio.IntBuffer}
      @param obj a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetAttachedObjectsARB(int containerObj, int maxCount, IntBuffer count, IntBuffer obj)  {

    final boolean count_is_direct = Buffers.isDirect(count);
    final boolean obj_is_direct = Buffers.isDirect(obj);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetAttachedObjectsARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetAttachedObjectsARB\" not available");
    }
        dispatch_glGetAttachedObjectsARB1(containerObj, maxCount, count_is_direct ? count : Buffers.getArray(count), count_is_direct ? Buffers.getDirectBufferByteOffset(count) : Buffers.getIndirectBufferByteOffset(count), count_is_direct, obj_is_direct ? obj : Buffers.getArray(obj), obj_is_direct ? Buffers.getDirectBufferByteOffset(obj) : Buffers.getIndirectBufferByteOffset(obj), obj_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetAttachedObjectsARB}(GLhandleARB containerObj, GLsizei maxCount, GLsizei *  count, GLhandleARB *  obj); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param count a direct or array-backed {@link java.nio.IntBuffer}
      @param obj a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetAttachedObjectsARB1(int containerObj, int maxCount, Object count, int count_byte_offset, boolean count_is_direct, Object obj, int obj_byte_offset, boolean obj_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetAttachedObjectsARB}(GLhandleARB containerObj, GLsizei maxCount, GLsizei *  count, GLhandleARB *  obj); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glGetAttachedObjectsARB(int containerObj, int maxCount, int[] count, int count_offset, int[] obj, int obj_offset)  {

    if(count != null && count.length <= count_offset)
      throw new GLException("array offset argument \"count_offset\" (" + count_offset + ") equals or exceeds array length (" + count.length + ")");
    if(obj != null && obj.length <= obj_offset)
      throw new GLException("array offset argument \"obj_offset\" (" + obj_offset + ") equals or exceeds array length (" + obj.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetAttachedObjectsARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetAttachedObjectsARB\" not available");
    }
        dispatch_glGetAttachedObjectsARB1(containerObj, maxCount, count, Buffers.SIZEOF_INT * count_offset, false, obj, Buffers.SIZEOF_INT * obj_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetAttachedShaders}(GLuint program, GLsizei maxCount, GLsizei *  count, GLuint *  obj); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param count a direct or array-backed {@link java.nio.IntBuffer}
      @param obj a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetAttachedShaders(int program, int maxCount, IntBuffer count, IntBuffer obj)  {

    final boolean count_is_direct = Buffers.isDirect(count);
    final boolean obj_is_direct = Buffers.isDirect(obj);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetAttachedShaders;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetAttachedShaders\" not available");
    }
        dispatch_glGetAttachedShaders1(program, maxCount, count_is_direct ? count : Buffers.getArray(count), count_is_direct ? Buffers.getDirectBufferByteOffset(count) : Buffers.getIndirectBufferByteOffset(count), count_is_direct, obj_is_direct ? obj : Buffers.getArray(obj), obj_is_direct ? Buffers.getDirectBufferByteOffset(obj) : Buffers.getIndirectBufferByteOffset(obj), obj_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetAttachedShaders}(GLuint program, GLsizei maxCount, GLsizei *  count, GLuint *  obj); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param count a direct or array-backed {@link java.nio.IntBuffer}
      @param obj a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetAttachedShaders1(int program, int maxCount, Object count, int count_byte_offset, boolean count_is_direct, Object obj, int obj_byte_offset, boolean obj_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetAttachedShaders}(GLuint program, GLsizei maxCount, GLsizei *  count, GLuint *  obj); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glGetAttachedShaders(int program, int maxCount, int[] count, int count_offset, int[] obj, int obj_offset)  {

    if(count != null && count.length <= count_offset)
      throw new GLException("array offset argument \"count_offset\" (" + count_offset + ") equals or exceeds array length (" + count.length + ")");
    if(obj != null && obj.length <= obj_offset)
      throw new GLException("array offset argument \"obj_offset\" (" + obj_offset + ") equals or exceeds array length (" + obj.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetAttachedShaders;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetAttachedShaders\" not available");
    }
        dispatch_glGetAttachedShaders1(program, maxCount, count, Buffers.SIZEOF_INT * count_offset, false, obj, Buffers.SIZEOF_INT * obj_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetAttribLocation}(GLuint program, const GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public int glGetAttribLocation(int program, String name)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetAttribLocation;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetAttribLocation\" not available");
    }
        return dispatch_glGetAttribLocation1(program, name, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetAttribLocation}(GLuint program, const GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native int dispatch_glGetAttribLocation1(int program, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBooleanIndexedvEXT}(GLenum target, GLuint index, GLboolean *  data); </code> <br>Part of <code>GL_EXT_draw_buffers2</code>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetBooleanIndexedv(int target, int index, ByteBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBooleanIndexedv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetBooleanIndexedv\" not available");
    }
        dispatch_glGetBooleanIndexedv1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBooleanIndexedvEXT}(GLenum target, GLuint index, GLboolean *  data); </code> <br>Part of <code>GL_EXT_draw_buffers2</code>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetBooleanIndexedv1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBooleanIndexedvEXT}(GLenum target, GLuint index, GLboolean *  data); </code> <br>Part of <code>GL_EXT_draw_buffers2</code>   */
  public void glGetBooleanIndexedv(int target, int index, byte[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBooleanIndexedv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetBooleanIndexedv\" not available");
    }
        dispatch_glGetBooleanIndexedv1(target, index, data, data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBooleani_v}(GLenum target, GLuint index, GLboolean *  data); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetBooleani_v(int target, int index, ByteBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBooleani_v;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetBooleani_v\" not available");
    }
        dispatch_glGetBooleani_v1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBooleani_v}(GLenum target, GLuint index, GLboolean *  data); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetBooleani_v1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBooleani_v}(GLenum target, GLuint index, GLboolean *  data); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glGetBooleani_v(int target, int index, byte[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBooleani_v;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetBooleani_v\" not available");
    }
        dispatch_glGetBooleani_v1(target, index, data, data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBooleanv}(GLenum pname, GLboolean *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetBooleanv(int pname, ByteBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBooleanv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetBooleanv\" not available");
    }
        dispatch_glGetBooleanv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBooleanv}(GLenum pname, GLboolean *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetBooleanv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBooleanv}(GLenum pname, GLboolean *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetBooleanv(int pname, byte[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBooleanv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetBooleanv\" not available");
    }
        dispatch_glGetBooleanv1(pname, params, params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameteri64v}(GLenum target, GLenum pname, GLint64 *  params); </code> <br>Part of <code>GL_VERSION_3_2</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetBufferParameteri64v(int target, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBufferParameteri64v;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetBufferParameteri64v\" not available");
    }
        dispatch_glGetBufferParameteri64v1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameteri64v}(GLenum target, GLenum pname, GLint64 *  params); </code> <br>Part of <code>GL_VERSION_3_2</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetBufferParameteri64v1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBufferParameteri64v}(GLenum target, GLenum pname, GLint64 *  params); </code> <br>Part of <code>GL_VERSION_3_2</code>   */
  public void glGetBufferParameteri64v(int target, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBufferParameteri64v;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetBufferParameteri64v\" not available");
    }
        dispatch_glGetBufferParameteri64v1(target, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_5</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetBufferParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetBufferParameteriv\" not available");
    }
        dispatch_glGetBufferParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_5</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetBufferParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBufferParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_5</code>   */
  public void glGetBufferParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetBufferParameteriv\" not available");
    }
        dispatch_glGetBufferParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameterui64vNV}(GLenum target, GLenum pname, GLuint64EXT *  params); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetBufferParameterui64vNV(int target, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBufferParameterui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetBufferParameterui64vNV\" not available");
    }
        dispatch_glGetBufferParameterui64vNV1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameterui64vNV}(GLenum target, GLenum pname, GLuint64EXT *  params); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetBufferParameterui64vNV1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBufferParameterui64vNV}(GLenum target, GLenum pname, GLuint64EXT *  params); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>   */
  public void glGetBufferParameterui64vNV(int target, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBufferParameterui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetBufferParameterui64vNV\" not available");
    }
        dispatch_glGetBufferParameterui64vNV1(target, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferSubData}(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_5</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetBufferSubData(int target, long offset, long size, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBufferSubData;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetBufferSubData\" not available");
    }
        dispatch_glGetBufferSubData1(target, offset, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferSubData}(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_5</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetBufferSubData1(int target, long offset, long size, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetClipPlane}(GLenum plane, GLdouble *  equation); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param equation a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetClipPlane(int plane, DoubleBuffer equation)  {

    final boolean equation_is_direct = Buffers.isDirect(equation);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetClipPlane;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetClipPlane\" not available");
    }
        dispatch_glGetClipPlane1(plane, equation_is_direct ? equation : Buffers.getArray(equation), equation_is_direct ? Buffers.getDirectBufferByteOffset(equation) : Buffers.getIndirectBufferByteOffset(equation), equation_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetClipPlane}(GLenum plane, GLdouble *  equation); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param equation a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetClipPlane1(int plane, Object equation, int equation_byte_offset, boolean equation_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetClipPlane}(GLenum plane, GLdouble *  equation); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetClipPlane(int plane, double[] equation, int equation_offset)  {

    if(equation != null && equation.length <= equation_offset)
      throw new GLException("array offset argument \"equation_offset\" (" + equation_offset + ") equals or exceeds array length (" + equation.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetClipPlane;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetClipPlane\" not available");
    }
        dispatch_glGetClipPlane1(plane, equation, Buffers.SIZEOF_DOUBLE * equation_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetColorTable}(GLenum target, GLenum format, GLenum type, GLvoid *  table); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param table a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetColorTable(int target, int format, int type, Buffer table)  {

    checkPackPBODisabled(true);
    final boolean table_is_direct = Buffers.isDirect(table);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetColorTable;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetColorTable\" not available");
    }
        dispatch_glGetColorTable1(target, format, type, table_is_direct ? table : Buffers.getArray(table), table_is_direct ? Buffers.getDirectBufferByteOffset(table) : Buffers.getIndirectBufferByteOffset(table), table_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetColorTable}(GLenum target, GLenum format, GLenum type, GLvoid *  table); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param table a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetColorTable1(int target, int format, int type, Object table, int table_byte_offset, boolean table_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetColorTable}(GLenum target, GLenum format, GLenum type, GLvoid *  table); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glGetColorTable(int target, int format, int type, long table_buffer_offset)  {

    checkPackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetColorTable;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetColorTable\" not available");
    }
        dispatch_glGetColorTable1(target, format, type, table_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetColorTable}(GLenum target, GLenum format, GLenum type, GLvoid *  table); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  private native void dispatch_glGetColorTable1(int target, int format, int type, long table_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetColorTableParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetColorTableParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetColorTableParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetColorTableParameterfv\" not available");
    }
        dispatch_glGetColorTableParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetColorTableParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetColorTableParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetColorTableParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glGetColorTableParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetColorTableParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetColorTableParameterfv\" not available");
    }
        dispatch_glGetColorTableParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetColorTableParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetColorTableParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetColorTableParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetColorTableParameteriv\" not available");
    }
        dispatch_glGetColorTableParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetColorTableParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetColorTableParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetColorTableParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glGetColorTableParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetColorTableParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetColorTableParameteriv\" not available");
    }
        dispatch_glGetColorTableParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetCompressedMultiTexImageEXT}(GLenum texunit, GLenum target, GLint lod, GLvoid *  img); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param img a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetCompressedMultiTexImageEXT(int texunit, int target, int lod, Buffer img)  {

    final boolean img_is_direct = Buffers.isDirect(img);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetCompressedMultiTexImageEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetCompressedMultiTexImageEXT\" not available");
    }
        dispatch_glGetCompressedMultiTexImageEXT1(texunit, target, lod, img_is_direct ? img : Buffers.getArray(img), img_is_direct ? Buffers.getDirectBufferByteOffset(img) : Buffers.getIndirectBufferByteOffset(img), img_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetCompressedMultiTexImageEXT}(GLenum texunit, GLenum target, GLint lod, GLvoid *  img); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param img a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetCompressedMultiTexImageEXT1(int texunit, int target, int lod, Object img, int img_byte_offset, boolean img_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetCompressedTexImage}(GLenum target, GLint level, GLvoid *  img); </code> <br>Part of <code>GL_VERSION_1_3</code>
      @param img a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetCompressedTexImage(int target, int level, Buffer img)  {

    checkPackPBODisabled(true);
    final boolean img_is_direct = Buffers.isDirect(img);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetCompressedTexImage;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetCompressedTexImage\" not available");
    }
        dispatch_glGetCompressedTexImage1(target, level, img_is_direct ? img : Buffers.getArray(img), img_is_direct ? Buffers.getDirectBufferByteOffset(img) : Buffers.getIndirectBufferByteOffset(img), img_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetCompressedTexImage}(GLenum target, GLint level, GLvoid *  img); </code> <br>Part of <code>GL_VERSION_1_3</code>
      @param img a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetCompressedTexImage1(int target, int level, Object img, int img_byte_offset, boolean img_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetCompressedTexImage}(GLenum target, GLint level, GLvoid *  img); </code> <br>Part of <code>GL_VERSION_1_3</code>   */
  public void glGetCompressedTexImage(int target, int level, long img_buffer_offset)  {

    checkPackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetCompressedTexImage;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetCompressedTexImage\" not available");
    }
        dispatch_glGetCompressedTexImage1(target, level, img_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetCompressedTexImage}(GLenum target, GLint level, GLvoid *  img); </code> <br>Part of <code>GL_VERSION_1_3</code>   */
  private native void dispatch_glGetCompressedTexImage1(int target, int level, long img_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetCompressedTextureImageEXT}(GLuint texture, GLenum target, GLint lod, GLvoid *  img); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param img a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetCompressedTextureImageEXT(int texture, int target, int lod, Buffer img)  {

    final boolean img_is_direct = Buffers.isDirect(img);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetCompressedTextureImageEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetCompressedTextureImageEXT\" not available");
    }
        dispatch_glGetCompressedTextureImageEXT1(texture, target, lod, img_is_direct ? img : Buffers.getArray(img), img_is_direct ? Buffers.getDirectBufferByteOffset(img) : Buffers.getIndirectBufferByteOffset(img), img_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetCompressedTextureImageEXT}(GLuint texture, GLenum target, GLint lod, GLvoid *  img); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param img a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetCompressedTextureImageEXT1(int texture, int target, int lod, Object img, int img_byte_offset, boolean img_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetConvolutionFilter}(GLenum target, GLenum format, GLenum type, GLvoid *  image); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param image a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetConvolutionFilter(int target, int format, int type, Buffer image)  {

    checkPackPBODisabled(true);
    final boolean image_is_direct = Buffers.isDirect(image);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetConvolutionFilter;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetConvolutionFilter\" not available");
    }
        dispatch_glGetConvolutionFilter1(target, format, type, image_is_direct ? image : Buffers.getArray(image), image_is_direct ? Buffers.getDirectBufferByteOffset(image) : Buffers.getIndirectBufferByteOffset(image), image_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetConvolutionFilter}(GLenum target, GLenum format, GLenum type, GLvoid *  image); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param image a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetConvolutionFilter1(int target, int format, int type, Object image, int image_byte_offset, boolean image_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetConvolutionFilter}(GLenum target, GLenum format, GLenum type, GLvoid *  image); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glGetConvolutionFilter(int target, int format, int type, long image_buffer_offset)  {

    checkPackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetConvolutionFilter;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetConvolutionFilter\" not available");
    }
        dispatch_glGetConvolutionFilter1(target, format, type, image_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetConvolutionFilter}(GLenum target, GLenum format, GLenum type, GLvoid *  image); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  private native void dispatch_glGetConvolutionFilter1(int target, int format, int type, long image_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetConvolutionParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetConvolutionParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetConvolutionParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetConvolutionParameterfv\" not available");
    }
        dispatch_glGetConvolutionParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetConvolutionParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetConvolutionParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetConvolutionParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glGetConvolutionParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetConvolutionParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetConvolutionParameterfv\" not available");
    }
        dispatch_glGetConvolutionParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetConvolutionParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetConvolutionParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetConvolutionParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetConvolutionParameteriv\" not available");
    }
        dispatch_glGetConvolutionParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetConvolutionParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetConvolutionParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetConvolutionParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glGetConvolutionParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetConvolutionParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetConvolutionParameteriv\" not available");
    }
        dispatch_glGetConvolutionParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGetDebugMessageLogAMD}(GLuint count, GLsizei bufsize, GLenum *  categories, GLuint *  severities, GLuint *  ids, GLsizei *  lengths, GLchar *  message); </code> <br>Part of <code>GL_AMD_debug_output</code>
      @param categories a direct or array-backed {@link java.nio.IntBuffer}
      @param severities a direct or array-backed {@link java.nio.IntBuffer}
      @param ids a direct or array-backed {@link java.nio.IntBuffer}
      @param lengths a direct or array-backed {@link java.nio.IntBuffer}
      @param message a direct or array-backed {@link java.nio.ByteBuffer}   */
  public int glGetDebugMessageLogAMD(int count, int bufsize, IntBuffer categories, IntBuffer severities, IntBuffer ids, IntBuffer lengths, ByteBuffer message)  {

    final boolean categories_is_direct = Buffers.isDirect(categories);
    final boolean severities_is_direct = Buffers.isDirect(severities);
    final boolean ids_is_direct = Buffers.isDirect(ids);
    final boolean lengths_is_direct = Buffers.isDirect(lengths);
    final boolean message_is_direct = Buffers.isDirect(message);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDebugMessageLogAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetDebugMessageLogAMD\" not available");
    }
        return dispatch_glGetDebugMessageLogAMD1(count, bufsize, categories_is_direct ? categories : Buffers.getArray(categories), categories_is_direct ? Buffers.getDirectBufferByteOffset(categories) : Buffers.getIndirectBufferByteOffset(categories), categories_is_direct, severities_is_direct ? severities : Buffers.getArray(severities), severities_is_direct ? Buffers.getDirectBufferByteOffset(severities) : Buffers.getIndirectBufferByteOffset(severities), severities_is_direct, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, lengths_is_direct ? lengths : Buffers.getArray(lengths), lengths_is_direct ? Buffers.getDirectBufferByteOffset(lengths) : Buffers.getIndirectBufferByteOffset(lengths), lengths_is_direct, message_is_direct ? message : Buffers.getArray(message), message_is_direct ? Buffers.getDirectBufferByteOffset(message) : Buffers.getIndirectBufferByteOffset(message), message_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGetDebugMessageLogAMD}(GLuint count, GLsizei bufsize, GLenum *  categories, GLuint *  severities, GLuint *  ids, GLsizei *  lengths, GLchar *  message); </code> <br>Part of <code>GL_AMD_debug_output</code>
      @param categories a direct or array-backed {@link java.nio.IntBuffer}
      @param severities a direct or array-backed {@link java.nio.IntBuffer}
      @param ids a direct or array-backed {@link java.nio.IntBuffer}
      @param lengths a direct or array-backed {@link java.nio.IntBuffer}
      @param message a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native int dispatch_glGetDebugMessageLogAMD1(int count, int bufsize, Object categories, int categories_byte_offset, boolean categories_is_direct, Object severities, int severities_byte_offset, boolean severities_is_direct, Object ids, int ids_byte_offset, boolean ids_is_direct, Object lengths, int lengths_byte_offset, boolean lengths_is_direct, Object message, int message_byte_offset, boolean message_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glGetDebugMessageLogAMD}(GLuint count, GLsizei bufsize, GLenum *  categories, GLuint *  severities, GLuint *  ids, GLsizei *  lengths, GLchar *  message); </code> <br>Part of <code>GL_AMD_debug_output</code>   */
  public int glGetDebugMessageLogAMD(int count, int bufsize, int[] categories, int categories_offset, int[] severities, int severities_offset, int[] ids, int ids_offset, int[] lengths, int lengths_offset, byte[] message, int message_offset)  {

    if(categories != null && categories.length <= categories_offset)
      throw new GLException("array offset argument \"categories_offset\" (" + categories_offset + ") equals or exceeds array length (" + categories.length + ")");
    if(severities != null && severities.length <= severities_offset)
      throw new GLException("array offset argument \"severities_offset\" (" + severities_offset + ") equals or exceeds array length (" + severities.length + ")");
    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    if(lengths != null && lengths.length <= lengths_offset)
      throw new GLException("array offset argument \"lengths_offset\" (" + lengths_offset + ") equals or exceeds array length (" + lengths.length + ")");
    if(message != null && message.length <= message_offset)
      throw new GLException("array offset argument \"message_offset\" (" + message_offset + ") equals or exceeds array length (" + message.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDebugMessageLogAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetDebugMessageLogAMD\" not available");
    }
        return dispatch_glGetDebugMessageLogAMD1(count, bufsize, categories, Buffers.SIZEOF_INT * categories_offset, false, severities, Buffers.SIZEOF_INT * severities_offset, false, ids, Buffers.SIZEOF_INT * ids_offset, false, lengths, Buffers.SIZEOF_INT * lengths_offset, false, message, message_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGetDebugMessageLogARB}(GLuint count, GLsizei bufsize, GLenum *  sources, GLenum *  types, GLuint *  ids, GLenum *  severities, GLsizei *  lengths, GLchar *  messageLog); </code> <br>Part of <code>GL_ARB_debug_output</code>
      @param sources a direct or array-backed {@link java.nio.IntBuffer}
      @param types a direct or array-backed {@link java.nio.IntBuffer}
      @param ids a direct or array-backed {@link java.nio.IntBuffer}
      @param severities a direct or array-backed {@link java.nio.IntBuffer}
      @param lengths a direct or array-backed {@link java.nio.IntBuffer}
      @param messageLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  public int glGetDebugMessageLogARB(int count, int bufsize, IntBuffer sources, IntBuffer types, IntBuffer ids, IntBuffer severities, IntBuffer lengths, ByteBuffer messageLog)  {

    final boolean sources_is_direct = Buffers.isDirect(sources);
    final boolean types_is_direct = Buffers.isDirect(types);
    final boolean ids_is_direct = Buffers.isDirect(ids);
    final boolean severities_is_direct = Buffers.isDirect(severities);
    final boolean lengths_is_direct = Buffers.isDirect(lengths);
    final boolean messageLog_is_direct = Buffers.isDirect(messageLog);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDebugMessageLogARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetDebugMessageLogARB\" not available");
    }
        return dispatch_glGetDebugMessageLogARB1(count, bufsize, sources_is_direct ? sources : Buffers.getArray(sources), sources_is_direct ? Buffers.getDirectBufferByteOffset(sources) : Buffers.getIndirectBufferByteOffset(sources), sources_is_direct, types_is_direct ? types : Buffers.getArray(types), types_is_direct ? Buffers.getDirectBufferByteOffset(types) : Buffers.getIndirectBufferByteOffset(types), types_is_direct, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, severities_is_direct ? severities : Buffers.getArray(severities), severities_is_direct ? Buffers.getDirectBufferByteOffset(severities) : Buffers.getIndirectBufferByteOffset(severities), severities_is_direct, lengths_is_direct ? lengths : Buffers.getArray(lengths), lengths_is_direct ? Buffers.getDirectBufferByteOffset(lengths) : Buffers.getIndirectBufferByteOffset(lengths), lengths_is_direct, messageLog_is_direct ? messageLog : Buffers.getArray(messageLog), messageLog_is_direct ? Buffers.getDirectBufferByteOffset(messageLog) : Buffers.getIndirectBufferByteOffset(messageLog), messageLog_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGetDebugMessageLogARB}(GLuint count, GLsizei bufsize, GLenum *  sources, GLenum *  types, GLuint *  ids, GLenum *  severities, GLsizei *  lengths, GLchar *  messageLog); </code> <br>Part of <code>GL_ARB_debug_output</code>
      @param sources a direct or array-backed {@link java.nio.IntBuffer}
      @param types a direct or array-backed {@link java.nio.IntBuffer}
      @param ids a direct or array-backed {@link java.nio.IntBuffer}
      @param severities a direct or array-backed {@link java.nio.IntBuffer}
      @param lengths a direct or array-backed {@link java.nio.IntBuffer}
      @param messageLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native int dispatch_glGetDebugMessageLogARB1(int count, int bufsize, Object sources, int sources_byte_offset, boolean sources_is_direct, Object types, int types_byte_offset, boolean types_is_direct, Object ids, int ids_byte_offset, boolean ids_is_direct, Object severities, int severities_byte_offset, boolean severities_is_direct, Object lengths, int lengths_byte_offset, boolean lengths_is_direct, Object messageLog, int messageLog_byte_offset, boolean messageLog_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glGetDebugMessageLogARB}(GLuint count, GLsizei bufsize, GLenum *  sources, GLenum *  types, GLuint *  ids, GLenum *  severities, GLsizei *  lengths, GLchar *  messageLog); </code> <br>Part of <code>GL_ARB_debug_output</code>   */
  public int glGetDebugMessageLogARB(int count, int bufsize, int[] sources, int sources_offset, int[] types, int types_offset, int[] ids, int ids_offset, int[] severities, int severities_offset, int[] lengths, int lengths_offset, byte[] messageLog, int messageLog_offset)  {

    if(sources != null && sources.length <= sources_offset)
      throw new GLException("array offset argument \"sources_offset\" (" + sources_offset + ") equals or exceeds array length (" + sources.length + ")");
    if(types != null && types.length <= types_offset)
      throw new GLException("array offset argument \"types_offset\" (" + types_offset + ") equals or exceeds array length (" + types.length + ")");
    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    if(severities != null && severities.length <= severities_offset)
      throw new GLException("array offset argument \"severities_offset\" (" + severities_offset + ") equals or exceeds array length (" + severities.length + ")");
    if(lengths != null && lengths.length <= lengths_offset)
      throw new GLException("array offset argument \"lengths_offset\" (" + lengths_offset + ") equals or exceeds array length (" + lengths.length + ")");
    if(messageLog != null && messageLog.length <= messageLog_offset)
      throw new GLException("array offset argument \"messageLog_offset\" (" + messageLog_offset + ") equals or exceeds array length (" + messageLog.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDebugMessageLogARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetDebugMessageLogARB\" not available");
    }
        return dispatch_glGetDebugMessageLogARB1(count, bufsize, sources, Buffers.SIZEOF_INT * sources_offset, false, types, Buffers.SIZEOF_INT * types_offset, false, ids, Buffers.SIZEOF_INT * ids_offset, false, severities, Buffers.SIZEOF_INT * severities_offset, false, lengths, Buffers.SIZEOF_INT * lengths_offset, false, messageLog, messageLog_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDoubleIndexedvEXT}(GLenum target, GLuint index, GLdouble *  data); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param data a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetDoubleIndexedvEXT(int target, int index, DoubleBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDoubleIndexedvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetDoubleIndexedvEXT\" not available");
    }
        dispatch_glGetDoubleIndexedvEXT1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDoubleIndexedvEXT}(GLenum target, GLuint index, GLdouble *  data); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param data a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetDoubleIndexedvEXT1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetDoubleIndexedvEXT}(GLenum target, GLuint index, GLdouble *  data); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetDoubleIndexedvEXT(int target, int index, double[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDoubleIndexedvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetDoubleIndexedvEXT\" not available");
    }
        dispatch_glGetDoubleIndexedvEXT1(target, index, data, Buffers.SIZEOF_DOUBLE * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDoublei_v}(GLenum target, GLuint index, GLdouble *  data); </code> <br>Part of <code>GL_ARB_viewport_array</code>
      @param data a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetDoublei_v(int target, int index, DoubleBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDoublei_v;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetDoublei_v\" not available");
    }
        dispatch_glGetDoublei_v1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDoublei_v}(GLenum target, GLuint index, GLdouble *  data); </code> <br>Part of <code>GL_ARB_viewport_array</code>
      @param data a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetDoublei_v1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetDoublei_v}(GLenum target, GLuint index, GLdouble *  data); </code> <br>Part of <code>GL_ARB_viewport_array</code>   */
  public void glGetDoublei_v(int target, int index, double[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDoublei_v;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetDoublei_v\" not available");
    }
        dispatch_glGetDoublei_v1(target, index, data, Buffers.SIZEOF_DOUBLE * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDoublev}(GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetDoublev(int pname, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDoublev;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetDoublev\" not available");
    }
        dispatch_glGetDoublev1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDoublev}(GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetDoublev1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetDoublev}(GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetDoublev(int pname, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDoublev;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetDoublev\" not available");
    }
        dispatch_glGetDoublev1(pname, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetError}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public int glGetError()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetError;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetError\" not available");
    }
        return dispatch_glGetError1(__addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetError}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native int dispatch_glGetError1(long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFenceivNV}(GLuint fence, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_fence</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetFenceivNV(int fence, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFenceivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFenceivNV\" not available");
    }
        dispatch_glGetFenceivNV1(fence, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFenceivNV}(GLuint fence, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_fence</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetFenceivNV1(int fence, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFenceivNV}(GLuint fence, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_fence</code>   */
  public void glGetFenceivNV(int fence, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFenceivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFenceivNV\" not available");
    }
        dispatch_glGetFenceivNV1(fence, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFloatIndexedvEXT}(GLenum target, GLuint index, GLfloat *  data); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetFloatIndexedvEXT(int target, int index, FloatBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFloatIndexedvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFloatIndexedvEXT\" not available");
    }
        dispatch_glGetFloatIndexedvEXT1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFloatIndexedvEXT}(GLenum target, GLuint index, GLfloat *  data); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetFloatIndexedvEXT1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFloatIndexedvEXT}(GLenum target, GLuint index, GLfloat *  data); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetFloatIndexedvEXT(int target, int index, float[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFloatIndexedvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFloatIndexedvEXT\" not available");
    }
        dispatch_glGetFloatIndexedvEXT1(target, index, data, Buffers.SIZEOF_FLOAT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFloati_v}(GLenum target, GLuint index, GLfloat *  data); </code> <br>Part of <code>GL_ARB_viewport_array</code>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetFloati_v(int target, int index, FloatBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFloati_v;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFloati_v\" not available");
    }
        dispatch_glGetFloati_v1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFloati_v}(GLenum target, GLuint index, GLfloat *  data); </code> <br>Part of <code>GL_ARB_viewport_array</code>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetFloati_v1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFloati_v}(GLenum target, GLuint index, GLfloat *  data); </code> <br>Part of <code>GL_ARB_viewport_array</code>   */
  public void glGetFloati_v(int target, int index, float[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFloati_v;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFloati_v\" not available");
    }
        dispatch_glGetFloati_v1(target, index, data, Buffers.SIZEOF_FLOAT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFloatv}(GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetFloatv(int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFloatv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFloatv\" not available");
    }
        dispatch_glGetFloatv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFloatv}(GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetFloatv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFloatv}(GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetFloatv(int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFloatv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFloatv\" not available");
    }
        dispatch_glGetFloatv1(pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetFragDataIndex}(GLuint program, const GLchar *  name); </code> <br>Part of <code>GL_ARB_blend_func_extended</code>   */
  public int glGetFragDataIndex(int program, String name)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFragDataIndex;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFragDataIndex\" not available");
    }
        return dispatch_glGetFragDataIndex1(program, name, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetFragDataIndex}(GLuint program, const GLchar *  name); </code> <br>Part of <code>GL_ARB_blend_func_extended</code>   */
  public native int dispatch_glGetFragDataIndex1(int program, String name, long procAddress);

  /** Entry point to C language function: <code> GLint {@native glGetFragDataLocation}(GLuint program, const GLchar *  name); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public int glGetFragDataLocation(int program, String name)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFragDataLocation;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFragDataLocation\" not available");
    }
        return dispatch_glGetFragDataLocation1(program, name, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetFragDataLocation}(GLuint program, const GLchar *  name); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public native int dispatch_glGetFragDataLocation1(int program, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFramebufferAttachmentParameteriv}(GLenum target, GLenum attachment, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetFramebufferAttachmentParameteriv(int target, int attachment, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFramebufferAttachmentParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFramebufferAttachmentParameteriv\" not available");
    }
        dispatch_glGetFramebufferAttachmentParameteriv1(target, attachment, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFramebufferAttachmentParameteriv}(GLenum target, GLenum attachment, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetFramebufferAttachmentParameteriv1(int target, int attachment, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFramebufferAttachmentParameteriv}(GLenum target, GLenum attachment, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public void glGetFramebufferAttachmentParameteriv(int target, int attachment, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFramebufferAttachmentParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFramebufferAttachmentParameteriv\" not available");
    }
        dispatch_glGetFramebufferAttachmentParameteriv1(target, attachment, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFramebufferParameterivEXT}(GLuint framebuffer, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetFramebufferParameterivEXT(int framebuffer, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFramebufferParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFramebufferParameterivEXT\" not available");
    }
        dispatch_glGetFramebufferParameterivEXT1(framebuffer, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFramebufferParameterivEXT}(GLuint framebuffer, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetFramebufferParameterivEXT1(int framebuffer, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFramebufferParameterivEXT}(GLuint framebuffer, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetFramebufferParameterivEXT(int framebuffer, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFramebufferParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFramebufferParameterivEXT\" not available");
    }
        dispatch_glGetFramebufferParameterivEXT1(framebuffer, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetGraphicsResetStatusARB}(void); </code> <br>Part of <code>GL_ARB_robustness</code>   */
  public int glGetGraphicsResetStatus()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetGraphicsResetStatus;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetGraphicsResetStatus\" not available");
    }
        return dispatch_glGetGraphicsResetStatus1(__addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetGraphicsResetStatusARB}(void); </code> <br>Part of <code>GL_ARB_robustness</code>   */
  public native int dispatch_glGetGraphicsResetStatus1(long procAddress);

  /** Entry point to C language function: <code> GLhandleARB {@native glGetHandleARB}(GLenum pname); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public int glGetHandleARB(int pname)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetHandleARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetHandleARB\" not available");
    }
        return dispatch_glGetHandleARB1(pname, __addr_);
  }

  /** Entry point to C language function: <code> GLhandleARB {@native glGetHandleARB}(GLenum pname); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public native int dispatch_glGetHandleARB1(int pname, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetHistogram}(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *  values); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param values a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetHistogram(int target, boolean reset, int format, int type, Buffer values)  {

    checkPackPBODisabled(true);
    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetHistogram;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetHistogram\" not available");
    }
        dispatch_glGetHistogram1(target, reset, format, type, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetHistogram}(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *  values); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param values a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetHistogram1(int target, boolean reset, int format, int type, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetHistogram}(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *  values); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glGetHistogram(int target, boolean reset, int format, int type, long values_buffer_offset)  {

    checkPackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetHistogram;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetHistogram\" not available");
    }
        dispatch_glGetHistogram1(target, reset, format, type, values_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetHistogram}(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *  values); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  private native void dispatch_glGetHistogram1(int target, boolean reset, int format, int type, long values_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetHistogramParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetHistogramParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetHistogramParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetHistogramParameterfv\" not available");
    }
        dispatch_glGetHistogramParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetHistogramParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetHistogramParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetHistogramParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glGetHistogramParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetHistogramParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetHistogramParameterfv\" not available");
    }
        dispatch_glGetHistogramParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetHistogramParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetHistogramParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetHistogramParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetHistogramParameteriv\" not available");
    }
        dispatch_glGetHistogramParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetHistogramParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetHistogramParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetHistogramParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glGetHistogramParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetHistogramParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetHistogramParameteriv\" not available");
    }
        dispatch_glGetHistogramParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInfoLogARB}(GLhandleARB obj, GLsizei maxLength, GLsizei *  length, GLcharARB *  infoLog); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetInfoLogARB(int obj, int maxLength, IntBuffer length, ByteBuffer infoLog)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean infoLog_is_direct = Buffers.isDirect(infoLog);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetInfoLogARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetInfoLogARB\" not available");
    }
        dispatch_glGetInfoLogARB1(obj, maxLength, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, infoLog_is_direct ? infoLog : Buffers.getArray(infoLog), infoLog_is_direct ? Buffers.getDirectBufferByteOffset(infoLog) : Buffers.getIndirectBufferByteOffset(infoLog), infoLog_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInfoLogARB}(GLhandleARB obj, GLsizei maxLength, GLsizei *  length, GLcharARB *  infoLog); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetInfoLogARB1(int obj, int maxLength, Object length, int length_byte_offset, boolean length_is_direct, Object infoLog, int infoLog_byte_offset, boolean infoLog_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInfoLogARB}(GLhandleARB obj, GLsizei maxLength, GLsizei *  length, GLcharARB *  infoLog); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glGetInfoLogARB(int obj, int maxLength, int[] length, int length_offset, byte[] infoLog, int infoLog_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(infoLog != null && infoLog.length <= infoLog_offset)
      throw new GLException("array offset argument \"infoLog_offset\" (" + infoLog_offset + ") equals or exceeds array length (" + infoLog.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetInfoLogARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetInfoLogARB\" not available");
    }
        dispatch_glGetInfoLogARB1(obj, maxLength, length, Buffers.SIZEOF_INT * length_offset, false, infoLog, infoLog_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInteger64i_v}(GLenum target, GLuint index, GLint64 *  data); </code> <br>Part of <code>GL_VERSION_3_2</code>
      @param data a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetInteger64i_v(int target, int index, LongBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetInteger64i_v;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetInteger64i_v\" not available");
    }
        dispatch_glGetInteger64i_v1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInteger64i_v}(GLenum target, GLuint index, GLint64 *  data); </code> <br>Part of <code>GL_VERSION_3_2</code>
      @param data a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetInteger64i_v1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInteger64i_v}(GLenum target, GLuint index, GLint64 *  data); </code> <br>Part of <code>GL_VERSION_3_2</code>   */
  public void glGetInteger64i_v(int target, int index, long[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetInteger64i_v;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetInteger64i_v\" not available");
    }
        dispatch_glGetInteger64i_v1(target, index, data, Buffers.SIZEOF_LONG * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInteger64v}(GLenum pname, GLint64 *  params); </code> <br>Part of <code>GL_ARB_sync</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetInteger64v(int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetInteger64v;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetInteger64v\" not available");
    }
        dispatch_glGetInteger64v1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInteger64v}(GLenum pname, GLint64 *  params); </code> <br>Part of <code>GL_ARB_sync</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetInteger64v1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInteger64v}(GLenum pname, GLint64 *  params); </code> <br>Part of <code>GL_ARB_sync</code>   */
  public void glGetInteger64v(int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetInteger64v;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetInteger64v\" not available");
    }
        dispatch_glGetInteger64v1(pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegerIndexedvEXT}(GLenum target, GLuint index, GLint *  data); </code> <br>Part of <code>GL_EXT_draw_buffers2</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetIntegerIndexedv(int target, int index, IntBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetIntegerIndexedv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetIntegerIndexedv\" not available");
    }
        dispatch_glGetIntegerIndexedv1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegerIndexedvEXT}(GLenum target, GLuint index, GLint *  data); </code> <br>Part of <code>GL_EXT_draw_buffers2</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetIntegerIndexedv1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegerIndexedvEXT}(GLenum target, GLuint index, GLint *  data); </code> <br>Part of <code>GL_EXT_draw_buffers2</code>   */
  public void glGetIntegerIndexedv(int target, int index, int[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetIntegerIndexedv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetIntegerIndexedv\" not available");
    }
        dispatch_glGetIntegerIndexedv1(target, index, data, Buffers.SIZEOF_INT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegeri_v}(GLenum target, GLuint index, GLint *  data); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetIntegeri_v(int target, int index, IntBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetIntegeri_v;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetIntegeri_v\" not available");
    }
        dispatch_glGetIntegeri_v1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegeri_v}(GLenum target, GLuint index, GLint *  data); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetIntegeri_v1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegeri_v}(GLenum target, GLuint index, GLint *  data); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glGetIntegeri_v(int target, int index, int[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetIntegeri_v;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetIntegeri_v\" not available");
    }
        dispatch_glGetIntegeri_v1(target, index, data, Buffers.SIZEOF_INT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegerui64i_vNV}(GLenum value, GLuint index, GLuint64EXT *  result); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>
      @param result a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetIntegerui64i_vNV(int value, int index, LongBuffer result)  {

    final boolean result_is_direct = Buffers.isDirect(result);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetIntegerui64i_vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetIntegerui64i_vNV\" not available");
    }
        dispatch_glGetIntegerui64i_vNV1(value, index, result_is_direct ? result : Buffers.getArray(result), result_is_direct ? Buffers.getDirectBufferByteOffset(result) : Buffers.getIndirectBufferByteOffset(result), result_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegerui64i_vNV}(GLenum value, GLuint index, GLuint64EXT *  result); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>
      @param result a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetIntegerui64i_vNV1(int value, int index, Object result, int result_byte_offset, boolean result_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegerui64i_vNV}(GLenum value, GLuint index, GLuint64EXT *  result); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public void glGetIntegerui64i_vNV(int value, int index, long[] result, int result_offset)  {

    if(result != null && result.length <= result_offset)
      throw new GLException("array offset argument \"result_offset\" (" + result_offset + ") equals or exceeds array length (" + result.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetIntegerui64i_vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetIntegerui64i_vNV\" not available");
    }
        dispatch_glGetIntegerui64i_vNV1(value, index, result, Buffers.SIZEOF_LONG * result_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegerui64vNV}(GLenum value, GLuint64EXT *  result); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>
      @param result a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetIntegerui64vNV(int value, LongBuffer result)  {

    final boolean result_is_direct = Buffers.isDirect(result);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetIntegerui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetIntegerui64vNV\" not available");
    }
        dispatch_glGetIntegerui64vNV1(value, result_is_direct ? result : Buffers.getArray(result), result_is_direct ? Buffers.getDirectBufferByteOffset(result) : Buffers.getIndirectBufferByteOffset(result), result_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegerui64vNV}(GLenum value, GLuint64EXT *  result); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>
      @param result a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetIntegerui64vNV1(int value, Object result, int result_byte_offset, boolean result_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegerui64vNV}(GLenum value, GLuint64EXT *  result); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>   */
  public void glGetIntegerui64vNV(int value, long[] result, int result_offset)  {

    if(result != null && result.length <= result_offset)
      throw new GLException("array offset argument \"result_offset\" (" + result_offset + ") equals or exceeds array length (" + result.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetIntegerui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetIntegerui64vNV\" not available");
    }
        dispatch_glGetIntegerui64vNV1(value, result, Buffers.SIZEOF_LONG * result_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegerv}(GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetIntegerv(int pname, IntBuffer params)  {

    if ( glStateTracker.getInt(pname, params, params_offset) ) { return; }
    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetIntegerv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetIntegerv\" not available");
    }
        dispatch_glGetIntegerv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegerv}(GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetIntegerv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegerv}(GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetIntegerv(int pname, int[] params, int params_offset)  {

    if ( glStateTracker.getInt(pname, params, params_offset) ) { return; }
    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetIntegerv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetIntegerv\" not available");
    }
        dispatch_glGetIntegerv1(pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInternalformativ}(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *  params); </code> <br>Part of <code>GL_ARB_internalformat_query</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetInternalformativ(int target, int internalformat, int pname, int bufSize, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetInternalformativ;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetInternalformativ\" not available");
    }
        dispatch_glGetInternalformativ1(target, internalformat, pname, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInternalformativ}(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *  params); </code> <br>Part of <code>GL_ARB_internalformat_query</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetInternalformativ1(int target, int internalformat, int pname, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInternalformativ}(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *  params); </code> <br>Part of <code>GL_ARB_internalformat_query</code>   */
  public void glGetInternalformativ(int target, int internalformat, int pname, int bufSize, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetInternalformativ;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetInternalformativ\" not available");
    }
        dispatch_glGetInternalformativ1(target, internalformat, pname, bufSize, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInvariantBooleanvEXT}(GLuint id, GLenum value, GLboolean *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetInvariantBooleanvEXT(int id, int value, ByteBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetInvariantBooleanvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetInvariantBooleanvEXT\" not available");
    }
        dispatch_glGetInvariantBooleanvEXT1(id, value, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInvariantBooleanvEXT}(GLuint id, GLenum value, GLboolean *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetInvariantBooleanvEXT1(int id, int value, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInvariantBooleanvEXT}(GLuint id, GLenum value, GLboolean *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glGetInvariantBooleanvEXT(int id, int value, byte[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetInvariantBooleanvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetInvariantBooleanvEXT\" not available");
    }
        dispatch_glGetInvariantBooleanvEXT1(id, value, data, data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInvariantFloatvEXT}(GLuint id, GLenum value, GLfloat *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetInvariantFloatvEXT(int id, int value, FloatBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetInvariantFloatvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetInvariantFloatvEXT\" not available");
    }
        dispatch_glGetInvariantFloatvEXT1(id, value, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInvariantFloatvEXT}(GLuint id, GLenum value, GLfloat *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetInvariantFloatvEXT1(int id, int value, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInvariantFloatvEXT}(GLuint id, GLenum value, GLfloat *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glGetInvariantFloatvEXT(int id, int value, float[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetInvariantFloatvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetInvariantFloatvEXT\" not available");
    }
        dispatch_glGetInvariantFloatvEXT1(id, value, data, Buffers.SIZEOF_FLOAT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInvariantIntegervEXT}(GLuint id, GLenum value, GLint *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetInvariantIntegervEXT(int id, int value, IntBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetInvariantIntegervEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetInvariantIntegervEXT\" not available");
    }
        dispatch_glGetInvariantIntegervEXT1(id, value, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInvariantIntegervEXT}(GLuint id, GLenum value, GLint *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetInvariantIntegervEXT1(int id, int value, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInvariantIntegervEXT}(GLuint id, GLenum value, GLint *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glGetInvariantIntegervEXT(int id, int value, int[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetInvariantIntegervEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetInvariantIntegervEXT\" not available");
    }
        dispatch_glGetInvariantIntegervEXT1(id, value, data, Buffers.SIZEOF_INT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLightfv}(GLenum light, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetLightfv(int light, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetLightfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetLightfv\" not available");
    }
        dispatch_glGetLightfv1(light, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLightfv}(GLenum light, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetLightfv1(int light, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetLightfv}(GLenum light, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetLightfv(int light, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetLightfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetLightfv\" not available");
    }
        dispatch_glGetLightfv1(light, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLightiv}(GLenum light, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetLightiv(int light, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetLightiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetLightiv\" not available");
    }
        dispatch_glGetLightiv1(light, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLightiv}(GLenum light, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetLightiv1(int light, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetLightiv}(GLenum light, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetLightiv(int light, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetLightiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetLightiv\" not available");
    }
        dispatch_glGetLightiv1(light, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLocalConstantBooleanvEXT}(GLuint id, GLenum value, GLboolean *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetLocalConstantBooleanvEXT(int id, int value, ByteBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetLocalConstantBooleanvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetLocalConstantBooleanvEXT\" not available");
    }
        dispatch_glGetLocalConstantBooleanvEXT1(id, value, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLocalConstantBooleanvEXT}(GLuint id, GLenum value, GLboolean *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetLocalConstantBooleanvEXT1(int id, int value, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetLocalConstantBooleanvEXT}(GLuint id, GLenum value, GLboolean *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glGetLocalConstantBooleanvEXT(int id, int value, byte[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetLocalConstantBooleanvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetLocalConstantBooleanvEXT\" not available");
    }
        dispatch_glGetLocalConstantBooleanvEXT1(id, value, data, data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLocalConstantFloatvEXT}(GLuint id, GLenum value, GLfloat *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetLocalConstantFloatvEXT(int id, int value, FloatBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetLocalConstantFloatvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetLocalConstantFloatvEXT\" not available");
    }
        dispatch_glGetLocalConstantFloatvEXT1(id, value, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLocalConstantFloatvEXT}(GLuint id, GLenum value, GLfloat *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetLocalConstantFloatvEXT1(int id, int value, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetLocalConstantFloatvEXT}(GLuint id, GLenum value, GLfloat *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glGetLocalConstantFloatvEXT(int id, int value, float[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetLocalConstantFloatvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetLocalConstantFloatvEXT\" not available");
    }
        dispatch_glGetLocalConstantFloatvEXT1(id, value, data, Buffers.SIZEOF_FLOAT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLocalConstantIntegervEXT}(GLuint id, GLenum value, GLint *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetLocalConstantIntegervEXT(int id, int value, IntBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetLocalConstantIntegervEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetLocalConstantIntegervEXT\" not available");
    }
        dispatch_glGetLocalConstantIntegervEXT1(id, value, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLocalConstantIntegervEXT}(GLuint id, GLenum value, GLint *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetLocalConstantIntegervEXT1(int id, int value, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetLocalConstantIntegervEXT}(GLuint id, GLenum value, GLint *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glGetLocalConstantIntegervEXT(int id, int value, int[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetLocalConstantIntegervEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetLocalConstantIntegervEXT\" not available");
    }
        dispatch_glGetLocalConstantIntegervEXT1(id, value, data, Buffers.SIZEOF_INT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapAttribParameterfvNV}(GLenum target, GLuint index, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_NV_evaluators</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMapAttribParameterfvNV(int target, int index, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMapAttribParameterfvNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMapAttribParameterfvNV\" not available");
    }
        dispatch_glGetMapAttribParameterfvNV1(target, index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapAttribParameterfvNV}(GLenum target, GLuint index, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_NV_evaluators</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMapAttribParameterfvNV1(int target, int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMapAttribParameterfvNV}(GLenum target, GLuint index, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_NV_evaluators</code>   */
  public void glGetMapAttribParameterfvNV(int target, int index, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMapAttribParameterfvNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMapAttribParameterfvNV\" not available");
    }
        dispatch_glGetMapAttribParameterfvNV1(target, index, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapAttribParameterivNV}(GLenum target, GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_evaluators</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMapAttribParameterivNV(int target, int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMapAttribParameterivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMapAttribParameterivNV\" not available");
    }
        dispatch_glGetMapAttribParameterivNV1(target, index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapAttribParameterivNV}(GLenum target, GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_evaluators</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMapAttribParameterivNV1(int target, int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMapAttribParameterivNV}(GLenum target, GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_evaluators</code>   */
  public void glGetMapAttribParameterivNV(int target, int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMapAttribParameterivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMapAttribParameterivNV\" not available");
    }
        dispatch_glGetMapAttribParameterivNV1(target, index, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapControlPointsNV}(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid *  points); </code> <br>Part of <code>GL_NV_evaluators</code>
      @param points a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetMapControlPointsNV(int target, int index, int type, int ustride, int vstride, boolean packed, Buffer points)  {

    final boolean points_is_direct = Buffers.isDirect(points);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMapControlPointsNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMapControlPointsNV\" not available");
    }
        dispatch_glGetMapControlPointsNV1(target, index, type, ustride, vstride, packed, points_is_direct ? points : Buffers.getArray(points), points_is_direct ? Buffers.getDirectBufferByteOffset(points) : Buffers.getIndirectBufferByteOffset(points), points_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapControlPointsNV}(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid *  points); </code> <br>Part of <code>GL_NV_evaluators</code>
      @param points a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetMapControlPointsNV1(int target, int index, int type, int ustride, int vstride, boolean packed, Object points, int points_byte_offset, boolean points_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMapParameterfvNV}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_NV_evaluators</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMapParameterfvNV(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMapParameterfvNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMapParameterfvNV\" not available");
    }
        dispatch_glGetMapParameterfvNV1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapParameterfvNV}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_NV_evaluators</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMapParameterfvNV1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMapParameterfvNV}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_NV_evaluators</code>   */
  public void glGetMapParameterfvNV(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMapParameterfvNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMapParameterfvNV\" not available");
    }
        dispatch_glGetMapParameterfvNV1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapParameterivNV}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_evaluators</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMapParameterivNV(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMapParameterivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMapParameterivNV\" not available");
    }
        dispatch_glGetMapParameterivNV1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapParameterivNV}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_evaluators</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMapParameterivNV1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMapParameterivNV}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_evaluators</code>   */
  public void glGetMapParameterivNV(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMapParameterivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMapParameterivNV\" not available");
    }
        dispatch_glGetMapParameterivNV1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapdv}(GLenum target, GLenum query, GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetMapdv(int target, int query, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMapdv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMapdv\" not available");
    }
        dispatch_glGetMapdv1(target, query, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapdv}(GLenum target, GLenum query, GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetMapdv1(int target, int query, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMapdv}(GLenum target, GLenum query, GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetMapdv(int target, int query, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMapdv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMapdv\" not available");
    }
        dispatch_glGetMapdv1(target, query, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapfv}(GLenum target, GLenum query, GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMapfv(int target, int query, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMapfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMapfv\" not available");
    }
        dispatch_glGetMapfv1(target, query, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapfv}(GLenum target, GLenum query, GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMapfv1(int target, int query, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMapfv}(GLenum target, GLenum query, GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetMapfv(int target, int query, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMapfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMapfv\" not available");
    }
        dispatch_glGetMapfv1(target, query, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapiv}(GLenum target, GLenum query, GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMapiv(int target, int query, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMapiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMapiv\" not available");
    }
        dispatch_glGetMapiv1(target, query, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapiv}(GLenum target, GLenum query, GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMapiv1(int target, int query, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMapiv}(GLenum target, GLenum query, GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetMapiv(int target, int query, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMapiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMapiv\" not available");
    }
        dispatch_glGetMapiv1(target, query, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMaterialfv}(GLenum face, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMaterialfv(int face, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMaterialfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMaterialfv\" not available");
    }
        dispatch_glGetMaterialfv1(face, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMaterialfv}(GLenum face, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMaterialfv1(int face, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMaterialfv}(GLenum face, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetMaterialfv(int face, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMaterialfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMaterialfv\" not available");
    }
        dispatch_glGetMaterialfv1(face, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMaterialiv}(GLenum face, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMaterialiv(int face, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMaterialiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMaterialiv\" not available");
    }
        dispatch_glGetMaterialiv1(face, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMaterialiv}(GLenum face, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMaterialiv1(int face, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMaterialiv}(GLenum face, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetMaterialiv(int face, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMaterialiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMaterialiv\" not available");
    }
        dispatch_glGetMaterialiv1(face, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMinmax}(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *  values); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param values a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetMinmax(int target, boolean reset, int format, int type, Buffer values)  {

    checkPackPBODisabled(true);
    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMinmax;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMinmax\" not available");
    }
        dispatch_glGetMinmax1(target, reset, format, type, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMinmax}(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *  values); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param values a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetMinmax1(int target, boolean reset, int format, int type, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMinmax}(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *  values); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glGetMinmax(int target, boolean reset, int format, int type, long values_buffer_offset)  {

    checkPackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMinmax;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMinmax\" not available");
    }
        dispatch_glGetMinmax1(target, reset, format, type, values_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMinmax}(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *  values); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  private native void dispatch_glGetMinmax1(int target, boolean reset, int format, int type, long values_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMinmaxParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMinmaxParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMinmaxParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMinmaxParameterfv\" not available");
    }
        dispatch_glGetMinmaxParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMinmaxParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMinmaxParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMinmaxParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glGetMinmaxParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMinmaxParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMinmaxParameterfv\" not available");
    }
        dispatch_glGetMinmaxParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMinmaxParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMinmaxParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMinmaxParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMinmaxParameteriv\" not available");
    }
        dispatch_glGetMinmaxParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMinmaxParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMinmaxParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMinmaxParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glGetMinmaxParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMinmaxParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMinmaxParameteriv\" not available");
    }
        dispatch_glGetMinmaxParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexEnvfvEXT}(GLenum texunit, GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMultiTexEnvfvEXT(int texunit, int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultiTexEnvfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultiTexEnvfvEXT\" not available");
    }
        dispatch_glGetMultiTexEnvfvEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexEnvfvEXT}(GLenum texunit, GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMultiTexEnvfvEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexEnvfvEXT}(GLenum texunit, GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetMultiTexEnvfvEXT(int texunit, int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultiTexEnvfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultiTexEnvfvEXT\" not available");
    }
        dispatch_glGetMultiTexEnvfvEXT1(texunit, target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexEnvivEXT}(GLenum texunit, GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMultiTexEnvivEXT(int texunit, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultiTexEnvivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultiTexEnvivEXT\" not available");
    }
        dispatch_glGetMultiTexEnvivEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexEnvivEXT}(GLenum texunit, GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMultiTexEnvivEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexEnvivEXT}(GLenum texunit, GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetMultiTexEnvivEXT(int texunit, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultiTexEnvivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultiTexEnvivEXT\" not available");
    }
        dispatch_glGetMultiTexEnvivEXT1(texunit, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexGendvEXT}(GLenum texunit, GLenum coord, GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetMultiTexGendvEXT(int texunit, int coord, int pname, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultiTexGendvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultiTexGendvEXT\" not available");
    }
        dispatch_glGetMultiTexGendvEXT1(texunit, coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexGendvEXT}(GLenum texunit, GLenum coord, GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetMultiTexGendvEXT1(int texunit, int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexGendvEXT}(GLenum texunit, GLenum coord, GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetMultiTexGendvEXT(int texunit, int coord, int pname, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultiTexGendvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultiTexGendvEXT\" not available");
    }
        dispatch_glGetMultiTexGendvEXT1(texunit, coord, pname, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexGenfvEXT}(GLenum texunit, GLenum coord, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMultiTexGenfvEXT(int texunit, int coord, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultiTexGenfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultiTexGenfvEXT\" not available");
    }
        dispatch_glGetMultiTexGenfvEXT1(texunit, coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexGenfvEXT}(GLenum texunit, GLenum coord, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMultiTexGenfvEXT1(int texunit, int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexGenfvEXT}(GLenum texunit, GLenum coord, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetMultiTexGenfvEXT(int texunit, int coord, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultiTexGenfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultiTexGenfvEXT\" not available");
    }
        dispatch_glGetMultiTexGenfvEXT1(texunit, coord, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexGenivEXT}(GLenum texunit, GLenum coord, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMultiTexGenivEXT(int texunit, int coord, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultiTexGenivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultiTexGenivEXT\" not available");
    }
        dispatch_glGetMultiTexGenivEXT1(texunit, coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexGenivEXT}(GLenum texunit, GLenum coord, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMultiTexGenivEXT1(int texunit, int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexGenivEXT}(GLenum texunit, GLenum coord, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetMultiTexGenivEXT(int texunit, int coord, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultiTexGenivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultiTexGenivEXT\" not available");
    }
        dispatch_glGetMultiTexGenivEXT1(texunit, coord, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexImageEXT}(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetMultiTexImageEXT(int texunit, int target, int level, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultiTexImageEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultiTexImageEXT\" not available");
    }
        dispatch_glGetMultiTexImageEXT1(texunit, target, level, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexImageEXT}(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetMultiTexImageEXT1(int texunit, int target, int level, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexLevelParameterfvEXT}(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMultiTexLevelParameterfvEXT(int texunit, int target, int level, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultiTexLevelParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultiTexLevelParameterfvEXT\" not available");
    }
        dispatch_glGetMultiTexLevelParameterfvEXT1(texunit, target, level, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexLevelParameterfvEXT}(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMultiTexLevelParameterfvEXT1(int texunit, int target, int level, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexLevelParameterfvEXT}(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetMultiTexLevelParameterfvEXT(int texunit, int target, int level, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultiTexLevelParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultiTexLevelParameterfvEXT\" not available");
    }
        dispatch_glGetMultiTexLevelParameterfvEXT1(texunit, target, level, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexLevelParameterivEXT}(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMultiTexLevelParameterivEXT(int texunit, int target, int level, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultiTexLevelParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultiTexLevelParameterivEXT\" not available");
    }
        dispatch_glGetMultiTexLevelParameterivEXT1(texunit, target, level, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexLevelParameterivEXT}(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMultiTexLevelParameterivEXT1(int texunit, int target, int level, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexLevelParameterivEXT}(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetMultiTexLevelParameterivEXT(int texunit, int target, int level, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultiTexLevelParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultiTexLevelParameterivEXT\" not available");
    }
        dispatch_glGetMultiTexLevelParameterivEXT1(texunit, target, level, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterIivEXT}(GLenum texunit, GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMultiTexParameterIivEXT(int texunit, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultiTexParameterIivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultiTexParameterIivEXT\" not available");
    }
        dispatch_glGetMultiTexParameterIivEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterIivEXT}(GLenum texunit, GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMultiTexParameterIivEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterIivEXT}(GLenum texunit, GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetMultiTexParameterIivEXT(int texunit, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultiTexParameterIivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultiTexParameterIivEXT\" not available");
    }
        dispatch_glGetMultiTexParameterIivEXT1(texunit, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterIuivEXT}(GLenum texunit, GLenum target, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMultiTexParameterIuivEXT(int texunit, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultiTexParameterIuivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultiTexParameterIuivEXT\" not available");
    }
        dispatch_glGetMultiTexParameterIuivEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterIuivEXT}(GLenum texunit, GLenum target, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMultiTexParameterIuivEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterIuivEXT}(GLenum texunit, GLenum target, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetMultiTexParameterIuivEXT(int texunit, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultiTexParameterIuivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultiTexParameterIuivEXT\" not available");
    }
        dispatch_glGetMultiTexParameterIuivEXT1(texunit, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterfvEXT}(GLenum texunit, GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMultiTexParameterfvEXT(int texunit, int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultiTexParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultiTexParameterfvEXT\" not available");
    }
        dispatch_glGetMultiTexParameterfvEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterfvEXT}(GLenum texunit, GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMultiTexParameterfvEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterfvEXT}(GLenum texunit, GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetMultiTexParameterfvEXT(int texunit, int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultiTexParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultiTexParameterfvEXT\" not available");
    }
        dispatch_glGetMultiTexParameterfvEXT1(texunit, target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterivEXT}(GLenum texunit, GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMultiTexParameterivEXT(int texunit, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultiTexParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultiTexParameterivEXT\" not available");
    }
        dispatch_glGetMultiTexParameterivEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterivEXT}(GLenum texunit, GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMultiTexParameterivEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterivEXT}(GLenum texunit, GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetMultiTexParameterivEXT(int texunit, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultiTexParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultiTexParameterivEXT\" not available");
    }
        dispatch_glGetMultiTexParameterivEXT1(texunit, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultisamplefv}(GLenum pname, GLuint index, GLfloat *  val); </code> <br>Part of <code>GL_ARB_texture_multisample</code>
      @param val a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMultisamplefv(int pname, int index, FloatBuffer val)  {

    final boolean val_is_direct = Buffers.isDirect(val);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultisamplefv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultisamplefv\" not available");
    }
        dispatch_glGetMultisamplefv1(pname, index, val_is_direct ? val : Buffers.getArray(val), val_is_direct ? Buffers.getDirectBufferByteOffset(val) : Buffers.getIndirectBufferByteOffset(val), val_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultisamplefv}(GLenum pname, GLuint index, GLfloat *  val); </code> <br>Part of <code>GL_ARB_texture_multisample</code>
      @param val a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMultisamplefv1(int pname, int index, Object val, int val_byte_offset, boolean val_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultisamplefv}(GLenum pname, GLuint index, GLfloat *  val); </code> <br>Part of <code>GL_ARB_texture_multisample</code>   */
  public void glGetMultisamplefv(int pname, int index, float[] val, int val_offset)  {

    if(val != null && val.length <= val_offset)
      throw new GLException("array offset argument \"val_offset\" (" + val_offset + ") equals or exceeds array length (" + val.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultisamplefv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultisamplefv\" not available");
    }
        dispatch_glGetMultisamplefv1(pname, index, val, Buffers.SIZEOF_FLOAT * val_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultisamplefvNV}(GLenum pname, GLuint index, GLfloat *  val); </code> <br>Part of <code>GL_NV_explicit_multisample</code>
      @param val a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMultisamplefvNV(int pname, int index, FloatBuffer val)  {

    final boolean val_is_direct = Buffers.isDirect(val);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultisamplefvNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultisamplefvNV\" not available");
    }
        dispatch_glGetMultisamplefvNV1(pname, index, val_is_direct ? val : Buffers.getArray(val), val_is_direct ? Buffers.getDirectBufferByteOffset(val) : Buffers.getIndirectBufferByteOffset(val), val_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultisamplefvNV}(GLenum pname, GLuint index, GLfloat *  val); </code> <br>Part of <code>GL_NV_explicit_multisample</code>
      @param val a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMultisamplefvNV1(int pname, int index, Object val, int val_byte_offset, boolean val_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultisamplefvNV}(GLenum pname, GLuint index, GLfloat *  val); </code> <br>Part of <code>GL_NV_explicit_multisample</code>   */
  public void glGetMultisamplefvNV(int pname, int index, float[] val, int val_offset)  {

    if(val != null && val.length <= val_offset)
      throw new GLException("array offset argument \"val_offset\" (" + val_offset + ") equals or exceeds array length (" + val.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMultisamplefvNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMultisamplefvNV\" not available");
    }
        dispatch_glGetMultisamplefvNV1(pname, index, val, Buffers.SIZEOF_FLOAT * val_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedBufferParameterivEXT}(GLuint buffer, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetNamedBufferParameterivEXT(int buffer, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedBufferParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedBufferParameterivEXT\" not available");
    }
        dispatch_glGetNamedBufferParameterivEXT1(buffer, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedBufferParameterivEXT}(GLuint buffer, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetNamedBufferParameterivEXT1(int buffer, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedBufferParameterivEXT}(GLuint buffer, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetNamedBufferParameterivEXT(int buffer, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedBufferParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedBufferParameterivEXT\" not available");
    }
        dispatch_glGetNamedBufferParameterivEXT1(buffer, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedBufferParameterui64vNV}(GLuint buffer, GLenum pname, GLuint64EXT *  params); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetNamedBufferParameterui64vNV(int buffer, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedBufferParameterui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedBufferParameterui64vNV\" not available");
    }
        dispatch_glGetNamedBufferParameterui64vNV1(buffer, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedBufferParameterui64vNV}(GLuint buffer, GLenum pname, GLuint64EXT *  params); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetNamedBufferParameterui64vNV1(int buffer, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedBufferParameterui64vNV}(GLuint buffer, GLenum pname, GLuint64EXT *  params); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>   */
  public void glGetNamedBufferParameterui64vNV(int buffer, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedBufferParameterui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedBufferParameterui64vNV\" not available");
    }
        dispatch_glGetNamedBufferParameterui64vNV1(buffer, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedBufferSubDataEXT}(GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid *  data); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetNamedBufferSubDataEXT(int buffer, long offset, long size, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedBufferSubDataEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedBufferSubDataEXT\" not available");
    }
        dispatch_glGetNamedBufferSubDataEXT1(buffer, offset, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedBufferSubDataEXT}(GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid *  data); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetNamedBufferSubDataEXT1(int buffer, long offset, long size, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedFramebufferAttachmentParameterivEXT}(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetNamedFramebufferAttachmentParameterivEXT(int framebuffer, int attachment, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedFramebufferAttachmentParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedFramebufferAttachmentParameterivEXT\" not available");
    }
        dispatch_glGetNamedFramebufferAttachmentParameterivEXT1(framebuffer, attachment, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedFramebufferAttachmentParameterivEXT}(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetNamedFramebufferAttachmentParameterivEXT1(int framebuffer, int attachment, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedFramebufferAttachmentParameterivEXT}(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetNamedFramebufferAttachmentParameterivEXT(int framebuffer, int attachment, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedFramebufferAttachmentParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedFramebufferAttachmentParameterivEXT\" not available");
    }
        dispatch_glGetNamedFramebufferAttachmentParameterivEXT1(framebuffer, attachment, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterIivEXT}(GLuint program, GLenum target, GLuint index, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetNamedProgramLocalParameterIivEXT(int program, int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedProgramLocalParameterIivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedProgramLocalParameterIivEXT\" not available");
    }
        dispatch_glGetNamedProgramLocalParameterIivEXT1(program, target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterIivEXT}(GLuint program, GLenum target, GLuint index, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetNamedProgramLocalParameterIivEXT1(int program, int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterIivEXT}(GLuint program, GLenum target, GLuint index, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetNamedProgramLocalParameterIivEXT(int program, int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedProgramLocalParameterIivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedProgramLocalParameterIivEXT\" not available");
    }
        dispatch_glGetNamedProgramLocalParameterIivEXT1(program, target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterIuivEXT}(GLuint program, GLenum target, GLuint index, GLuint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetNamedProgramLocalParameterIuivEXT(int program, int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedProgramLocalParameterIuivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedProgramLocalParameterIuivEXT\" not available");
    }
        dispatch_glGetNamedProgramLocalParameterIuivEXT1(program, target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterIuivEXT}(GLuint program, GLenum target, GLuint index, GLuint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetNamedProgramLocalParameterIuivEXT1(int program, int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterIuivEXT}(GLuint program, GLenum target, GLuint index, GLuint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetNamedProgramLocalParameterIuivEXT(int program, int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedProgramLocalParameterIuivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedProgramLocalParameterIuivEXT\" not available");
    }
        dispatch_glGetNamedProgramLocalParameterIuivEXT1(program, target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterdvEXT}(GLuint program, GLenum target, GLuint index, GLdouble *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetNamedProgramLocalParameterdvEXT(int program, int target, int index, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedProgramLocalParameterdvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedProgramLocalParameterdvEXT\" not available");
    }
        dispatch_glGetNamedProgramLocalParameterdvEXT1(program, target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterdvEXT}(GLuint program, GLenum target, GLuint index, GLdouble *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetNamedProgramLocalParameterdvEXT1(int program, int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterdvEXT}(GLuint program, GLenum target, GLuint index, GLdouble *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetNamedProgramLocalParameterdvEXT(int program, int target, int index, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedProgramLocalParameterdvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedProgramLocalParameterdvEXT\" not available");
    }
        dispatch_glGetNamedProgramLocalParameterdvEXT1(program, target, index, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterfvEXT}(GLuint program, GLenum target, GLuint index, GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetNamedProgramLocalParameterfvEXT(int program, int target, int index, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedProgramLocalParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedProgramLocalParameterfvEXT\" not available");
    }
        dispatch_glGetNamedProgramLocalParameterfvEXT1(program, target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterfvEXT}(GLuint program, GLenum target, GLuint index, GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetNamedProgramLocalParameterfvEXT1(int program, int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterfvEXT}(GLuint program, GLenum target, GLuint index, GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetNamedProgramLocalParameterfvEXT(int program, int target, int index, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedProgramLocalParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedProgramLocalParameterfvEXT\" not available");
    }
        dispatch_glGetNamedProgramLocalParameterfvEXT1(program, target, index, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedProgramStringEXT}(GLuint program, GLenum target, GLenum pname, GLvoid *  string); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param string a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetNamedProgramStringEXT(int program, int target, int pname, Buffer string)  {

    final boolean string_is_direct = Buffers.isDirect(string);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedProgramStringEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedProgramStringEXT\" not available");
    }
        dispatch_glGetNamedProgramStringEXT1(program, target, pname, string_is_direct ? string : Buffers.getArray(string), string_is_direct ? Buffers.getDirectBufferByteOffset(string) : Buffers.getIndirectBufferByteOffset(string), string_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedProgramStringEXT}(GLuint program, GLenum target, GLenum pname, GLvoid *  string); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param string a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetNamedProgramStringEXT1(int program, int target, int pname, Object string, int string_byte_offset, boolean string_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedProgramivEXT}(GLuint program, GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetNamedProgramivEXT(int program, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedProgramivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedProgramivEXT\" not available");
    }
        dispatch_glGetNamedProgramivEXT1(program, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedProgramivEXT}(GLuint program, GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetNamedProgramivEXT1(int program, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedProgramivEXT}(GLuint program, GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetNamedProgramivEXT(int program, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedProgramivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedProgramivEXT\" not available");
    }
        dispatch_glGetNamedProgramivEXT1(program, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedRenderbufferParameterivEXT}(GLuint renderbuffer, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetNamedRenderbufferParameterivEXT(int renderbuffer, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedRenderbufferParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedRenderbufferParameterivEXT\" not available");
    }
        dispatch_glGetNamedRenderbufferParameterivEXT1(renderbuffer, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedRenderbufferParameterivEXT}(GLuint renderbuffer, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetNamedRenderbufferParameterivEXT1(int renderbuffer, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedRenderbufferParameterivEXT}(GLuint renderbuffer, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetNamedRenderbufferParameterivEXT(int renderbuffer, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedRenderbufferParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedRenderbufferParameterivEXT\" not available");
    }
        dispatch_glGetNamedRenderbufferParameterivEXT1(renderbuffer, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedStringARB}(GLint namelen, const GLchar *  name, GLsizei bufSize, GLint *  stringlen, GLchar *  string); </code> <br>Part of <code>GL_ARB_shading_language_include</code>
      @param stringlen a direct or array-backed {@link java.nio.IntBuffer}
      @param string a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetNamedStringARB(int namelen, String name, int bufSize, IntBuffer stringlen, ByteBuffer string)  {

    final boolean stringlen_is_direct = Buffers.isDirect(stringlen);
    final boolean string_is_direct = Buffers.isDirect(string);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedStringARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedStringARB\" not available");
    }
        dispatch_glGetNamedStringARB1(namelen, name, bufSize, stringlen_is_direct ? stringlen : Buffers.getArray(stringlen), stringlen_is_direct ? Buffers.getDirectBufferByteOffset(stringlen) : Buffers.getIndirectBufferByteOffset(stringlen), stringlen_is_direct, string_is_direct ? string : Buffers.getArray(string), string_is_direct ? Buffers.getDirectBufferByteOffset(string) : Buffers.getIndirectBufferByteOffset(string), string_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedStringARB}(GLint namelen, const GLchar *  name, GLsizei bufSize, GLint *  stringlen, GLchar *  string); </code> <br>Part of <code>GL_ARB_shading_language_include</code>
      @param stringlen a direct or array-backed {@link java.nio.IntBuffer}
      @param string a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetNamedStringARB1(int namelen, String name, int bufSize, Object stringlen, int stringlen_byte_offset, boolean stringlen_is_direct, Object string, int string_byte_offset, boolean string_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedStringARB}(GLint namelen, const GLchar *  name, GLsizei bufSize, GLint *  stringlen, GLchar *  string); </code> <br>Part of <code>GL_ARB_shading_language_include</code>   */
  public void glGetNamedStringARB(int namelen, String name, int bufSize, int[] stringlen, int stringlen_offset, byte[] string, int string_offset)  {

    if(stringlen != null && stringlen.length <= stringlen_offset)
      throw new GLException("array offset argument \"stringlen_offset\" (" + stringlen_offset + ") equals or exceeds array length (" + stringlen.length + ")");
    if(string != null && string.length <= string_offset)
      throw new GLException("array offset argument \"string_offset\" (" + string_offset + ") equals or exceeds array length (" + string.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedStringARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedStringARB\" not available");
    }
        dispatch_glGetNamedStringARB1(namelen, name, bufSize, stringlen, Buffers.SIZEOF_INT * stringlen_offset, false, string, string_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedStringivARB}(GLint namelen, const GLchar *  name, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_shading_language_include</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetNamedStringivARB(int namelen, String name, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedStringivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedStringivARB\" not available");
    }
        dispatch_glGetNamedStringivARB1(namelen, name, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedStringivARB}(GLint namelen, const GLchar *  name, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_shading_language_include</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetNamedStringivARB1(int namelen, String name, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedStringivARB}(GLint namelen, const GLchar *  name, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_shading_language_include</code>   */
  public void glGetNamedStringivARB(int namelen, String name, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetNamedStringivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetNamedStringivARB\" not available");
    }
        dispatch_glGetNamedStringivARB1(namelen, name, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectParameterfvARB}(GLhandleARB obj, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetObjectParameterfvARB(int obj, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetObjectParameterfvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetObjectParameterfvARB\" not available");
    }
        dispatch_glGetObjectParameterfvARB1(obj, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectParameterfvARB}(GLhandleARB obj, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetObjectParameterfvARB1(int obj, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetObjectParameterfvARB}(GLhandleARB obj, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glGetObjectParameterfvARB(int obj, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetObjectParameterfvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetObjectParameterfvARB\" not available");
    }
        dispatch_glGetObjectParameterfvARB1(obj, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectParameterivAPPLE}(GLenum objectType, GLuint name, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_APPLE_object_purgeable</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetObjectParameterivAPPLE(int objectType, int name, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetObjectParameterivAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetObjectParameterivAPPLE\" not available");
    }
        dispatch_glGetObjectParameterivAPPLE1(objectType, name, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectParameterivAPPLE}(GLenum objectType, GLuint name, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_APPLE_object_purgeable</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetObjectParameterivAPPLE1(int objectType, int name, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetObjectParameterivAPPLE}(GLenum objectType, GLuint name, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_APPLE_object_purgeable</code>   */
  public void glGetObjectParameterivAPPLE(int objectType, int name, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetObjectParameterivAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetObjectParameterivAPPLE\" not available");
    }
        dispatch_glGetObjectParameterivAPPLE1(objectType, name, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectParameterivARB}(GLhandleARB obj, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetObjectParameterivARB(int obj, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetObjectParameterivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetObjectParameterivARB\" not available");
    }
        dispatch_glGetObjectParameterivARB1(obj, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectParameterivARB}(GLhandleARB obj, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetObjectParameterivARB1(int obj, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetObjectParameterivARB}(GLhandleARB obj, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glGetObjectParameterivARB(int obj, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetObjectParameterivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetObjectParameterivARB\" not available");
    }
        dispatch_glGetObjectParameterivARB1(obj, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetOcclusionQueryivNV}(GLuint id, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_occlusion_query</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetOcclusionQueryivNV(int id, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetOcclusionQueryivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetOcclusionQueryivNV\" not available");
    }
        dispatch_glGetOcclusionQueryivNV1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetOcclusionQueryivNV}(GLuint id, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_occlusion_query</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetOcclusionQueryivNV1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetOcclusionQueryivNV}(GLuint id, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_occlusion_query</code>   */
  public void glGetOcclusionQueryivNV(int id, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetOcclusionQueryivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetOcclusionQueryivNV\" not available");
    }
        dispatch_glGetOcclusionQueryivNV1(id, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetOcclusionQueryuivNV}(GLuint id, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_NV_occlusion_query</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetOcclusionQueryuivNV(int id, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetOcclusionQueryuivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetOcclusionQueryuivNV\" not available");
    }
        dispatch_glGetOcclusionQueryuivNV1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetOcclusionQueryuivNV}(GLuint id, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_NV_occlusion_query</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetOcclusionQueryuivNV1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetOcclusionQueryuivNV}(GLuint id, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_NV_occlusion_query</code>   */
  public void glGetOcclusionQueryuivNV(int id, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetOcclusionQueryuivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetOcclusionQueryuivNV\" not available");
    }
        dispatch_glGetOcclusionQueryuivNV1(id, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterDataAMD}(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *  data, GLint *  bytesWritten); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}
      @param bytesWritten a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetPerfMonitorCounterDataAMD(int monitor, int pname, int dataSize, IntBuffer data, IntBuffer bytesWritten)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final boolean bytesWritten_is_direct = Buffers.isDirect(bytesWritten);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorCounterDataAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPerfMonitorCounterDataAMD\" not available");
    }
        dispatch_glGetPerfMonitorCounterDataAMD1(monitor, pname, dataSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, bytesWritten_is_direct ? bytesWritten : Buffers.getArray(bytesWritten), bytesWritten_is_direct ? Buffers.getDirectBufferByteOffset(bytesWritten) : Buffers.getIndirectBufferByteOffset(bytesWritten), bytesWritten_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterDataAMD}(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *  data, GLint *  bytesWritten); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}
      @param bytesWritten a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetPerfMonitorCounterDataAMD1(int monitor, int pname, int dataSize, Object data, int data_byte_offset, boolean data_is_direct, Object bytesWritten, int bytesWritten_byte_offset, boolean bytesWritten_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterDataAMD}(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *  data, GLint *  bytesWritten); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glGetPerfMonitorCounterDataAMD(int monitor, int pname, int dataSize, int[] data, int data_offset, int[] bytesWritten, int bytesWritten_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    if(bytesWritten != null && bytesWritten.length <= bytesWritten_offset)
      throw new GLException("array offset argument \"bytesWritten_offset\" (" + bytesWritten_offset + ") equals or exceeds array length (" + bytesWritten.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorCounterDataAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPerfMonitorCounterDataAMD\" not available");
    }
        dispatch_glGetPerfMonitorCounterDataAMD1(monitor, pname, dataSize, data, Buffers.SIZEOF_INT * data_offset, false, bytesWritten, Buffers.SIZEOF_INT * bytesWritten_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterInfoAMD}(GLuint group, GLuint counter, GLenum pname, GLvoid *  data); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetPerfMonitorCounterInfoAMD(int group, int counter, int pname, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorCounterInfoAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPerfMonitorCounterInfoAMD\" not available");
    }
        dispatch_glGetPerfMonitorCounterInfoAMD1(group, counter, pname, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterInfoAMD}(GLuint group, GLuint counter, GLenum pname, GLvoid *  data); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetPerfMonitorCounterInfoAMD1(int group, int counter, int pname, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterStringAMD}(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *  length, GLchar *  counterString); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param counterString a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetPerfMonitorCounterStringAMD(int group, int counter, int bufSize, IntBuffer length, ByteBuffer counterString)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean counterString_is_direct = Buffers.isDirect(counterString);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorCounterStringAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPerfMonitorCounterStringAMD\" not available");
    }
        dispatch_glGetPerfMonitorCounterStringAMD1(group, counter, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, counterString_is_direct ? counterString : Buffers.getArray(counterString), counterString_is_direct ? Buffers.getDirectBufferByteOffset(counterString) : Buffers.getIndirectBufferByteOffset(counterString), counterString_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterStringAMD}(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *  length, GLchar *  counterString); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param counterString a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetPerfMonitorCounterStringAMD1(int group, int counter, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object counterString, int counterString_byte_offset, boolean counterString_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterStringAMD}(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *  length, GLchar *  counterString); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glGetPerfMonitorCounterStringAMD(int group, int counter, int bufSize, int[] length, int length_offset, byte[] counterString, int counterString_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(counterString != null && counterString.length <= counterString_offset)
      throw new GLException("array offset argument \"counterString_offset\" (" + counterString_offset + ") equals or exceeds array length (" + counterString.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorCounterStringAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPerfMonitorCounterStringAMD\" not available");
    }
        dispatch_glGetPerfMonitorCounterStringAMD1(group, counter, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, counterString, counterString_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCountersAMD}(GLuint group, GLint *  numCounters, GLint *  maxActiveCounters, GLsizei counterSize, GLuint *  counters); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param numCounters a direct or array-backed {@link java.nio.IntBuffer}
      @param maxActiveCounters a direct or array-backed {@link java.nio.IntBuffer}
      @param counters a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetPerfMonitorCountersAMD(int group, IntBuffer numCounters, IntBuffer maxActiveCounters, int counterSize, IntBuffer counters)  {

    final boolean numCounters_is_direct = Buffers.isDirect(numCounters);
    final boolean maxActiveCounters_is_direct = Buffers.isDirect(maxActiveCounters);
    final boolean counters_is_direct = Buffers.isDirect(counters);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorCountersAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPerfMonitorCountersAMD\" not available");
    }
        dispatch_glGetPerfMonitorCountersAMD1(group, numCounters_is_direct ? numCounters : Buffers.getArray(numCounters), numCounters_is_direct ? Buffers.getDirectBufferByteOffset(numCounters) : Buffers.getIndirectBufferByteOffset(numCounters), numCounters_is_direct, maxActiveCounters_is_direct ? maxActiveCounters : Buffers.getArray(maxActiveCounters), maxActiveCounters_is_direct ? Buffers.getDirectBufferByteOffset(maxActiveCounters) : Buffers.getIndirectBufferByteOffset(maxActiveCounters), maxActiveCounters_is_direct, counterSize, counters_is_direct ? counters : Buffers.getArray(counters), counters_is_direct ? Buffers.getDirectBufferByteOffset(counters) : Buffers.getIndirectBufferByteOffset(counters), counters_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCountersAMD}(GLuint group, GLint *  numCounters, GLint *  maxActiveCounters, GLsizei counterSize, GLuint *  counters); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param numCounters a direct or array-backed {@link java.nio.IntBuffer}
      @param maxActiveCounters a direct or array-backed {@link java.nio.IntBuffer}
      @param counters a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetPerfMonitorCountersAMD1(int group, Object numCounters, int numCounters_byte_offset, boolean numCounters_is_direct, Object maxActiveCounters, int maxActiveCounters_byte_offset, boolean maxActiveCounters_is_direct, int counterSize, Object counters, int counters_byte_offset, boolean counters_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCountersAMD}(GLuint group, GLint *  numCounters, GLint *  maxActiveCounters, GLsizei counterSize, GLuint *  counters); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glGetPerfMonitorCountersAMD(int group, int[] numCounters, int numCounters_offset, int[] maxActiveCounters, int maxActiveCounters_offset, int counterSize, int[] counters, int counters_offset)  {

    if(numCounters != null && numCounters.length <= numCounters_offset)
      throw new GLException("array offset argument \"numCounters_offset\" (" + numCounters_offset + ") equals or exceeds array length (" + numCounters.length + ")");
    if(maxActiveCounters != null && maxActiveCounters.length <= maxActiveCounters_offset)
      throw new GLException("array offset argument \"maxActiveCounters_offset\" (" + maxActiveCounters_offset + ") equals or exceeds array length (" + maxActiveCounters.length + ")");
    if(counters != null && counters.length <= counters_offset)
      throw new GLException("array offset argument \"counters_offset\" (" + counters_offset + ") equals or exceeds array length (" + counters.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorCountersAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPerfMonitorCountersAMD\" not available");
    }
        dispatch_glGetPerfMonitorCountersAMD1(group, numCounters, Buffers.SIZEOF_INT * numCounters_offset, false, maxActiveCounters, Buffers.SIZEOF_INT * maxActiveCounters_offset, false, counterSize, counters, Buffers.SIZEOF_INT * counters_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupStringAMD}(GLuint group, GLsizei bufSize, GLsizei *  length, GLchar *  groupString); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param groupString a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetPerfMonitorGroupStringAMD(int group, int bufSize, IntBuffer length, ByteBuffer groupString)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean groupString_is_direct = Buffers.isDirect(groupString);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorGroupStringAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPerfMonitorGroupStringAMD\" not available");
    }
        dispatch_glGetPerfMonitorGroupStringAMD1(group, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, groupString_is_direct ? groupString : Buffers.getArray(groupString), groupString_is_direct ? Buffers.getDirectBufferByteOffset(groupString) : Buffers.getIndirectBufferByteOffset(groupString), groupString_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupStringAMD}(GLuint group, GLsizei bufSize, GLsizei *  length, GLchar *  groupString); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param groupString a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetPerfMonitorGroupStringAMD1(int group, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object groupString, int groupString_byte_offset, boolean groupString_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupStringAMD}(GLuint group, GLsizei bufSize, GLsizei *  length, GLchar *  groupString); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glGetPerfMonitorGroupStringAMD(int group, int bufSize, int[] length, int length_offset, byte[] groupString, int groupString_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(groupString != null && groupString.length <= groupString_offset)
      throw new GLException("array offset argument \"groupString_offset\" (" + groupString_offset + ") equals or exceeds array length (" + groupString.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorGroupStringAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPerfMonitorGroupStringAMD\" not available");
    }
        dispatch_glGetPerfMonitorGroupStringAMD1(group, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, groupString, groupString_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupsAMD}(GLint *  numGroups, GLsizei groupsSize, GLuint *  groups); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param numGroups a direct or array-backed {@link java.nio.IntBuffer}
      @param groups a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetPerfMonitorGroupsAMD(IntBuffer numGroups, int groupsSize, IntBuffer groups)  {

    final boolean numGroups_is_direct = Buffers.isDirect(numGroups);
    final boolean groups_is_direct = Buffers.isDirect(groups);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorGroupsAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPerfMonitorGroupsAMD\" not available");
    }
        dispatch_glGetPerfMonitorGroupsAMD1(numGroups_is_direct ? numGroups : Buffers.getArray(numGroups), numGroups_is_direct ? Buffers.getDirectBufferByteOffset(numGroups) : Buffers.getIndirectBufferByteOffset(numGroups), numGroups_is_direct, groupsSize, groups_is_direct ? groups : Buffers.getArray(groups), groups_is_direct ? Buffers.getDirectBufferByteOffset(groups) : Buffers.getIndirectBufferByteOffset(groups), groups_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupsAMD}(GLint *  numGroups, GLsizei groupsSize, GLuint *  groups); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param numGroups a direct or array-backed {@link java.nio.IntBuffer}
      @param groups a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetPerfMonitorGroupsAMD1(Object numGroups, int numGroups_byte_offset, boolean numGroups_is_direct, int groupsSize, Object groups, int groups_byte_offset, boolean groups_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupsAMD}(GLint *  numGroups, GLsizei groupsSize, GLuint *  groups); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glGetPerfMonitorGroupsAMD(int[] numGroups, int numGroups_offset, int groupsSize, int[] groups, int groups_offset)  {

    if(numGroups != null && numGroups.length <= numGroups_offset)
      throw new GLException("array offset argument \"numGroups_offset\" (" + numGroups_offset + ") equals or exceeds array length (" + numGroups.length + ")");
    if(groups != null && groups.length <= groups_offset)
      throw new GLException("array offset argument \"groups_offset\" (" + groups_offset + ") equals or exceeds array length (" + groups.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorGroupsAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPerfMonitorGroupsAMD\" not available");
    }
        dispatch_glGetPerfMonitorGroupsAMD1(numGroups, Buffers.SIZEOF_INT * numGroups_offset, false, groupsSize, groups, Buffers.SIZEOF_INT * groups_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPixelMapfv}(GLenum map, GLfloat *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetPixelMapfv(int map, FloatBuffer values)  {

    checkPackPBODisabled(true);
    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPixelMapfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPixelMapfv\" not available");
    }
        dispatch_glGetPixelMapfv1(map, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPixelMapfv}(GLenum map, GLfloat *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetPixelMapfv1(int map, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPixelMapfv}(GLenum map, GLfloat *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetPixelMapfv(int map, float[] values, int values_offset)  {

    checkPackPBODisabled(true);
    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPixelMapfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPixelMapfv\" not available");
    }
        dispatch_glGetPixelMapfv1(map, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPixelMapfv}(GLenum map, GLfloat *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetPixelMapfv(int map, long values_buffer_offset)  {

    checkPackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPixelMapfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPixelMapfv\" not available");
    }
        dispatch_glGetPixelMapfv1(map, values_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPixelMapfv}(GLenum map, GLfloat *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  private native void dispatch_glGetPixelMapfv1(int map, long values_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPixelMapuiv}(GLenum map, GLuint *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetPixelMapuiv(int map, IntBuffer values)  {

    checkPackPBODisabled(true);
    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPixelMapuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPixelMapuiv\" not available");
    }
        dispatch_glGetPixelMapuiv1(map, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPixelMapuiv}(GLenum map, GLuint *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetPixelMapuiv1(int map, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPixelMapuiv}(GLenum map, GLuint *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetPixelMapuiv(int map, int[] values, int values_offset)  {

    checkPackPBODisabled(true);
    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPixelMapuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPixelMapuiv\" not available");
    }
        dispatch_glGetPixelMapuiv1(map, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPixelMapuiv}(GLenum map, GLuint *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetPixelMapuiv(int map, long values_buffer_offset)  {

    checkPackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPixelMapuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPixelMapuiv\" not available");
    }
        dispatch_glGetPixelMapuiv1(map, values_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPixelMapuiv}(GLenum map, GLuint *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  private native void dispatch_glGetPixelMapuiv1(int map, long values_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPixelMapusv}(GLenum map, GLushort *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param values a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glGetPixelMapusv(int map, ShortBuffer values)  {

    checkPackPBODisabled(true);
    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPixelMapusv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPixelMapusv\" not available");
    }
        dispatch_glGetPixelMapusv1(map, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPixelMapusv}(GLenum map, GLushort *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param values a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glGetPixelMapusv1(int map, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPixelMapusv}(GLenum map, GLushort *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetPixelMapusv(int map, short[] values, int values_offset)  {

    checkPackPBODisabled(true);
    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPixelMapusv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPixelMapusv\" not available");
    }
        dispatch_glGetPixelMapusv1(map, values, Buffers.SIZEOF_SHORT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPixelMapusv}(GLenum map, GLushort *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetPixelMapusv(int map, long values_buffer_offset)  {

    checkPackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPixelMapusv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPixelMapusv\" not available");
    }
        dispatch_glGetPixelMapusv1(map, values_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPixelMapusv}(GLenum map, GLushort *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  private native void dispatch_glGetPixelMapusv1(int map, long values_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPolygonStipple}(GLubyte *  mask); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param mask a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetPolygonStipple(ByteBuffer mask)  {

    checkPackPBODisabled(true);
    final boolean mask_is_direct = Buffers.isDirect(mask);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPolygonStipple;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPolygonStipple\" not available");
    }
        dispatch_glGetPolygonStipple1(mask_is_direct ? mask : Buffers.getArray(mask), mask_is_direct ? Buffers.getDirectBufferByteOffset(mask) : Buffers.getIndirectBufferByteOffset(mask), mask_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPolygonStipple}(GLubyte *  mask); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param mask a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetPolygonStipple1(Object mask, int mask_byte_offset, boolean mask_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPolygonStipple}(GLubyte *  mask); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetPolygonStipple(byte[] mask, int mask_offset)  {

    checkPackPBODisabled(true);
    if(mask != null && mask.length <= mask_offset)
      throw new GLException("array offset argument \"mask_offset\" (" + mask_offset + ") equals or exceeds array length (" + mask.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPolygonStipple;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPolygonStipple\" not available");
    }
        dispatch_glGetPolygonStipple1(mask, mask_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPolygonStipple}(GLubyte *  mask); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetPolygonStipple(long mask_buffer_offset)  {

    checkPackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPolygonStipple;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPolygonStipple\" not available");
    }
        dispatch_glGetPolygonStipple1(mask_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPolygonStipple}(GLubyte *  mask); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  private native void dispatch_glGetPolygonStipple1(long mask_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramBinary}(GLuint program, GLsizei bufSize, GLsizei *  length, GLenum *  binaryFormat, GLvoid *  binary); </code> <br>Part of <code>GL_ARB_get_program_binary</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param binaryFormat a direct or array-backed {@link java.nio.IntBuffer}
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetProgramBinary(int program, int bufSize, IntBuffer length, IntBuffer binaryFormat, Buffer binary)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean binaryFormat_is_direct = Buffers.isDirect(binaryFormat);
    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramBinary;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramBinary\" not available");
    }
        dispatch_glGetProgramBinary1(program, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, binaryFormat_is_direct ? binaryFormat : Buffers.getArray(binaryFormat), binaryFormat_is_direct ? Buffers.getDirectBufferByteOffset(binaryFormat) : Buffers.getIndirectBufferByteOffset(binaryFormat), binaryFormat_is_direct, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramBinary}(GLuint program, GLsizei bufSize, GLsizei *  length, GLenum *  binaryFormat, GLvoid *  binary); </code> <br>Part of <code>GL_ARB_get_program_binary</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param binaryFormat a direct or array-backed {@link java.nio.IntBuffer}
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetProgramBinary1(int program, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object binaryFormat, int binaryFormat_byte_offset, boolean binaryFormat_is_direct, Object binary, int binary_byte_offset, boolean binary_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramBinary}(GLuint program, GLsizei bufSize, GLsizei *  length, GLenum *  binaryFormat, GLvoid *  binary); </code> <br>Part of <code>GL_ARB_get_program_binary</code>
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetProgramBinary(int program, int bufSize, int[] length, int length_offset, int[] binaryFormat, int binaryFormat_offset, Buffer binary)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(binaryFormat != null && binaryFormat.length <= binaryFormat_offset)
      throw new GLException("array offset argument \"binaryFormat_offset\" (" + binaryFormat_offset + ") equals or exceeds array length (" + binaryFormat.length + ")");
    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramBinary;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramBinary\" not available");
    }
        dispatch_glGetProgramBinary1(program, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, binaryFormat, Buffers.SIZEOF_INT * binaryFormat_offset, false, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterIivNV}(GLenum target, GLuint index, GLint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramEnvParameterIivNV(int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramEnvParameterIivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramEnvParameterIivNV\" not available");
    }
        dispatch_glGetProgramEnvParameterIivNV1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterIivNV}(GLenum target, GLuint index, GLint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramEnvParameterIivNV1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterIivNV}(GLenum target, GLuint index, GLint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>   */
  public void glGetProgramEnvParameterIivNV(int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramEnvParameterIivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramEnvParameterIivNV\" not available");
    }
        dispatch_glGetProgramEnvParameterIivNV1(target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterIuivNV}(GLenum target, GLuint index, GLuint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramEnvParameterIuivNV(int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramEnvParameterIuivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramEnvParameterIuivNV\" not available");
    }
        dispatch_glGetProgramEnvParameterIuivNV1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterIuivNV}(GLenum target, GLuint index, GLuint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramEnvParameterIuivNV1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterIuivNV}(GLenum target, GLuint index, GLuint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>   */
  public void glGetProgramEnvParameterIuivNV(int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramEnvParameterIuivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramEnvParameterIuivNV\" not available");
    }
        dispatch_glGetProgramEnvParameterIuivNV1(target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterdvARB}(GLenum target, GLuint index, GLdouble *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetProgramEnvParameterdvARB(int target, int index, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramEnvParameterdvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramEnvParameterdvARB\" not available");
    }
        dispatch_glGetProgramEnvParameterdvARB1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterdvARB}(GLenum target, GLuint index, GLdouble *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetProgramEnvParameterdvARB1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterdvARB}(GLenum target, GLuint index, GLdouble *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glGetProgramEnvParameterdvARB(int target, int index, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramEnvParameterdvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramEnvParameterdvARB\" not available");
    }
        dispatch_glGetProgramEnvParameterdvARB1(target, index, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterfvARB}(GLenum target, GLuint index, GLfloat *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetProgramEnvParameterfvARB(int target, int index, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramEnvParameterfvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramEnvParameterfvARB\" not available");
    }
        dispatch_glGetProgramEnvParameterfvARB1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterfvARB}(GLenum target, GLuint index, GLfloat *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetProgramEnvParameterfvARB1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterfvARB}(GLenum target, GLuint index, GLfloat *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glGetProgramEnvParameterfvARB(int target, int index, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramEnvParameterfvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramEnvParameterfvARB\" not available");
    }
        dispatch_glGetProgramEnvParameterfvARB1(target, index, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramInfoLog}(GLuint program, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetProgramInfoLog(int program, int bufSize, IntBuffer length, ByteBuffer infoLog)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean infoLog_is_direct = Buffers.isDirect(infoLog);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramInfoLog;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramInfoLog\" not available");
    }
        dispatch_glGetProgramInfoLog1(program, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, infoLog_is_direct ? infoLog : Buffers.getArray(infoLog), infoLog_is_direct ? Buffers.getDirectBufferByteOffset(infoLog) : Buffers.getIndirectBufferByteOffset(infoLog), infoLog_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramInfoLog}(GLuint program, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetProgramInfoLog1(int program, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object infoLog, int infoLog_byte_offset, boolean infoLog_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramInfoLog}(GLuint program, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glGetProgramInfoLog(int program, int bufSize, int[] length, int length_offset, byte[] infoLog, int infoLog_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(infoLog != null && infoLog.length <= infoLog_offset)
      throw new GLException("array offset argument \"infoLog_offset\" (" + infoLog_offset + ") equals or exceeds array length (" + infoLog.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramInfoLog;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramInfoLog\" not available");
    }
        dispatch_glGetProgramInfoLog1(program, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, infoLog, infoLog_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterIivNV}(GLenum target, GLuint index, GLint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramLocalParameterIivNV(int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramLocalParameterIivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramLocalParameterIivNV\" not available");
    }
        dispatch_glGetProgramLocalParameterIivNV1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterIivNV}(GLenum target, GLuint index, GLint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramLocalParameterIivNV1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterIivNV}(GLenum target, GLuint index, GLint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>   */
  public void glGetProgramLocalParameterIivNV(int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramLocalParameterIivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramLocalParameterIivNV\" not available");
    }
        dispatch_glGetProgramLocalParameterIivNV1(target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterIuivNV}(GLenum target, GLuint index, GLuint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramLocalParameterIuivNV(int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramLocalParameterIuivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramLocalParameterIuivNV\" not available");
    }
        dispatch_glGetProgramLocalParameterIuivNV1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterIuivNV}(GLenum target, GLuint index, GLuint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramLocalParameterIuivNV1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterIuivNV}(GLenum target, GLuint index, GLuint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>   */
  public void glGetProgramLocalParameterIuivNV(int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramLocalParameterIuivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramLocalParameterIuivNV\" not available");
    }
        dispatch_glGetProgramLocalParameterIuivNV1(target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterdvARB}(GLenum target, GLuint index, GLdouble *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetProgramLocalParameterdvARB(int target, int index, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramLocalParameterdvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramLocalParameterdvARB\" not available");
    }
        dispatch_glGetProgramLocalParameterdvARB1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterdvARB}(GLenum target, GLuint index, GLdouble *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetProgramLocalParameterdvARB1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterdvARB}(GLenum target, GLuint index, GLdouble *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glGetProgramLocalParameterdvARB(int target, int index, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramLocalParameterdvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramLocalParameterdvARB\" not available");
    }
        dispatch_glGetProgramLocalParameterdvARB1(target, index, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterfvARB}(GLenum target, GLuint index, GLfloat *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetProgramLocalParameterfvARB(int target, int index, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramLocalParameterfvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramLocalParameterfvARB\" not available");
    }
        dispatch_glGetProgramLocalParameterfvARB1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterfvARB}(GLenum target, GLuint index, GLfloat *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetProgramLocalParameterfvARB1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterfvARB}(GLenum target, GLuint index, GLfloat *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glGetProgramLocalParameterfvARB(int target, int index, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramLocalParameterfvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramLocalParameterfvARB\" not available");
    }
        dispatch_glGetProgramLocalParameterfvARB1(target, index, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramPipelineInfoLog}(GLuint pipeline, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetProgramPipelineInfoLog(int pipeline, int bufSize, IntBuffer length, ByteBuffer infoLog)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean infoLog_is_direct = Buffers.isDirect(infoLog);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramPipelineInfoLog;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramPipelineInfoLog\" not available");
    }
        dispatch_glGetProgramPipelineInfoLog1(pipeline, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, infoLog_is_direct ? infoLog : Buffers.getArray(infoLog), infoLog_is_direct ? Buffers.getDirectBufferByteOffset(infoLog) : Buffers.getIndirectBufferByteOffset(infoLog), infoLog_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramPipelineInfoLog}(GLuint pipeline, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetProgramPipelineInfoLog1(int pipeline, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object infoLog, int infoLog_byte_offset, boolean infoLog_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramPipelineInfoLog}(GLuint pipeline, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glGetProgramPipelineInfoLog(int pipeline, int bufSize, int[] length, int length_offset, byte[] infoLog, int infoLog_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(infoLog != null && infoLog.length <= infoLog_offset)
      throw new GLException("array offset argument \"infoLog_offset\" (" + infoLog_offset + ") equals or exceeds array length (" + infoLog.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramPipelineInfoLog;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramPipelineInfoLog\" not available");
    }
        dispatch_glGetProgramPipelineInfoLog1(pipeline, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, infoLog, infoLog_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramPipelineiv}(GLuint pipeline, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramPipelineiv(int pipeline, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramPipelineiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramPipelineiv\" not available");
    }
        dispatch_glGetProgramPipelineiv1(pipeline, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramPipelineiv}(GLuint pipeline, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramPipelineiv1(int pipeline, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramPipelineiv}(GLuint pipeline, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glGetProgramPipelineiv(int pipeline, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramPipelineiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramPipelineiv\" not available");
    }
        dispatch_glGetProgramPipelineiv1(pipeline, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramStageiv}(GLuint program, GLenum shadertype, GLenum pname, GLint *  values); </code> <br>Part of <code>GL_ARB_shader_subroutine</code>
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramStageiv(int program, int shadertype, int pname, IntBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramStageiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramStageiv\" not available");
    }
        dispatch_glGetProgramStageiv1(program, shadertype, pname, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramStageiv}(GLuint program, GLenum shadertype, GLenum pname, GLint *  values); </code> <br>Part of <code>GL_ARB_shader_subroutine</code>
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramStageiv1(int program, int shadertype, int pname, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramStageiv}(GLuint program, GLenum shadertype, GLenum pname, GLint *  values); </code> <br>Part of <code>GL_ARB_shader_subroutine</code>   */
  public void glGetProgramStageiv(int program, int shadertype, int pname, int[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramStageiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramStageiv\" not available");
    }
        dispatch_glGetProgramStageiv1(program, shadertype, pname, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramStringARB}(GLenum target, GLenum pname, GLvoid *  string); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param string a direct only {@link java.nio.Buffer}   */
  public void glGetProgramStringARB(int target, int pname, Buffer string)  {

    if (!Buffers.isDirect(string))
      throw new GLException("Argument \"string\" is not a direct buffer");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramStringARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramStringARB\" not available");
    }
        dispatch_glGetProgramStringARB0(target, pname, string, Buffers.getDirectBufferByteOffset(string), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramStringARB}(GLenum target, GLenum pname, GLvoid *  string); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param string a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glGetProgramStringARB0(int target, int pname, Object string, int string_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramSubroutineParameteruivNV}(GLenum target, GLuint index, GLuint *  param); </code> <br>Part of <code>GL_NV_gpu_program5</code>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramSubroutineParameteruivNV(int target, int index, IntBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramSubroutineParameteruivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramSubroutineParameteruivNV\" not available");
    }
        dispatch_glGetProgramSubroutineParameteruivNV1(target, index, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramSubroutineParameteruivNV}(GLenum target, GLuint index, GLuint *  param); </code> <br>Part of <code>GL_NV_gpu_program5</code>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramSubroutineParameteruivNV1(int target, int index, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramSubroutineParameteruivNV}(GLenum target, GLuint index, GLuint *  param); </code> <br>Part of <code>GL_NV_gpu_program5</code>   */
  public void glGetProgramSubroutineParameteruivNV(int target, int index, int[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramSubroutineParameteruivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramSubroutineParameteruivNV\" not available");
    }
        dispatch_glGetProgramSubroutineParameteruivNV1(target, index, param, Buffers.SIZEOF_INT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramiv}(GLuint program, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramiv(int program, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramiv\" not available");
    }
        dispatch_glGetProgramiv1(program, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramiv}(GLuint program, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramiv1(int program, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramiv}(GLuint program, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glGetProgramiv(int program, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramiv\" not available");
    }
        dispatch_glGetProgramiv1(program, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramivARB}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramivARB(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramivARB\" not available");
    }
        dispatch_glGetProgramivARB1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramivARB}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramivARB1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramivARB}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glGetProgramivARB(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramivARB\" not available");
    }
        dispatch_glGetProgramivARB1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryIndexediv}(GLenum target, GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_transform_feedback3</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetQueryIndexediv(int target, int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryIndexediv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetQueryIndexediv\" not available");
    }
        dispatch_glGetQueryIndexediv1(target, index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryIndexediv}(GLenum target, GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_transform_feedback3</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetQueryIndexediv1(int target, int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryIndexediv}(GLenum target, GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_transform_feedback3</code>   */
  public void glGetQueryIndexediv(int target, int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryIndexediv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetQueryIndexediv\" not available");
    }
        dispatch_glGetQueryIndexediv1(target, index, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjecti64v}(GLuint id, GLenum pname, GLint64 *  params); </code> <br>Part of <code>GL_ARB_timer_query</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetQueryObjecti64v(int id, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryObjecti64v;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetQueryObjecti64v\" not available");
    }
        dispatch_glGetQueryObjecti64v1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjecti64v}(GLuint id, GLenum pname, GLint64 *  params); </code> <br>Part of <code>GL_ARB_timer_query</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetQueryObjecti64v1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjecti64v}(GLuint id, GLenum pname, GLint64 *  params); </code> <br>Part of <code>GL_ARB_timer_query</code>   */
  public void glGetQueryObjecti64v(int id, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryObjecti64v;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetQueryObjecti64v\" not available");
    }
        dispatch_glGetQueryObjecti64v1(id, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjecti64vEXT}(GLuint id, GLenum pname, GLint64EXT *  params); </code> <br>Part of <code>GL_EXT_timer_query</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetQueryObjecti64vEXT(int id, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryObjecti64vEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetQueryObjecti64vEXT\" not available");
    }
        dispatch_glGetQueryObjecti64vEXT1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjecti64vEXT}(GLuint id, GLenum pname, GLint64EXT *  params); </code> <br>Part of <code>GL_EXT_timer_query</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetQueryObjecti64vEXT1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjecti64vEXT}(GLuint id, GLenum pname, GLint64EXT *  params); </code> <br>Part of <code>GL_EXT_timer_query</code>   */
  public void glGetQueryObjecti64vEXT(int id, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryObjecti64vEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetQueryObjecti64vEXT\" not available");
    }
        dispatch_glGetQueryObjecti64vEXT1(id, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectiv}(GLuint id, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_5</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetQueryObjectiv(int id, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryObjectiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetQueryObjectiv\" not available");
    }
        dispatch_glGetQueryObjectiv1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectiv}(GLuint id, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_5</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetQueryObjectiv1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjectiv}(GLuint id, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_5</code>   */
  public void glGetQueryObjectiv(int id, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryObjectiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetQueryObjectiv\" not available");
    }
        dispatch_glGetQueryObjectiv1(id, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectui64v}(GLuint id, GLenum pname, GLuint64 *  params); </code> <br>Part of <code>GL_ARB_timer_query</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetQueryObjectui64v(int id, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryObjectui64v;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetQueryObjectui64v\" not available");
    }
        dispatch_glGetQueryObjectui64v1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectui64v}(GLuint id, GLenum pname, GLuint64 *  params); </code> <br>Part of <code>GL_ARB_timer_query</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetQueryObjectui64v1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjectui64v}(GLuint id, GLenum pname, GLuint64 *  params); </code> <br>Part of <code>GL_ARB_timer_query</code>   */
  public void glGetQueryObjectui64v(int id, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryObjectui64v;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetQueryObjectui64v\" not available");
    }
        dispatch_glGetQueryObjectui64v1(id, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectui64vEXT}(GLuint id, GLenum pname, GLuint64EXT *  params); </code> <br>Part of <code>GL_EXT_timer_query</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetQueryObjectui64vEXT(int id, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryObjectui64vEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetQueryObjectui64vEXT\" not available");
    }
        dispatch_glGetQueryObjectui64vEXT1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectui64vEXT}(GLuint id, GLenum pname, GLuint64EXT *  params); </code> <br>Part of <code>GL_EXT_timer_query</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetQueryObjectui64vEXT1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjectui64vEXT}(GLuint id, GLenum pname, GLuint64EXT *  params); </code> <br>Part of <code>GL_EXT_timer_query</code>   */
  public void glGetQueryObjectui64vEXT(int id, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryObjectui64vEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetQueryObjectui64vEXT\" not available");
    }
        dispatch_glGetQueryObjectui64vEXT1(id, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectuiv}(GLuint id, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_VERSION_1_5</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetQueryObjectuiv(int id, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryObjectuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetQueryObjectuiv\" not available");
    }
        dispatch_glGetQueryObjectuiv1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectuiv}(GLuint id, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_VERSION_1_5</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetQueryObjectuiv1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjectuiv}(GLuint id, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_VERSION_1_5</code>   */
  public void glGetQueryObjectuiv(int id, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryObjectuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetQueryObjectuiv\" not available");
    }
        dispatch_glGetQueryObjectuiv1(id, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryiv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_5</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetQueryiv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetQueryiv\" not available");
    }
        dispatch_glGetQueryiv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryiv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_5</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetQueryiv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryiv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_5</code>   */
  public void glGetQueryiv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetQueryiv\" not available");
    }
        dispatch_glGetQueryiv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetRenderbufferParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetRenderbufferParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetRenderbufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetRenderbufferParameteriv\" not available");
    }
        dispatch_glGetRenderbufferParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetRenderbufferParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetRenderbufferParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetRenderbufferParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public void glGetRenderbufferParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetRenderbufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetRenderbufferParameteriv\" not available");
    }
        dispatch_glGetRenderbufferParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterIiv}(GLuint sampler, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_sampler_objects</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetSamplerParameterIiv(int sampler, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetSamplerParameterIiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetSamplerParameterIiv\" not available");
    }
        dispatch_glGetSamplerParameterIiv1(sampler, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterIiv}(GLuint sampler, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_sampler_objects</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetSamplerParameterIiv1(int sampler, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterIiv}(GLuint sampler, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_sampler_objects</code>   */
  public void glGetSamplerParameterIiv(int sampler, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetSamplerParameterIiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetSamplerParameterIiv\" not available");
    }
        dispatch_glGetSamplerParameterIiv1(sampler, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterIuiv}(GLuint sampler, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_ARB_sampler_objects</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetSamplerParameterIuiv(int sampler, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetSamplerParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetSamplerParameterIuiv\" not available");
    }
        dispatch_glGetSamplerParameterIuiv1(sampler, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterIuiv}(GLuint sampler, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_ARB_sampler_objects</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetSamplerParameterIuiv1(int sampler, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterIuiv}(GLuint sampler, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_ARB_sampler_objects</code>   */
  public void glGetSamplerParameterIuiv(int sampler, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetSamplerParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetSamplerParameterIuiv\" not available");
    }
        dispatch_glGetSamplerParameterIuiv1(sampler, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterfv}(GLuint sampler, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_ARB_sampler_objects</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetSamplerParameterfv(int sampler, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetSamplerParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetSamplerParameterfv\" not available");
    }
        dispatch_glGetSamplerParameterfv1(sampler, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterfv}(GLuint sampler, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_ARB_sampler_objects</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetSamplerParameterfv1(int sampler, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterfv}(GLuint sampler, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_ARB_sampler_objects</code>   */
  public void glGetSamplerParameterfv(int sampler, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetSamplerParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetSamplerParameterfv\" not available");
    }
        dispatch_glGetSamplerParameterfv1(sampler, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameteriv}(GLuint sampler, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_sampler_objects</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetSamplerParameteriv(int sampler, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetSamplerParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetSamplerParameteriv\" not available");
    }
        dispatch_glGetSamplerParameteriv1(sampler, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameteriv}(GLuint sampler, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_sampler_objects</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetSamplerParameteriv1(int sampler, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetSamplerParameteriv}(GLuint sampler, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_sampler_objects</code>   */
  public void glGetSamplerParameteriv(int sampler, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetSamplerParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetSamplerParameteriv\" not available");
    }
        dispatch_glGetSamplerParameteriv1(sampler, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSeparableFilter}(GLenum target, GLenum format, GLenum type, GLvoid *  row, GLvoid *  column, GLvoid *  span); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param row a direct or array-backed {@link java.nio.Buffer}
      @param column a direct or array-backed {@link java.nio.Buffer}
      @param span a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetSeparableFilter(int target, int format, int type, Buffer row, Buffer column, Buffer span)  {

    checkPackPBODisabled(true);
    final boolean row_is_direct = Buffers.isDirect(row);
    final boolean column_is_direct = Buffers.isDirect(column);
    final boolean span_is_direct = Buffers.isDirect(span);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetSeparableFilter;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetSeparableFilter\" not available");
    }
        dispatch_glGetSeparableFilter1(target, format, type, row_is_direct ? row : Buffers.getArray(row), row_is_direct ? Buffers.getDirectBufferByteOffset(row) : Buffers.getIndirectBufferByteOffset(row), row_is_direct, column_is_direct ? column : Buffers.getArray(column), column_is_direct ? Buffers.getDirectBufferByteOffset(column) : Buffers.getIndirectBufferByteOffset(column), column_is_direct, span_is_direct ? span : Buffers.getArray(span), span_is_direct ? Buffers.getDirectBufferByteOffset(span) : Buffers.getIndirectBufferByteOffset(span), span_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSeparableFilter}(GLenum target, GLenum format, GLenum type, GLvoid *  row, GLvoid *  column, GLvoid *  span); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param row a direct or array-backed {@link java.nio.Buffer}
      @param column a direct or array-backed {@link java.nio.Buffer}
      @param span a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetSeparableFilter1(int target, int format, int type, Object row, int row_byte_offset, boolean row_is_direct, Object column, int column_byte_offset, boolean column_is_direct, Object span, int span_byte_offset, boolean span_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetSeparableFilter}(GLenum target, GLenum format, GLenum type, GLvoid *  row, GLvoid *  column, GLvoid *  span); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glGetSeparableFilter(int target, int format, int type, long row_buffer_offset, long column_buffer_offset, long span_buffer_offset)  {

    checkPackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetSeparableFilter;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetSeparableFilter\" not available");
    }
        dispatch_glGetSeparableFilter1(target, format, type, row_buffer_offset, column_buffer_offset, span_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSeparableFilter}(GLenum target, GLenum format, GLenum type, GLvoid *  row, GLvoid *  column, GLvoid *  span); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  private native void dispatch_glGetSeparableFilter1(int target, int format, int type, long row_buffer_offset, long column_buffer_offset, long span_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetShaderInfoLog}(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetShaderInfoLog(int shader, int bufSize, IntBuffer length, ByteBuffer infoLog)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean infoLog_is_direct = Buffers.isDirect(infoLog);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderInfoLog;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetShaderInfoLog\" not available");
    }
        dispatch_glGetShaderInfoLog1(shader, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, infoLog_is_direct ? infoLog : Buffers.getArray(infoLog), infoLog_is_direct ? Buffers.getDirectBufferByteOffset(infoLog) : Buffers.getIndirectBufferByteOffset(infoLog), infoLog_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderInfoLog}(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetShaderInfoLog1(int shader, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object infoLog, int infoLog_byte_offset, boolean infoLog_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetShaderInfoLog}(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glGetShaderInfoLog(int shader, int bufSize, int[] length, int length_offset, byte[] infoLog, int infoLog_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(infoLog != null && infoLog.length <= infoLog_offset)
      throw new GLException("array offset argument \"infoLog_offset\" (" + infoLog_offset + ") equals or exceeds array length (" + infoLog.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderInfoLog;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetShaderInfoLog\" not available");
    }
        dispatch_glGetShaderInfoLog1(shader, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, infoLog, infoLog_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderPrecisionFormat}(GLenum shadertype, GLenum precisiontype, GLint *  range, GLint *  precision); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>
      @param range a direct or array-backed {@link java.nio.IntBuffer}
      @param precision a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetShaderPrecisionFormat(int shadertype, int precisiontype, IntBuffer range, IntBuffer precision)  {

    if ( !_context.isGLES2Compatible() ) {
    throw new GLException("Method \"glGetShaderPrecisionFormat\" not available");
    }
    final boolean range_is_direct = Buffers.isDirect(range);
    final boolean precision_is_direct = Buffers.isDirect(precision);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderPrecisionFormat;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetShaderPrecisionFormat\" not available");
    }
        dispatch_glGetShaderPrecisionFormat1(shadertype, precisiontype, range_is_direct ? range : Buffers.getArray(range), range_is_direct ? Buffers.getDirectBufferByteOffset(range) : Buffers.getIndirectBufferByteOffset(range), range_is_direct, precision_is_direct ? precision : Buffers.getArray(precision), precision_is_direct ? Buffers.getDirectBufferByteOffset(precision) : Buffers.getIndirectBufferByteOffset(precision), precision_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderPrecisionFormat}(GLenum shadertype, GLenum precisiontype, GLint *  range, GLint *  precision); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>
      @param range a direct or array-backed {@link java.nio.IntBuffer}
      @param precision a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetShaderPrecisionFormat1(int shadertype, int precisiontype, Object range, int range_byte_offset, boolean range_is_direct, Object precision, int precision_byte_offset, boolean precision_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetShaderPrecisionFormat}(GLenum shadertype, GLenum precisiontype, GLint *  range, GLint *  precision); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>   */
  public void glGetShaderPrecisionFormat(int shadertype, int precisiontype, int[] range, int range_offset, int[] precision, int precision_offset)  {

    if ( !_context.isGLES2Compatible() ) {
    throw new GLException("Method \"glGetShaderPrecisionFormat\" not available");
    }
    if(range != null && range.length <= range_offset)
      throw new GLException("array offset argument \"range_offset\" (" + range_offset + ") equals or exceeds array length (" + range.length + ")");
    if(precision != null && precision.length <= precision_offset)
      throw new GLException("array offset argument \"precision_offset\" (" + precision_offset + ") equals or exceeds array length (" + precision.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderPrecisionFormat;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetShaderPrecisionFormat\" not available");
    }
        dispatch_glGetShaderPrecisionFormat1(shadertype, precisiontype, range, Buffers.SIZEOF_INT * range_offset, false, precision, Buffers.SIZEOF_INT * precision_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderSource}(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  source); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param source a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetShaderSource(int shader, int bufSize, IntBuffer length, ByteBuffer source)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean source_is_direct = Buffers.isDirect(source);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderSource;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetShaderSource\" not available");
    }
        dispatch_glGetShaderSource1(shader, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, source_is_direct ? source : Buffers.getArray(source), source_is_direct ? Buffers.getDirectBufferByteOffset(source) : Buffers.getIndirectBufferByteOffset(source), source_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderSource}(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  source); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param source a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetShaderSource1(int shader, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object source, int source_byte_offset, boolean source_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetShaderSource}(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  source); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glGetShaderSource(int shader, int bufSize, int[] length, int length_offset, byte[] source, int source_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(source != null && source.length <= source_offset)
      throw new GLException("array offset argument \"source_offset\" (" + source_offset + ") equals or exceeds array length (" + source.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderSource;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetShaderSource\" not available");
    }
        dispatch_glGetShaderSource1(shader, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, source, source_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderSourceARB}(GLhandleARB obj, GLsizei maxLength, GLsizei *  length, GLcharARB *  source); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param source a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetShaderSourceARB(int obj, int maxLength, IntBuffer length, ByteBuffer source)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean source_is_direct = Buffers.isDirect(source);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderSourceARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetShaderSourceARB\" not available");
    }
        dispatch_glGetShaderSourceARB1(obj, maxLength, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, source_is_direct ? source : Buffers.getArray(source), source_is_direct ? Buffers.getDirectBufferByteOffset(source) : Buffers.getIndirectBufferByteOffset(source), source_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderSourceARB}(GLhandleARB obj, GLsizei maxLength, GLsizei *  length, GLcharARB *  source); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param source a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetShaderSourceARB1(int obj, int maxLength, Object length, int length_byte_offset, boolean length_is_direct, Object source, int source_byte_offset, boolean source_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetShaderSourceARB}(GLhandleARB obj, GLsizei maxLength, GLsizei *  length, GLcharARB *  source); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glGetShaderSourceARB(int obj, int maxLength, int[] length, int length_offset, byte[] source, int source_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(source != null && source.length <= source_offset)
      throw new GLException("array offset argument \"source_offset\" (" + source_offset + ") equals or exceeds array length (" + source.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderSourceARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetShaderSourceARB\" not available");
    }
        dispatch_glGetShaderSourceARB1(obj, maxLength, length, Buffers.SIZEOF_INT * length_offset, false, source, source_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderiv}(GLuint shader, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetShaderiv(int shader, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetShaderiv\" not available");
    }
        dispatch_glGetShaderiv1(shader, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderiv}(GLuint shader, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetShaderiv1(int shader, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetShaderiv}(GLuint shader, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glGetShaderiv(int shader, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetShaderiv\" not available");
    }
        dispatch_glGetShaderiv1(shader, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> const GLubyte *  {@native glGetString}(GLenum name); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public String glGetString(int name)  {

    if(_context.isExtensionCacheInitialized()) {
    if(GL.GL_EXTENSIONS==name) {
    return _context.getGLExtensionsString();
    } /* else if(GL.GL_VERSION==name) {
    return _context.getGLVersion();
    } */
    }
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetString;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetString\" not available");
    }
        return dispatch_glGetString1(name, __addr_);
  }

  /** Entry point to C language function: <code> const GLubyte *  {@native glGetString}(GLenum name); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  private native String dispatch_glGetString1(int name, long procAddress);

  /** Entry point to C language function: <code> const GLubyte *  {@native glGetStringi}(GLenum name, GLuint index); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public String glGetStringi(int name, int index)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetStringi;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetStringi\" not available");
    }
        return dispatch_glGetStringi1(name, index, __addr_);
  }

  /** Entry point to C language function: <code> const GLubyte *  {@native glGetStringi}(GLenum name, GLuint index); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public native String dispatch_glGetStringi1(int name, int index, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glGetSubroutineIndex}(GLuint program, GLenum shadertype, const GLchar *  name); </code> <br>Part of <code>GL_ARB_shader_subroutine</code>   */
  public int glGetSubroutineIndex(int program, int shadertype, String name)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetSubroutineIndex;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetSubroutineIndex\" not available");
    }
        return dispatch_glGetSubroutineIndex1(program, shadertype, name, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGetSubroutineIndex}(GLuint program, GLenum shadertype, const GLchar *  name); </code> <br>Part of <code>GL_ARB_shader_subroutine</code>   */
  public native int dispatch_glGetSubroutineIndex1(int program, int shadertype, String name, long procAddress);

  /** Entry point to C language function: <code> GLint {@native glGetSubroutineUniformLocation}(GLuint program, GLenum shadertype, const GLchar *  name); </code> <br>Part of <code>GL_ARB_shader_subroutine</code>   */
  public int glGetSubroutineUniformLocation(int program, int shadertype, String name)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetSubroutineUniformLocation;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetSubroutineUniformLocation\" not available");
    }
        return dispatch_glGetSubroutineUniformLocation1(program, shadertype, name, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetSubroutineUniformLocation}(GLuint program, GLenum shadertype, const GLchar *  name); </code> <br>Part of <code>GL_ARB_shader_subroutine</code>   */
  public native int dispatch_glGetSubroutineUniformLocation1(int program, int shadertype, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetSynciv}(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *  length, GLint *  values); </code> <br>Part of <code>GL_ARB_sync</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetSynciv(long sync, int pname, int bufSize, IntBuffer length, IntBuffer values)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetSynciv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetSynciv\" not available");
    }
        dispatch_glGetSynciv1(sync, pname, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSynciv}(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *  length, GLint *  values); </code> <br>Part of <code>GL_ARB_sync</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetSynciv1(long sync, int pname, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetSynciv}(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *  length, GLint *  values); </code> <br>Part of <code>GL_ARB_sync</code>   */
  public void glGetSynciv(long sync, int pname, int bufSize, int[] length, int length_offset, int[] values, int values_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetSynciv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetSynciv\" not available");
    }
        dispatch_glGetSynciv1(sync, pname, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexEnvfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTexEnvfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexEnvfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexEnvfv\" not available");
    }
        dispatch_glGetTexEnvfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexEnvfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTexEnvfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexEnvfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetTexEnvfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexEnvfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexEnvfv\" not available");
    }
        dispatch_glGetTexEnvfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexEnviv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexEnviv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexEnviv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexEnviv\" not available");
    }
        dispatch_glGetTexEnviv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexEnviv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexEnviv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexEnviv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetTexEnviv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexEnviv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexEnviv\" not available");
    }
        dispatch_glGetTexEnviv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGendv}(GLenum coord, GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetTexGendv(int coord, int pname, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexGendv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexGendv\" not available");
    }
        dispatch_glGetTexGendv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGendv}(GLenum coord, GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetTexGendv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexGendv}(GLenum coord, GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetTexGendv(int coord, int pname, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexGendv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexGendv\" not available");
    }
        dispatch_glGetTexGendv1(coord, pname, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGenfv}(GLenum coord, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTexGenfv(int coord, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexGenfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexGenfv\" not available");
    }
        dispatch_glGetTexGenfv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGenfv}(GLenum coord, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTexGenfv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexGenfv}(GLenum coord, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetTexGenfv(int coord, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexGenfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexGenfv\" not available");
    }
        dispatch_glGetTexGenfv1(coord, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGeniv}(GLenum coord, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexGeniv(int coord, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexGeniv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexGeniv\" not available");
    }
        dispatch_glGetTexGeniv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGeniv}(GLenum coord, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexGeniv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexGeniv}(GLenum coord, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetTexGeniv(int coord, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexGeniv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexGeniv\" not available");
    }
        dispatch_glGetTexGeniv1(coord, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexImage}(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetTexImage(int target, int level, int format, int type, Buffer pixels)  {

    checkPackPBODisabled(true);
    int width = 0, height = 0, depth = 1;
    int[] tmp = new int[1];
    glGetTexLevelParameteriv(target, level, GL_TEXTURE_WIDTH, tmp, 0);
    width = tmp[0];
    glGetTexLevelParameteriv(target, level, GL_TEXTURE_HEIGHT, tmp, 0);
    height = tmp[0];
    if (target == GL_TEXTURE_3D) {
    glGetTexLevelParameteriv(target, level, GL_TEXTURE_DEPTH, tmp, 0);
    depth = tmp[0];
    }
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width          , height         , depth, true));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexImage;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexImage\" not available");
    }
        dispatch_glGetTexImage1(target, level, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexImage}(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetTexImage1(int target, int level, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexImage}(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetTexImage(int target, int level, int format, int type, long pixels_buffer_offset)  {

    checkPackPBOEnabled(true);
    int width = 0, height = 0, depth = 1;
    int[] tmp = new int[1];
    glGetTexLevelParameteriv(target, level, GL_TEXTURE_WIDTH, tmp, 0);
    width = tmp[0];
    glGetTexLevelParameteriv(target, level, GL_TEXTURE_HEIGHT, tmp, 0);
    height = tmp[0];
    if (target == GL_TEXTURE_3D) {
    glGetTexLevelParameteriv(target, level, GL_TEXTURE_DEPTH, tmp, 0);
    depth = tmp[0];
    }
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexImage;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexImage\" not available");
    }
        dispatch_glGetTexImage1(target, level, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexImage}(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  private native void dispatch_glGetTexImage1(int target, int level, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexLevelParameterfv}(GLenum target, GLint level, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTexLevelParameterfv(int target, int level, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexLevelParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexLevelParameterfv\" not available");
    }
        dispatch_glGetTexLevelParameterfv1(target, level, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexLevelParameterfv}(GLenum target, GLint level, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTexLevelParameterfv1(int target, int level, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexLevelParameterfv}(GLenum target, GLint level, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetTexLevelParameterfv(int target, int level, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexLevelParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexLevelParameterfv\" not available");
    }
        dispatch_glGetTexLevelParameterfv1(target, level, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexLevelParameteriv}(GLenum target, GLint level, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexLevelParameteriv(int target, int level, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexLevelParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexLevelParameteriv\" not available");
    }
        dispatch_glGetTexLevelParameteriv1(target, level, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexLevelParameteriv}(GLenum target, GLint level, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexLevelParameteriv1(int target, int level, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexLevelParameteriv}(GLenum target, GLint level, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetTexLevelParameteriv(int target, int level, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexLevelParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexLevelParameteriv\" not available");
    }
        dispatch_glGetTexLevelParameteriv1(target, level, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterIiv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_texture_integer</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexParameterIiv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexParameterIiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexParameterIiv\" not available");
    }
        dispatch_glGetTexParameterIiv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterIiv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_texture_integer</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexParameterIiv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameterIiv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_texture_integer</code>   */
  public void glGetTexParameterIiv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexParameterIiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexParameterIiv\" not available");
    }
        dispatch_glGetTexParameterIiv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterIuiv}(GLenum target, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_texture_integer</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexParameterIuiv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexParameterIuiv\" not available");
    }
        dispatch_glGetTexParameterIuiv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterIuiv}(GLenum target, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_texture_integer</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexParameterIuiv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameterIuiv}(GLenum target, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_texture_integer</code>   */
  public void glGetTexParameterIuiv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexParameterIuiv\" not available");
    }
        dispatch_glGetTexParameterIuiv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTexParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexParameterfv\" not available");
    }
        dispatch_glGetTexParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTexParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetTexParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexParameterfv\" not available");
    }
        dispatch_glGetTexParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexParameteriv\" not available");
    }
        dispatch_glGetTexParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glGetTexParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexParameteriv\" not available");
    }
        dispatch_glGetTexParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureImageEXT}(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetTextureImageEXT(int texture, int target, int level, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTextureImageEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTextureImageEXT\" not available");
    }
        dispatch_glGetTextureImageEXT1(texture, target, level, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureImageEXT}(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetTextureImageEXT1(int texture, int target, int level, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureLevelParameterfvEXT}(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTextureLevelParameterfvEXT(int texture, int target, int level, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTextureLevelParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTextureLevelParameterfvEXT\" not available");
    }
        dispatch_glGetTextureLevelParameterfvEXT1(texture, target, level, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureLevelParameterfvEXT}(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTextureLevelParameterfvEXT1(int texture, int target, int level, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureLevelParameterfvEXT}(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetTextureLevelParameterfvEXT(int texture, int target, int level, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTextureLevelParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTextureLevelParameterfvEXT\" not available");
    }
        dispatch_glGetTextureLevelParameterfvEXT1(texture, target, level, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureLevelParameterivEXT}(GLuint texture, GLenum target, GLint level, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTextureLevelParameterivEXT(int texture, int target, int level, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTextureLevelParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTextureLevelParameterivEXT\" not available");
    }
        dispatch_glGetTextureLevelParameterivEXT1(texture, target, level, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureLevelParameterivEXT}(GLuint texture, GLenum target, GLint level, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTextureLevelParameterivEXT1(int texture, int target, int level, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureLevelParameterivEXT}(GLuint texture, GLenum target, GLint level, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetTextureLevelParameterivEXT(int texture, int target, int level, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTextureLevelParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTextureLevelParameterivEXT\" not available");
    }
        dispatch_glGetTextureLevelParameterivEXT1(texture, target, level, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureParameterIivEXT}(GLuint texture, GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTextureParameterIivEXT(int texture, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTextureParameterIivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTextureParameterIivEXT\" not available");
    }
        dispatch_glGetTextureParameterIivEXT1(texture, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureParameterIivEXT}(GLuint texture, GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTextureParameterIivEXT1(int texture, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureParameterIivEXT}(GLuint texture, GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetTextureParameterIivEXT(int texture, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTextureParameterIivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTextureParameterIivEXT\" not available");
    }
        dispatch_glGetTextureParameterIivEXT1(texture, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureParameterIuivEXT}(GLuint texture, GLenum target, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTextureParameterIuivEXT(int texture, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTextureParameterIuivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTextureParameterIuivEXT\" not available");
    }
        dispatch_glGetTextureParameterIuivEXT1(texture, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureParameterIuivEXT}(GLuint texture, GLenum target, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTextureParameterIuivEXT1(int texture, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureParameterIuivEXT}(GLuint texture, GLenum target, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetTextureParameterIuivEXT(int texture, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTextureParameterIuivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTextureParameterIuivEXT\" not available");
    }
        dispatch_glGetTextureParameterIuivEXT1(texture, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureParameterfvEXT}(GLuint texture, GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTextureParameterfvEXT(int texture, int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTextureParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTextureParameterfvEXT\" not available");
    }
        dispatch_glGetTextureParameterfvEXT1(texture, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureParameterfvEXT}(GLuint texture, GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTextureParameterfvEXT1(int texture, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureParameterfvEXT}(GLuint texture, GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetTextureParameterfvEXT(int texture, int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTextureParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTextureParameterfvEXT\" not available");
    }
        dispatch_glGetTextureParameterfvEXT1(texture, target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureParameterivEXT}(GLuint texture, GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTextureParameterivEXT(int texture, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTextureParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTextureParameterivEXT\" not available");
    }
        dispatch_glGetTextureParameterivEXT1(texture, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureParameterivEXT}(GLuint texture, GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTextureParameterivEXT1(int texture, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureParameterivEXT}(GLuint texture, GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glGetTextureParameterivEXT(int texture, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTextureParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTextureParameterivEXT\" not available");
    }
        dispatch_glGetTextureParameterivEXT1(texture, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTransformFeedbackVarying}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLsizei *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_transform_feedback</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetTransformFeedbackVarying(int program, int index, int bufSize, IntBuffer length, IntBuffer size, IntBuffer type, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean size_is_direct = Buffers.isDirect(size);
    final boolean type_is_direct = Buffers.isDirect(type);
    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTransformFeedbackVarying;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTransformFeedbackVarying\" not available");
    }
        dispatch_glGetTransformFeedbackVarying1(program, index, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, size_is_direct ? size : Buffers.getArray(size), size_is_direct ? Buffers.getDirectBufferByteOffset(size) : Buffers.getIndirectBufferByteOffset(size), size_is_direct, type_is_direct ? type : Buffers.getArray(type), type_is_direct ? Buffers.getDirectBufferByteOffset(type) : Buffers.getIndirectBufferByteOffset(type), type_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTransformFeedbackVarying}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLsizei *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_transform_feedback</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetTransformFeedbackVarying1(int program, int index, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object size, int size_byte_offset, boolean size_is_direct, Object type, int type_byte_offset, boolean type_is_direct, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTransformFeedbackVarying}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLsizei *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_transform_feedback</code>   */
  public void glGetTransformFeedbackVarying(int program, int index, int bufSize, int[] length, int length_offset, int[] size, int size_offset, int[] type, int type_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(size != null && size.length <= size_offset)
      throw new GLException("array offset argument \"size_offset\" (" + size_offset + ") equals or exceeds array length (" + size.length + ")");
    if(type != null && type.length <= type_offset)
      throw new GLException("array offset argument \"type_offset\" (" + type_offset + ") equals or exceeds array length (" + type.length + ")");
    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTransformFeedbackVarying;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTransformFeedbackVarying\" not available");
    }
        dispatch_glGetTransformFeedbackVarying1(program, index, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, size, Buffers.SIZEOF_INT * size_offset, false, type, Buffers.SIZEOF_INT * type_offset, false, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGetUniformBlockIndex}(GLuint program, const GLchar *  uniformBlockName); </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>   */
  public int glGetUniformBlockIndex(int program, String uniformBlockName)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformBlockIndex;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformBlockIndex\" not available");
    }
        return dispatch_glGetUniformBlockIndex1(program, uniformBlockName, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGetUniformBlockIndex}(GLuint program, const GLchar *  uniformBlockName); </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>   */
  public native int dispatch_glGetUniformBlockIndex1(int program, String uniformBlockName, long procAddress);

  /** Entry point to C language function: <code> GLint {@native glGetUniformBufferSizeEXT}(GLuint program, GLint location); </code> <br>Part of <code>GL_EXT_bindable_uniform</code>   */
  public int glGetUniformBufferSizeEXT(int program, int location)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformBufferSizeEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformBufferSizeEXT\" not available");
    }
        return dispatch_glGetUniformBufferSizeEXT1(program, location, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetUniformBufferSizeEXT}(GLuint program, GLint location); </code> <br>Part of <code>GL_EXT_bindable_uniform</code>   */
  public native int dispatch_glGetUniformBufferSizeEXT1(int program, int location, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformIndices}(GLuint program, GLsizei uniformCount, const GLchar *  *  uniformNames, GLuint *  uniformIndices); </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>
      @param uniformIndices a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetUniformIndices(int program, int uniformCount, String[] uniformNames, IntBuffer uniformIndices)  {

    final boolean uniformIndices_is_direct = Buffers.isDirect(uniformIndices);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformIndices;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformIndices\" not available");
    }
        dispatch_glGetUniformIndices1(program, uniformCount, uniformNames, uniformIndices_is_direct ? uniformIndices : Buffers.getArray(uniformIndices), uniformIndices_is_direct ? Buffers.getDirectBufferByteOffset(uniformIndices) : Buffers.getIndirectBufferByteOffset(uniformIndices), uniformIndices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformIndices}(GLuint program, GLsizei uniformCount, const GLchar *  *  uniformNames, GLuint *  uniformIndices); </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>
      @param uniformIndices a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetUniformIndices1(int program, int uniformCount, String[] uniformNames, Object uniformIndices, int uniformIndices_byte_offset, boolean uniformIndices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformIndices}(GLuint program, GLsizei uniformCount, const GLchar *  *  uniformNames, GLuint *  uniformIndices); </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>   */
  public void glGetUniformIndices(int program, int uniformCount, String[] uniformNames, int[] uniformIndices, int uniformIndices_offset)  {

    if(uniformIndices != null && uniformIndices.length <= uniformIndices_offset)
      throw new GLException("array offset argument \"uniformIndices_offset\" (" + uniformIndices_offset + ") equals or exceeds array length (" + uniformIndices.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformIndices;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformIndices\" not available");
    }
        dispatch_glGetUniformIndices1(program, uniformCount, uniformNames, uniformIndices, Buffers.SIZEOF_INT * uniformIndices_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetUniformLocation}(GLuint program, const GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public int glGetUniformLocation(int program, String name)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformLocation;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformLocation\" not available");
    }
        return dispatch_glGetUniformLocation1(program, name, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetUniformLocation}(GLuint program, const GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native int dispatch_glGetUniformLocation1(int program, String name, long procAddress);

  /** Entry point to C language function: <code> GLint {@native glGetUniformLocationARB}(GLhandleARB programObj, const GLcharARB *  name); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public int glGetUniformLocationARB(int programObj, String name)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformLocationARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformLocationARB\" not available");
    }
        return dispatch_glGetUniformLocationARB1(programObj, name, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetUniformLocationARB}(GLhandleARB programObj, const GLcharARB *  name); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public native int dispatch_glGetUniformLocationARB1(int programObj, String name, long procAddress);

  /** Entry point to C language function: <code> GLintptr {@native glGetUniformOffsetEXT}(GLuint program, GLint location); </code> <br>Part of <code>GL_EXT_bindable_uniform</code>   */
  public long glGetUniformOffsetEXT(int program, int location)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformOffsetEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformOffsetEXT\" not available");
    }
        return dispatch_glGetUniformOffsetEXT1(program, location, __addr_);
  }

  /** Entry point to C language function: <code> GLintptr {@native glGetUniformOffsetEXT}(GLuint program, GLint location); </code> <br>Part of <code>GL_EXT_bindable_uniform</code>   */
  public native long dispatch_glGetUniformOffsetEXT1(int program, int location, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformSubroutineuiv}(GLenum shadertype, GLint location, GLuint *  params); </code> <br>Part of <code>GL_ARB_shader_subroutine</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetUniformSubroutineuiv(int shadertype, int location, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformSubroutineuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformSubroutineuiv\" not available");
    }
        dispatch_glGetUniformSubroutineuiv1(shadertype, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformSubroutineuiv}(GLenum shadertype, GLint location, GLuint *  params); </code> <br>Part of <code>GL_ARB_shader_subroutine</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetUniformSubroutineuiv1(int shadertype, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformSubroutineuiv}(GLenum shadertype, GLint location, GLuint *  params); </code> <br>Part of <code>GL_ARB_shader_subroutine</code>   */
  public void glGetUniformSubroutineuiv(int shadertype, int location, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformSubroutineuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformSubroutineuiv\" not available");
    }
        dispatch_glGetUniformSubroutineuiv1(shadertype, location, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformdv}(GLuint program, GLint location, GLdouble *  params); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetUniformdv(int program, int location, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformdv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformdv\" not available");
    }
        dispatch_glGetUniformdv1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformdv}(GLuint program, GLint location, GLdouble *  params); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetUniformdv1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformdv}(GLuint program, GLint location, GLdouble *  params); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>   */
  public void glGetUniformdv(int program, int location, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformdv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformdv\" not available");
    }
        dispatch_glGetUniformdv1(program, location, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformfv}(GLuint program, GLint location, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetUniformfv(int program, int location, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformfv\" not available");
    }
        dispatch_glGetUniformfv1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformfv}(GLuint program, GLint location, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetUniformfv1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformfv}(GLuint program, GLint location, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glGetUniformfv(int program, int location, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformfv\" not available");
    }
        dispatch_glGetUniformfv1(program, location, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformfvARB}(GLhandleARB programObj, GLint location, GLfloat *  params); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetUniformfvARB(int programObj, int location, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformfvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformfvARB\" not available");
    }
        dispatch_glGetUniformfvARB1(programObj, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformfvARB}(GLhandleARB programObj, GLint location, GLfloat *  params); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetUniformfvARB1(int programObj, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformfvARB}(GLhandleARB programObj, GLint location, GLfloat *  params); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glGetUniformfvARB(int programObj, int location, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformfvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformfvARB\" not available");
    }
        dispatch_glGetUniformfvARB1(programObj, location, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformi64vNV}(GLuint program, GLint location, GLint64EXT *  params); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetUniformi64vNV(int program, int location, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformi64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformi64vNV\" not available");
    }
        dispatch_glGetUniformi64vNV1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformi64vNV}(GLuint program, GLint location, GLint64EXT *  params); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetUniformi64vNV1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformi64vNV}(GLuint program, GLint location, GLint64EXT *  params); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glGetUniformi64vNV(int program, int location, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformi64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformi64vNV\" not available");
    }
        dispatch_glGetUniformi64vNV1(program, location, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformiv}(GLuint program, GLint location, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetUniformiv(int program, int location, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformiv\" not available");
    }
        dispatch_glGetUniformiv1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformiv}(GLuint program, GLint location, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetUniformiv1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformiv}(GLuint program, GLint location, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glGetUniformiv(int program, int location, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformiv\" not available");
    }
        dispatch_glGetUniformiv1(program, location, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformivARB}(GLhandleARB programObj, GLint location, GLint *  params); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetUniformivARB(int programObj, int location, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformivARB\" not available");
    }
        dispatch_glGetUniformivARB1(programObj, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformivARB}(GLhandleARB programObj, GLint location, GLint *  params); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetUniformivARB1(int programObj, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformivARB}(GLhandleARB programObj, GLint location, GLint *  params); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glGetUniformivARB(int programObj, int location, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformivARB\" not available");
    }
        dispatch_glGetUniformivARB1(programObj, location, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformui64vNV}(GLuint program, GLint location, GLuint64EXT *  params); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetUniformui64vNV(int program, int location, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformui64vNV\" not available");
    }
        dispatch_glGetUniformui64vNV1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformui64vNV}(GLuint program, GLint location, GLuint64EXT *  params); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetUniformui64vNV1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformui64vNV}(GLuint program, GLint location, GLuint64EXT *  params); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>   */
  public void glGetUniformui64vNV(int program, int location, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformui64vNV\" not available");
    }
        dispatch_glGetUniformui64vNV1(program, location, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformuiv}(GLuint program, GLint location, GLuint *  params); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetUniformuiv(int program, int location, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformuiv\" not available");
    }
        dispatch_glGetUniformuiv1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformuiv}(GLuint program, GLint location, GLuint *  params); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetUniformuiv1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformuiv}(GLuint program, GLint location, GLuint *  params); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public void glGetUniformuiv(int program, int location, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformuiv\" not available");
    }
        dispatch_glGetUniformuiv1(program, location, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVariantBooleanvEXT}(GLuint id, GLenum value, GLboolean *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetVariantBooleanvEXT(int id, int value, ByteBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVariantBooleanvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVariantBooleanvEXT\" not available");
    }
        dispatch_glGetVariantBooleanvEXT1(id, value, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVariantBooleanvEXT}(GLuint id, GLenum value, GLboolean *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetVariantBooleanvEXT1(int id, int value, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVariantBooleanvEXT}(GLuint id, GLenum value, GLboolean *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glGetVariantBooleanvEXT(int id, int value, byte[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVariantBooleanvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVariantBooleanvEXT\" not available");
    }
        dispatch_glGetVariantBooleanvEXT1(id, value, data, data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVariantFloatvEXT}(GLuint id, GLenum value, GLfloat *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetVariantFloatvEXT(int id, int value, FloatBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVariantFloatvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVariantFloatvEXT\" not available");
    }
        dispatch_glGetVariantFloatvEXT1(id, value, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVariantFloatvEXT}(GLuint id, GLenum value, GLfloat *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetVariantFloatvEXT1(int id, int value, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVariantFloatvEXT}(GLuint id, GLenum value, GLfloat *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glGetVariantFloatvEXT(int id, int value, float[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVariantFloatvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVariantFloatvEXT\" not available");
    }
        dispatch_glGetVariantFloatvEXT1(id, value, data, Buffers.SIZEOF_FLOAT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVariantIntegervEXT}(GLuint id, GLenum value, GLint *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVariantIntegervEXT(int id, int value, IntBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVariantIntegervEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVariantIntegervEXT\" not available");
    }
        dispatch_glGetVariantIntegervEXT1(id, value, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVariantIntegervEXT}(GLuint id, GLenum value, GLint *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVariantIntegervEXT1(int id, int value, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVariantIntegervEXT}(GLuint id, GLenum value, GLint *  data); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glGetVariantIntegervEXT(int id, int value, int[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVariantIntegervEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVariantIntegervEXT\" not available");
    }
        dispatch_glGetVariantIntegervEXT1(id, value, data, Buffers.SIZEOF_INT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIiv}(GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVertexAttribIiv(int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribIiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribIiv\" not available");
    }
        dispatch_glGetVertexAttribIiv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIiv}(GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVertexAttribIiv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIiv}(GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glGetVertexAttribIiv(int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribIiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribIiv\" not available");
    }
        dispatch_glGetVertexAttribIiv1(index, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIivEXT}(GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVertexAttribIivEXT(int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribIivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribIivEXT\" not available");
    }
        dispatch_glGetVertexAttribIivEXT1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIivEXT}(GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVertexAttribIivEXT1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIivEXT}(GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public void glGetVertexAttribIivEXT(int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribIivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribIivEXT\" not available");
    }
        dispatch_glGetVertexAttribIivEXT1(index, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIuiv}(GLuint index, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVertexAttribIuiv(int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribIuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribIuiv\" not available");
    }
        dispatch_glGetVertexAttribIuiv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIuiv}(GLuint index, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVertexAttribIuiv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIuiv}(GLuint index, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glGetVertexAttribIuiv(int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribIuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribIuiv\" not available");
    }
        dispatch_glGetVertexAttribIuiv1(index, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIuivEXT}(GLuint index, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVertexAttribIuivEXT(int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribIuivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribIuivEXT\" not available");
    }
        dispatch_glGetVertexAttribIuivEXT1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIuivEXT}(GLuint index, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVertexAttribIuivEXT1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIuivEXT}(GLuint index, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public void glGetVertexAttribIuivEXT(int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribIuivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribIuivEXT\" not available");
    }
        dispatch_glGetVertexAttribIuivEXT1(index, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribLdv}(GLuint index, GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetVertexAttribLdv(int index, int pname, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribLdv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribLdv\" not available");
    }
        dispatch_glGetVertexAttribLdv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribLdv}(GLuint index, GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetVertexAttribLdv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribLdv}(GLuint index, GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>   */
  public void glGetVertexAttribLdv(int index, int pname, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribLdv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribLdv\" not available");
    }
        dispatch_glGetVertexAttribLdv1(index, pname, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribLi64vNV}(GLuint index, GLenum pname, GLint64EXT *  params); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetVertexAttribLi64vNV(int index, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribLi64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribLi64vNV\" not available");
    }
        dispatch_glGetVertexAttribLi64vNV1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribLi64vNV}(GLuint index, GLenum pname, GLint64EXT *  params); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetVertexAttribLi64vNV1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribLi64vNV}(GLuint index, GLenum pname, GLint64EXT *  params); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public void glGetVertexAttribLi64vNV(int index, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribLi64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribLi64vNV\" not available");
    }
        dispatch_glGetVertexAttribLi64vNV1(index, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribLui64vNV}(GLuint index, GLenum pname, GLuint64EXT *  params); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetVertexAttribLui64vNV(int index, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribLui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribLui64vNV\" not available");
    }
        dispatch_glGetVertexAttribLui64vNV1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribLui64vNV}(GLuint index, GLenum pname, GLuint64EXT *  params); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetVertexAttribLui64vNV1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribLui64vNV}(GLuint index, GLenum pname, GLuint64EXT *  params); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public void glGetVertexAttribLui64vNV(int index, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribLui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribLui64vNV\" not available");
    }
        dispatch_glGetVertexAttribLui64vNV1(index, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribdv}(GLuint index, GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetVertexAttribdv(int index, int pname, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribdv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribdv\" not available");
    }
        dispatch_glGetVertexAttribdv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribdv}(GLuint index, GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetVertexAttribdv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribdv}(GLuint index, GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glGetVertexAttribdv(int index, int pname, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribdv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribdv\" not available");
    }
        dispatch_glGetVertexAttribdv1(index, pname, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribdvARB}(GLuint index, GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetVertexAttribdvARB(int index, int pname, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribdvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribdvARB\" not available");
    }
        dispatch_glGetVertexAttribdvARB1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribdvARB}(GLuint index, GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetVertexAttribdvARB1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribdvARB}(GLuint index, GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glGetVertexAttribdvARB(int index, int pname, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribdvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribdvARB\" not available");
    }
        dispatch_glGetVertexAttribdvARB1(index, pname, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribfv}(GLuint index, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetVertexAttribfv(int index, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribfv\" not available");
    }
        dispatch_glGetVertexAttribfv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribfv}(GLuint index, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetVertexAttribfv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribfv}(GLuint index, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glGetVertexAttribfv(int index, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribfv\" not available");
    }
        dispatch_glGetVertexAttribfv1(index, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribfvARB}(GLuint index, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetVertexAttribfvARB(int index, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribfvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribfvARB\" not available");
    }
        dispatch_glGetVertexAttribfvARB1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribfvARB}(GLuint index, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetVertexAttribfvARB1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribfvARB}(GLuint index, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glGetVertexAttribfvARB(int index, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribfvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribfvARB\" not available");
    }
        dispatch_glGetVertexAttribfvARB1(index, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribiv}(GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVertexAttribiv(int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribiv\" not available");
    }
        dispatch_glGetVertexAttribiv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribiv}(GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVertexAttribiv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribiv}(GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glGetVertexAttribiv(int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribiv\" not available");
    }
        dispatch_glGetVertexAttribiv1(index, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribivARB}(GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVertexAttribivARB(int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribivARB\" not available");
    }
        dispatch_glGetVertexAttribivARB1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribivARB}(GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVertexAttribivARB1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribivARB}(GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glGetVertexAttribivARB(int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribivARB\" not available");
    }
        dispatch_glGetVertexAttribivARB1(index, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureStreamdvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_NV_video_capture</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetVideoCaptureStreamdvNV(int video_capture_slot, int stream, int pname, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVideoCaptureStreamdvNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVideoCaptureStreamdvNV\" not available");
    }
        dispatch_glGetVideoCaptureStreamdvNV1(video_capture_slot, stream, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureStreamdvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_NV_video_capture</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetVideoCaptureStreamdvNV1(int video_capture_slot, int stream, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureStreamdvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *  params); </code> <br>Part of <code>GL_NV_video_capture</code>   */
  public void glGetVideoCaptureStreamdvNV(int video_capture_slot, int stream, int pname, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVideoCaptureStreamdvNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVideoCaptureStreamdvNV\" not available");
    }
        dispatch_glGetVideoCaptureStreamdvNV1(video_capture_slot, stream, pname, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureStreamfvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_NV_video_capture</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetVideoCaptureStreamfvNV(int video_capture_slot, int stream, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVideoCaptureStreamfvNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVideoCaptureStreamfvNV\" not available");
    }
        dispatch_glGetVideoCaptureStreamfvNV1(video_capture_slot, stream, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureStreamfvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_NV_video_capture</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetVideoCaptureStreamfvNV1(int video_capture_slot, int stream, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureStreamfvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_NV_video_capture</code>   */
  public void glGetVideoCaptureStreamfvNV(int video_capture_slot, int stream, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVideoCaptureStreamfvNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVideoCaptureStreamfvNV\" not available");
    }
        dispatch_glGetVideoCaptureStreamfvNV1(video_capture_slot, stream, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureStreamivNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_video_capture</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVideoCaptureStreamivNV(int video_capture_slot, int stream, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVideoCaptureStreamivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVideoCaptureStreamivNV\" not available");
    }
        dispatch_glGetVideoCaptureStreamivNV1(video_capture_slot, stream, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureStreamivNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_video_capture</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVideoCaptureStreamivNV1(int video_capture_slot, int stream, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureStreamivNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_video_capture</code>   */
  public void glGetVideoCaptureStreamivNV(int video_capture_slot, int stream, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVideoCaptureStreamivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVideoCaptureStreamivNV\" not available");
    }
        dispatch_glGetVideoCaptureStreamivNV1(video_capture_slot, stream, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureivNV}(GLuint video_capture_slot, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_video_capture</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVideoCaptureivNV(int video_capture_slot, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVideoCaptureivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVideoCaptureivNV\" not available");
    }
        dispatch_glGetVideoCaptureivNV1(video_capture_slot, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureivNV}(GLuint video_capture_slot, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_video_capture</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVideoCaptureivNV1(int video_capture_slot, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureivNV}(GLuint video_capture_slot, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_video_capture</code>   */
  public void glGetVideoCaptureivNV(int video_capture_slot, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVideoCaptureivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVideoCaptureivNV\" not available");
    }
        dispatch_glGetVideoCaptureivNV1(video_capture_slot, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnColorTableARB}(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *  table); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param table a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetnColorTable(int target, int format, int type, int bufSize, Buffer table)  {

    final boolean table_is_direct = Buffers.isDirect(table);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnColorTable;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnColorTable\" not available");
    }
        dispatch_glGetnColorTable1(target, format, type, bufSize, table_is_direct ? table : Buffers.getArray(table), table_is_direct ? Buffers.getDirectBufferByteOffset(table) : Buffers.getIndirectBufferByteOffset(table), table_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnColorTableARB}(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *  table); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param table a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetnColorTable1(int target, int format, int type, int bufSize, Object table, int table_byte_offset, boolean table_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnCompressedTexImageARB}(GLenum target, GLint lod, GLsizei bufSize, GLvoid *  img); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param img a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetnCompressedTexImage(int target, int lod, int bufSize, Buffer img)  {

    final boolean img_is_direct = Buffers.isDirect(img);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnCompressedTexImage;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnCompressedTexImage\" not available");
    }
        dispatch_glGetnCompressedTexImage1(target, lod, bufSize, img_is_direct ? img : Buffers.getArray(img), img_is_direct ? Buffers.getDirectBufferByteOffset(img) : Buffers.getIndirectBufferByteOffset(img), img_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnCompressedTexImageARB}(GLenum target, GLint lod, GLsizei bufSize, GLvoid *  img); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param img a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetnCompressedTexImage1(int target, int lod, int bufSize, Object img, int img_byte_offset, boolean img_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnConvolutionFilterARB}(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *  image); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param image a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetnConvolutionFilter(int target, int format, int type, int bufSize, Buffer image)  {

    final boolean image_is_direct = Buffers.isDirect(image);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnConvolutionFilter;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnConvolutionFilter\" not available");
    }
        dispatch_glGetnConvolutionFilter1(target, format, type, bufSize, image_is_direct ? image : Buffers.getArray(image), image_is_direct ? Buffers.getDirectBufferByteOffset(image) : Buffers.getIndirectBufferByteOffset(image), image_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnConvolutionFilterARB}(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *  image); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param image a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetnConvolutionFilter1(int target, int format, int type, int bufSize, Object image, int image_byte_offset, boolean image_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnHistogramARB}(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *  values); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param values a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetnHistogram(int target, boolean reset, int format, int type, int bufSize, Buffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnHistogram;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnHistogram\" not available");
    }
        dispatch_glGetnHistogram1(target, reset, format, type, bufSize, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnHistogramARB}(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *  values); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param values a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetnHistogram1(int target, boolean reset, int format, int type, int bufSize, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnMapdvARB}(GLenum target, GLenum query, GLsizei bufSize, GLdouble *  v); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetnMapdv(int target, int query, int bufSize, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnMapdv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnMapdv\" not available");
    }
        dispatch_glGetnMapdv1(target, query, bufSize, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnMapdvARB}(GLenum target, GLenum query, GLsizei bufSize, GLdouble *  v); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetnMapdv1(int target, int query, int bufSize, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnMapdvARB}(GLenum target, GLenum query, GLsizei bufSize, GLdouble *  v); </code> <br>Part of <code>GL_ARB_robustness</code>   */
  public void glGetnMapdv(int target, int query, int bufSize, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnMapdv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnMapdv\" not available");
    }
        dispatch_glGetnMapdv1(target, query, bufSize, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnMapfvARB}(GLenum target, GLenum query, GLsizei bufSize, GLfloat *  v); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetnMapfv(int target, int query, int bufSize, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnMapfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnMapfv\" not available");
    }
        dispatch_glGetnMapfv1(target, query, bufSize, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnMapfvARB}(GLenum target, GLenum query, GLsizei bufSize, GLfloat *  v); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetnMapfv1(int target, int query, int bufSize, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnMapfvARB}(GLenum target, GLenum query, GLsizei bufSize, GLfloat *  v); </code> <br>Part of <code>GL_ARB_robustness</code>   */
  public void glGetnMapfv(int target, int query, int bufSize, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnMapfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnMapfv\" not available");
    }
        dispatch_glGetnMapfv1(target, query, bufSize, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnMapivARB}(GLenum target, GLenum query, GLsizei bufSize, GLint *  v); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetnMapiv(int target, int query, int bufSize, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnMapiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnMapiv\" not available");
    }
        dispatch_glGetnMapiv1(target, query, bufSize, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnMapivARB}(GLenum target, GLenum query, GLsizei bufSize, GLint *  v); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetnMapiv1(int target, int query, int bufSize, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnMapivARB}(GLenum target, GLenum query, GLsizei bufSize, GLint *  v); </code> <br>Part of <code>GL_ARB_robustness</code>   */
  public void glGetnMapiv(int target, int query, int bufSize, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnMapiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnMapiv\" not available");
    }
        dispatch_glGetnMapiv1(target, query, bufSize, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnMinmaxARB}(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *  values); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param values a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetnMinmax(int target, boolean reset, int format, int type, int bufSize, Buffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnMinmax;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnMinmax\" not available");
    }
        dispatch_glGetnMinmax1(target, reset, format, type, bufSize, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnMinmaxARB}(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *  values); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param values a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetnMinmax1(int target, boolean reset, int format, int type, int bufSize, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnPixelMapfvARB}(GLenum map, GLsizei bufSize, GLfloat *  values); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetnPixelMapfv(int map, int bufSize, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnPixelMapfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnPixelMapfv\" not available");
    }
        dispatch_glGetnPixelMapfv1(map, bufSize, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnPixelMapfvARB}(GLenum map, GLsizei bufSize, GLfloat *  values); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetnPixelMapfv1(int map, int bufSize, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnPixelMapfvARB}(GLenum map, GLsizei bufSize, GLfloat *  values); </code> <br>Part of <code>GL_ARB_robustness</code>   */
  public void glGetnPixelMapfv(int map, int bufSize, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnPixelMapfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnPixelMapfv\" not available");
    }
        dispatch_glGetnPixelMapfv1(map, bufSize, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnPixelMapuivARB}(GLenum map, GLsizei bufSize, GLuint *  values); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetnPixelMapuiv(int map, int bufSize, IntBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnPixelMapuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnPixelMapuiv\" not available");
    }
        dispatch_glGetnPixelMapuiv1(map, bufSize, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnPixelMapuivARB}(GLenum map, GLsizei bufSize, GLuint *  values); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetnPixelMapuiv1(int map, int bufSize, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnPixelMapuivARB}(GLenum map, GLsizei bufSize, GLuint *  values); </code> <br>Part of <code>GL_ARB_robustness</code>   */
  public void glGetnPixelMapuiv(int map, int bufSize, int[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnPixelMapuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnPixelMapuiv\" not available");
    }
        dispatch_glGetnPixelMapuiv1(map, bufSize, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnPixelMapusvARB}(GLenum map, GLsizei bufSize, GLushort *  values); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param values a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glGetnPixelMapusv(int map, int bufSize, ShortBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnPixelMapusv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnPixelMapusv\" not available");
    }
        dispatch_glGetnPixelMapusv1(map, bufSize, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnPixelMapusvARB}(GLenum map, GLsizei bufSize, GLushort *  values); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param values a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glGetnPixelMapusv1(int map, int bufSize, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnPixelMapusvARB}(GLenum map, GLsizei bufSize, GLushort *  values); </code> <br>Part of <code>GL_ARB_robustness</code>   */
  public void glGetnPixelMapusv(int map, int bufSize, short[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnPixelMapusv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnPixelMapusv\" not available");
    }
        dispatch_glGetnPixelMapusv1(map, bufSize, values, Buffers.SIZEOF_SHORT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnPolygonStippleARB}(GLsizei bufSize, GLubyte *  pattern); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param pattern a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetnPolygonStipple(int bufSize, ByteBuffer pattern)  {

    final boolean pattern_is_direct = Buffers.isDirect(pattern);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnPolygonStipple;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnPolygonStipple\" not available");
    }
        dispatch_glGetnPolygonStipple1(bufSize, pattern_is_direct ? pattern : Buffers.getArray(pattern), pattern_is_direct ? Buffers.getDirectBufferByteOffset(pattern) : Buffers.getIndirectBufferByteOffset(pattern), pattern_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnPolygonStippleARB}(GLsizei bufSize, GLubyte *  pattern); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param pattern a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetnPolygonStipple1(int bufSize, Object pattern, int pattern_byte_offset, boolean pattern_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnPolygonStippleARB}(GLsizei bufSize, GLubyte *  pattern); </code> <br>Part of <code>GL_ARB_robustness</code>   */
  public void glGetnPolygonStipple(int bufSize, byte[] pattern, int pattern_offset)  {

    if(pattern != null && pattern.length <= pattern_offset)
      throw new GLException("array offset argument \"pattern_offset\" (" + pattern_offset + ") equals or exceeds array length (" + pattern.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnPolygonStipple;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnPolygonStipple\" not available");
    }
        dispatch_glGetnPolygonStipple1(bufSize, pattern, pattern_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnSeparableFilterARB}(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, GLvoid *  row, GLsizei columnBufSize, GLvoid *  column, GLvoid *  span); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param row a direct or array-backed {@link java.nio.Buffer}
      @param column a direct or array-backed {@link java.nio.Buffer}
      @param span a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetnSeparableFilter(int target, int format, int type, int rowBufSize, Buffer row, int columnBufSize, Buffer column, Buffer span)  {

    final boolean row_is_direct = Buffers.isDirect(row);
    final boolean column_is_direct = Buffers.isDirect(column);
    final boolean span_is_direct = Buffers.isDirect(span);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnSeparableFilter;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnSeparableFilter\" not available");
    }
        dispatch_glGetnSeparableFilter1(target, format, type, rowBufSize, row_is_direct ? row : Buffers.getArray(row), row_is_direct ? Buffers.getDirectBufferByteOffset(row) : Buffers.getIndirectBufferByteOffset(row), row_is_direct, columnBufSize, column_is_direct ? column : Buffers.getArray(column), column_is_direct ? Buffers.getDirectBufferByteOffset(column) : Buffers.getIndirectBufferByteOffset(column), column_is_direct, span_is_direct ? span : Buffers.getArray(span), span_is_direct ? Buffers.getDirectBufferByteOffset(span) : Buffers.getIndirectBufferByteOffset(span), span_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnSeparableFilterARB}(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, GLvoid *  row, GLsizei columnBufSize, GLvoid *  column, GLvoid *  span); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param row a direct or array-backed {@link java.nio.Buffer}
      @param column a direct or array-backed {@link java.nio.Buffer}
      @param span a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetnSeparableFilter1(int target, int format, int type, int rowBufSize, Object row, int row_byte_offset, boolean row_is_direct, int columnBufSize, Object column, int column_byte_offset, boolean column_is_direct, Object span, int span_byte_offset, boolean span_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnTexImageARB}(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid *  img); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param img a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetnTexImage(int target, int level, int format, int type, int bufSize, Buffer img)  {

    final boolean img_is_direct = Buffers.isDirect(img);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnTexImage;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnTexImage\" not available");
    }
        dispatch_glGetnTexImage1(target, level, format, type, bufSize, img_is_direct ? img : Buffers.getArray(img), img_is_direct ? Buffers.getDirectBufferByteOffset(img) : Buffers.getIndirectBufferByteOffset(img), img_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnTexImageARB}(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid *  img); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param img a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetnTexImage1(int target, int level, int format, int type, int bufSize, Object img, int img_byte_offset, boolean img_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformdvARB}(GLuint program, GLint location, GLsizei bufSize, GLdouble *  params); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetnUniformdv(int program, int location, int bufSize, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnUniformdv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnUniformdv\" not available");
    }
        dispatch_glGetnUniformdv1(program, location, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformdvARB}(GLuint program, GLint location, GLsizei bufSize, GLdouble *  params); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetnUniformdv1(int program, int location, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformdvARB}(GLuint program, GLint location, GLsizei bufSize, GLdouble *  params); </code> <br>Part of <code>GL_ARB_robustness</code>   */
  public void glGetnUniformdv(int program, int location, int bufSize, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnUniformdv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnUniformdv\" not available");
    }
        dispatch_glGetnUniformdv1(program, location, bufSize, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformfvARB}(GLuint program, GLint location, GLsizei bufSize, GLfloat *  params); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetnUniformfv(int program, int location, int bufSize, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnUniformfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnUniformfv\" not available");
    }
        dispatch_glGetnUniformfv1(program, location, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformfvARB}(GLuint program, GLint location, GLsizei bufSize, GLfloat *  params); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetnUniformfv1(int program, int location, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformfvARB}(GLuint program, GLint location, GLsizei bufSize, GLfloat *  params); </code> <br>Part of <code>GL_ARB_robustness</code>   */
  public void glGetnUniformfv(int program, int location, int bufSize, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnUniformfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnUniformfv\" not available");
    }
        dispatch_glGetnUniformfv1(program, location, bufSize, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformivARB}(GLuint program, GLint location, GLsizei bufSize, GLint *  params); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetnUniformiv(int program, int location, int bufSize, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnUniformiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnUniformiv\" not available");
    }
        dispatch_glGetnUniformiv1(program, location, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformivARB}(GLuint program, GLint location, GLsizei bufSize, GLint *  params); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetnUniformiv1(int program, int location, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformivARB}(GLuint program, GLint location, GLsizei bufSize, GLint *  params); </code> <br>Part of <code>GL_ARB_robustness</code>   */
  public void glGetnUniformiv(int program, int location, int bufSize, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnUniformiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnUniformiv\" not available");
    }
        dispatch_glGetnUniformiv1(program, location, bufSize, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformuivARB}(GLuint program, GLint location, GLsizei bufSize, GLuint *  params); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetnUniformuiv(int program, int location, int bufSize, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnUniformuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnUniformuiv\" not available");
    }
        dispatch_glGetnUniformuiv1(program, location, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformuivARB}(GLuint program, GLint location, GLsizei bufSize, GLuint *  params); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetnUniformuiv1(int program, int location, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformuivARB}(GLuint program, GLint location, GLsizei bufSize, GLuint *  params); </code> <br>Part of <code>GL_ARB_robustness</code>   */
  public void glGetnUniformuiv(int program, int location, int bufSize, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnUniformuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnUniformuiv\" not available");
    }
        dispatch_glGetnUniformuiv1(program, location, bufSize, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glHint}(GLenum target, GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glHint(int target, int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glHint;
    if (__addr_ == 0) {
      throw new GLException("Method \"glHint\" not available");
    }
        dispatch_glHint1(target, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glHint}(GLenum target, GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glHint1(int target, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glHintPGI}(GLenum target, GLint mode); </code> <br>Part of <code>GL_PGI_misc_hints</code>   */
  public void glHintPGI(int target, int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glHintPGI;
    if (__addr_ == 0) {
      throw new GLException("Method \"glHintPGI\" not available");
    }
        dispatch_glHintPGI1(target, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glHintPGI}(GLenum target, GLint mode); </code> <br>Part of <code>GL_PGI_misc_hints</code>   */
  public native void dispatch_glHintPGI1(int target, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glHistogram}(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glHistogram(int target, int width, int internalformat, boolean sink)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glHistogram;
    if (__addr_ == 0) {
      throw new GLException("Method \"glHistogram\" not available");
    }
        dispatch_glHistogram1(target, width, internalformat, sink, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glHistogram}(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public native void dispatch_glHistogram1(int target, int width, int internalformat, boolean sink, long procAddress);

  /** Entry point to C language function: <code> GLsync {@native glImportSyncEXT}(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags); </code> <br>Part of <code>GL_EXT_x11_sync_object</code>   */
  public long glImportSyncEXT(int external_sync_type, long external_sync, int flags)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glImportSyncEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glImportSyncEXT\" not available");
    }
        return dispatch_glImportSyncEXT1(external_sync_type, external_sync, flags, __addr_);
  }

  /** Entry point to C language function: <code> GLsync {@native glImportSyncEXT}(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags); </code> <br>Part of <code>GL_EXT_x11_sync_object</code>   */
  public native long dispatch_glImportSyncEXT1(int external_sync_type, long external_sync, int flags, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexFormatNV}(GLenum type, GLsizei stride); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public void glIndexFormatNV(int type, int stride)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIndexFormatNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIndexFormatNV\" not available");
    }
        dispatch_glIndexFormatNV1(type, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexFormatNV}(GLenum type, GLsizei stride); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public native void dispatch_glIndexFormatNV1(int type, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexFuncEXT}(GLenum func, GLclampf ref); </code> <br>Part of <code>GL_EXT_index_func</code>   */
  public void glIndexFuncEXT(int func, float ref)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIndexFuncEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIndexFuncEXT\" not available");
    }
        dispatch_glIndexFuncEXT1(func, ref, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexFuncEXT}(GLenum func, GLclampf ref); </code> <br>Part of <code>GL_EXT_index_func</code>   */
  public native void dispatch_glIndexFuncEXT1(int func, float ref, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexMask}(GLuint mask); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glIndexMask(int mask)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIndexMask;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIndexMask\" not available");
    }
        dispatch_glIndexMask1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexMask}(GLuint mask); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glIndexMask1(int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexMaterialEXT}(GLenum face, GLenum mode); </code> <br>Part of <code>GL_EXT_index_material</code>   */
  public void glIndexMaterialEXT(int face, int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIndexMaterialEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIndexMaterialEXT\" not available");
    }
        dispatch_glIndexMaterialEXT1(face, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexMaterialEXT}(GLenum face, GLenum mode); </code> <br>Part of <code>GL_EXT_index_material</code>   */
  public native void dispatch_glIndexMaterialEXT1(int face, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexPointer}(GLenum type, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}   */
  public void glIndexPointer(int type, int stride, Buffer ptr)  {

    final boolean ptr_is_direct = Buffers.isDirect(ptr);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIndexPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIndexPointer\" not available");
    }
        dispatch_glIndexPointer1(type, stride, ptr_is_direct ? ptr : Buffers.getArray(ptr), ptr_is_direct ? Buffers.getDirectBufferByteOffset(ptr) : Buffers.getIndirectBufferByteOffset(ptr), ptr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexPointer}(GLenum type, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glIndexPointer1(int type, int stride, Object ptr, int ptr_byte_offset, boolean ptr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexd}(GLdouble c); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glIndexd(double c)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIndexd;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIndexd\" not available");
    }
        dispatch_glIndexd1(c, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexd}(GLdouble c); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glIndexd1(double c, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexdv}(const GLdouble *  c); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param c a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glIndexdv(DoubleBuffer c)  {

    final boolean c_is_direct = Buffers.isDirect(c);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIndexdv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIndexdv\" not available");
    }
        dispatch_glIndexdv1(c_is_direct ? c : Buffers.getArray(c), c_is_direct ? Buffers.getDirectBufferByteOffset(c) : Buffers.getIndirectBufferByteOffset(c), c_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexdv}(const GLdouble *  c); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param c a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glIndexdv1(Object c, int c_byte_offset, boolean c_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexdv}(const GLdouble *  c); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glIndexdv(double[] c, int c_offset)  {

    if(c != null && c.length <= c_offset)
      throw new GLException("array offset argument \"c_offset\" (" + c_offset + ") equals or exceeds array length (" + c.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIndexdv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIndexdv\" not available");
    }
        dispatch_glIndexdv1(c, Buffers.SIZEOF_DOUBLE * c_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexf}(GLfloat c); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glIndexf(float c)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIndexf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIndexf\" not available");
    }
        dispatch_glIndexf1(c, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexf}(GLfloat c); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glIndexf1(float c, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexfv}(const GLfloat *  c); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param c a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glIndexfv(FloatBuffer c)  {

    final boolean c_is_direct = Buffers.isDirect(c);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIndexfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIndexfv\" not available");
    }
        dispatch_glIndexfv1(c_is_direct ? c : Buffers.getArray(c), c_is_direct ? Buffers.getDirectBufferByteOffset(c) : Buffers.getIndirectBufferByteOffset(c), c_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexfv}(const GLfloat *  c); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param c a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glIndexfv1(Object c, int c_byte_offset, boolean c_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexfv}(const GLfloat *  c); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glIndexfv(float[] c, int c_offset)  {

    if(c != null && c.length <= c_offset)
      throw new GLException("array offset argument \"c_offset\" (" + c_offset + ") equals or exceeds array length (" + c.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIndexfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIndexfv\" not available");
    }
        dispatch_glIndexfv1(c, Buffers.SIZEOF_FLOAT * c_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexi}(GLint c); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glIndexi(int c)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIndexi;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIndexi\" not available");
    }
        dispatch_glIndexi1(c, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexi}(GLint c); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glIndexi1(int c, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexiv}(const GLint *  c); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param c a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glIndexiv(IntBuffer c)  {

    final boolean c_is_direct = Buffers.isDirect(c);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIndexiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIndexiv\" not available");
    }
        dispatch_glIndexiv1(c_is_direct ? c : Buffers.getArray(c), c_is_direct ? Buffers.getDirectBufferByteOffset(c) : Buffers.getIndirectBufferByteOffset(c), c_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexiv}(const GLint *  c); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param c a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glIndexiv1(Object c, int c_byte_offset, boolean c_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexiv}(const GLint *  c); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glIndexiv(int[] c, int c_offset)  {

    if(c != null && c.length <= c_offset)
      throw new GLException("array offset argument \"c_offset\" (" + c_offset + ") equals or exceeds array length (" + c.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIndexiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIndexiv\" not available");
    }
        dispatch_glIndexiv1(c, Buffers.SIZEOF_INT * c_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexs}(GLshort c); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glIndexs(short c)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIndexs;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIndexs\" not available");
    }
        dispatch_glIndexs1(c, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexs}(GLshort c); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glIndexs1(short c, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexsv}(const GLshort *  c); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param c a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glIndexsv(ShortBuffer c)  {

    final boolean c_is_direct = Buffers.isDirect(c);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIndexsv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIndexsv\" not available");
    }
        dispatch_glIndexsv1(c_is_direct ? c : Buffers.getArray(c), c_is_direct ? Buffers.getDirectBufferByteOffset(c) : Buffers.getIndirectBufferByteOffset(c), c_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexsv}(const GLshort *  c); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param c a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glIndexsv1(Object c, int c_byte_offset, boolean c_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexsv}(const GLshort *  c); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glIndexsv(short[] c, int c_offset)  {

    if(c != null && c.length <= c_offset)
      throw new GLException("array offset argument \"c_offset\" (" + c_offset + ") equals or exceeds array length (" + c.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIndexsv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIndexsv\" not available");
    }
        dispatch_glIndexsv1(c, Buffers.SIZEOF_SHORT * c_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexub}(GLubyte c); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public void glIndexub(byte c)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIndexub;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIndexub\" not available");
    }
        dispatch_glIndexub1(c, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexub}(GLubyte c); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public native void dispatch_glIndexub1(byte c, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexubv}(const GLubyte *  c); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param c a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glIndexubv(ByteBuffer c)  {

    final boolean c_is_direct = Buffers.isDirect(c);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIndexubv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIndexubv\" not available");
    }
        dispatch_glIndexubv1(c_is_direct ? c : Buffers.getArray(c), c_is_direct ? Buffers.getDirectBufferByteOffset(c) : Buffers.getIndirectBufferByteOffset(c), c_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexubv}(const GLubyte *  c); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param c a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glIndexubv1(Object c, int c_byte_offset, boolean c_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexubv}(const GLubyte *  c); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public void glIndexubv(byte[] c, int c_offset)  {

    if(c != null && c.length <= c_offset)
      throw new GLException("array offset argument \"c_offset\" (" + c_offset + ") equals or exceeds array length (" + c.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIndexubv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIndexubv\" not available");
    }
        dispatch_glIndexubv1(c, c_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInitNames}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glInitNames()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glInitNames;
    if (__addr_ == 0) {
      throw new GLException("Method \"glInitNames\" not available");
    }
        dispatch_glInitNames1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glInitNames}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glInitNames1(long procAddress);

  /** Entry point to C language function: <code> void {@native glInsertComponentEXT}(GLuint res, GLuint src, GLuint num); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glInsertComponentEXT(int res, int src, int num)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glInsertComponentEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glInsertComponentEXT\" not available");
    }
        dispatch_glInsertComponentEXT1(res, src, num, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInsertComponentEXT}(GLuint res, GLuint src, GLuint num); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public native void dispatch_glInsertComponentEXT1(int res, int src, int num, long procAddress);

  /** Entry point to C language function: <code> void {@native glInterleavedArrays}(GLenum format, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glInterleavedArrays(int format, int stride, Buffer pointer)  {

    checkArrayVBODisabled(true);
    Buffers.rangeCheck(pointer, 1);
    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glInterleavedArrays;
    if (__addr_ == 0) {
      throw new GLException("Method \"glInterleavedArrays\" not available");
    }
        dispatch_glInterleavedArrays1(format, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInterleavedArrays}(GLenum format, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glInterleavedArrays1(int format, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glInterleavedArrays}(GLenum format, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public void glInterleavedArrays(int format, int stride, long pointer_buffer_offset)  {

    checkArrayVBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glInterleavedArrays;
    if (__addr_ == 0) {
      throw new GLException("Method \"glInterleavedArrays\" not available");
    }
        dispatch_glInterleavedArrays1(format, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInterleavedArrays}(GLenum format, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  private native void dispatch_glInterleavedArrays1(int format, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsBuffer}(GLuint buffer); </code> <br>Part of <code>GL_VERSION_1_5</code>   */
  public boolean glIsBuffer(int buffer)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsBuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsBuffer\" not available");
    }
        return dispatch_glIsBuffer1(buffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsBuffer}(GLuint buffer); </code> <br>Part of <code>GL_VERSION_1_5</code>   */
  public native boolean dispatch_glIsBuffer1(int buffer, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsBufferResidentNV}(GLenum target); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>   */
  public boolean glIsBufferResidentNV(int target)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsBufferResidentNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsBufferResidentNV\" not available");
    }
        return dispatch_glIsBufferResidentNV1(target, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsBufferResidentNV}(GLenum target); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>   */
  public native boolean dispatch_glIsBufferResidentNV1(int target, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabled}(GLenum cap); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public boolean glIsEnabled(int cap)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsEnabled;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsEnabled\" not available");
    }
        return dispatch_glIsEnabled1(cap, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabled}(GLenum cap); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public native boolean dispatch_glIsEnabled1(int cap, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabledIndexedEXT}(GLenum target, GLuint index); </code> <br>Part of <code>GL_EXT_draw_buffers2</code>   */
  public boolean glIsEnabledIndexed(int target, int index)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsEnabledIndexed;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsEnabledIndexed\" not available");
    }
        return dispatch_glIsEnabledIndexed1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabledIndexedEXT}(GLenum target, GLuint index); </code> <br>Part of <code>GL_EXT_draw_buffers2</code>   */
  public native boolean dispatch_glIsEnabledIndexed1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabledi}(GLenum target, GLuint index); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public boolean glIsEnabledi(int target, int index)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsEnabledi;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsEnabledi\" not available");
    }
        return dispatch_glIsEnabledi1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabledi}(GLenum target, GLuint index); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public native boolean dispatch_glIsEnabledi1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsFenceAPPLE}(GLuint fence); </code> <br>Part of <code>GL_APPLE_fence</code>   */
  public boolean glIsFenceAPPLE(int fence)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsFenceAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsFenceAPPLE\" not available");
    }
        return dispatch_glIsFenceAPPLE1(fence, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsFenceAPPLE}(GLuint fence); </code> <br>Part of <code>GL_APPLE_fence</code>   */
  public native boolean dispatch_glIsFenceAPPLE1(int fence, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsFenceNV}(GLuint fence); </code> <br>Part of <code>GL_NV_fence</code>   */
  public boolean glIsFenceNV(int fence)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsFenceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsFenceNV\" not available");
    }
        return dispatch_glIsFenceNV1(fence, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsFenceNV}(GLuint fence); </code> <br>Part of <code>GL_NV_fence</code>   */
  public native boolean dispatch_glIsFenceNV1(int fence, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsFramebuffer}(GLuint framebuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public boolean glIsFramebuffer(int framebuffer)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsFramebuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsFramebuffer\" not available");
    }
        return dispatch_glIsFramebuffer1(framebuffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsFramebuffer}(GLuint framebuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public native boolean dispatch_glIsFramebuffer1(int framebuffer, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsList}(GLuint list); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public boolean glIsList(int list)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsList;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsList\" not available");
    }
        return dispatch_glIsList1(list, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsList}(GLuint list); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native boolean dispatch_glIsList1(int list, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsNameAMD}(GLenum identifier, GLuint name); </code> <br>Part of <code>GL_AMD_name_gen_delete</code>   */
  public boolean glIsNameAMD(int identifier, int name)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsNameAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsNameAMD\" not available");
    }
        return dispatch_glIsNameAMD1(identifier, name, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsNameAMD}(GLenum identifier, GLuint name); </code> <br>Part of <code>GL_AMD_name_gen_delete</code>   */
  public native boolean dispatch_glIsNameAMD1(int identifier, int name, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsNamedBufferResidentNV}(GLuint buffer); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>   */
  public boolean glIsNamedBufferResidentNV(int buffer)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsNamedBufferResidentNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsNamedBufferResidentNV\" not available");
    }
        return dispatch_glIsNamedBufferResidentNV1(buffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsNamedBufferResidentNV}(GLuint buffer); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>   */
  public native boolean dispatch_glIsNamedBufferResidentNV1(int buffer, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsNamedStringARB}(GLint namelen, const GLchar *  name); </code> <br>Part of <code>GL_ARB_shading_language_include</code>   */
  public boolean glIsNamedStringARB(int namelen, String name)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsNamedStringARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsNamedStringARB\" not available");
    }
        return dispatch_glIsNamedStringARB1(namelen, name, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsNamedStringARB}(GLint namelen, const GLchar *  name); </code> <br>Part of <code>GL_ARB_shading_language_include</code>   */
  public native boolean dispatch_glIsNamedStringARB1(int namelen, String name, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsOcclusionQueryNV}(GLuint id); </code> <br>Part of <code>GL_NV_occlusion_query</code>   */
  public boolean glIsOcclusionQueryNV(int id)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsOcclusionQueryNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsOcclusionQueryNV\" not available");
    }
        return dispatch_glIsOcclusionQueryNV1(id, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsOcclusionQueryNV}(GLuint id); </code> <br>Part of <code>GL_NV_occlusion_query</code>   */
  public native boolean dispatch_glIsOcclusionQueryNV1(int id, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsProgram}(GLuint program); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public boolean glIsProgram(int program)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsProgram;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsProgram\" not available");
    }
        return dispatch_glIsProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsProgram}(GLuint program); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native boolean dispatch_glIsProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsProgramARB}(GLuint program); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public boolean glIsProgramARB(int program)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsProgramARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsProgramARB\" not available");
    }
        return dispatch_glIsProgramARB1(program, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsProgramARB}(GLuint program); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public native boolean dispatch_glIsProgramARB1(int program, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsProgramPipeline}(GLuint pipeline); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public boolean glIsProgramPipeline(int pipeline)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsProgramPipeline;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsProgramPipeline\" not available");
    }
        return dispatch_glIsProgramPipeline1(pipeline, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsProgramPipeline}(GLuint pipeline); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public native boolean dispatch_glIsProgramPipeline1(int pipeline, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsQuery}(GLuint id); </code> <br>Part of <code>GL_VERSION_1_5</code>   */
  public boolean glIsQuery(int id)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsQuery;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsQuery\" not available");
    }
        return dispatch_glIsQuery1(id, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsQuery}(GLuint id); </code> <br>Part of <code>GL_VERSION_1_5</code>   */
  public native boolean dispatch_glIsQuery1(int id, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsRenderbuffer}(GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public boolean glIsRenderbuffer(int renderbuffer)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsRenderbuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsRenderbuffer\" not available");
    }
        return dispatch_glIsRenderbuffer1(renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsRenderbuffer}(GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public native boolean dispatch_glIsRenderbuffer1(int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsSampler}(GLuint sampler); </code> <br>Part of <code>GL_ARB_sampler_objects</code>   */
  public boolean glIsSampler(int sampler)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsSampler;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsSampler\" not available");
    }
        return dispatch_glIsSampler1(sampler, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsSampler}(GLuint sampler); </code> <br>Part of <code>GL_ARB_sampler_objects</code>   */
  public native boolean dispatch_glIsSampler1(int sampler, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsShader}(GLuint shader); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public boolean glIsShader(int shader)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsShader;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsShader\" not available");
    }
        return dispatch_glIsShader1(shader, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsShader}(GLuint shader); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native boolean dispatch_glIsShader1(int shader, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsSync}(GLsync sync); </code> <br>Part of <code>GL_ARB_sync</code>   */
  public boolean glIsSync(long sync)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsSync;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsSync\" not available");
    }
        return dispatch_glIsSync1(sync, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsSync}(GLsync sync); </code> <br>Part of <code>GL_ARB_sync</code>   */
  public native boolean dispatch_glIsSync1(long sync, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsTexture}(GLuint texture); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public boolean glIsTexture(int texture)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsTexture;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsTexture\" not available");
    }
        return dispatch_glIsTexture1(texture, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsTexture}(GLuint texture); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public native boolean dispatch_glIsTexture1(int texture, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsTransformFeedback}(GLuint id); </code> <br>Part of <code>GL_ARB_transform_feedback2</code>   */
  public boolean glIsTransformFeedback(int id)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsTransformFeedback\" not available");
    }
        return dispatch_glIsTransformFeedback1(id, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsTransformFeedback}(GLuint id); </code> <br>Part of <code>GL_ARB_transform_feedback2</code>   */
  public native boolean dispatch_glIsTransformFeedback1(int id, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsTransformFeedbackNV}(GLuint id); </code> <br>Part of <code>GL_NV_transform_feedback2</code>   */
  public boolean glIsTransformFeedbackNV(int id)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsTransformFeedbackNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsTransformFeedbackNV\" not available");
    }
        return dispatch_glIsTransformFeedbackNV1(id, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsTransformFeedbackNV}(GLuint id); </code> <br>Part of <code>GL_NV_transform_feedback2</code>   */
  public native boolean dispatch_glIsTransformFeedbackNV1(int id, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsVariantEnabledEXT}(GLuint id, GLenum cap); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public boolean glIsVariantEnabledEXT(int id, int cap)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsVariantEnabledEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsVariantEnabledEXT\" not available");
    }
        return dispatch_glIsVariantEnabledEXT1(id, cap, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsVariantEnabledEXT}(GLuint id, GLenum cap); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public native boolean dispatch_glIsVariantEnabledEXT1(int id, int cap, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsVertexArray}(GLuint array); </code> <br>Part of <code>GL_ARB_vertex_array_object</code>   */
  public boolean glIsVertexArray(int array)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsVertexArray;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsVertexArray\" not available");
    }
        return dispatch_glIsVertexArray1(array, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsVertexArray}(GLuint array); </code> <br>Part of <code>GL_ARB_vertex_array_object</code>   */
  public native boolean dispatch_glIsVertexArray1(int array, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsVertexAttribEnabledAPPLE}(GLuint index, GLenum pname); </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code>   */
  public boolean glIsVertexAttribEnabledAPPLE(int index, int pname)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsVertexAttribEnabledAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsVertexAttribEnabledAPPLE\" not available");
    }
        return dispatch_glIsVertexAttribEnabledAPPLE1(index, pname, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsVertexAttribEnabledAPPLE}(GLuint index, GLenum pname); </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code>   */
  public native boolean dispatch_glIsVertexAttribEnabledAPPLE1(int index, int pname, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightModelf}(GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glLightModelf(int pname, float param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLightModelf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLightModelf\" not available");
    }
        dispatch_glLightModelf1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightModelf}(GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glLightModelf1(int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightModelfv}(GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glLightModelfv(int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLightModelfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLightModelfv\" not available");
    }
        dispatch_glLightModelfv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightModelfv}(GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glLightModelfv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightModelfv}(GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glLightModelfv(int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLightModelfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLightModelfv\" not available");
    }
        dispatch_glLightModelfv1(pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightModeli}(GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glLightModeli(int pname, int param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLightModeli;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLightModeli\" not available");
    }
        dispatch_glLightModeli1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightModeli}(GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glLightModeli1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightModeliv}(GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glLightModeliv(int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLightModeliv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLightModeliv\" not available");
    }
        dispatch_glLightModeliv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightModeliv}(GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glLightModeliv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightModeliv}(GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glLightModeliv(int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLightModeliv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLightModeliv\" not available");
    }
        dispatch_glLightModeliv1(pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightf}(GLenum light, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glLightf(int light, int pname, float param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLightf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLightf\" not available");
    }
        dispatch_glLightf1(light, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightf}(GLenum light, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glLightf1(int light, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightfv}(GLenum light, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glLightfv(int light, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLightfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLightfv\" not available");
    }
        dispatch_glLightfv1(light, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightfv}(GLenum light, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glLightfv1(int light, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightfv}(GLenum light, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glLightfv(int light, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLightfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLightfv\" not available");
    }
        dispatch_glLightfv1(light, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLighti}(GLenum light, GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glLighti(int light, int pname, int param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLighti;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLighti\" not available");
    }
        dispatch_glLighti1(light, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLighti}(GLenum light, GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glLighti1(int light, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightiv}(GLenum light, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glLightiv(int light, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLightiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLightiv\" not available");
    }
        dispatch_glLightiv1(light, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightiv}(GLenum light, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glLightiv1(int light, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightiv}(GLenum light, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glLightiv(int light, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLightiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLightiv\" not available");
    }
        dispatch_glLightiv1(light, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLineStipple}(GLint factor, GLushort pattern); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glLineStipple(int factor, short pattern)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLineStipple;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLineStipple\" not available");
    }
        dispatch_glLineStipple1(factor, pattern, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLineStipple}(GLint factor, GLushort pattern); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glLineStipple1(int factor, short pattern, long procAddress);

  /** Entry point to C language function: <code> void {@native glLineWidth}(GLfloat width); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glLineWidth(float width)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLineWidth;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLineWidth\" not available");
    }
        dispatch_glLineWidth1(width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLineWidth}(GLfloat width); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glLineWidth1(float width, long procAddress);

  /** Entry point to C language function: <code> void {@native glLinkProgram}(GLuint program); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glLinkProgram(int program)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLinkProgram;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLinkProgram\" not available");
    }
        dispatch_glLinkProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLinkProgram}(GLuint program); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glLinkProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glLinkProgramARB}(GLhandleARB programObj); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glLinkProgramARB(int programObj)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLinkProgramARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLinkProgramARB\" not available");
    }
        dispatch_glLinkProgramARB1(programObj, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLinkProgramARB}(GLhandleARB programObj); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public native void dispatch_glLinkProgramARB1(int programObj, long procAddress);

  /** Entry point to C language function: <code> void {@native glListBase}(GLuint base); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glListBase(int base)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glListBase;
    if (__addr_ == 0) {
      throw new GLException("Method \"glListBase\" not available");
    }
        dispatch_glListBase1(base, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glListBase}(GLuint base); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glListBase1(int base, long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadIdentity}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glLoadIdentity()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLoadIdentity;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLoadIdentity\" not available");
    }
        dispatch_glLoadIdentity1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadIdentity}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glLoadIdentity1(long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadMatrixd}(const GLdouble *  m); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glLoadMatrixd(DoubleBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLoadMatrixd;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLoadMatrixd\" not available");
    }
        dispatch_glLoadMatrixd1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadMatrixd}(const GLdouble *  m); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glLoadMatrixd1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadMatrixd}(const GLdouble *  m); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glLoadMatrixd(double[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLoadMatrixd;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLoadMatrixd\" not available");
    }
        dispatch_glLoadMatrixd1(m, Buffers.SIZEOF_DOUBLE * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadMatrixf}(const GLfloat *  m); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glLoadMatrixf(FloatBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLoadMatrixf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLoadMatrixf\" not available");
    }
        dispatch_glLoadMatrixf1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadMatrixf}(const GLfloat *  m); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glLoadMatrixf1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadMatrixf}(const GLfloat *  m); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glLoadMatrixf(float[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLoadMatrixf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLoadMatrixf\" not available");
    }
        dispatch_glLoadMatrixf1(m, Buffers.SIZEOF_FLOAT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadName}(GLuint name); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glLoadName(int name)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLoadName;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLoadName\" not available");
    }
        dispatch_glLoadName1(name, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadName}(GLuint name); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glLoadName1(int name, long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadTransposeMatrixd}(const GLdouble *  m); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glLoadTransposeMatrixd(DoubleBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLoadTransposeMatrixd;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLoadTransposeMatrixd\" not available");
    }
        dispatch_glLoadTransposeMatrixd1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadTransposeMatrixd}(const GLdouble *  m); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glLoadTransposeMatrixd1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadTransposeMatrixd}(const GLdouble *  m); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glLoadTransposeMatrixd(double[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLoadTransposeMatrixd;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLoadTransposeMatrixd\" not available");
    }
        dispatch_glLoadTransposeMatrixd1(m, Buffers.SIZEOF_DOUBLE * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadTransposeMatrixf}(const GLfloat *  m); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glLoadTransposeMatrixf(FloatBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLoadTransposeMatrixf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLoadTransposeMatrixf\" not available");
    }
        dispatch_glLoadTransposeMatrixf1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadTransposeMatrixf}(const GLfloat *  m); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glLoadTransposeMatrixf1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadTransposeMatrixf}(const GLfloat *  m); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glLoadTransposeMatrixf(float[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLoadTransposeMatrixf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLoadTransposeMatrixf\" not available");
    }
        dispatch_glLoadTransposeMatrixf1(m, Buffers.SIZEOF_FLOAT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLockArraysEXT}(GLint first, GLsizei count); </code> <br>Part of <code>GL_EXT_compiled_vertex_array</code>   */
  public void glLockArraysEXT(int first, int count)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLockArraysEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLockArraysEXT\" not available");
    }
        dispatch_glLockArraysEXT1(first, count, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLockArraysEXT}(GLint first, GLsizei count); </code> <br>Part of <code>GL_EXT_compiled_vertex_array</code>   */
  public native void dispatch_glLockArraysEXT1(int first, int count, long procAddress);

  /** Entry point to C language function: <code> void {@native glLogicOp}(GLenum opcode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glLogicOp(int opcode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glLogicOp;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLogicOp\" not available");
    }
        dispatch_glLogicOp1(opcode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLogicOp}(GLenum opcode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glLogicOp1(int opcode, long procAddress);

  /** Entry point to C language function: <code> void {@native glMakeBufferNonResidentNV}(GLenum target); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>   */
  public void glMakeBufferNonResidentNV(int target)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMakeBufferNonResidentNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMakeBufferNonResidentNV\" not available");
    }
        dispatch_glMakeBufferNonResidentNV1(target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMakeBufferNonResidentNV}(GLenum target); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>   */
  public native void dispatch_glMakeBufferNonResidentNV1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glMakeBufferResidentNV}(GLenum target, GLenum access); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>   */
  public void glMakeBufferResidentNV(int target, int access)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMakeBufferResidentNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMakeBufferResidentNV\" not available");
    }
        dispatch_glMakeBufferResidentNV1(target, access, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMakeBufferResidentNV}(GLenum target, GLenum access); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>   */
  public native void dispatch_glMakeBufferResidentNV1(int target, int access, long procAddress);

  /** Entry point to C language function: <code> void {@native glMakeNamedBufferNonResidentNV}(GLuint buffer); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>   */
  public void glMakeNamedBufferNonResidentNV(int buffer)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMakeNamedBufferNonResidentNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMakeNamedBufferNonResidentNV\" not available");
    }
        dispatch_glMakeNamedBufferNonResidentNV1(buffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMakeNamedBufferNonResidentNV}(GLuint buffer); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>   */
  public native void dispatch_glMakeNamedBufferNonResidentNV1(int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glMakeNamedBufferResidentNV}(GLuint buffer, GLenum access); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>   */
  public void glMakeNamedBufferResidentNV(int buffer, int access)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMakeNamedBufferResidentNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMakeNamedBufferResidentNV\" not available");
    }
        dispatch_glMakeNamedBufferResidentNV1(buffer, access, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMakeNamedBufferResidentNV}(GLuint buffer, GLenum access); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>   */
  public native void dispatch_glMakeNamedBufferResidentNV1(int buffer, int access, long procAddress);

  /** Entry point to C language function: <code> void {@native glMap1d}(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *  points); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param points a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMap1d(int target, double u1, double u2, int stride, int order, DoubleBuffer points)  {

    final boolean points_is_direct = Buffers.isDirect(points);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMap1d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMap1d\" not available");
    }
        dispatch_glMap1d1(target, u1, u2, stride, order, points_is_direct ? points : Buffers.getArray(points), points_is_direct ? Buffers.getDirectBufferByteOffset(points) : Buffers.getIndirectBufferByteOffset(points), points_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMap1d}(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *  points); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param points a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMap1d1(int target, double u1, double u2, int stride, int order, Object points, int points_byte_offset, boolean points_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMap1d}(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *  points); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glMap1d(int target, double u1, double u2, int stride, int order, double[] points, int points_offset)  {

    if(points != null && points.length <= points_offset)
      throw new GLException("array offset argument \"points_offset\" (" + points_offset + ") equals or exceeds array length (" + points.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMap1d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMap1d\" not available");
    }
        dispatch_glMap1d1(target, u1, u2, stride, order, points, Buffers.SIZEOF_DOUBLE * points_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMap1f}(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *  points); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param points a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMap1f(int target, float u1, float u2, int stride, int order, FloatBuffer points)  {

    final boolean points_is_direct = Buffers.isDirect(points);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMap1f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMap1f\" not available");
    }
        dispatch_glMap1f1(target, u1, u2, stride, order, points_is_direct ? points : Buffers.getArray(points), points_is_direct ? Buffers.getDirectBufferByteOffset(points) : Buffers.getIndirectBufferByteOffset(points), points_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMap1f}(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *  points); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param points a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMap1f1(int target, float u1, float u2, int stride, int order, Object points, int points_byte_offset, boolean points_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMap1f}(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *  points); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glMap1f(int target, float u1, float u2, int stride, int order, float[] points, int points_offset)  {

    if(points != null && points.length <= points_offset)
      throw new GLException("array offset argument \"points_offset\" (" + points_offset + ") equals or exceeds array length (" + points.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMap1f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMap1f\" not available");
    }
        dispatch_glMap1f1(target, u1, u2, stride, order, points, Buffers.SIZEOF_FLOAT * points_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMap2d}(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *  points); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param points a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMap2d(int target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, DoubleBuffer points)  {

    final boolean points_is_direct = Buffers.isDirect(points);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMap2d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMap2d\" not available");
    }
        dispatch_glMap2d1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_is_direct ? points : Buffers.getArray(points), points_is_direct ? Buffers.getDirectBufferByteOffset(points) : Buffers.getIndirectBufferByteOffset(points), points_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMap2d}(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *  points); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param points a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMap2d1(int target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, Object points, int points_byte_offset, boolean points_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMap2d}(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *  points); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glMap2d(int target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double[] points, int points_offset)  {

    if(points != null && points.length <= points_offset)
      throw new GLException("array offset argument \"points_offset\" (" + points_offset + ") equals or exceeds array length (" + points.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMap2d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMap2d\" not available");
    }
        dispatch_glMap2d1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points, Buffers.SIZEOF_DOUBLE * points_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMap2f}(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *  points); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param points a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMap2f(int target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, FloatBuffer points)  {

    final boolean points_is_direct = Buffers.isDirect(points);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMap2f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMap2f\" not available");
    }
        dispatch_glMap2f1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_is_direct ? points : Buffers.getArray(points), points_is_direct ? Buffers.getDirectBufferByteOffset(points) : Buffers.getIndirectBufferByteOffset(points), points_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMap2f}(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *  points); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param points a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMap2f1(int target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, Object points, int points_byte_offset, boolean points_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMap2f}(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *  points); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glMap2f(int target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float[] points, int points_offset)  {

    if(points != null && points.length <= points_offset)
      throw new GLException("array offset argument \"points_offset\" (" + points_offset + ") equals or exceeds array length (" + points.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMap2f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMap2f\" not available");
    }
        dispatch_glMap2f1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points, Buffers.SIZEOF_FLOAT * points_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLvoid *  {@native glMapBufferRange}(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access); </code> <br>Part of <code>GL_ARB_map_buffer_range</code>   */
  public ByteBuffer glMapBufferRange(int target, long offset, long length, int access)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapBufferRange;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMapBufferRange\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_glMapBufferRange1(target, offset, length, access, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> GLvoid *  {@native glMapBufferRange}(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access); </code> <br>Part of <code>GL_ARB_map_buffer_range</code>   */
  private native ByteBuffer dispatch_glMapBufferRange1(int target, long offset, long length, int access, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapControlPointsNV}(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid *  points); </code> <br>Part of <code>GL_NV_evaluators</code>
      @param points a direct or array-backed {@link java.nio.Buffer}   */
  public void glMapControlPointsNV(int target, int index, int type, int ustride, int vstride, int uorder, int vorder, boolean packed, Buffer points)  {

    final boolean points_is_direct = Buffers.isDirect(points);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapControlPointsNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMapControlPointsNV\" not available");
    }
        dispatch_glMapControlPointsNV1(target, index, type, ustride, vstride, uorder, vorder, packed, points_is_direct ? points : Buffers.getArray(points), points_is_direct ? Buffers.getDirectBufferByteOffset(points) : Buffers.getIndirectBufferByteOffset(points), points_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapControlPointsNV}(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid *  points); </code> <br>Part of <code>GL_NV_evaluators</code>
      @param points a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMapControlPointsNV1(int target, int index, int type, int ustride, int vstride, int uorder, int vorder, boolean packed, Object points, int points_byte_offset, boolean points_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapGrid1d}(GLint un, GLdouble u1, GLdouble u2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glMapGrid1d(int un, double u1, double u2)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapGrid1d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMapGrid1d\" not available");
    }
        dispatch_glMapGrid1d1(un, u1, u2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapGrid1d}(GLint un, GLdouble u1, GLdouble u2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glMapGrid1d1(int un, double u1, double u2, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapGrid1f}(GLint un, GLfloat u1, GLfloat u2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glMapGrid1f(int un, float u1, float u2)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapGrid1f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMapGrid1f\" not available");
    }
        dispatch_glMapGrid1f1(un, u1, u2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapGrid1f}(GLint un, GLfloat u1, GLfloat u2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glMapGrid1f1(int un, float u1, float u2, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapGrid2d}(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glMapGrid2d(int un, double u1, double u2, int vn, double v1, double v2)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapGrid2d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMapGrid2d\" not available");
    }
        dispatch_glMapGrid2d1(un, u1, u2, vn, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapGrid2d}(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glMapGrid2d1(int un, double u1, double u2, int vn, double v1, double v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapGrid2f}(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glMapGrid2f(int un, float u1, float u2, int vn, float v1, float v2)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapGrid2f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMapGrid2f\" not available");
    }
        dispatch_glMapGrid2f1(un, u1, u2, vn, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapGrid2f}(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glMapGrid2f1(int un, float u1, float u2, int vn, float v1, float v2, long procAddress);

  /** Entry point to C language function: <code> GLvoid *  {@native glMapNamedBufferRangeEXT}(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public ByteBuffer glMapNamedBufferRangeEXT(int buffer, long offset, long length, int access)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapNamedBufferRangeEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMapNamedBufferRangeEXT\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_glMapNamedBufferRangeEXT1(buffer, offset, length, access, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> GLvoid *  {@native glMapNamedBufferRangeEXT}(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  private native ByteBuffer dispatch_glMapNamedBufferRangeEXT1(int buffer, long offset, long length, int access, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapParameterfvNV}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_NV_evaluators</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMapParameterfvNV(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapParameterfvNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMapParameterfvNV\" not available");
    }
        dispatch_glMapParameterfvNV1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapParameterfvNV}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_NV_evaluators</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMapParameterfvNV1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapParameterfvNV}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_NV_evaluators</code>   */
  public void glMapParameterfvNV(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapParameterfvNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMapParameterfvNV\" not available");
    }
        dispatch_glMapParameterfvNV1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapParameterivNV}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_NV_evaluators</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMapParameterivNV(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapParameterivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMapParameterivNV\" not available");
    }
        dispatch_glMapParameterivNV1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapParameterivNV}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_NV_evaluators</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMapParameterivNV1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapParameterivNV}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_NV_evaluators</code>   */
  public void glMapParameterivNV(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapParameterivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMapParameterivNV\" not available");
    }
        dispatch_glMapParameterivNV1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib1dAPPLE}(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *  points); </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code>
      @param points a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMapVertexAttrib1dAPPLE(int index, int size, double u1, double u2, int stride, int order, DoubleBuffer points)  {

    final boolean points_is_direct = Buffers.isDirect(points);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapVertexAttrib1dAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMapVertexAttrib1dAPPLE\" not available");
    }
        dispatch_glMapVertexAttrib1dAPPLE1(index, size, u1, u2, stride, order, points_is_direct ? points : Buffers.getArray(points), points_is_direct ? Buffers.getDirectBufferByteOffset(points) : Buffers.getIndirectBufferByteOffset(points), points_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib1dAPPLE}(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *  points); </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code>
      @param points a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMapVertexAttrib1dAPPLE1(int index, int size, double u1, double u2, int stride, int order, Object points, int points_byte_offset, boolean points_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib1dAPPLE}(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *  points); </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code>   */
  public void glMapVertexAttrib1dAPPLE(int index, int size, double u1, double u2, int stride, int order, double[] points, int points_offset)  {

    if(points != null && points.length <= points_offset)
      throw new GLException("array offset argument \"points_offset\" (" + points_offset + ") equals or exceeds array length (" + points.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapVertexAttrib1dAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMapVertexAttrib1dAPPLE\" not available");
    }
        dispatch_glMapVertexAttrib1dAPPLE1(index, size, u1, u2, stride, order, points, Buffers.SIZEOF_DOUBLE * points_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib1fAPPLE}(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *  points); </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code>
      @param points a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMapVertexAttrib1fAPPLE(int index, int size, float u1, float u2, int stride, int order, FloatBuffer points)  {

    final boolean points_is_direct = Buffers.isDirect(points);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapVertexAttrib1fAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMapVertexAttrib1fAPPLE\" not available");
    }
        dispatch_glMapVertexAttrib1fAPPLE1(index, size, u1, u2, stride, order, points_is_direct ? points : Buffers.getArray(points), points_is_direct ? Buffers.getDirectBufferByteOffset(points) : Buffers.getIndirectBufferByteOffset(points), points_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib1fAPPLE}(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *  points); </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code>
      @param points a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMapVertexAttrib1fAPPLE1(int index, int size, float u1, float u2, int stride, int order, Object points, int points_byte_offset, boolean points_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib1fAPPLE}(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *  points); </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code>   */
  public void glMapVertexAttrib1fAPPLE(int index, int size, float u1, float u2, int stride, int order, float[] points, int points_offset)  {

    if(points != null && points.length <= points_offset)
      throw new GLException("array offset argument \"points_offset\" (" + points_offset + ") equals or exceeds array length (" + points.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapVertexAttrib1fAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMapVertexAttrib1fAPPLE\" not available");
    }
        dispatch_glMapVertexAttrib1fAPPLE1(index, size, u1, u2, stride, order, points, Buffers.SIZEOF_FLOAT * points_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib2dAPPLE}(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *  points); </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code>
      @param points a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMapVertexAttrib2dAPPLE(int index, int size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, DoubleBuffer points)  {

    final boolean points_is_direct = Buffers.isDirect(points);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapVertexAttrib2dAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMapVertexAttrib2dAPPLE\" not available");
    }
        dispatch_glMapVertexAttrib2dAPPLE1(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_is_direct ? points : Buffers.getArray(points), points_is_direct ? Buffers.getDirectBufferByteOffset(points) : Buffers.getIndirectBufferByteOffset(points), points_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib2dAPPLE}(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *  points); </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code>
      @param points a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMapVertexAttrib2dAPPLE1(int index, int size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, Object points, int points_byte_offset, boolean points_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib2dAPPLE}(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *  points); </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code>   */
  public void glMapVertexAttrib2dAPPLE(int index, int size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double[] points, int points_offset)  {

    if(points != null && points.length <= points_offset)
      throw new GLException("array offset argument \"points_offset\" (" + points_offset + ") equals or exceeds array length (" + points.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapVertexAttrib2dAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMapVertexAttrib2dAPPLE\" not available");
    }
        dispatch_glMapVertexAttrib2dAPPLE1(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points, Buffers.SIZEOF_DOUBLE * points_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib2fAPPLE}(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *  points); </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code>
      @param points a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMapVertexAttrib2fAPPLE(int index, int size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, FloatBuffer points)  {

    final boolean points_is_direct = Buffers.isDirect(points);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapVertexAttrib2fAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMapVertexAttrib2fAPPLE\" not available");
    }
        dispatch_glMapVertexAttrib2fAPPLE1(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_is_direct ? points : Buffers.getArray(points), points_is_direct ? Buffers.getDirectBufferByteOffset(points) : Buffers.getIndirectBufferByteOffset(points), points_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib2fAPPLE}(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *  points); </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code>
      @param points a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMapVertexAttrib2fAPPLE1(int index, int size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, Object points, int points_byte_offset, boolean points_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib2fAPPLE}(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *  points); </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code>   */
  public void glMapVertexAttrib2fAPPLE(int index, int size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float[] points, int points_offset)  {

    if(points != null && points.length <= points_offset)
      throw new GLException("array offset argument \"points_offset\" (" + points_offset + ") equals or exceeds array length (" + points.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapVertexAttrib2fAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMapVertexAttrib2fAPPLE\" not available");
    }
        dispatch_glMapVertexAttrib2fAPPLE1(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points, Buffers.SIZEOF_FLOAT * points_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMaterialf}(GLenum face, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glMaterialf(int face, int pname, float param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMaterialf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMaterialf\" not available");
    }
        dispatch_glMaterialf1(face, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMaterialf}(GLenum face, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glMaterialf1(int face, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glMaterialfv}(GLenum face, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMaterialfv(int face, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMaterialfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMaterialfv\" not available");
    }
        dispatch_glMaterialfv1(face, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMaterialfv}(GLenum face, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMaterialfv1(int face, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMaterialfv}(GLenum face, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glMaterialfv(int face, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMaterialfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMaterialfv\" not available");
    }
        dispatch_glMaterialfv1(face, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMateriali}(GLenum face, GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glMateriali(int face, int pname, int param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMateriali;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMateriali\" not available");
    }
        dispatch_glMateriali1(face, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMateriali}(GLenum face, GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glMateriali1(int face, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glMaterialiv}(GLenum face, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMaterialiv(int face, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMaterialiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMaterialiv\" not available");
    }
        dispatch_glMaterialiv1(face, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMaterialiv}(GLenum face, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMaterialiv1(int face, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMaterialiv}(GLenum face, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glMaterialiv(int face, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMaterialiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMaterialiv\" not available");
    }
        dispatch_glMaterialiv1(face, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixFrustumEXT}(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMatrixFrustumEXT(int mode, double left, double right, double bottom, double top, double zNear, double zFar)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixFrustumEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixFrustumEXT\" not available");
    }
        dispatch_glMatrixFrustumEXT1(mode, left, right, bottom, top, zNear, zFar, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixFrustumEXT}(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glMatrixFrustumEXT1(int mode, double left, double right, double bottom, double top, double zNear, double zFar, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixIndexPointerARB}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_ARB_matrix_palette</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glMatrixIndexPointer(int size, int type, int stride, Buffer pointer)  {

    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixIndexPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixIndexPointer\" not available");
    }
        dispatch_glMatrixIndexPointer1(size, type, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixIndexPointerARB}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_ARB_matrix_palette</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMatrixIndexPointer1(int size, int type, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixIndexubvARB}(GLint size, const GLubyte *  indices); </code> <br>Part of <code>GL_ARB_matrix_palette</code>
      @param indices a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glMatrixIndexubvARB(int size, ByteBuffer indices)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixIndexubvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixIndexubvARB\" not available");
    }
        dispatch_glMatrixIndexubvARB1(size, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixIndexubvARB}(GLint size, const GLubyte *  indices); </code> <br>Part of <code>GL_ARB_matrix_palette</code>
      @param indices a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glMatrixIndexubvARB1(int size, Object indices, int indices_byte_offset, boolean indices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixIndexubvARB}(GLint size, const GLubyte *  indices); </code> <br>Part of <code>GL_ARB_matrix_palette</code>   */
  public void glMatrixIndexubvARB(int size, byte[] indices, int indices_offset)  {

    if(indices != null && indices.length <= indices_offset)
      throw new GLException("array offset argument \"indices_offset\" (" + indices_offset + ") equals or exceeds array length (" + indices.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixIndexubvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixIndexubvARB\" not available");
    }
        dispatch_glMatrixIndexubvARB1(size, indices, indices_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixIndexuivARB}(GLint size, const GLuint *  indices); </code> <br>Part of <code>GL_ARB_matrix_palette</code>
      @param indices a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMatrixIndexuivARB(int size, IntBuffer indices)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixIndexuivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixIndexuivARB\" not available");
    }
        dispatch_glMatrixIndexuivARB1(size, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixIndexuivARB}(GLint size, const GLuint *  indices); </code> <br>Part of <code>GL_ARB_matrix_palette</code>
      @param indices a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMatrixIndexuivARB1(int size, Object indices, int indices_byte_offset, boolean indices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixIndexuivARB}(GLint size, const GLuint *  indices); </code> <br>Part of <code>GL_ARB_matrix_palette</code>   */
  public void glMatrixIndexuivARB(int size, int[] indices, int indices_offset)  {

    if(indices != null && indices.length <= indices_offset)
      throw new GLException("array offset argument \"indices_offset\" (" + indices_offset + ") equals or exceeds array length (" + indices.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixIndexuivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixIndexuivARB\" not available");
    }
        dispatch_glMatrixIndexuivARB1(size, indices, Buffers.SIZEOF_INT * indices_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixIndexusvARB}(GLint size, const GLushort *  indices); </code> <br>Part of <code>GL_ARB_matrix_palette</code>
      @param indices a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glMatrixIndexusvARB(int size, ShortBuffer indices)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixIndexusvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixIndexusvARB\" not available");
    }
        dispatch_glMatrixIndexusvARB1(size, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixIndexusvARB}(GLint size, const GLushort *  indices); </code> <br>Part of <code>GL_ARB_matrix_palette</code>
      @param indices a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glMatrixIndexusvARB1(int size, Object indices, int indices_byte_offset, boolean indices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixIndexusvARB}(GLint size, const GLushort *  indices); </code> <br>Part of <code>GL_ARB_matrix_palette</code>   */
  public void glMatrixIndexusvARB(int size, short[] indices, int indices_offset)  {

    if(indices != null && indices.length <= indices_offset)
      throw new GLException("array offset argument \"indices_offset\" (" + indices_offset + ") equals or exceeds array length (" + indices.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixIndexusvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixIndexusvARB\" not available");
    }
        dispatch_glMatrixIndexusvARB1(size, indices, Buffers.SIZEOF_SHORT * indices_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixLoadIdentityEXT}(GLenum mode); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMatrixLoadIdentityEXT(int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixLoadIdentityEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixLoadIdentityEXT\" not available");
    }
        dispatch_glMatrixLoadIdentityEXT1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixLoadIdentityEXT}(GLenum mode); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glMatrixLoadIdentityEXT1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixLoadTransposedEXT}(GLenum mode, const GLdouble *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMatrixLoadTransposedEXT(int mode, DoubleBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixLoadTransposedEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixLoadTransposedEXT\" not available");
    }
        dispatch_glMatrixLoadTransposedEXT1(mode, m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixLoadTransposedEXT}(GLenum mode, const GLdouble *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMatrixLoadTransposedEXT1(int mode, Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixLoadTransposedEXT}(GLenum mode, const GLdouble *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMatrixLoadTransposedEXT(int mode, double[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixLoadTransposedEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixLoadTransposedEXT\" not available");
    }
        dispatch_glMatrixLoadTransposedEXT1(mode, m, Buffers.SIZEOF_DOUBLE * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixLoadTransposefEXT}(GLenum mode, const GLfloat *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMatrixLoadTransposefEXT(int mode, FloatBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixLoadTransposefEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixLoadTransposefEXT\" not available");
    }
        dispatch_glMatrixLoadTransposefEXT1(mode, m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixLoadTransposefEXT}(GLenum mode, const GLfloat *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMatrixLoadTransposefEXT1(int mode, Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixLoadTransposefEXT}(GLenum mode, const GLfloat *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMatrixLoadTransposefEXT(int mode, float[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixLoadTransposefEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixLoadTransposefEXT\" not available");
    }
        dispatch_glMatrixLoadTransposefEXT1(mode, m, Buffers.SIZEOF_FLOAT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixLoaddEXT}(GLenum mode, const GLdouble *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMatrixLoaddEXT(int mode, DoubleBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixLoaddEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixLoaddEXT\" not available");
    }
        dispatch_glMatrixLoaddEXT1(mode, m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixLoaddEXT}(GLenum mode, const GLdouble *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMatrixLoaddEXT1(int mode, Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixLoaddEXT}(GLenum mode, const GLdouble *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMatrixLoaddEXT(int mode, double[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixLoaddEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixLoaddEXT\" not available");
    }
        dispatch_glMatrixLoaddEXT1(mode, m, Buffers.SIZEOF_DOUBLE * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixLoadfEXT}(GLenum mode, const GLfloat *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMatrixLoadfEXT(int mode, FloatBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixLoadfEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixLoadfEXT\" not available");
    }
        dispatch_glMatrixLoadfEXT1(mode, m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixLoadfEXT}(GLenum mode, const GLfloat *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMatrixLoadfEXT1(int mode, Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixLoadfEXT}(GLenum mode, const GLfloat *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMatrixLoadfEXT(int mode, float[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixLoadfEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixLoadfEXT\" not available");
    }
        dispatch_glMatrixLoadfEXT1(mode, m, Buffers.SIZEOF_FLOAT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixMode}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glMatrixMode(int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixMode;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixMode\" not available");
    }
        dispatch_glMatrixMode1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixMode}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glMatrixMode1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixMultTransposedEXT}(GLenum mode, const GLdouble *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMatrixMultTransposedEXT(int mode, DoubleBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixMultTransposedEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixMultTransposedEXT\" not available");
    }
        dispatch_glMatrixMultTransposedEXT1(mode, m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixMultTransposedEXT}(GLenum mode, const GLdouble *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMatrixMultTransposedEXT1(int mode, Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixMultTransposedEXT}(GLenum mode, const GLdouble *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMatrixMultTransposedEXT(int mode, double[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixMultTransposedEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixMultTransposedEXT\" not available");
    }
        dispatch_glMatrixMultTransposedEXT1(mode, m, Buffers.SIZEOF_DOUBLE * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixMultTransposefEXT}(GLenum mode, const GLfloat *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMatrixMultTransposefEXT(int mode, FloatBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixMultTransposefEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixMultTransposefEXT\" not available");
    }
        dispatch_glMatrixMultTransposefEXT1(mode, m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixMultTransposefEXT}(GLenum mode, const GLfloat *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMatrixMultTransposefEXT1(int mode, Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixMultTransposefEXT}(GLenum mode, const GLfloat *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMatrixMultTransposefEXT(int mode, float[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixMultTransposefEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixMultTransposefEXT\" not available");
    }
        dispatch_glMatrixMultTransposefEXT1(mode, m, Buffers.SIZEOF_FLOAT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixMultdEXT}(GLenum mode, const GLdouble *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMatrixMultdEXT(int mode, DoubleBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixMultdEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixMultdEXT\" not available");
    }
        dispatch_glMatrixMultdEXT1(mode, m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixMultdEXT}(GLenum mode, const GLdouble *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMatrixMultdEXT1(int mode, Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixMultdEXT}(GLenum mode, const GLdouble *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMatrixMultdEXT(int mode, double[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixMultdEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixMultdEXT\" not available");
    }
        dispatch_glMatrixMultdEXT1(mode, m, Buffers.SIZEOF_DOUBLE * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixMultfEXT}(GLenum mode, const GLfloat *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMatrixMultfEXT(int mode, FloatBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixMultfEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixMultfEXT\" not available");
    }
        dispatch_glMatrixMultfEXT1(mode, m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixMultfEXT}(GLenum mode, const GLfloat *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMatrixMultfEXT1(int mode, Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixMultfEXT}(GLenum mode, const GLfloat *  m); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMatrixMultfEXT(int mode, float[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixMultfEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixMultfEXT\" not available");
    }
        dispatch_glMatrixMultfEXT1(mode, m, Buffers.SIZEOF_FLOAT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixOrthoEXT}(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMatrixOrthoEXT(int mode, double left, double right, double bottom, double top, double zNear, double zFar)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixOrthoEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixOrthoEXT\" not available");
    }
        dispatch_glMatrixOrthoEXT1(mode, left, right, bottom, top, zNear, zFar, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixOrthoEXT}(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glMatrixOrthoEXT1(int mode, double left, double right, double bottom, double top, double zNear, double zFar, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixPopEXT}(GLenum mode); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMatrixPopEXT(int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixPopEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixPopEXT\" not available");
    }
        dispatch_glMatrixPopEXT1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixPopEXT}(GLenum mode); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glMatrixPopEXT1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixPushEXT}(GLenum mode); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMatrixPushEXT(int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixPushEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixPushEXT\" not available");
    }
        dispatch_glMatrixPushEXT1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixPushEXT}(GLenum mode); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glMatrixPushEXT1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixRotatedEXT}(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMatrixRotatedEXT(int mode, double angle, double x, double y, double z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixRotatedEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixRotatedEXT\" not available");
    }
        dispatch_glMatrixRotatedEXT1(mode, angle, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixRotatedEXT}(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glMatrixRotatedEXT1(int mode, double angle, double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixRotatefEXT}(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMatrixRotatefEXT(int mode, float angle, float x, float y, float z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixRotatefEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixRotatefEXT\" not available");
    }
        dispatch_glMatrixRotatefEXT1(mode, angle, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixRotatefEXT}(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glMatrixRotatefEXT1(int mode, float angle, float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixScaledEXT}(GLenum mode, GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMatrixScaledEXT(int mode, double x, double y, double z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixScaledEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixScaledEXT\" not available");
    }
        dispatch_glMatrixScaledEXT1(mode, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixScaledEXT}(GLenum mode, GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glMatrixScaledEXT1(int mode, double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixScalefEXT}(GLenum mode, GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMatrixScalefEXT(int mode, float x, float y, float z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixScalefEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixScalefEXT\" not available");
    }
        dispatch_glMatrixScalefEXT1(mode, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixScalefEXT}(GLenum mode, GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glMatrixScalefEXT1(int mode, float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixTranslatedEXT}(GLenum mode, GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMatrixTranslatedEXT(int mode, double x, double y, double z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixTranslatedEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixTranslatedEXT\" not available");
    }
        dispatch_glMatrixTranslatedEXT1(mode, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixTranslatedEXT}(GLenum mode, GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glMatrixTranslatedEXT1(int mode, double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixTranslatefEXT}(GLenum mode, GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMatrixTranslatefEXT(int mode, float x, float y, float z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixTranslatefEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixTranslatefEXT\" not available");
    }
        dispatch_glMatrixTranslatefEXT1(mode, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixTranslatefEXT}(GLenum mode, GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glMatrixTranslatefEXT1(int mode, float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glMemoryBarrier}(GLbitfield barriers); </code> <br>Part of <code>GL_ARB_shader_image_load_store</code>   */
  public void glMemoryBarrier(int barriers)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMemoryBarrier;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMemoryBarrier\" not available");
    }
        dispatch_glMemoryBarrier1(barriers, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMemoryBarrier}(GLbitfield barriers); </code> <br>Part of <code>GL_ARB_shader_image_load_store</code>   */
  public native void dispatch_glMemoryBarrier1(int barriers, long procAddress);

  /** Entry point to C language function: <code> void {@native glMinSampleShadingARB}(GLclampf value); </code> <br>Part of <code>GL_ARB_sample_shading</code>   */
  public void glMinSampleShading(float value)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMinSampleShading;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMinSampleShading\" not available");
    }
        dispatch_glMinSampleShading1(value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMinSampleShadingARB}(GLclampf value); </code> <br>Part of <code>GL_ARB_sample_shading</code>   */
  public native void dispatch_glMinSampleShading1(float value, long procAddress);

  /** Entry point to C language function: <code> void {@native glMinmax}(GLenum target, GLenum internalformat, GLboolean sink); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glMinmax(int target, int internalformat, boolean sink)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMinmax;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMinmax\" not available");
    }
        dispatch_glMinmax1(target, internalformat, sink, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMinmax}(GLenum target, GLenum internalformat, GLboolean sink); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public native void dispatch_glMinmax1(int target, int internalformat, boolean sink, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultMatrixd}(const GLdouble *  m); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMultMatrixd(DoubleBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultMatrixd;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultMatrixd\" not available");
    }
        dispatch_glMultMatrixd1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultMatrixd}(const GLdouble *  m); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMultMatrixd1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultMatrixd}(const GLdouble *  m); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glMultMatrixd(double[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultMatrixd;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultMatrixd\" not available");
    }
        dispatch_glMultMatrixd1(m, Buffers.SIZEOF_DOUBLE * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultMatrixf}(const GLfloat *  m); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMultMatrixf(FloatBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultMatrixf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultMatrixf\" not available");
    }
        dispatch_glMultMatrixf1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultMatrixf}(const GLfloat *  m); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMultMatrixf1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultMatrixf}(const GLfloat *  m); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glMultMatrixf(float[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultMatrixf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultMatrixf\" not available");
    }
        dispatch_glMultMatrixf1(m, Buffers.SIZEOF_FLOAT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultTransposeMatrixd}(const GLdouble *  m); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMultTransposeMatrixd(DoubleBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultTransposeMatrixd;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultTransposeMatrixd\" not available");
    }
        dispatch_glMultTransposeMatrixd1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultTransposeMatrixd}(const GLdouble *  m); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMultTransposeMatrixd1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultTransposeMatrixd}(const GLdouble *  m); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultTransposeMatrixd(double[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultTransposeMatrixd;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultTransposeMatrixd\" not available");
    }
        dispatch_glMultTransposeMatrixd1(m, Buffers.SIZEOF_DOUBLE * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultTransposeMatrixf}(const GLfloat *  m); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMultTransposeMatrixf(FloatBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultTransposeMatrixf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultTransposeMatrixf\" not available");
    }
        dispatch_glMultTransposeMatrixf1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultTransposeMatrixf}(const GLfloat *  m); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMultTransposeMatrixf1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultTransposeMatrixf}(const GLfloat *  m); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultTransposeMatrixf(float[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultTransposeMatrixf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultTransposeMatrixf\" not available");
    }
        dispatch_glMultTransposeMatrixf1(m, Buffers.SIZEOF_FLOAT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawArrays}(GLenum mode, const GLint *  first, const GLsizei *  count, GLsizei primcount); </code> <br>Part of <code>GL_VERSION_1_4</code>
      @param first a direct or array-backed {@link java.nio.IntBuffer}
      @param count a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiDrawArrays(int mode, IntBuffer first, IntBuffer count, int primcount)  {

    final boolean first_is_direct = Buffers.isDirect(first);
    final boolean count_is_direct = Buffers.isDirect(count);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiDrawArrays;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiDrawArrays\" not available");
    }
        dispatch_glMultiDrawArrays1(mode, first_is_direct ? first : Buffers.getArray(first), first_is_direct ? Buffers.getDirectBufferByteOffset(first) : Buffers.getIndirectBufferByteOffset(first), first_is_direct, count_is_direct ? count : Buffers.getArray(count), count_is_direct ? Buffers.getDirectBufferByteOffset(count) : Buffers.getIndirectBufferByteOffset(count), count_is_direct, primcount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawArrays}(GLenum mode, const GLint *  first, const GLsizei *  count, GLsizei primcount); </code> <br>Part of <code>GL_VERSION_1_4</code>
      @param first a direct or array-backed {@link java.nio.IntBuffer}
      @param count a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiDrawArrays1(int mode, Object first, int first_byte_offset, boolean first_is_direct, Object count, int count_byte_offset, boolean count_is_direct, int primcount, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiDrawArrays}(GLenum mode, const GLint *  first, const GLsizei *  count, GLsizei primcount); </code> <br>Part of <code>GL_VERSION_1_4</code>   */
  public void glMultiDrawArrays(int mode, int[] first, int first_offset, int[] count, int count_offset, int primcount)  {

    if(first != null && first.length <= first_offset)
      throw new GLException("array offset argument \"first_offset\" (" + first_offset + ") equals or exceeds array length (" + first.length + ")");
    if(count != null && count.length <= count_offset)
      throw new GLException("array offset argument \"count_offset\" (" + count_offset + ") equals or exceeds array length (" + count.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiDrawArrays;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiDrawArrays\" not available");
    }
        dispatch_glMultiDrawArrays1(mode, first, Buffers.SIZEOF_INT * first_offset, false, count, Buffers.SIZEOF_INT * count_offset, false, primcount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawArraysIndirectAMD}(GLenum mode, const GLvoid *  indirect, GLsizei primcount, GLsizei stride); </code> <br>Part of <code>GL_AMD_multi_draw_indirect</code>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiDrawArraysIndirectAMD(int mode, Buffer indirect, int primcount, int stride)  {

    final boolean indirect_is_direct = Buffers.isDirect(indirect);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiDrawArraysIndirectAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiDrawArraysIndirectAMD\" not available");
    }
        dispatch_glMultiDrawArraysIndirectAMD1(mode, indirect_is_direct ? indirect : Buffers.getArray(indirect), indirect_is_direct ? Buffers.getDirectBufferByteOffset(indirect) : Buffers.getIndirectBufferByteOffset(indirect), indirect_is_direct, primcount, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawArraysIndirectAMD}(GLenum mode, const GLvoid *  indirect, GLsizei primcount, GLsizei stride); </code> <br>Part of <code>GL_AMD_multi_draw_indirect</code>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiDrawArraysIndirectAMD1(int mode, Object indirect, int indirect_byte_offset, boolean indirect_is_direct, int primcount, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiDrawElements}(GLenum mode, const GLsizei *  count, GLenum type, const GLvoid *  *  indices, GLsizei primcount); </code> <br>Part of <code>GL_VERSION_1_4</code>
      @param count a direct or array-backed {@link java.nio.IntBuffer}
      @param indices a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glMultiDrawElements(int mode, IntBuffer count, int type, PointerBuffer indices, int primcount)  {

    final boolean count_is_direct = Buffers.isDirect(count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiDrawElements;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiDrawElements\" not available");
    }
        dispatch_glMultiDrawElements1(mode, count_is_direct ? count : Buffers.getArray(count), count_is_direct ? Buffers.getDirectBufferByteOffset(count) : Buffers.getIndirectBufferByteOffset(count), count_is_direct, type, indices_is_direct ? ( indices != null ? indices.getBuffer() : null ) : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, primcount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawElements}(GLenum mode, const GLsizei *  count, GLenum type, const GLvoid *  *  indices, GLsizei primcount); </code> <br>Part of <code>GL_VERSION_1_4</code>
      @param count a direct or array-backed {@link java.nio.IntBuffer}
      @param indices a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private native void dispatch_glMultiDrawElements1(int mode, Object count, int count_byte_offset, boolean count_is_direct, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int primcount, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiDrawElements}(GLenum mode, const GLsizei *  count, GLenum type, const GLvoid *  *  indices, GLsizei primcount); </code> <br>Part of <code>GL_VERSION_1_4</code>
      @param indices a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glMultiDrawElements(int mode, int[] count, int count_offset, int type, PointerBuffer indices, int primcount)  {

    if(count != null && count.length <= count_offset)
      throw new GLException("array offset argument \"count_offset\" (" + count_offset + ") equals or exceeds array length (" + count.length + ")");
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiDrawElements;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiDrawElements\" not available");
    }
        dispatch_glMultiDrawElements1(mode, count, Buffers.SIZEOF_INT * count_offset, false, type, indices_is_direct ? ( indices != null ? indices.getBuffer() : null ) : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, primcount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawElementsIndirectAMD}(GLenum mode, GLenum type, const GLvoid *  indirect, GLsizei primcount, GLsizei stride); </code> <br>Part of <code>GL_AMD_multi_draw_indirect</code>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiDrawElementsIndirectAMD(int mode, int type, Buffer indirect, int primcount, int stride)  {

    final boolean indirect_is_direct = Buffers.isDirect(indirect);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiDrawElementsIndirectAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiDrawElementsIndirectAMD\" not available");
    }
        dispatch_glMultiDrawElementsIndirectAMD1(mode, type, indirect_is_direct ? indirect : Buffers.getArray(indirect), indirect_is_direct ? Buffers.getDirectBufferByteOffset(indirect) : Buffers.getIndirectBufferByteOffset(indirect), indirect_is_direct, primcount, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawElementsIndirectAMD}(GLenum mode, GLenum type, const GLvoid *  indirect, GLsizei primcount, GLsizei stride); </code> <br>Part of <code>GL_AMD_multi_draw_indirect</code>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiDrawElementsIndirectAMD1(int mode, int type, Object indirect, int indirect_byte_offset, boolean indirect_is_direct, int primcount, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexBufferEXT}(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMultiTexBufferEXT(int texunit, int target, int internalformat, int buffer)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexBufferEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexBufferEXT\" not available");
    }
        dispatch_glMultiTexBufferEXT1(texunit, target, internalformat, buffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexBufferEXT}(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glMultiTexBufferEXT1(int texunit, int target, int internalformat, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1d}(GLenum target, GLdouble s); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord1d(int target, double s)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord1d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord1d\" not available");
    }
        dispatch_glMultiTexCoord1d1(target, s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1d}(GLenum target, GLdouble s); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public native void dispatch_glMultiTexCoord1d1(int target, double s, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1dv}(GLenum target, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMultiTexCoord1dv(int target, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord1dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord1dv\" not available");
    }
        dispatch_glMultiTexCoord1dv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1dv}(GLenum target, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMultiTexCoord1dv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1dv}(GLenum target, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord1dv(int target, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord1dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord1dv\" not available");
    }
        dispatch_glMultiTexCoord1dv1(target, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1f}(GLenum target, GLfloat s); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord1f(int target, float s)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord1f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord1f\" not available");
    }
        dispatch_glMultiTexCoord1f1(target, s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1f}(GLenum target, GLfloat s); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public native void dispatch_glMultiTexCoord1f1(int target, float s, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1fv}(GLenum target, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMultiTexCoord1fv(int target, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord1fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord1fv\" not available");
    }
        dispatch_glMultiTexCoord1fv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1fv}(GLenum target, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMultiTexCoord1fv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1fv}(GLenum target, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord1fv(int target, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord1fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord1fv\" not available");
    }
        dispatch_glMultiTexCoord1fv1(target, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1hNV}(GLenum target, GLhalfNV s); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glMultiTexCoord1h(int target, short s)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord1h;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord1h\" not available");
    }
        dispatch_glMultiTexCoord1h1(target, s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1hNV}(GLenum target, GLhalfNV s); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public native void dispatch_glMultiTexCoord1h1(int target, short s, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1hvNV}(GLenum target, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glMultiTexCoord1hv(int target, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord1hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord1hv\" not available");
    }
        dispatch_glMultiTexCoord1hv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1hvNV}(GLenum target, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glMultiTexCoord1hv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1hvNV}(GLenum target, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glMultiTexCoord1hv(int target, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord1hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord1hv\" not available");
    }
        dispatch_glMultiTexCoord1hv1(target, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1i}(GLenum target, GLint s); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord1i(int target, int s)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord1i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord1i\" not available");
    }
        dispatch_glMultiTexCoord1i1(target, s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1i}(GLenum target, GLint s); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public native void dispatch_glMultiTexCoord1i1(int target, int s, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1iv}(GLenum target, const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexCoord1iv(int target, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord1iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord1iv\" not available");
    }
        dispatch_glMultiTexCoord1iv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1iv}(GLenum target, const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexCoord1iv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1iv}(GLenum target, const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord1iv(int target, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord1iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord1iv\" not available");
    }
        dispatch_glMultiTexCoord1iv1(target, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1s}(GLenum target, GLshort s); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord1s(int target, short s)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord1s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord1s\" not available");
    }
        dispatch_glMultiTexCoord1s1(target, s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1s}(GLenum target, GLshort s); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public native void dispatch_glMultiTexCoord1s1(int target, short s, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1sv}(GLenum target, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glMultiTexCoord1sv(int target, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord1sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord1sv\" not available");
    }
        dispatch_glMultiTexCoord1sv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1sv}(GLenum target, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glMultiTexCoord1sv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1sv}(GLenum target, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord1sv(int target, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord1sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord1sv\" not available");
    }
        dispatch_glMultiTexCoord1sv1(target, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2d}(GLenum target, GLdouble s, GLdouble t); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord2d(int target, double s, double t)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord2d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord2d\" not available");
    }
        dispatch_glMultiTexCoord2d1(target, s, t, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2d}(GLenum target, GLdouble s, GLdouble t); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public native void dispatch_glMultiTexCoord2d1(int target, double s, double t, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2dv}(GLenum target, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMultiTexCoord2dv(int target, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord2dv\" not available");
    }
        dispatch_glMultiTexCoord2dv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2dv}(GLenum target, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMultiTexCoord2dv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2dv}(GLenum target, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord2dv(int target, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord2dv\" not available");
    }
        dispatch_glMultiTexCoord2dv1(target, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2f}(GLenum target, GLfloat s, GLfloat t); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord2f(int target, float s, float t)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord2f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord2f\" not available");
    }
        dispatch_glMultiTexCoord2f1(target, s, t, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2f}(GLenum target, GLfloat s, GLfloat t); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public native void dispatch_glMultiTexCoord2f1(int target, float s, float t, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2fv}(GLenum target, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMultiTexCoord2fv(int target, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord2fv\" not available");
    }
        dispatch_glMultiTexCoord2fv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2fv}(GLenum target, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMultiTexCoord2fv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2fv}(GLenum target, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord2fv(int target, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord2fv\" not available");
    }
        dispatch_glMultiTexCoord2fv1(target, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2hNV}(GLenum target, GLhalfNV s, GLhalfNV t); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glMultiTexCoord2h(int target, short s, short t)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord2h;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord2h\" not available");
    }
        dispatch_glMultiTexCoord2h1(target, s, t, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2hNV}(GLenum target, GLhalfNV s, GLhalfNV t); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public native void dispatch_glMultiTexCoord2h1(int target, short s, short t, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2hvNV}(GLenum target, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glMultiTexCoord2hv(int target, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord2hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord2hv\" not available");
    }
        dispatch_glMultiTexCoord2hv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2hvNV}(GLenum target, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glMultiTexCoord2hv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2hvNV}(GLenum target, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glMultiTexCoord2hv(int target, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord2hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord2hv\" not available");
    }
        dispatch_glMultiTexCoord2hv1(target, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2i}(GLenum target, GLint s, GLint t); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord2i(int target, int s, int t)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord2i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord2i\" not available");
    }
        dispatch_glMultiTexCoord2i1(target, s, t, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2i}(GLenum target, GLint s, GLint t); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public native void dispatch_glMultiTexCoord2i1(int target, int s, int t, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2iv}(GLenum target, const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexCoord2iv(int target, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord2iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord2iv\" not available");
    }
        dispatch_glMultiTexCoord2iv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2iv}(GLenum target, const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexCoord2iv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2iv}(GLenum target, const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord2iv(int target, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord2iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord2iv\" not available");
    }
        dispatch_glMultiTexCoord2iv1(target, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2s}(GLenum target, GLshort s, GLshort t); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord2s(int target, short s, short t)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord2s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord2s\" not available");
    }
        dispatch_glMultiTexCoord2s1(target, s, t, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2s}(GLenum target, GLshort s, GLshort t); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public native void dispatch_glMultiTexCoord2s1(int target, short s, short t, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2sv}(GLenum target, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glMultiTexCoord2sv(int target, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord2sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord2sv\" not available");
    }
        dispatch_glMultiTexCoord2sv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2sv}(GLenum target, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glMultiTexCoord2sv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2sv}(GLenum target, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord2sv(int target, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord2sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord2sv\" not available");
    }
        dispatch_glMultiTexCoord2sv1(target, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3d}(GLenum target, GLdouble s, GLdouble t, GLdouble r); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord3d(int target, double s, double t, double r)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord3d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord3d\" not available");
    }
        dispatch_glMultiTexCoord3d1(target, s, t, r, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3d}(GLenum target, GLdouble s, GLdouble t, GLdouble r); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public native void dispatch_glMultiTexCoord3d1(int target, double s, double t, double r, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3dv}(GLenum target, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMultiTexCoord3dv(int target, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord3dv\" not available");
    }
        dispatch_glMultiTexCoord3dv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3dv}(GLenum target, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMultiTexCoord3dv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3dv}(GLenum target, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord3dv(int target, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord3dv\" not available");
    }
        dispatch_glMultiTexCoord3dv1(target, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3f}(GLenum target, GLfloat s, GLfloat t, GLfloat r); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord3f(int target, float s, float t, float r)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord3f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord3f\" not available");
    }
        dispatch_glMultiTexCoord3f1(target, s, t, r, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3f}(GLenum target, GLfloat s, GLfloat t, GLfloat r); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public native void dispatch_glMultiTexCoord3f1(int target, float s, float t, float r, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3fv}(GLenum target, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMultiTexCoord3fv(int target, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord3fv\" not available");
    }
        dispatch_glMultiTexCoord3fv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3fv}(GLenum target, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMultiTexCoord3fv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3fv}(GLenum target, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord3fv(int target, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord3fv\" not available");
    }
        dispatch_glMultiTexCoord3fv1(target, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3hNV}(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glMultiTexCoord3h(int target, short s, short t, short r)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord3h;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord3h\" not available");
    }
        dispatch_glMultiTexCoord3h1(target, s, t, r, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3hNV}(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public native void dispatch_glMultiTexCoord3h1(int target, short s, short t, short r, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3hvNV}(GLenum target, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glMultiTexCoord3hv(int target, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord3hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord3hv\" not available");
    }
        dispatch_glMultiTexCoord3hv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3hvNV}(GLenum target, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glMultiTexCoord3hv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3hvNV}(GLenum target, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glMultiTexCoord3hv(int target, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord3hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord3hv\" not available");
    }
        dispatch_glMultiTexCoord3hv1(target, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3i}(GLenum target, GLint s, GLint t, GLint r); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord3i(int target, int s, int t, int r)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord3i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord3i\" not available");
    }
        dispatch_glMultiTexCoord3i1(target, s, t, r, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3i}(GLenum target, GLint s, GLint t, GLint r); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public native void dispatch_glMultiTexCoord3i1(int target, int s, int t, int r, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3iv}(GLenum target, const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexCoord3iv(int target, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord3iv\" not available");
    }
        dispatch_glMultiTexCoord3iv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3iv}(GLenum target, const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexCoord3iv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3iv}(GLenum target, const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord3iv(int target, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord3iv\" not available");
    }
        dispatch_glMultiTexCoord3iv1(target, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3s}(GLenum target, GLshort s, GLshort t, GLshort r); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord3s(int target, short s, short t, short r)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord3s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord3s\" not available");
    }
        dispatch_glMultiTexCoord3s1(target, s, t, r, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3s}(GLenum target, GLshort s, GLshort t, GLshort r); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public native void dispatch_glMultiTexCoord3s1(int target, short s, short t, short r, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3sv}(GLenum target, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glMultiTexCoord3sv(int target, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord3sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord3sv\" not available");
    }
        dispatch_glMultiTexCoord3sv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3sv}(GLenum target, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glMultiTexCoord3sv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3sv}(GLenum target, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord3sv(int target, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord3sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord3sv\" not available");
    }
        dispatch_glMultiTexCoord3sv1(target, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4d}(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord4d(int target, double s, double t, double r, double q)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord4d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord4d\" not available");
    }
        dispatch_glMultiTexCoord4d1(target, s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4d}(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public native void dispatch_glMultiTexCoord4d1(int target, double s, double t, double r, double q, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4dv}(GLenum target, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMultiTexCoord4dv(int target, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord4dv\" not available");
    }
        dispatch_glMultiTexCoord4dv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4dv}(GLenum target, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMultiTexCoord4dv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4dv}(GLenum target, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord4dv(int target, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord4dv\" not available");
    }
        dispatch_glMultiTexCoord4dv1(target, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4f}(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord4f(int target, float s, float t, float r, float q)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord4f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord4f\" not available");
    }
        dispatch_glMultiTexCoord4f1(target, s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4f}(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public native void dispatch_glMultiTexCoord4f1(int target, float s, float t, float r, float q, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4fv}(GLenum target, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMultiTexCoord4fv(int target, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord4fv\" not available");
    }
        dispatch_glMultiTexCoord4fv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4fv}(GLenum target, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMultiTexCoord4fv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4fv}(GLenum target, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord4fv(int target, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord4fv\" not available");
    }
        dispatch_glMultiTexCoord4fv1(target, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4hNV}(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glMultiTexCoord4h(int target, short s, short t, short r, short q)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord4h;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord4h\" not available");
    }
        dispatch_glMultiTexCoord4h1(target, s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4hNV}(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public native void dispatch_glMultiTexCoord4h1(int target, short s, short t, short r, short q, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4hvNV}(GLenum target, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glMultiTexCoord4hv(int target, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord4hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord4hv\" not available");
    }
        dispatch_glMultiTexCoord4hv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4hvNV}(GLenum target, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glMultiTexCoord4hv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4hvNV}(GLenum target, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glMultiTexCoord4hv(int target, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord4hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord4hv\" not available");
    }
        dispatch_glMultiTexCoord4hv1(target, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4i}(GLenum target, GLint s, GLint t, GLint r, GLint q); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord4i(int target, int s, int t, int r, int q)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord4i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord4i\" not available");
    }
        dispatch_glMultiTexCoord4i1(target, s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4i}(GLenum target, GLint s, GLint t, GLint r, GLint q); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public native void dispatch_glMultiTexCoord4i1(int target, int s, int t, int r, int q, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4iv}(GLenum target, const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexCoord4iv(int target, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord4iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord4iv\" not available");
    }
        dispatch_glMultiTexCoord4iv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4iv}(GLenum target, const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexCoord4iv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4iv}(GLenum target, const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord4iv(int target, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord4iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord4iv\" not available");
    }
        dispatch_glMultiTexCoord4iv1(target, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4s}(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord4s(int target, short s, short t, short r, short q)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord4s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord4s\" not available");
    }
        dispatch_glMultiTexCoord4s1(target, s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4s}(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public native void dispatch_glMultiTexCoord4s1(int target, short s, short t, short r, short q, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4sv}(GLenum target, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glMultiTexCoord4sv(int target, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord4sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord4sv\" not available");
    }
        dispatch_glMultiTexCoord4sv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4sv}(GLenum target, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glMultiTexCoord4sv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4sv}(GLenum target, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glMultiTexCoord4sv(int target, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord4sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord4sv\" not available");
    }
        dispatch_glMultiTexCoord4sv1(target, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP1ui}(GLenum texture, GLenum type, GLuint coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glMultiTexCoordP1ui(int texture, int type, int coords)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoordP1ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoordP1ui\" not available");
    }
        dispatch_glMultiTexCoordP1ui1(texture, type, coords, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP1ui}(GLenum texture, GLenum type, GLuint coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public native void dispatch_glMultiTexCoordP1ui1(int texture, int type, int coords, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP1uiv}(GLenum texture, GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexCoordP1uiv(int texture, int type, IntBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoordP1uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoordP1uiv\" not available");
    }
        dispatch_glMultiTexCoordP1uiv1(texture, type, coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP1uiv}(GLenum texture, GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexCoordP1uiv1(int texture, int type, Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP1uiv}(GLenum texture, GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glMultiTexCoordP1uiv(int texture, int type, int[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoordP1uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoordP1uiv\" not available");
    }
        dispatch_glMultiTexCoordP1uiv1(texture, type, coords, Buffers.SIZEOF_INT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP2ui}(GLenum texture, GLenum type, GLuint coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glMultiTexCoordP2ui(int texture, int type, int coords)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoordP2ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoordP2ui\" not available");
    }
        dispatch_glMultiTexCoordP2ui1(texture, type, coords, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP2ui}(GLenum texture, GLenum type, GLuint coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public native void dispatch_glMultiTexCoordP2ui1(int texture, int type, int coords, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP2uiv}(GLenum texture, GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexCoordP2uiv(int texture, int type, IntBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoordP2uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoordP2uiv\" not available");
    }
        dispatch_glMultiTexCoordP2uiv1(texture, type, coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP2uiv}(GLenum texture, GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexCoordP2uiv1(int texture, int type, Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP2uiv}(GLenum texture, GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glMultiTexCoordP2uiv(int texture, int type, int[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoordP2uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoordP2uiv\" not available");
    }
        dispatch_glMultiTexCoordP2uiv1(texture, type, coords, Buffers.SIZEOF_INT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP3ui}(GLenum texture, GLenum type, GLuint coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glMultiTexCoordP3ui(int texture, int type, int coords)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoordP3ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoordP3ui\" not available");
    }
        dispatch_glMultiTexCoordP3ui1(texture, type, coords, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP3ui}(GLenum texture, GLenum type, GLuint coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public native void dispatch_glMultiTexCoordP3ui1(int texture, int type, int coords, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP3uiv}(GLenum texture, GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexCoordP3uiv(int texture, int type, IntBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoordP3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoordP3uiv\" not available");
    }
        dispatch_glMultiTexCoordP3uiv1(texture, type, coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP3uiv}(GLenum texture, GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexCoordP3uiv1(int texture, int type, Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP3uiv}(GLenum texture, GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glMultiTexCoordP3uiv(int texture, int type, int[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoordP3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoordP3uiv\" not available");
    }
        dispatch_glMultiTexCoordP3uiv1(texture, type, coords, Buffers.SIZEOF_INT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP4ui}(GLenum texture, GLenum type, GLuint coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glMultiTexCoordP4ui(int texture, int type, int coords)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoordP4ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoordP4ui\" not available");
    }
        dispatch_glMultiTexCoordP4ui1(texture, type, coords, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP4ui}(GLenum texture, GLenum type, GLuint coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public native void dispatch_glMultiTexCoordP4ui1(int texture, int type, int coords, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP4uiv}(GLenum texture, GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexCoordP4uiv(int texture, int type, IntBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoordP4uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoordP4uiv\" not available");
    }
        dispatch_glMultiTexCoordP4uiv1(texture, type, coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP4uiv}(GLenum texture, GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexCoordP4uiv1(int texture, int type, Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP4uiv}(GLenum texture, GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glMultiTexCoordP4uiv(int texture, int type, int[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoordP4uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoordP4uiv\" not available");
    }
        dispatch_glMultiTexCoordP4uiv1(texture, type, coords, Buffers.SIZEOF_INT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordPointerEXT}(GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiTexCoordPointerEXT(int texunit, int size, int type, int stride, Buffer pointer)  {

    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoordPointerEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoordPointerEXT\" not available");
    }
        dispatch_glMultiTexCoordPointerEXT1(texunit, size, type, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordPointerEXT}(GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiTexCoordPointerEXT1(int texunit, int size, int type, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexEnvfEXT}(GLenum texunit, GLenum target, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMultiTexEnvfEXT(int texunit, int target, int pname, float param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexEnvfEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexEnvfEXT\" not available");
    }
        dispatch_glMultiTexEnvfEXT1(texunit, target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexEnvfEXT}(GLenum texunit, GLenum target, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glMultiTexEnvfEXT1(int texunit, int target, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexEnvfvEXT}(GLenum texunit, GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMultiTexEnvfvEXT(int texunit, int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexEnvfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexEnvfvEXT\" not available");
    }
        dispatch_glMultiTexEnvfvEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexEnvfvEXT}(GLenum texunit, GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMultiTexEnvfvEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexEnvfvEXT}(GLenum texunit, GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMultiTexEnvfvEXT(int texunit, int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexEnvfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexEnvfvEXT\" not available");
    }
        dispatch_glMultiTexEnvfvEXT1(texunit, target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexEnviEXT}(GLenum texunit, GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMultiTexEnviEXT(int texunit, int target, int pname, int param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexEnviEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexEnviEXT\" not available");
    }
        dispatch_glMultiTexEnviEXT1(texunit, target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexEnviEXT}(GLenum texunit, GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glMultiTexEnviEXT1(int texunit, int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexEnvivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexEnvivEXT(int texunit, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexEnvivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexEnvivEXT\" not available");
    }
        dispatch_glMultiTexEnvivEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexEnvivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexEnvivEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexEnvivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMultiTexEnvivEXT(int texunit, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexEnvivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexEnvivEXT\" not available");
    }
        dispatch_glMultiTexEnvivEXT1(texunit, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexGendEXT}(GLenum texunit, GLenum coord, GLenum pname, GLdouble param); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMultiTexGendEXT(int texunit, int coord, int pname, double param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexGendEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexGendEXT\" not available");
    }
        dispatch_glMultiTexGendEXT1(texunit, coord, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexGendEXT}(GLenum texunit, GLenum coord, GLenum pname, GLdouble param); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glMultiTexGendEXT1(int texunit, int coord, int pname, double param, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexGendvEXT}(GLenum texunit, GLenum coord, GLenum pname, const GLdouble *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMultiTexGendvEXT(int texunit, int coord, int pname, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexGendvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexGendvEXT\" not available");
    }
        dispatch_glMultiTexGendvEXT1(texunit, coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexGendvEXT}(GLenum texunit, GLenum coord, GLenum pname, const GLdouble *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMultiTexGendvEXT1(int texunit, int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexGendvEXT}(GLenum texunit, GLenum coord, GLenum pname, const GLdouble *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMultiTexGendvEXT(int texunit, int coord, int pname, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexGendvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexGendvEXT\" not available");
    }
        dispatch_glMultiTexGendvEXT1(texunit, coord, pname, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexGenfEXT}(GLenum texunit, GLenum coord, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMultiTexGenfEXT(int texunit, int coord, int pname, float param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexGenfEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexGenfEXT\" not available");
    }
        dispatch_glMultiTexGenfEXT1(texunit, coord, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexGenfEXT}(GLenum texunit, GLenum coord, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glMultiTexGenfEXT1(int texunit, int coord, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexGenfvEXT}(GLenum texunit, GLenum coord, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMultiTexGenfvEXT(int texunit, int coord, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexGenfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexGenfvEXT\" not available");
    }
        dispatch_glMultiTexGenfvEXT1(texunit, coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexGenfvEXT}(GLenum texunit, GLenum coord, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMultiTexGenfvEXT1(int texunit, int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexGenfvEXT}(GLenum texunit, GLenum coord, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMultiTexGenfvEXT(int texunit, int coord, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexGenfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexGenfvEXT\" not available");
    }
        dispatch_glMultiTexGenfvEXT1(texunit, coord, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexGeniEXT}(GLenum texunit, GLenum coord, GLenum pname, GLint param); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMultiTexGeniEXT(int texunit, int coord, int pname, int param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexGeniEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexGeniEXT\" not available");
    }
        dispatch_glMultiTexGeniEXT1(texunit, coord, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexGeniEXT}(GLenum texunit, GLenum coord, GLenum pname, GLint param); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glMultiTexGeniEXT1(int texunit, int coord, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexGenivEXT}(GLenum texunit, GLenum coord, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexGenivEXT(int texunit, int coord, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexGenivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexGenivEXT\" not available");
    }
        dispatch_glMultiTexGenivEXT1(texunit, coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexGenivEXT}(GLenum texunit, GLenum coord, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexGenivEXT1(int texunit, int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexGenivEXT}(GLenum texunit, GLenum coord, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMultiTexGenivEXT(int texunit, int coord, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexGenivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexGenivEXT\" not available");
    }
        dispatch_glMultiTexGenivEXT1(texunit, coord, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiTexImage1DEXT(int texunit, int target, int level, int internalformat, int width, int border, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexImage1DEXT\" not available");
    }
        dispatch_glMultiTexImage1DEXT1(texunit, target, level, internalformat, width, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiTexImage1DEXT1(int texunit, int target, int level, int internalformat, int width, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiTexImage2DEXT(int texunit, int target, int level, int internalformat, int width, int height, int border, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexImage2DEXT\" not available");
    }
        dispatch_glMultiTexImage2DEXT1(texunit, target, level, internalformat, width, height, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiTexImage2DEXT1(int texunit, int target, int level, int internalformat, int width, int height, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexImage3DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiTexImage3DEXT(int texunit, int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexImage3DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexImage3DEXT\" not available");
    }
        dispatch_glMultiTexImage3DEXT1(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexImage3DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiTexImage3DEXT1(int texunit, int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexParameterIivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexParameterIivEXT(int texunit, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexParameterIivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexParameterIivEXT\" not available");
    }
        dispatch_glMultiTexParameterIivEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexParameterIivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexParameterIivEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexParameterIivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMultiTexParameterIivEXT(int texunit, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexParameterIivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexParameterIivEXT\" not available");
    }
        dispatch_glMultiTexParameterIivEXT1(texunit, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexParameterIuivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLuint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexParameterIuivEXT(int texunit, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexParameterIuivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexParameterIuivEXT\" not available");
    }
        dispatch_glMultiTexParameterIuivEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexParameterIuivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLuint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexParameterIuivEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexParameterIuivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLuint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMultiTexParameterIuivEXT(int texunit, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexParameterIuivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexParameterIuivEXT\" not available");
    }
        dispatch_glMultiTexParameterIuivEXT1(texunit, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexParameterfEXT}(GLenum texunit, GLenum target, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMultiTexParameterfEXT(int texunit, int target, int pname, float param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexParameterfEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexParameterfEXT\" not available");
    }
        dispatch_glMultiTexParameterfEXT1(texunit, target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexParameterfEXT}(GLenum texunit, GLenum target, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glMultiTexParameterfEXT1(int texunit, int target, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexParameterfvEXT}(GLenum texunit, GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMultiTexParameterfvEXT(int texunit, int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexParameterfvEXT\" not available");
    }
        dispatch_glMultiTexParameterfvEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexParameterfvEXT}(GLenum texunit, GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMultiTexParameterfvEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexParameterfvEXT}(GLenum texunit, GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMultiTexParameterfvEXT(int texunit, int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexParameterfvEXT\" not available");
    }
        dispatch_glMultiTexParameterfvEXT1(texunit, target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexParameteriEXT}(GLenum texunit, GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMultiTexParameteriEXT(int texunit, int target, int pname, int param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexParameteriEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexParameteriEXT\" not available");
    }
        dispatch_glMultiTexParameteriEXT1(texunit, target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexParameteriEXT}(GLenum texunit, GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glMultiTexParameteriEXT1(int texunit, int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexParameterivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexParameterivEXT(int texunit, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexParameterivEXT\" not available");
    }
        dispatch_glMultiTexParameterivEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexParameterivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexParameterivEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexParameterivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMultiTexParameterivEXT(int texunit, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexParameterivEXT\" not available");
    }
        dispatch_glMultiTexParameterivEXT1(texunit, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexRenderbufferEXT}(GLenum texunit, GLenum target, GLuint renderbuffer); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glMultiTexRenderbufferEXT(int texunit, int target, int renderbuffer)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexRenderbufferEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexRenderbufferEXT\" not available");
    }
        dispatch_glMultiTexRenderbufferEXT1(texunit, target, renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexRenderbufferEXT}(GLenum texunit, GLenum target, GLuint renderbuffer); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glMultiTexRenderbufferEXT1(int texunit, int target, int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexSubImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiTexSubImage1DEXT(int texunit, int target, int level, int xoffset, int width, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexSubImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexSubImage1DEXT\" not available");
    }
        dispatch_glMultiTexSubImage1DEXT1(texunit, target, level, xoffset, width, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexSubImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiTexSubImage1DEXT1(int texunit, int target, int level, int xoffset, int width, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexSubImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiTexSubImage2DEXT(int texunit, int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexSubImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexSubImage2DEXT\" not available");
    }
        dispatch_glMultiTexSubImage2DEXT1(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexSubImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiTexSubImage2DEXT1(int texunit, int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexSubImage3DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiTexSubImage3DEXT(int texunit, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexSubImage3DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexSubImage3DEXT\" not available");
    }
        dispatch_glMultiTexSubImage3DEXT1(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexSubImage3DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiTexSubImage3DEXT1(int texunit, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedBufferDataEXT}(GLuint buffer, GLsizeiptr size, const GLvoid *  data, GLenum usage); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glNamedBufferDataEXT(int buffer, long size, Buffer data, int usage)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedBufferDataEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedBufferDataEXT\" not available");
    }
        dispatch_glNamedBufferDataEXT1(buffer, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, usage, __addr_);
    bufferSizeTracker.setDirectStateBufferSize(buffer, this, size);
  }

  /** Entry point to C language function: <code> void {@native glNamedBufferDataEXT}(GLuint buffer, GLsizeiptr size, const GLvoid *  data, GLenum usage); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glNamedBufferDataEXT1(int buffer, long size, Object data, int data_byte_offset, boolean data_is_direct, int usage, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedBufferSubDataEXT}(GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid *  data); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glNamedBufferSubDataEXT(int buffer, long offset, long size, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedBufferSubDataEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedBufferSubDataEXT\" not available");
    }
        dispatch_glNamedBufferSubDataEXT1(buffer, offset, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedBufferSubDataEXT}(GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid *  data); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glNamedBufferSubDataEXT1(int buffer, long offset, long size, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedCopyBufferSubDataEXT}(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glNamedCopyBufferSubDataEXT(int readBuffer, int writeBuffer, long readOffset, long writeOffset, long size)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedCopyBufferSubDataEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedCopyBufferSubDataEXT\" not available");
    }
        dispatch_glNamedCopyBufferSubDataEXT1(readBuffer, writeBuffer, readOffset, writeOffset, size, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedCopyBufferSubDataEXT}(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glNamedCopyBufferSubDataEXT1(int readBuffer, int writeBuffer, long readOffset, long writeOffset, long size, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedFramebufferRenderbufferEXT}(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glNamedFramebufferRenderbufferEXT(int framebuffer, int attachment, int renderbuffertarget, int renderbuffer)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedFramebufferRenderbufferEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedFramebufferRenderbufferEXT\" not available");
    }
        dispatch_glNamedFramebufferRenderbufferEXT1(framebuffer, attachment, renderbuffertarget, renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferRenderbufferEXT}(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glNamedFramebufferRenderbufferEXT1(int framebuffer, int attachment, int renderbuffertarget, int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTexture1DEXT}(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glNamedFramebufferTexture1DEXT(int framebuffer, int attachment, int textarget, int texture, int level)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedFramebufferTexture1DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedFramebufferTexture1DEXT\" not available");
    }
        dispatch_glNamedFramebufferTexture1DEXT1(framebuffer, attachment, textarget, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTexture1DEXT}(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glNamedFramebufferTexture1DEXT1(int framebuffer, int attachment, int textarget, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTexture2DEXT}(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glNamedFramebufferTexture2DEXT(int framebuffer, int attachment, int textarget, int texture, int level)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedFramebufferTexture2DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedFramebufferTexture2DEXT\" not available");
    }
        dispatch_glNamedFramebufferTexture2DEXT1(framebuffer, attachment, textarget, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTexture2DEXT}(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glNamedFramebufferTexture2DEXT1(int framebuffer, int attachment, int textarget, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTexture3DEXT}(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glNamedFramebufferTexture3DEXT(int framebuffer, int attachment, int textarget, int texture, int level, int zoffset)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedFramebufferTexture3DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedFramebufferTexture3DEXT\" not available");
    }
        dispatch_glNamedFramebufferTexture3DEXT1(framebuffer, attachment, textarget, texture, level, zoffset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTexture3DEXT}(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glNamedFramebufferTexture3DEXT1(int framebuffer, int attachment, int textarget, int texture, int level, int zoffset, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTextureEXT}(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glNamedFramebufferTextureEXT(int framebuffer, int attachment, int texture, int level)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedFramebufferTextureEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedFramebufferTextureEXT\" not available");
    }
        dispatch_glNamedFramebufferTextureEXT1(framebuffer, attachment, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTextureEXT}(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glNamedFramebufferTextureEXT1(int framebuffer, int attachment, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTextureFaceEXT}(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glNamedFramebufferTextureFaceEXT(int framebuffer, int attachment, int texture, int level, int face)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedFramebufferTextureFaceEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedFramebufferTextureFaceEXT\" not available");
    }
        dispatch_glNamedFramebufferTextureFaceEXT1(framebuffer, attachment, texture, level, face, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTextureFaceEXT}(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glNamedFramebufferTextureFaceEXT1(int framebuffer, int attachment, int texture, int level, int face, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTextureLayerEXT}(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glNamedFramebufferTextureLayerEXT(int framebuffer, int attachment, int texture, int level, int layer)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedFramebufferTextureLayerEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedFramebufferTextureLayerEXT\" not available");
    }
        dispatch_glNamedFramebufferTextureLayerEXT1(framebuffer, attachment, texture, level, layer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTextureLayerEXT}(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glNamedFramebufferTextureLayerEXT1(int framebuffer, int attachment, int texture, int level, int layer, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameter4dEXT}(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glNamedProgramLocalParameter4dEXT(int program, int target, int index, double x, double y, double z, double w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedProgramLocalParameter4dEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedProgramLocalParameter4dEXT\" not available");
    }
        dispatch_glNamedProgramLocalParameter4dEXT1(program, target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameter4dEXT}(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glNamedProgramLocalParameter4dEXT1(int program, int target, int index, double x, double y, double z, double w, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameter4dvEXT}(GLuint program, GLenum target, GLuint index, const GLdouble *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glNamedProgramLocalParameter4dvEXT(int program, int target, int index, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedProgramLocalParameter4dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedProgramLocalParameter4dvEXT\" not available");
    }
        dispatch_glNamedProgramLocalParameter4dvEXT1(program, target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameter4dvEXT}(GLuint program, GLenum target, GLuint index, const GLdouble *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glNamedProgramLocalParameter4dvEXT1(int program, int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameter4dvEXT}(GLuint program, GLenum target, GLuint index, const GLdouble *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glNamedProgramLocalParameter4dvEXT(int program, int target, int index, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedProgramLocalParameter4dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedProgramLocalParameter4dvEXT\" not available");
    }
        dispatch_glNamedProgramLocalParameter4dvEXT1(program, target, index, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameter4fEXT}(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glNamedProgramLocalParameter4fEXT(int program, int target, int index, float x, float y, float z, float w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedProgramLocalParameter4fEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedProgramLocalParameter4fEXT\" not available");
    }
        dispatch_glNamedProgramLocalParameter4fEXT1(program, target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameter4fEXT}(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glNamedProgramLocalParameter4fEXT1(int program, int target, int index, float x, float y, float z, float w, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameter4fvEXT}(GLuint program, GLenum target, GLuint index, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glNamedProgramLocalParameter4fvEXT(int program, int target, int index, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedProgramLocalParameter4fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedProgramLocalParameter4fvEXT\" not available");
    }
        dispatch_glNamedProgramLocalParameter4fvEXT1(program, target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameter4fvEXT}(GLuint program, GLenum target, GLuint index, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glNamedProgramLocalParameter4fvEXT1(int program, int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameter4fvEXT}(GLuint program, GLenum target, GLuint index, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glNamedProgramLocalParameter4fvEXT(int program, int target, int index, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedProgramLocalParameter4fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedProgramLocalParameter4fvEXT\" not available");
    }
        dispatch_glNamedProgramLocalParameter4fvEXT1(program, target, index, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameterI4iEXT}(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glNamedProgramLocalParameterI4iEXT(int program, int target, int index, int x, int y, int z, int w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedProgramLocalParameterI4iEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedProgramLocalParameterI4iEXT\" not available");
    }
        dispatch_glNamedProgramLocalParameterI4iEXT1(program, target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameterI4iEXT}(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glNamedProgramLocalParameterI4iEXT1(int program, int target, int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameterI4ivEXT}(GLuint program, GLenum target, GLuint index, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glNamedProgramLocalParameterI4ivEXT(int program, int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedProgramLocalParameterI4ivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedProgramLocalParameterI4ivEXT\" not available");
    }
        dispatch_glNamedProgramLocalParameterI4ivEXT1(program, target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameterI4ivEXT}(GLuint program, GLenum target, GLuint index, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glNamedProgramLocalParameterI4ivEXT1(int program, int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameterI4ivEXT}(GLuint program, GLenum target, GLuint index, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glNamedProgramLocalParameterI4ivEXT(int program, int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedProgramLocalParameterI4ivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedProgramLocalParameterI4ivEXT\" not available");
    }
        dispatch_glNamedProgramLocalParameterI4ivEXT1(program, target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameterI4uiEXT}(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glNamedProgramLocalParameterI4uiEXT(int program, int target, int index, int x, int y, int z, int w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedProgramLocalParameterI4uiEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedProgramLocalParameterI4uiEXT\" not available");
    }
        dispatch_glNamedProgramLocalParameterI4uiEXT1(program, target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameterI4uiEXT}(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glNamedProgramLocalParameterI4uiEXT1(int program, int target, int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameterI4uivEXT}(GLuint program, GLenum target, GLuint index, const GLuint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glNamedProgramLocalParameterI4uivEXT(int program, int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedProgramLocalParameterI4uivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedProgramLocalParameterI4uivEXT\" not available");
    }
        dispatch_glNamedProgramLocalParameterI4uivEXT1(program, target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameterI4uivEXT}(GLuint program, GLenum target, GLuint index, const GLuint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glNamedProgramLocalParameterI4uivEXT1(int program, int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameterI4uivEXT}(GLuint program, GLenum target, GLuint index, const GLuint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glNamedProgramLocalParameterI4uivEXT(int program, int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedProgramLocalParameterI4uivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedProgramLocalParameterI4uivEXT\" not available");
    }
        dispatch_glNamedProgramLocalParameterI4uivEXT1(program, target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameters4fvEXT}(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glNamedProgramLocalParameters4fvEXT(int program, int target, int index, int count, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedProgramLocalParameters4fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedProgramLocalParameters4fvEXT\" not available");
    }
        dispatch_glNamedProgramLocalParameters4fvEXT1(program, target, index, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameters4fvEXT}(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glNamedProgramLocalParameters4fvEXT1(int program, int target, int index, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameters4fvEXT}(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glNamedProgramLocalParameters4fvEXT(int program, int target, int index, int count, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedProgramLocalParameters4fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedProgramLocalParameters4fvEXT\" not available");
    }
        dispatch_glNamedProgramLocalParameters4fvEXT1(program, target, index, count, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParametersI4ivEXT}(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glNamedProgramLocalParametersI4ivEXT(int program, int target, int index, int count, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedProgramLocalParametersI4ivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedProgramLocalParametersI4ivEXT\" not available");
    }
        dispatch_glNamedProgramLocalParametersI4ivEXT1(program, target, index, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParametersI4ivEXT}(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glNamedProgramLocalParametersI4ivEXT1(int program, int target, int index, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParametersI4ivEXT}(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glNamedProgramLocalParametersI4ivEXT(int program, int target, int index, int count, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedProgramLocalParametersI4ivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedProgramLocalParametersI4ivEXT\" not available");
    }
        dispatch_glNamedProgramLocalParametersI4ivEXT1(program, target, index, count, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParametersI4uivEXT}(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glNamedProgramLocalParametersI4uivEXT(int program, int target, int index, int count, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedProgramLocalParametersI4uivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedProgramLocalParametersI4uivEXT\" not available");
    }
        dispatch_glNamedProgramLocalParametersI4uivEXT1(program, target, index, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParametersI4uivEXT}(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glNamedProgramLocalParametersI4uivEXT1(int program, int target, int index, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParametersI4uivEXT}(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glNamedProgramLocalParametersI4uivEXT(int program, int target, int index, int count, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedProgramLocalParametersI4uivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedProgramLocalParametersI4uivEXT\" not available");
    }
        dispatch_glNamedProgramLocalParametersI4uivEXT1(program, target, index, count, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramStringEXT}(GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid *  string); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param string a direct or array-backed {@link java.nio.Buffer}   */
  public void glNamedProgramStringEXT(int program, int target, int format, int len, Buffer string)  {

    final boolean string_is_direct = Buffers.isDirect(string);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedProgramStringEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedProgramStringEXT\" not available");
    }
        dispatch_glNamedProgramStringEXT1(program, target, format, len, string_is_direct ? string : Buffers.getArray(string), string_is_direct ? Buffers.getDirectBufferByteOffset(string) : Buffers.getIndirectBufferByteOffset(string), string_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramStringEXT}(GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid *  string); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param string a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glNamedProgramStringEXT1(int program, int target, int format, int len, Object string, int string_byte_offset, boolean string_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedRenderbufferStorageEXT}(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glNamedRenderbufferStorageEXT(int renderbuffer, int internalformat, int width, int height)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedRenderbufferStorageEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedRenderbufferStorageEXT\" not available");
    }
        dispatch_glNamedRenderbufferStorageEXT1(renderbuffer, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedRenderbufferStorageEXT}(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glNamedRenderbufferStorageEXT1(int renderbuffer, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedRenderbufferStorageMultisampleCoverageEXT}(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glNamedRenderbufferStorageMultisampleCoverageEXT(int renderbuffer, int coverageSamples, int colorSamples, int internalformat, int width, int height)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedRenderbufferStorageMultisampleCoverageEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedRenderbufferStorageMultisampleCoverageEXT\" not available");
    }
        dispatch_glNamedRenderbufferStorageMultisampleCoverageEXT1(renderbuffer, coverageSamples, colorSamples, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedRenderbufferStorageMultisampleCoverageEXT}(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glNamedRenderbufferStorageMultisampleCoverageEXT1(int renderbuffer, int coverageSamples, int colorSamples, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedRenderbufferStorageMultisampleEXT}(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glNamedRenderbufferStorageMultisampleEXT(int renderbuffer, int samples, int internalformat, int width, int height)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedRenderbufferStorageMultisampleEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedRenderbufferStorageMultisampleEXT\" not available");
    }
        dispatch_glNamedRenderbufferStorageMultisampleEXT1(renderbuffer, samples, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedRenderbufferStorageMultisampleEXT}(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glNamedRenderbufferStorageMultisampleEXT1(int renderbuffer, int samples, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedStringARB}(GLenum type, GLint namelen, const GLchar *  name, GLint stringlen, const GLchar *  string); </code> <br>Part of <code>GL_ARB_shading_language_include</code>   */
  public void glNamedStringARB(int type, int namelen, String name, int stringlen, String string)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNamedStringARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNamedStringARB\" not available");
    }
        dispatch_glNamedStringARB1(type, namelen, name, stringlen, string, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedStringARB}(GLenum type, GLint namelen, const GLchar *  name, GLint stringlen, const GLchar *  string); </code> <br>Part of <code>GL_ARB_shading_language_include</code>   */
  public native void dispatch_glNamedStringARB1(int type, int namelen, String name, int stringlen, String string, long procAddress);

  /** Entry point to C language function: <code> void {@native glNewList}(GLuint list, GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glNewList(int list, int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNewList;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNewList\" not available");
    }
        dispatch_glNewList1(list, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNewList}(GLuint list, GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glNewList1(int list, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3b}(GLbyte nx, GLbyte ny, GLbyte nz); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glNormal3b(byte nx, byte ny, byte nz)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormal3b;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormal3b\" not available");
    }
        dispatch_glNormal3b1(nx, ny, nz, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3b}(GLbyte nx, GLbyte ny, GLbyte nz); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glNormal3b1(byte nx, byte ny, byte nz, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3bv}(const GLbyte *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glNormal3bv(ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormal3bv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormal3bv\" not available");
    }
        dispatch_glNormal3bv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3bv}(const GLbyte *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glNormal3bv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3bv}(const GLbyte *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glNormal3bv(byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormal3bv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormal3bv\" not available");
    }
        dispatch_glNormal3bv1(v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3d}(GLdouble nx, GLdouble ny, GLdouble nz); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glNormal3d(double nx, double ny, double nz)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormal3d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormal3d\" not available");
    }
        dispatch_glNormal3d1(nx, ny, nz, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3d}(GLdouble nx, GLdouble ny, GLdouble nz); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glNormal3d1(double nx, double ny, double nz, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glNormal3dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormal3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormal3dv\" not available");
    }
        dispatch_glNormal3dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glNormal3dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glNormal3dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormal3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormal3dv\" not available");
    }
        dispatch_glNormal3dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3f}(GLfloat nx, GLfloat ny, GLfloat nz); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glNormal3f(float nx, float ny, float nz)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormal3f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormal3f\" not available");
    }
        dispatch_glNormal3f1(nx, ny, nz, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3f}(GLfloat nx, GLfloat ny, GLfloat nz); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glNormal3f1(float nx, float ny, float nz, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glNormal3fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormal3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormal3fv\" not available");
    }
        dispatch_glNormal3fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glNormal3fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glNormal3fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormal3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormal3fv\" not available");
    }
        dispatch_glNormal3fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3hNV}(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glNormal3h(short nx, short ny, short nz)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormal3h;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormal3h\" not available");
    }
        dispatch_glNormal3h1(nx, ny, nz, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3hNV}(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public native void dispatch_glNormal3h1(short nx, short ny, short nz, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glNormal3hv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormal3hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormal3hv\" not available");
    }
        dispatch_glNormal3hv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glNormal3hv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glNormal3hv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormal3hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormal3hv\" not available");
    }
        dispatch_glNormal3hv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3i}(GLint nx, GLint ny, GLint nz); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glNormal3i(int nx, int ny, int nz)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormal3i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormal3i\" not available");
    }
        dispatch_glNormal3i1(nx, ny, nz, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3i}(GLint nx, GLint ny, GLint nz); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glNormal3i1(int nx, int ny, int nz, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glNormal3iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormal3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormal3iv\" not available");
    }
        dispatch_glNormal3iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glNormal3iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glNormal3iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormal3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormal3iv\" not available");
    }
        dispatch_glNormal3iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3s}(GLshort nx, GLshort ny, GLshort nz); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glNormal3s(short nx, short ny, short nz)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormal3s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormal3s\" not available");
    }
        dispatch_glNormal3s1(nx, ny, nz, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3s}(GLshort nx, GLshort ny, GLshort nz); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glNormal3s1(short nx, short ny, short nz, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glNormal3sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormal3sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormal3sv\" not available");
    }
        dispatch_glNormal3sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glNormal3sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glNormal3sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormal3sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormal3sv\" not available");
    }
        dispatch_glNormal3sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormalFormatNV}(GLenum type, GLsizei stride); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public void glNormalFormatNV(int type, int stride)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormalFormatNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormalFormatNV\" not available");
    }
        dispatch_glNormalFormatNV1(type, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormalFormatNV}(GLenum type, GLsizei stride); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public native void dispatch_glNormalFormatNV1(int type, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormalP3ui}(GLenum type, GLuint coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glNormalP3ui(int type, int coords)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormalP3ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormalP3ui\" not available");
    }
        dispatch_glNormalP3ui1(type, coords, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormalP3ui}(GLenum type, GLuint coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public native void dispatch_glNormalP3ui1(int type, int coords, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormalP3uiv}(GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glNormalP3uiv(int type, IntBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormalP3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormalP3uiv\" not available");
    }
        dispatch_glNormalP3uiv1(type, coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormalP3uiv}(GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glNormalP3uiv1(int type, Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormalP3uiv}(GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glNormalP3uiv(int type, int[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormalP3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormalP3uiv\" not available");
    }
        dispatch_glNormalP3uiv1(type, coords, Buffers.SIZEOF_INT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormalPointer}(GLenum type, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}   */
  public void glNormalPointer(int type, int stride, Buffer ptr)  {

    checkArrayVBODisabled(true);
    Buffers.rangeCheck(ptr, 1);
    final boolean ptr_is_direct = Buffers.isDirect(ptr);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormalPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormalPointer\" not available");
    }
        dispatch_glNormalPointer1(type, stride, ptr_is_direct ? ptr : Buffers.getArray(ptr), ptr_is_direct ? Buffers.getDirectBufferByteOffset(ptr) : Buffers.getIndirectBufferByteOffset(ptr), ptr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormalPointer}(GLenum type, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glNormalPointer1(int type, int stride, Object ptr, int ptr_byte_offset, boolean ptr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormalPointer}(GLenum type, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public void glNormalPointer(int type, int stride, long ptr_buffer_offset)  {

    checkArrayVBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormalPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormalPointer\" not available");
    }
        dispatch_glNormalPointer1(type, stride, ptr_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormalPointer}(GLenum type, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  private native void dispatch_glNormalPointer1(int type, int stride, long ptr_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> GLenum {@native glObjectPurgeableAPPLE}(GLenum objectType, GLuint name, GLenum option); </code> <br>Part of <code>GL_APPLE_object_purgeable</code>   */
  public int glObjectPurgeableAPPLE(int objectType, int name, int option)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glObjectPurgeableAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glObjectPurgeableAPPLE\" not available");
    }
        return dispatch_glObjectPurgeableAPPLE1(objectType, name, option, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glObjectPurgeableAPPLE}(GLenum objectType, GLuint name, GLenum option); </code> <br>Part of <code>GL_APPLE_object_purgeable</code>   */
  public native int dispatch_glObjectPurgeableAPPLE1(int objectType, int name, int option, long procAddress);

  /** Entry point to C language function: <code> GLenum {@native glObjectUnpurgeableAPPLE}(GLenum objectType, GLuint name, GLenum option); </code> <br>Part of <code>GL_APPLE_object_purgeable</code>   */
  public int glObjectUnpurgeableAPPLE(int objectType, int name, int option)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glObjectUnpurgeableAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glObjectUnpurgeableAPPLE\" not available");
    }
        return dispatch_glObjectUnpurgeableAPPLE1(objectType, name, option, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glObjectUnpurgeableAPPLE}(GLenum objectType, GLuint name, GLenum option); </code> <br>Part of <code>GL_APPLE_object_purgeable</code>   */
  public native int dispatch_glObjectUnpurgeableAPPLE1(int objectType, int name, int option, long procAddress);

  /** Entry point to C language function: <code> void {@native glOrtho}(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glOrtho(double left, double right, double bottom, double top, double near_val, double far_val)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glOrtho;
    if (__addr_ == 0) {
      throw new GLException("Method \"glOrtho\" not available");
    }
        dispatch_glOrtho1(left, right, bottom, top, near_val, far_val, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glOrtho}(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glOrtho1(double left, double right, double bottom, double top, double near_val, double far_val, long procAddress);

  /** Entry point to C language function: <code> void {@native glPNTrianglesfATI}(GLenum pname, GLfloat param); </code> <br>Part of <code>GL_ATI_pn_triangles</code>   */
  public void glPNTrianglesfATI(int pname, float param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPNTrianglesfATI;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPNTrianglesfATI\" not available");
    }
        dispatch_glPNTrianglesfATI1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPNTrianglesfATI}(GLenum pname, GLfloat param); </code> <br>Part of <code>GL_ATI_pn_triangles</code>   */
  public native void dispatch_glPNTrianglesfATI1(int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPNTrianglesiATI}(GLenum pname, GLint param); </code> <br>Part of <code>GL_ATI_pn_triangles</code>   */
  public void glPNTrianglesiATI(int pname, int param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPNTrianglesiATI;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPNTrianglesiATI\" not available");
    }
        dispatch_glPNTrianglesiATI1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPNTrianglesiATI}(GLenum pname, GLint param); </code> <br>Part of <code>GL_ATI_pn_triangles</code>   */
  public native void dispatch_glPNTrianglesiATI1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPassThrough}(GLfloat token); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glPassThrough(float token)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPassThrough;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPassThrough\" not available");
    }
        dispatch_glPassThrough1(token, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPassThrough}(GLfloat token); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glPassThrough1(float token, long procAddress);

  /** Entry point to C language function: <code> void {@native glPatchParameterfv}(GLenum pname, const GLfloat *  values); </code> <br>Part of <code>GL_ARB_tessellation_shader</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glPatchParameterfv(int pname, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPatchParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPatchParameterfv\" not available");
    }
        dispatch_glPatchParameterfv1(pname, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPatchParameterfv}(GLenum pname, const GLfloat *  values); </code> <br>Part of <code>GL_ARB_tessellation_shader</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glPatchParameterfv1(int pname, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPatchParameterfv}(GLenum pname, const GLfloat *  values); </code> <br>Part of <code>GL_ARB_tessellation_shader</code>   */
  public void glPatchParameterfv(int pname, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPatchParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPatchParameterfv\" not available");
    }
        dispatch_glPatchParameterfv1(pname, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPatchParameteri}(GLenum pname, GLint value); </code> <br>Part of <code>GL_ARB_tessellation_shader</code>   */
  public void glPatchParameteri(int pname, int value)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPatchParameteri;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPatchParameteri\" not available");
    }
        dispatch_glPatchParameteri1(pname, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPatchParameteri}(GLenum pname, GLint value); </code> <br>Part of <code>GL_ARB_tessellation_shader</code>   */
  public native void dispatch_glPatchParameteri1(int pname, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glPauseTransformFeedback}(void); </code> <br>Part of <code>GL_ARB_transform_feedback2</code>   */
  public void glPauseTransformFeedback()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPauseTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPauseTransformFeedback\" not available");
    }
        dispatch_glPauseTransformFeedback1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPauseTransformFeedback}(void); </code> <br>Part of <code>GL_ARB_transform_feedback2</code>   */
  public native void dispatch_glPauseTransformFeedback1(long procAddress);

  /** Entry point to C language function: <code> void {@native glPauseTransformFeedbackNV}(void); </code> <br>Part of <code>GL_NV_transform_feedback2</code>   */
  public void glPauseTransformFeedbackNV()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPauseTransformFeedbackNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPauseTransformFeedbackNV\" not available");
    }
        dispatch_glPauseTransformFeedbackNV1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPauseTransformFeedbackNV}(void); </code> <br>Part of <code>GL_NV_transform_feedback2</code>   */
  public native void dispatch_glPauseTransformFeedbackNV1(long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelDataRangeNV}(GLenum target, GLsizei length, GLvoid *  pointer); </code> <br>Part of <code>GL_NV_pixel_data_range</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void glPixelDataRangeNV(int target, int length, Buffer pointer)  {

    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelDataRangeNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPixelDataRangeNV\" not available");
    }
        dispatch_glPixelDataRangeNV0(target, length, pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelDataRangeNV}(GLenum target, GLsizei length, GLvoid *  pointer); </code> <br>Part of <code>GL_NV_pixel_data_range</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glPixelDataRangeNV0(int target, int length, Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelMapfv}(GLenum map, GLint mapsize, const GLfloat *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glPixelMapfv(int map, int mapsize, FloatBuffer values)  {

    checkUnpackPBODisabled(true);
    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelMapfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPixelMapfv\" not available");
    }
        dispatch_glPixelMapfv1(map, mapsize, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelMapfv}(GLenum map, GLint mapsize, const GLfloat *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glPixelMapfv1(int map, int mapsize, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelMapfv}(GLenum map, GLint mapsize, const GLfloat *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glPixelMapfv(int map, int mapsize, float[] values, int values_offset)  {

    checkUnpackPBODisabled(true);
    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelMapfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPixelMapfv\" not available");
    }
        dispatch_glPixelMapfv1(map, mapsize, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelMapfv}(GLenum map, GLint mapsize, const GLfloat *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glPixelMapfv(int map, int mapsize, long values_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelMapfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPixelMapfv\" not available");
    }
        dispatch_glPixelMapfv1(map, mapsize, values_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelMapfv}(GLenum map, GLint mapsize, const GLfloat *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  private native void dispatch_glPixelMapfv1(int map, int mapsize, long values_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelMapuiv}(GLenum map, GLint mapsize, const GLuint *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glPixelMapuiv(int map, int mapsize, IntBuffer values)  {

    checkUnpackPBODisabled(true);
    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelMapuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPixelMapuiv\" not available");
    }
        dispatch_glPixelMapuiv1(map, mapsize, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelMapuiv}(GLenum map, GLint mapsize, const GLuint *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glPixelMapuiv1(int map, int mapsize, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelMapuiv}(GLenum map, GLint mapsize, const GLuint *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glPixelMapuiv(int map, int mapsize, int[] values, int values_offset)  {

    checkUnpackPBODisabled(true);
    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelMapuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPixelMapuiv\" not available");
    }
        dispatch_glPixelMapuiv1(map, mapsize, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelMapuiv}(GLenum map, GLint mapsize, const GLuint *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glPixelMapuiv(int map, int mapsize, long values_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelMapuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPixelMapuiv\" not available");
    }
        dispatch_glPixelMapuiv1(map, mapsize, values_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelMapuiv}(GLenum map, GLint mapsize, const GLuint *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  private native void dispatch_glPixelMapuiv1(int map, int mapsize, long values_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelMapusv}(GLenum map, GLint mapsize, const GLushort *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param values a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glPixelMapusv(int map, int mapsize, ShortBuffer values)  {

    checkUnpackPBODisabled(true);
    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelMapusv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPixelMapusv\" not available");
    }
        dispatch_glPixelMapusv1(map, mapsize, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelMapusv}(GLenum map, GLint mapsize, const GLushort *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param values a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glPixelMapusv1(int map, int mapsize, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelMapusv}(GLenum map, GLint mapsize, const GLushort *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glPixelMapusv(int map, int mapsize, short[] values, int values_offset)  {

    checkUnpackPBODisabled(true);
    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelMapusv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPixelMapusv\" not available");
    }
        dispatch_glPixelMapusv1(map, mapsize, values, Buffers.SIZEOF_SHORT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelMapusv}(GLenum map, GLint mapsize, const GLushort *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glPixelMapusv(int map, int mapsize, long values_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelMapusv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPixelMapusv\" not available");
    }
        dispatch_glPixelMapusv1(map, mapsize, values_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelMapusv}(GLenum map, GLint mapsize, const GLushort *  values); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  private native void dispatch_glPixelMapusv1(int map, int mapsize, long values_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelStoref}(GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glPixelStoref(int pname, float param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelStoref;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPixelStoref\" not available");
    }
        dispatch_glPixelStoref1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelStoref}(GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glPixelStoref1(int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelStorei}(GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glPixelStorei(int pname, int param)  {

    glStateTracker.setInt(pname, param);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelStorei;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPixelStorei\" not available");
    }
        dispatch_glPixelStorei1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelStorei}(GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  private native void dispatch_glPixelStorei1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelTransferf}(GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glPixelTransferf(int pname, float param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelTransferf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPixelTransferf\" not available");
    }
        dispatch_glPixelTransferf1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelTransferf}(GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glPixelTransferf1(int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelTransferi}(GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glPixelTransferi(int pname, int param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelTransferi;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPixelTransferi\" not available");
    }
        dispatch_glPixelTransferi1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelTransferi}(GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glPixelTransferi1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelTransformParameterfEXT}(GLenum target, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_EXT_pixel_transform</code>   */
  public void glPixelTransformParameterfEXT(int target, int pname, float param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelTransformParameterfEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPixelTransformParameterfEXT\" not available");
    }
        dispatch_glPixelTransformParameterfEXT1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelTransformParameterfEXT}(GLenum target, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_EXT_pixel_transform</code>   */
  public native void dispatch_glPixelTransformParameterfEXT1(int target, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelTransformParameterfvEXT}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_pixel_transform</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glPixelTransformParameterfvEXT(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelTransformParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPixelTransformParameterfvEXT\" not available");
    }
        dispatch_glPixelTransformParameterfvEXT1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelTransformParameterfvEXT}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_pixel_transform</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glPixelTransformParameterfvEXT1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelTransformParameterfvEXT}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_pixel_transform</code>   */
  public void glPixelTransformParameterfvEXT(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelTransformParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPixelTransformParameterfvEXT\" not available");
    }
        dispatch_glPixelTransformParameterfvEXT1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelTransformParameteriEXT}(GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_EXT_pixel_transform</code>   */
  public void glPixelTransformParameteriEXT(int target, int pname, int param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelTransformParameteriEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPixelTransformParameteriEXT\" not available");
    }
        dispatch_glPixelTransformParameteriEXT1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelTransformParameteriEXT}(GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_EXT_pixel_transform</code>   */
  public native void dispatch_glPixelTransformParameteriEXT1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelTransformParameterivEXT}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_EXT_pixel_transform</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glPixelTransformParameterivEXT(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelTransformParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPixelTransformParameterivEXT\" not available");
    }
        dispatch_glPixelTransformParameterivEXT1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelTransformParameterivEXT}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_EXT_pixel_transform</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glPixelTransformParameterivEXT1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelTransformParameterivEXT}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_EXT_pixel_transform</code>   */
  public void glPixelTransformParameterivEXT(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelTransformParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPixelTransformParameterivEXT\" not available");
    }
        dispatch_glPixelTransformParameterivEXT1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelZoom}(GLfloat xfactor, GLfloat yfactor); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glPixelZoom(float xfactor, float yfactor)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelZoom;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPixelZoom\" not available");
    }
        dispatch_glPixelZoom1(xfactor, yfactor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelZoom}(GLfloat xfactor, GLfloat yfactor); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glPixelZoom1(float xfactor, float yfactor, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointParameterf}(GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_4</code>   */
  public void glPointParameterf(int pname, float param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPointParameterf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPointParameterf\" not available");
    }
        dispatch_glPointParameterf1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointParameterf}(GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_4</code>   */
  public native void dispatch_glPointParameterf1(int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointParameterfv}(GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_4</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glPointParameterfv(int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPointParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPointParameterfv\" not available");
    }
        dispatch_glPointParameterfv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointParameterfv}(GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_4</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glPointParameterfv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointParameterfv}(GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_4</code>   */
  public void glPointParameterfv(int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPointParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPointParameterfv\" not available");
    }
        dispatch_glPointParameterfv1(pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointParameteri}(GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_4</code>   */
  public void glPointParameteri(int pname, int param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPointParameteri;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPointParameteri\" not available");
    }
        dispatch_glPointParameteri1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointParameteri}(GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_4</code>   */
  public native void dispatch_glPointParameteri1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointParameteriv}(GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glPointParameteriv(int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPointParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPointParameteriv\" not available");
    }
        dispatch_glPointParameteriv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointParameteriv}(GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glPointParameteriv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointParameteriv}(GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_4</code>   */
  public void glPointParameteriv(int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPointParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPointParameteriv\" not available");
    }
        dispatch_glPointParameteriv1(pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointSize}(GLfloat size); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glPointSize(float size)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPointSize;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPointSize\" not available");
    }
        dispatch_glPointSize1(size, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointSize}(GLfloat size); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glPointSize1(float size, long procAddress);

  /** Entry point to C language function: <code> void {@native glPolygonMode}(GLenum face, GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glPolygonMode(int face, int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPolygonMode;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPolygonMode\" not available");
    }
        dispatch_glPolygonMode1(face, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPolygonMode}(GLenum face, GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glPolygonMode1(int face, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glPolygonOffset}(GLfloat factor, GLfloat units); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_1_0</code>   */
  public void glPolygonOffset(float factor, float units)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPolygonOffset;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPolygonOffset\" not available");
    }
        dispatch_glPolygonOffset1(factor, units, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPolygonOffset}(GLfloat factor, GLfloat units); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glPolygonOffset1(float factor, float units, long procAddress);

  /** Entry point to C language function: <code> void {@native glPolygonStipple}(const GLubyte *  mask); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param mask a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glPolygonStipple(ByteBuffer mask)  {

    checkUnpackPBODisabled(true);
    final boolean mask_is_direct = Buffers.isDirect(mask);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPolygonStipple;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPolygonStipple\" not available");
    }
        dispatch_glPolygonStipple1(mask_is_direct ? mask : Buffers.getArray(mask), mask_is_direct ? Buffers.getDirectBufferByteOffset(mask) : Buffers.getIndirectBufferByteOffset(mask), mask_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPolygonStipple}(const GLubyte *  mask); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param mask a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glPolygonStipple1(Object mask, int mask_byte_offset, boolean mask_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPolygonStipple}(const GLubyte *  mask); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glPolygonStipple(byte[] mask, int mask_offset)  {

    checkUnpackPBODisabled(true);
    if(mask != null && mask.length <= mask_offset)
      throw new GLException("array offset argument \"mask_offset\" (" + mask_offset + ") equals or exceeds array length (" + mask.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPolygonStipple;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPolygonStipple\" not available");
    }
        dispatch_glPolygonStipple1(mask, mask_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPolygonStipple}(const GLubyte *  mask); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glPolygonStipple(long mask_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPolygonStipple;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPolygonStipple\" not available");
    }
        dispatch_glPolygonStipple1(mask_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPolygonStipple}(const GLubyte *  mask); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  private native void dispatch_glPolygonStipple1(long mask_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glPopAttrib}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glPopAttrib()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPopAttrib;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPopAttrib\" not available");
    }
        dispatch_glPopAttrib1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPopAttrib}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glPopAttrib1(long procAddress);

  /** Entry point to C language function: <code> void {@native glPopClientAttrib}(void); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public void glPopClientAttrib()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPopClientAttrib;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPopClientAttrib\" not available");
    }
        dispatch_glPopClientAttrib1(__addr_);
    bufferStateTracker.clearBufferObjectState();
    glStateTracker.popAttrib();
  }

  /** Entry point to C language function: <code> void {@native glPopClientAttrib}(void); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  private native void dispatch_glPopClientAttrib1(long procAddress);

  /** Entry point to C language function: <code> void {@native glPopMatrix}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glPopMatrix()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPopMatrix;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPopMatrix\" not available");
    }
        dispatch_glPopMatrix1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPopMatrix}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glPopMatrix1(long procAddress);

  /** Entry point to C language function: <code> void {@native glPopName}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glPopName()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPopName;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPopName\" not available");
    }
        dispatch_glPopName1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPopName}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glPopName1(long procAddress);

  /** Entry point to C language function: <code> void {@native glPrimitiveRestartIndex}(GLuint index); </code> <br>Part of <code>GL_VERSION_3_1</code>   */
  public void glPrimitiveRestartIndex(int index)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPrimitiveRestartIndex;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPrimitiveRestartIndex\" not available");
    }
        dispatch_glPrimitiveRestartIndex1(index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPrimitiveRestartIndex}(GLuint index); </code> <br>Part of <code>GL_VERSION_3_1</code>   */
  public native void dispatch_glPrimitiveRestartIndex1(int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glPrimitiveRestartIndexNV}(GLuint index); </code> <br>Part of <code>GL_NV_primitive_restart</code>   */
  public void glPrimitiveRestartIndexNV(int index)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPrimitiveRestartIndexNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPrimitiveRestartIndexNV\" not available");
    }
        dispatch_glPrimitiveRestartIndexNV1(index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPrimitiveRestartIndexNV}(GLuint index); </code> <br>Part of <code>GL_NV_primitive_restart</code>   */
  public native void dispatch_glPrimitiveRestartIndexNV1(int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glPrimitiveRestartNV}(void); </code> <br>Part of <code>GL_NV_primitive_restart</code>   */
  public void glPrimitiveRestartNV()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPrimitiveRestartNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPrimitiveRestartNV\" not available");
    }
        dispatch_glPrimitiveRestartNV1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPrimitiveRestartNV}(void); </code> <br>Part of <code>GL_NV_primitive_restart</code>   */
  public native void dispatch_glPrimitiveRestartNV1(long procAddress);

  /** Entry point to C language function: <code> void {@native glPrioritizeTextures}(GLsizei n, const GLuint *  textures, const GLclampf *  priorities); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}
      @param priorities a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glPrioritizeTextures(int n, IntBuffer textures, FloatBuffer priorities)  {

    final boolean textures_is_direct = Buffers.isDirect(textures);
    final boolean priorities_is_direct = Buffers.isDirect(priorities);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPrioritizeTextures;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPrioritizeTextures\" not available");
    }
        dispatch_glPrioritizeTextures1(n, textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, priorities_is_direct ? priorities : Buffers.getArray(priorities), priorities_is_direct ? Buffers.getDirectBufferByteOffset(priorities) : Buffers.getIndirectBufferByteOffset(priorities), priorities_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPrioritizeTextures}(GLsizei n, const GLuint *  textures, const GLclampf *  priorities); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}
      @param priorities a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glPrioritizeTextures1(int n, Object textures, int textures_byte_offset, boolean textures_is_direct, Object priorities, int priorities_byte_offset, boolean priorities_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPrioritizeTextures}(GLsizei n, const GLuint *  textures, const GLclampf *  priorities); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public void glPrioritizeTextures(int n, int[] textures, int textures_offset, float[] priorities, int priorities_offset)  {

    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    if(priorities != null && priorities.length <= priorities_offset)
      throw new GLException("array offset argument \"priorities_offset\" (" + priorities_offset + ") equals or exceeds array length (" + priorities.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPrioritizeTextures;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPrioritizeTextures\" not available");
    }
        dispatch_glPrioritizeTextures1(n, textures, Buffers.SIZEOF_INT * textures_offset, false, priorities, Buffers.SIZEOF_FLOAT * priorities_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramBinary}(GLuint program, GLenum binaryFormat, const GLvoid *  binary, GLsizei length); </code> <br>Part of <code>GL_ARB_get_program_binary</code>
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glProgramBinary(int program, int binaryFormat, Buffer binary, int length)  {

    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramBinary;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramBinary\" not available");
    }
        dispatch_glProgramBinary1(program, binaryFormat, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramBinary}(GLuint program, GLenum binaryFormat, const GLvoid *  binary, GLsizei length); </code> <br>Part of <code>GL_ARB_get_program_binary</code>
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glProgramBinary1(int program, int binaryFormat, Object binary, int binary_byte_offset, boolean binary_is_direct, int length, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramBufferParametersIivNV}(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *  params); </code> <br>Part of <code>GL_NV_parameter_buffer_object</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramBufferParametersIivNV(int target, int buffer, int index, int count, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramBufferParametersIivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramBufferParametersIivNV\" not available");
    }
        dispatch_glProgramBufferParametersIivNV1(target, buffer, index, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramBufferParametersIivNV}(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *  params); </code> <br>Part of <code>GL_NV_parameter_buffer_object</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramBufferParametersIivNV1(int target, int buffer, int index, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramBufferParametersIivNV}(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *  params); </code> <br>Part of <code>GL_NV_parameter_buffer_object</code>   */
  public void glProgramBufferParametersIivNV(int target, int buffer, int index, int count, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramBufferParametersIivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramBufferParametersIivNV\" not available");
    }
        dispatch_glProgramBufferParametersIivNV1(target, buffer, index, count, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramBufferParametersIuivNV}(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *  params); </code> <br>Part of <code>GL_NV_parameter_buffer_object</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramBufferParametersIuivNV(int target, int buffer, int index, int count, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramBufferParametersIuivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramBufferParametersIuivNV\" not available");
    }
        dispatch_glProgramBufferParametersIuivNV1(target, buffer, index, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramBufferParametersIuivNV}(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *  params); </code> <br>Part of <code>GL_NV_parameter_buffer_object</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramBufferParametersIuivNV1(int target, int buffer, int index, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramBufferParametersIuivNV}(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *  params); </code> <br>Part of <code>GL_NV_parameter_buffer_object</code>   */
  public void glProgramBufferParametersIuivNV(int target, int buffer, int index, int count, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramBufferParametersIuivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramBufferParametersIuivNV\" not available");
    }
        dispatch_glProgramBufferParametersIuivNV1(target, buffer, index, count, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramBufferParametersfvNV}(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *  params); </code> <br>Part of <code>GL_NV_parameter_buffer_object</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramBufferParametersfvNV(int target, int buffer, int index, int count, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramBufferParametersfvNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramBufferParametersfvNV\" not available");
    }
        dispatch_glProgramBufferParametersfvNV1(target, buffer, index, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramBufferParametersfvNV}(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *  params); </code> <br>Part of <code>GL_NV_parameter_buffer_object</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramBufferParametersfvNV1(int target, int buffer, int index, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramBufferParametersfvNV}(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *  params); </code> <br>Part of <code>GL_NV_parameter_buffer_object</code>   */
  public void glProgramBufferParametersfvNV(int target, int buffer, int index, int count, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramBufferParametersfvNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramBufferParametersfvNV\" not available");
    }
        dispatch_glProgramBufferParametersfvNV1(target, buffer, index, count, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameter4dARB}(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glProgramEnvParameter4dARB(int target, int index, double x, double y, double z, double w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramEnvParameter4dARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramEnvParameter4dARB\" not available");
    }
        dispatch_glProgramEnvParameter4dARB1(target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameter4dARB}(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public native void dispatch_glProgramEnvParameter4dARB1(int target, int index, double x, double y, double z, double w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramEnvParameter4dvARB}(GLenum target, GLuint index, const GLdouble *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramEnvParameter4dvARB(int target, int index, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramEnvParameter4dvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramEnvParameter4dvARB\" not available");
    }
        dispatch_glProgramEnvParameter4dvARB1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameter4dvARB}(GLenum target, GLuint index, const GLdouble *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramEnvParameter4dvARB1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramEnvParameter4dvARB}(GLenum target, GLuint index, const GLdouble *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glProgramEnvParameter4dvARB(int target, int index, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramEnvParameter4dvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramEnvParameter4dvARB\" not available");
    }
        dispatch_glProgramEnvParameter4dvARB1(target, index, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameter4fARB}(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glProgramEnvParameter4fARB(int target, int index, float x, float y, float z, float w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramEnvParameter4fARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramEnvParameter4fARB\" not available");
    }
        dispatch_glProgramEnvParameter4fARB1(target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameter4fARB}(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public native void dispatch_glProgramEnvParameter4fARB1(int target, int index, float x, float y, float z, float w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramEnvParameter4fvARB}(GLenum target, GLuint index, const GLfloat *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramEnvParameter4fvARB(int target, int index, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramEnvParameter4fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramEnvParameter4fvARB\" not available");
    }
        dispatch_glProgramEnvParameter4fvARB1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameter4fvARB}(GLenum target, GLuint index, const GLfloat *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramEnvParameter4fvARB1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramEnvParameter4fvARB}(GLenum target, GLuint index, const GLfloat *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glProgramEnvParameter4fvARB(int target, int index, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramEnvParameter4fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramEnvParameter4fvARB\" not available");
    }
        dispatch_glProgramEnvParameter4fvARB1(target, index, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameterI4iNV}(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w); </code> <br>Part of <code>GL_NV_gpu_program4</code>   */
  public void glProgramEnvParameterI4iNV(int target, int index, int x, int y, int z, int w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramEnvParameterI4iNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramEnvParameterI4iNV\" not available");
    }
        dispatch_glProgramEnvParameterI4iNV1(target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameterI4iNV}(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w); </code> <br>Part of <code>GL_NV_gpu_program4</code>   */
  public native void dispatch_glProgramEnvParameterI4iNV1(int target, int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramEnvParameterI4ivNV}(GLenum target, GLuint index, const GLint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramEnvParameterI4ivNV(int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramEnvParameterI4ivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramEnvParameterI4ivNV\" not available");
    }
        dispatch_glProgramEnvParameterI4ivNV1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameterI4ivNV}(GLenum target, GLuint index, const GLint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramEnvParameterI4ivNV1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramEnvParameterI4ivNV}(GLenum target, GLuint index, const GLint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>   */
  public void glProgramEnvParameterI4ivNV(int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramEnvParameterI4ivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramEnvParameterI4ivNV\" not available");
    }
        dispatch_glProgramEnvParameterI4ivNV1(target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameterI4uiNV}(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w); </code> <br>Part of <code>GL_NV_gpu_program4</code>   */
  public void glProgramEnvParameterI4uiNV(int target, int index, int x, int y, int z, int w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramEnvParameterI4uiNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramEnvParameterI4uiNV\" not available");
    }
        dispatch_glProgramEnvParameterI4uiNV1(target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameterI4uiNV}(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w); </code> <br>Part of <code>GL_NV_gpu_program4</code>   */
  public native void dispatch_glProgramEnvParameterI4uiNV1(int target, int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramEnvParameterI4uivNV}(GLenum target, GLuint index, const GLuint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramEnvParameterI4uivNV(int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramEnvParameterI4uivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramEnvParameterI4uivNV\" not available");
    }
        dispatch_glProgramEnvParameterI4uivNV1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameterI4uivNV}(GLenum target, GLuint index, const GLuint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramEnvParameterI4uivNV1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramEnvParameterI4uivNV}(GLenum target, GLuint index, const GLuint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>   */
  public void glProgramEnvParameterI4uivNV(int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramEnvParameterI4uivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramEnvParameterI4uivNV\" not available");
    }
        dispatch_glProgramEnvParameterI4uivNV1(target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameters4fvEXT}(GLenum target, GLuint index, GLsizei count, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_gpu_program_parameters</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramEnvParameters4fvEXT(int target, int index, int count, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramEnvParameters4fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramEnvParameters4fvEXT\" not available");
    }
        dispatch_glProgramEnvParameters4fvEXT1(target, index, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameters4fvEXT}(GLenum target, GLuint index, GLsizei count, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_gpu_program_parameters</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramEnvParameters4fvEXT1(int target, int index, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramEnvParameters4fvEXT}(GLenum target, GLuint index, GLsizei count, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_gpu_program_parameters</code>   */
  public void glProgramEnvParameters4fvEXT(int target, int index, int count, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramEnvParameters4fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramEnvParameters4fvEXT\" not available");
    }
        dispatch_glProgramEnvParameters4fvEXT1(target, index, count, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParametersI4ivNV}(GLenum target, GLuint index, GLsizei count, const GLint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramEnvParametersI4ivNV(int target, int index, int count, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramEnvParametersI4ivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramEnvParametersI4ivNV\" not available");
    }
        dispatch_glProgramEnvParametersI4ivNV1(target, index, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParametersI4ivNV}(GLenum target, GLuint index, GLsizei count, const GLint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramEnvParametersI4ivNV1(int target, int index, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramEnvParametersI4ivNV}(GLenum target, GLuint index, GLsizei count, const GLint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>   */
  public void glProgramEnvParametersI4ivNV(int target, int index, int count, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramEnvParametersI4ivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramEnvParametersI4ivNV\" not available");
    }
        dispatch_glProgramEnvParametersI4ivNV1(target, index, count, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParametersI4uivNV}(GLenum target, GLuint index, GLsizei count, const GLuint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramEnvParametersI4uivNV(int target, int index, int count, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramEnvParametersI4uivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramEnvParametersI4uivNV\" not available");
    }
        dispatch_glProgramEnvParametersI4uivNV1(target, index, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParametersI4uivNV}(GLenum target, GLuint index, GLsizei count, const GLuint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramEnvParametersI4uivNV1(int target, int index, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramEnvParametersI4uivNV}(GLenum target, GLuint index, GLsizei count, const GLuint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>   */
  public void glProgramEnvParametersI4uivNV(int target, int index, int count, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramEnvParametersI4uivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramEnvParametersI4uivNV\" not available");
    }
        dispatch_glProgramEnvParametersI4uivNV1(target, index, count, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameter4dARB}(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glProgramLocalParameter4dARB(int target, int index, double x, double y, double z, double w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramLocalParameter4dARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramLocalParameter4dARB\" not available");
    }
        dispatch_glProgramLocalParameter4dARB1(target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameter4dARB}(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public native void dispatch_glProgramLocalParameter4dARB1(int target, int index, double x, double y, double z, double w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramLocalParameter4dvARB}(GLenum target, GLuint index, const GLdouble *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramLocalParameter4dvARB(int target, int index, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramLocalParameter4dvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramLocalParameter4dvARB\" not available");
    }
        dispatch_glProgramLocalParameter4dvARB1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameter4dvARB}(GLenum target, GLuint index, const GLdouble *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramLocalParameter4dvARB1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramLocalParameter4dvARB}(GLenum target, GLuint index, const GLdouble *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glProgramLocalParameter4dvARB(int target, int index, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramLocalParameter4dvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramLocalParameter4dvARB\" not available");
    }
        dispatch_glProgramLocalParameter4dvARB1(target, index, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameter4fARB}(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glProgramLocalParameter4fARB(int target, int index, float x, float y, float z, float w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramLocalParameter4fARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramLocalParameter4fARB\" not available");
    }
        dispatch_glProgramLocalParameter4fARB1(target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameter4fARB}(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public native void dispatch_glProgramLocalParameter4fARB1(int target, int index, float x, float y, float z, float w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramLocalParameter4fvARB}(GLenum target, GLuint index, const GLfloat *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramLocalParameter4fvARB(int target, int index, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramLocalParameter4fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramLocalParameter4fvARB\" not available");
    }
        dispatch_glProgramLocalParameter4fvARB1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameter4fvARB}(GLenum target, GLuint index, const GLfloat *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramLocalParameter4fvARB1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramLocalParameter4fvARB}(GLenum target, GLuint index, const GLfloat *  params); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glProgramLocalParameter4fvARB(int target, int index, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramLocalParameter4fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramLocalParameter4fvARB\" not available");
    }
        dispatch_glProgramLocalParameter4fvARB1(target, index, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameterI4iNV}(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w); </code> <br>Part of <code>GL_NV_gpu_program4</code>   */
  public void glProgramLocalParameterI4iNV(int target, int index, int x, int y, int z, int w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramLocalParameterI4iNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramLocalParameterI4iNV\" not available");
    }
        dispatch_glProgramLocalParameterI4iNV1(target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameterI4iNV}(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w); </code> <br>Part of <code>GL_NV_gpu_program4</code>   */
  public native void dispatch_glProgramLocalParameterI4iNV1(int target, int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramLocalParameterI4ivNV}(GLenum target, GLuint index, const GLint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramLocalParameterI4ivNV(int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramLocalParameterI4ivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramLocalParameterI4ivNV\" not available");
    }
        dispatch_glProgramLocalParameterI4ivNV1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameterI4ivNV}(GLenum target, GLuint index, const GLint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramLocalParameterI4ivNV1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramLocalParameterI4ivNV}(GLenum target, GLuint index, const GLint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>   */
  public void glProgramLocalParameterI4ivNV(int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramLocalParameterI4ivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramLocalParameterI4ivNV\" not available");
    }
        dispatch_glProgramLocalParameterI4ivNV1(target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameterI4uiNV}(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w); </code> <br>Part of <code>GL_NV_gpu_program4</code>   */
  public void glProgramLocalParameterI4uiNV(int target, int index, int x, int y, int z, int w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramLocalParameterI4uiNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramLocalParameterI4uiNV\" not available");
    }
        dispatch_glProgramLocalParameterI4uiNV1(target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameterI4uiNV}(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w); </code> <br>Part of <code>GL_NV_gpu_program4</code>   */
  public native void dispatch_glProgramLocalParameterI4uiNV1(int target, int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramLocalParameterI4uivNV}(GLenum target, GLuint index, const GLuint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramLocalParameterI4uivNV(int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramLocalParameterI4uivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramLocalParameterI4uivNV\" not available");
    }
        dispatch_glProgramLocalParameterI4uivNV1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameterI4uivNV}(GLenum target, GLuint index, const GLuint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramLocalParameterI4uivNV1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramLocalParameterI4uivNV}(GLenum target, GLuint index, const GLuint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>   */
  public void glProgramLocalParameterI4uivNV(int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramLocalParameterI4uivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramLocalParameterI4uivNV\" not available");
    }
        dispatch_glProgramLocalParameterI4uivNV1(target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameters4fvEXT}(GLenum target, GLuint index, GLsizei count, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_gpu_program_parameters</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramLocalParameters4fvEXT(int target, int index, int count, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramLocalParameters4fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramLocalParameters4fvEXT\" not available");
    }
        dispatch_glProgramLocalParameters4fvEXT1(target, index, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameters4fvEXT}(GLenum target, GLuint index, GLsizei count, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_gpu_program_parameters</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramLocalParameters4fvEXT1(int target, int index, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramLocalParameters4fvEXT}(GLenum target, GLuint index, GLsizei count, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_gpu_program_parameters</code>   */
  public void glProgramLocalParameters4fvEXT(int target, int index, int count, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramLocalParameters4fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramLocalParameters4fvEXT\" not available");
    }
        dispatch_glProgramLocalParameters4fvEXT1(target, index, count, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParametersI4ivNV}(GLenum target, GLuint index, GLsizei count, const GLint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramLocalParametersI4ivNV(int target, int index, int count, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramLocalParametersI4ivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramLocalParametersI4ivNV\" not available");
    }
        dispatch_glProgramLocalParametersI4ivNV1(target, index, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParametersI4ivNV}(GLenum target, GLuint index, GLsizei count, const GLint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramLocalParametersI4ivNV1(int target, int index, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramLocalParametersI4ivNV}(GLenum target, GLuint index, GLsizei count, const GLint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>   */
  public void glProgramLocalParametersI4ivNV(int target, int index, int count, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramLocalParametersI4ivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramLocalParametersI4ivNV\" not available");
    }
        dispatch_glProgramLocalParametersI4ivNV1(target, index, count, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParametersI4uivNV}(GLenum target, GLuint index, GLsizei count, const GLuint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramLocalParametersI4uivNV(int target, int index, int count, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramLocalParametersI4uivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramLocalParametersI4uivNV\" not available");
    }
        dispatch_glProgramLocalParametersI4uivNV1(target, index, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParametersI4uivNV}(GLenum target, GLuint index, GLsizei count, const GLuint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramLocalParametersI4uivNV1(int target, int index, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramLocalParametersI4uivNV}(GLenum target, GLuint index, GLsizei count, const GLuint *  params); </code> <br>Part of <code>GL_NV_gpu_program4</code>   */
  public void glProgramLocalParametersI4uivNV(int target, int index, int count, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramLocalParametersI4uivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramLocalParametersI4uivNV\" not available");
    }
        dispatch_glProgramLocalParametersI4uivNV1(target, index, count, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramParameteri}(GLuint program, GLenum pname, GLint value); </code> <br>Part of <code>GL_ARB_get_program_binary</code>   */
  public void glProgramParameteri(int program, int pname, int value)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramParameteri;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramParameteri\" not available");
    }
        dispatch_glProgramParameteri1(program, pname, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramParameteri}(GLuint program, GLenum pname, GLint value); </code> <br>Part of <code>GL_ARB_get_program_binary</code>   */
  public native void dispatch_glProgramParameteri1(int program, int pname, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramParameteriARB}(GLuint program, GLenum pname, GLint value); </code> <br>Part of <code>GL_ARB_geometry_shader4</code>   */
  public void glProgramParameteriARB(int program, int pname, int value)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramParameteriARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramParameteriARB\" not available");
    }
        dispatch_glProgramParameteriARB1(program, pname, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramParameteriARB}(GLuint program, GLenum pname, GLint value); </code> <br>Part of <code>GL_ARB_geometry_shader4</code>   */
  public native void dispatch_glProgramParameteriARB1(int program, int pname, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramStringARB}(GLenum target, GLenum format, GLsizei len, const GLvoid *  string); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glProgramStringARB(int target, int format, int len, String string)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramStringARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramStringARB\" not available");
    }
        dispatch_glProgramStringARB1(target, format, len, string, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramStringARB}(GLenum target, GLenum format, GLsizei len, const GLvoid *  string); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public native void dispatch_glProgramStringARB1(int target, int format, int len, String string, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramSubroutineParametersuivNV}(GLenum target, GLsizei count, const GLuint *  params); </code> <br>Part of <code>GL_NV_gpu_program5</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramSubroutineParametersuivNV(int target, int count, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramSubroutineParametersuivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramSubroutineParametersuivNV\" not available");
    }
        dispatch_glProgramSubroutineParametersuivNV1(target, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramSubroutineParametersuivNV}(GLenum target, GLsizei count, const GLuint *  params); </code> <br>Part of <code>GL_NV_gpu_program5</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramSubroutineParametersuivNV1(int target, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramSubroutineParametersuivNV}(GLenum target, GLsizei count, const GLuint *  params); </code> <br>Part of <code>GL_NV_gpu_program5</code>   */
  public void glProgramSubroutineParametersuivNV(int target, int count, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramSubroutineParametersuivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramSubroutineParametersuivNV\" not available");
    }
        dispatch_glProgramSubroutineParametersuivNV1(target, count, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1d}(GLuint program, GLint location, GLdouble v0); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform1d(int program, int location, double v0)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1d\" not available");
    }
        dispatch_glProgramUniform1d1(program, location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1d}(GLuint program, GLint location, GLdouble v0); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public native void dispatch_glProgramUniform1d1(int program, int location, double v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1dEXT}(GLuint program, GLint location, GLdouble x); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform1dEXT(int program, int location, double x)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1dEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1dEXT\" not available");
    }
        dispatch_glProgramUniform1dEXT1(program, location, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1dEXT}(GLuint program, GLint location, GLdouble x); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glProgramUniform1dEXT1(int program, int location, double x, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniform1dv(int program, int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1dv\" not available");
    }
        dispatch_glProgramUniform1dv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniform1dv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform1dv(int program, int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1dv\" not available");
    }
        dispatch_glProgramUniform1dv1(program, location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniform1dvEXT(int program, int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1dvEXT\" not available");
    }
        dispatch_glProgramUniform1dvEXT1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniform1dvEXT1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform1dvEXT(int program, int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1dvEXT\" not available");
    }
        dispatch_glProgramUniform1dvEXT1(program, location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1f}(GLuint program, GLint location, GLfloat v0); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform1f(int program, int location, float v0)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1f\" not available");
    }
        dispatch_glProgramUniform1f1(program, location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1f}(GLuint program, GLint location, GLfloat v0); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public native void dispatch_glProgramUniform1f1(int program, int location, float v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1fEXT}(GLuint program, GLint location, GLfloat v0); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform1fEXT(int program, int location, float v0)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1fEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1fEXT\" not available");
    }
        dispatch_glProgramUniform1fEXT1(program, location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1fEXT}(GLuint program, GLint location, GLfloat v0); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glProgramUniform1fEXT1(int program, int location, float v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniform1fv(int program, int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1fv\" not available");
    }
        dispatch_glProgramUniform1fv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniform1fv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform1fv(int program, int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1fv\" not available");
    }
        dispatch_glProgramUniform1fv1(program, location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1fvEXT}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniform1fvEXT(int program, int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1fvEXT\" not available");
    }
        dispatch_glProgramUniform1fvEXT1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1fvEXT}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniform1fvEXT1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1fvEXT}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform1fvEXT(int program, int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1fvEXT\" not available");
    }
        dispatch_glProgramUniform1fvEXT1(program, location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1i}(GLuint program, GLint location, GLint v0); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform1i(int program, int location, int v0)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1i\" not available");
    }
        dispatch_glProgramUniform1i1(program, location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1i}(GLuint program, GLint location, GLint v0); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public native void dispatch_glProgramUniform1i1(int program, int location, int v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1i64NV}(GLuint program, GLint location, GLint64EXT x); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glProgramUniform1i64NV(int program, int location, long x)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1i64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1i64NV\" not available");
    }
        dispatch_glProgramUniform1i64NV1(program, location, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1i64NV}(GLuint program, GLint location, GLint64EXT x); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public native void dispatch_glProgramUniform1i64NV1(int program, int location, long x, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform1i64vNV(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1i64vNV\" not available");
    }
        dispatch_glProgramUniform1i64vNV1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform1i64vNV1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glProgramUniform1i64vNV(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1i64vNV\" not available");
    }
        dispatch_glProgramUniform1i64vNV1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1iEXT}(GLuint program, GLint location, GLint v0); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform1iEXT(int program, int location, int v0)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1iEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1iEXT\" not available");
    }
        dispatch_glProgramUniform1iEXT1(program, location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1iEXT}(GLuint program, GLint location, GLint v0); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glProgramUniform1iEXT1(int program, int location, int v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1iv}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform1iv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1iv\" not available");
    }
        dispatch_glProgramUniform1iv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1iv}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform1iv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1iv}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform1iv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1iv\" not available");
    }
        dispatch_glProgramUniform1iv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1ivEXT}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform1ivEXT(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1ivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1ivEXT\" not available");
    }
        dispatch_glProgramUniform1ivEXT1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1ivEXT}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform1ivEXT1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1ivEXT}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform1ivEXT(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1ivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1ivEXT\" not available");
    }
        dispatch_glProgramUniform1ivEXT1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1ui}(GLuint program, GLint location, GLuint v0); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform1ui(int program, int location, int v0)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1ui\" not available");
    }
        dispatch_glProgramUniform1ui1(program, location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1ui}(GLuint program, GLint location, GLuint v0); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public native void dispatch_glProgramUniform1ui1(int program, int location, int v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1ui64NV}(GLuint program, GLint location, GLuint64EXT x); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glProgramUniform1ui64NV(int program, int location, long x)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1ui64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1ui64NV\" not available");
    }
        dispatch_glProgramUniform1ui64NV1(program, location, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1ui64NV}(GLuint program, GLint location, GLuint64EXT x); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public native void dispatch_glProgramUniform1ui64NV1(int program, int location, long x, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform1ui64vNV(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1ui64vNV\" not available");
    }
        dispatch_glProgramUniform1ui64vNV1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform1ui64vNV1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glProgramUniform1ui64vNV(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1ui64vNV\" not available");
    }
        dispatch_glProgramUniform1ui64vNV1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1uiEXT}(GLuint program, GLint location, GLuint v0); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform1uiEXT(int program, int location, int v0)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1uiEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1uiEXT\" not available");
    }
        dispatch_glProgramUniform1uiEXT1(program, location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1uiEXT}(GLuint program, GLint location, GLuint v0); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glProgramUniform1uiEXT1(int program, int location, int v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform1uiv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1uiv\" not available");
    }
        dispatch_glProgramUniform1uiv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform1uiv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform1uiv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1uiv\" not available");
    }
        dispatch_glProgramUniform1uiv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1uivEXT}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform1uivEXT(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1uivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1uivEXT\" not available");
    }
        dispatch_glProgramUniform1uivEXT1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1uivEXT}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform1uivEXT1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1uivEXT}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform1uivEXT(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform1uivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform1uivEXT\" not available");
    }
        dispatch_glProgramUniform1uivEXT1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2d}(GLuint program, GLint location, GLdouble v0, GLdouble v1); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform2d(int program, int location, double v0, double v1)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2d\" not available");
    }
        dispatch_glProgramUniform2d1(program, location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2d}(GLuint program, GLint location, GLdouble v0, GLdouble v1); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public native void dispatch_glProgramUniform2d1(int program, int location, double v0, double v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2dEXT}(GLuint program, GLint location, GLdouble x, GLdouble y); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform2dEXT(int program, int location, double x, double y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2dEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2dEXT\" not available");
    }
        dispatch_glProgramUniform2dEXT1(program, location, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2dEXT}(GLuint program, GLint location, GLdouble x, GLdouble y); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glProgramUniform2dEXT1(int program, int location, double x, double y, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniform2dv(int program, int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2dv\" not available");
    }
        dispatch_glProgramUniform2dv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniform2dv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform2dv(int program, int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2dv\" not available");
    }
        dispatch_glProgramUniform2dv1(program, location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniform2dvEXT(int program, int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2dvEXT\" not available");
    }
        dispatch_glProgramUniform2dvEXT1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniform2dvEXT1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform2dvEXT(int program, int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2dvEXT\" not available");
    }
        dispatch_glProgramUniform2dvEXT1(program, location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2f}(GLuint program, GLint location, GLfloat v0, GLfloat v1); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform2f(int program, int location, float v0, float v1)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2f\" not available");
    }
        dispatch_glProgramUniform2f1(program, location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2f}(GLuint program, GLint location, GLfloat v0, GLfloat v1); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public native void dispatch_glProgramUniform2f1(int program, int location, float v0, float v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2fEXT}(GLuint program, GLint location, GLfloat v0, GLfloat v1); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform2fEXT(int program, int location, float v0, float v1)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2fEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2fEXT\" not available");
    }
        dispatch_glProgramUniform2fEXT1(program, location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2fEXT}(GLuint program, GLint location, GLfloat v0, GLfloat v1); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glProgramUniform2fEXT1(int program, int location, float v0, float v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniform2fv(int program, int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2fv\" not available");
    }
        dispatch_glProgramUniform2fv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniform2fv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform2fv(int program, int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2fv\" not available");
    }
        dispatch_glProgramUniform2fv1(program, location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2fvEXT}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniform2fvEXT(int program, int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2fvEXT\" not available");
    }
        dispatch_glProgramUniform2fvEXT1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2fvEXT}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniform2fvEXT1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2fvEXT}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform2fvEXT(int program, int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2fvEXT\" not available");
    }
        dispatch_glProgramUniform2fvEXT1(program, location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2i}(GLuint program, GLint location, GLint v0, GLint v1); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform2i(int program, int location, int v0, int v1)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2i\" not available");
    }
        dispatch_glProgramUniform2i1(program, location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2i}(GLuint program, GLint location, GLint v0, GLint v1); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public native void dispatch_glProgramUniform2i1(int program, int location, int v0, int v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2i64NV}(GLuint program, GLint location, GLint64EXT x, GLint64EXT y); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glProgramUniform2i64NV(int program, int location, long x, long y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2i64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2i64NV\" not available");
    }
        dispatch_glProgramUniform2i64NV1(program, location, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2i64NV}(GLuint program, GLint location, GLint64EXT x, GLint64EXT y); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public native void dispatch_glProgramUniform2i64NV1(int program, int location, long x, long y, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform2i64vNV(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2i64vNV\" not available");
    }
        dispatch_glProgramUniform2i64vNV1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform2i64vNV1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glProgramUniform2i64vNV(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2i64vNV\" not available");
    }
        dispatch_glProgramUniform2i64vNV1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2iEXT}(GLuint program, GLint location, GLint v0, GLint v1); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform2iEXT(int program, int location, int v0, int v1)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2iEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2iEXT\" not available");
    }
        dispatch_glProgramUniform2iEXT1(program, location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2iEXT}(GLuint program, GLint location, GLint v0, GLint v1); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glProgramUniform2iEXT1(int program, int location, int v0, int v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2iv}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform2iv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2iv\" not available");
    }
        dispatch_glProgramUniform2iv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2iv}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform2iv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2iv}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform2iv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2iv\" not available");
    }
        dispatch_glProgramUniform2iv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2ivEXT}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform2ivEXT(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2ivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2ivEXT\" not available");
    }
        dispatch_glProgramUniform2ivEXT1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2ivEXT}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform2ivEXT1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2ivEXT}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform2ivEXT(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2ivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2ivEXT\" not available");
    }
        dispatch_glProgramUniform2ivEXT1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2ui}(GLuint program, GLint location, GLuint v0, GLuint v1); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform2ui(int program, int location, int v0, int v1)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2ui\" not available");
    }
        dispatch_glProgramUniform2ui1(program, location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2ui}(GLuint program, GLint location, GLuint v0, GLuint v1); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public native void dispatch_glProgramUniform2ui1(int program, int location, int v0, int v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2ui64NV}(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glProgramUniform2ui64NV(int program, int location, long x, long y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2ui64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2ui64NV\" not available");
    }
        dispatch_glProgramUniform2ui64NV1(program, location, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2ui64NV}(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public native void dispatch_glProgramUniform2ui64NV1(int program, int location, long x, long y, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform2ui64vNV(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2ui64vNV\" not available");
    }
        dispatch_glProgramUniform2ui64vNV1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform2ui64vNV1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glProgramUniform2ui64vNV(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2ui64vNV\" not available");
    }
        dispatch_glProgramUniform2ui64vNV1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2uiEXT}(GLuint program, GLint location, GLuint v0, GLuint v1); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform2uiEXT(int program, int location, int v0, int v1)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2uiEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2uiEXT\" not available");
    }
        dispatch_glProgramUniform2uiEXT1(program, location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2uiEXT}(GLuint program, GLint location, GLuint v0, GLuint v1); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glProgramUniform2uiEXT1(int program, int location, int v0, int v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform2uiv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2uiv\" not available");
    }
        dispatch_glProgramUniform2uiv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform2uiv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform2uiv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2uiv\" not available");
    }
        dispatch_glProgramUniform2uiv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2uivEXT}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform2uivEXT(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2uivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2uivEXT\" not available");
    }
        dispatch_glProgramUniform2uivEXT1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2uivEXT}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform2uivEXT1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2uivEXT}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform2uivEXT(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform2uivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform2uivEXT\" not available");
    }
        dispatch_glProgramUniform2uivEXT1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3d}(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform3d(int program, int location, double v0, double v1, double v2)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3d\" not available");
    }
        dispatch_glProgramUniform3d1(program, location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3d}(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public native void dispatch_glProgramUniform3d1(int program, int location, double v0, double v1, double v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3dEXT}(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform3dEXT(int program, int location, double x, double y, double z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3dEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3dEXT\" not available");
    }
        dispatch_glProgramUniform3dEXT1(program, location, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3dEXT}(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glProgramUniform3dEXT1(int program, int location, double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniform3dv(int program, int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3dv\" not available");
    }
        dispatch_glProgramUniform3dv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniform3dv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform3dv(int program, int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3dv\" not available");
    }
        dispatch_glProgramUniform3dv1(program, location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniform3dvEXT(int program, int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3dvEXT\" not available");
    }
        dispatch_glProgramUniform3dvEXT1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniform3dvEXT1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform3dvEXT(int program, int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3dvEXT\" not available");
    }
        dispatch_glProgramUniform3dvEXT1(program, location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3f}(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform3f(int program, int location, float v0, float v1, float v2)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3f\" not available");
    }
        dispatch_glProgramUniform3f1(program, location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3f}(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public native void dispatch_glProgramUniform3f1(int program, int location, float v0, float v1, float v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3fEXT}(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform3fEXT(int program, int location, float v0, float v1, float v2)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3fEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3fEXT\" not available");
    }
        dispatch_glProgramUniform3fEXT1(program, location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3fEXT}(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glProgramUniform3fEXT1(int program, int location, float v0, float v1, float v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniform3fv(int program, int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3fv\" not available");
    }
        dispatch_glProgramUniform3fv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniform3fv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform3fv(int program, int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3fv\" not available");
    }
        dispatch_glProgramUniform3fv1(program, location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3fvEXT}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniform3fvEXT(int program, int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3fvEXT\" not available");
    }
        dispatch_glProgramUniform3fvEXT1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3fvEXT}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniform3fvEXT1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3fvEXT}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform3fvEXT(int program, int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3fvEXT\" not available");
    }
        dispatch_glProgramUniform3fvEXT1(program, location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3i}(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform3i(int program, int location, int v0, int v1, int v2)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3i\" not available");
    }
        dispatch_glProgramUniform3i1(program, location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3i}(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public native void dispatch_glProgramUniform3i1(int program, int location, int v0, int v1, int v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3i64NV}(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glProgramUniform3i64NV(int program, int location, long x, long y, long z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3i64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3i64NV\" not available");
    }
        dispatch_glProgramUniform3i64NV1(program, location, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3i64NV}(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public native void dispatch_glProgramUniform3i64NV1(int program, int location, long x, long y, long z, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform3i64vNV(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3i64vNV\" not available");
    }
        dispatch_glProgramUniform3i64vNV1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform3i64vNV1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glProgramUniform3i64vNV(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3i64vNV\" not available");
    }
        dispatch_glProgramUniform3i64vNV1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3iEXT}(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform3iEXT(int program, int location, int v0, int v1, int v2)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3iEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3iEXT\" not available");
    }
        dispatch_glProgramUniform3iEXT1(program, location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3iEXT}(GLuint program, GLint location, GLint v0, GLint v1, GLint v2); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glProgramUniform3iEXT1(int program, int location, int v0, int v1, int v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3iv}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform3iv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3iv\" not available");
    }
        dispatch_glProgramUniform3iv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3iv}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform3iv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3iv}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform3iv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3iv\" not available");
    }
        dispatch_glProgramUniform3iv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3ivEXT}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform3ivEXT(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3ivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3ivEXT\" not available");
    }
        dispatch_glProgramUniform3ivEXT1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3ivEXT}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform3ivEXT1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3ivEXT}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform3ivEXT(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3ivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3ivEXT\" not available");
    }
        dispatch_glProgramUniform3ivEXT1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3ui}(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform3ui(int program, int location, int v0, int v1, int v2)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3ui\" not available");
    }
        dispatch_glProgramUniform3ui1(program, location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3ui}(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public native void dispatch_glProgramUniform3ui1(int program, int location, int v0, int v1, int v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3ui64NV}(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glProgramUniform3ui64NV(int program, int location, long x, long y, long z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3ui64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3ui64NV\" not available");
    }
        dispatch_glProgramUniform3ui64NV1(program, location, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3ui64NV}(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public native void dispatch_glProgramUniform3ui64NV1(int program, int location, long x, long y, long z, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform3ui64vNV(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3ui64vNV\" not available");
    }
        dispatch_glProgramUniform3ui64vNV1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform3ui64vNV1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glProgramUniform3ui64vNV(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3ui64vNV\" not available");
    }
        dispatch_glProgramUniform3ui64vNV1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3uiEXT}(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform3uiEXT(int program, int location, int v0, int v1, int v2)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3uiEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3uiEXT\" not available");
    }
        dispatch_glProgramUniform3uiEXT1(program, location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3uiEXT}(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glProgramUniform3uiEXT1(int program, int location, int v0, int v1, int v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform3uiv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3uiv\" not available");
    }
        dispatch_glProgramUniform3uiv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform3uiv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform3uiv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3uiv\" not available");
    }
        dispatch_glProgramUniform3uiv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3uivEXT}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform3uivEXT(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3uivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3uivEXT\" not available");
    }
        dispatch_glProgramUniform3uivEXT1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3uivEXT}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform3uivEXT1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3uivEXT}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform3uivEXT(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform3uivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform3uivEXT\" not available");
    }
        dispatch_glProgramUniform3uivEXT1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4d}(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform4d(int program, int location, double v0, double v1, double v2, double v3)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4d\" not available");
    }
        dispatch_glProgramUniform4d1(program, location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4d}(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public native void dispatch_glProgramUniform4d1(int program, int location, double v0, double v1, double v2, double v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4dEXT}(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform4dEXT(int program, int location, double x, double y, double z, double w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4dEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4dEXT\" not available");
    }
        dispatch_glProgramUniform4dEXT1(program, location, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4dEXT}(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glProgramUniform4dEXT1(int program, int location, double x, double y, double z, double w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniform4dv(int program, int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4dv\" not available");
    }
        dispatch_glProgramUniform4dv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniform4dv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform4dv(int program, int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4dv\" not available");
    }
        dispatch_glProgramUniform4dv1(program, location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniform4dvEXT(int program, int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4dvEXT\" not available");
    }
        dispatch_glProgramUniform4dvEXT1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniform4dvEXT1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform4dvEXT(int program, int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4dvEXT\" not available");
    }
        dispatch_glProgramUniform4dvEXT1(program, location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4f}(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform4f(int program, int location, float v0, float v1, float v2, float v3)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4f\" not available");
    }
        dispatch_glProgramUniform4f1(program, location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4f}(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public native void dispatch_glProgramUniform4f1(int program, int location, float v0, float v1, float v2, float v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4fEXT}(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform4fEXT(int program, int location, float v0, float v1, float v2, float v3)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4fEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4fEXT\" not available");
    }
        dispatch_glProgramUniform4fEXT1(program, location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4fEXT}(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glProgramUniform4fEXT1(int program, int location, float v0, float v1, float v2, float v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniform4fv(int program, int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4fv\" not available");
    }
        dispatch_glProgramUniform4fv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniform4fv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform4fv(int program, int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4fv\" not available");
    }
        dispatch_glProgramUniform4fv1(program, location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4fvEXT}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniform4fvEXT(int program, int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4fvEXT\" not available");
    }
        dispatch_glProgramUniform4fvEXT1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4fvEXT}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniform4fvEXT1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4fvEXT}(GLuint program, GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform4fvEXT(int program, int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4fvEXT\" not available");
    }
        dispatch_glProgramUniform4fvEXT1(program, location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4i}(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform4i(int program, int location, int v0, int v1, int v2, int v3)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4i\" not available");
    }
        dispatch_glProgramUniform4i1(program, location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4i}(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public native void dispatch_glProgramUniform4i1(int program, int location, int v0, int v1, int v2, int v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4i64NV}(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glProgramUniform4i64NV(int program, int location, long x, long y, long z, long w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4i64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4i64NV\" not available");
    }
        dispatch_glProgramUniform4i64NV1(program, location, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4i64NV}(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public native void dispatch_glProgramUniform4i64NV1(int program, int location, long x, long y, long z, long w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform4i64vNV(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4i64vNV\" not available");
    }
        dispatch_glProgramUniform4i64vNV1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform4i64vNV1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glProgramUniform4i64vNV(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4i64vNV\" not available");
    }
        dispatch_glProgramUniform4i64vNV1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4iEXT}(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform4iEXT(int program, int location, int v0, int v1, int v2, int v3)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4iEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4iEXT\" not available");
    }
        dispatch_glProgramUniform4iEXT1(program, location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4iEXT}(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glProgramUniform4iEXT1(int program, int location, int v0, int v1, int v2, int v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4iv}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform4iv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4iv\" not available");
    }
        dispatch_glProgramUniform4iv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4iv}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform4iv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4iv}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform4iv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4iv\" not available");
    }
        dispatch_glProgramUniform4iv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4ivEXT}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform4ivEXT(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4ivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4ivEXT\" not available");
    }
        dispatch_glProgramUniform4ivEXT1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4ivEXT}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform4ivEXT1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4ivEXT}(GLuint program, GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform4ivEXT(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4ivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4ivEXT\" not available");
    }
        dispatch_glProgramUniform4ivEXT1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4ui}(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform4ui(int program, int location, int v0, int v1, int v2, int v3)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4ui\" not available");
    }
        dispatch_glProgramUniform4ui1(program, location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4ui}(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public native void dispatch_glProgramUniform4ui1(int program, int location, int v0, int v1, int v2, int v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4ui64NV}(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glProgramUniform4ui64NV(int program, int location, long x, long y, long z, long w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4ui64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4ui64NV\" not available");
    }
        dispatch_glProgramUniform4ui64NV1(program, location, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4ui64NV}(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public native void dispatch_glProgramUniform4ui64NV1(int program, int location, long x, long y, long z, long w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform4ui64vNV(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4ui64vNV\" not available");
    }
        dispatch_glProgramUniform4ui64vNV1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform4ui64vNV1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glProgramUniform4ui64vNV(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4ui64vNV\" not available");
    }
        dispatch_glProgramUniform4ui64vNV1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4uiEXT}(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform4uiEXT(int program, int location, int v0, int v1, int v2, int v3)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4uiEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4uiEXT\" not available");
    }
        dispatch_glProgramUniform4uiEXT1(program, location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4uiEXT}(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glProgramUniform4uiEXT1(int program, int location, int v0, int v1, int v2, int v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform4uiv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4uiv\" not available");
    }
        dispatch_glProgramUniform4uiv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform4uiv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniform4uiv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4uiv\" not available");
    }
        dispatch_glProgramUniform4uiv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4uivEXT}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform4uivEXT(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4uivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4uivEXT\" not available");
    }
        dispatch_glProgramUniform4uivEXT1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4uivEXT}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform4uivEXT1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4uivEXT}(GLuint program, GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniform4uivEXT(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniform4uivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniform4uivEXT\" not available");
    }
        dispatch_glProgramUniform4uivEXT1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix2dv(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2dv\" not available");
    }
        dispatch_glProgramUniformMatrix2dv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix2dv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniformMatrix2dv(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2dv\" not available");
    }
        dispatch_glProgramUniformMatrix2dv1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix2dvEXT(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2dvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix2dvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix2dvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniformMatrix2dvEXT(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2dvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix2dvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix2fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2fv\" not available");
    }
        dispatch_glProgramUniformMatrix2fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix2fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniformMatrix2fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2fv\" not available");
    }
        dispatch_glProgramUniformMatrix2fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix2fvEXT(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2fvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix2fvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix2fvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniformMatrix2fvEXT(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2fvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix2fvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix2x3dv(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2x3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2x3dv\" not available");
    }
        dispatch_glProgramUniformMatrix2x3dv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix2x3dv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniformMatrix2x3dv(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2x3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2x3dv\" not available");
    }
        dispatch_glProgramUniformMatrix2x3dv1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix2x3dvEXT(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2x3dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2x3dvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix2x3dvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix2x3dvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniformMatrix2x3dvEXT(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2x3dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2x3dvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix2x3dvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix2x3fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2x3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2x3fv\" not available");
    }
        dispatch_glProgramUniformMatrix2x3fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix2x3fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniformMatrix2x3fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2x3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2x3fv\" not available");
    }
        dispatch_glProgramUniformMatrix2x3fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix2x3fvEXT(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2x3fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2x3fvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix2x3fvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix2x3fvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniformMatrix2x3fvEXT(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2x3fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2x3fvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix2x3fvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix2x4dv(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2x4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2x4dv\" not available");
    }
        dispatch_glProgramUniformMatrix2x4dv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix2x4dv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniformMatrix2x4dv(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2x4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2x4dv\" not available");
    }
        dispatch_glProgramUniformMatrix2x4dv1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix2x4dvEXT(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2x4dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2x4dvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix2x4dvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix2x4dvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniformMatrix2x4dvEXT(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2x4dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2x4dvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix2x4dvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix2x4fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2x4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2x4fv\" not available");
    }
        dispatch_glProgramUniformMatrix2x4fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix2x4fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniformMatrix2x4fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2x4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2x4fv\" not available");
    }
        dispatch_glProgramUniformMatrix2x4fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix2x4fvEXT(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2x4fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2x4fvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix2x4fvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix2x4fvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniformMatrix2x4fvEXT(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix2x4fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix2x4fvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix2x4fvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix3dv(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3dv\" not available");
    }
        dispatch_glProgramUniformMatrix3dv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix3dv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniformMatrix3dv(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3dv\" not available");
    }
        dispatch_glProgramUniformMatrix3dv1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix3dvEXT(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3dvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix3dvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix3dvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniformMatrix3dvEXT(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3dvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix3dvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix3fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3fv\" not available");
    }
        dispatch_glProgramUniformMatrix3fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix3fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniformMatrix3fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3fv\" not available");
    }
        dispatch_glProgramUniformMatrix3fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix3fvEXT(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3fvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix3fvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix3fvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniformMatrix3fvEXT(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3fvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix3fvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix3x2dv(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3x2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3x2dv\" not available");
    }
        dispatch_glProgramUniformMatrix3x2dv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix3x2dv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniformMatrix3x2dv(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3x2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3x2dv\" not available");
    }
        dispatch_glProgramUniformMatrix3x2dv1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix3x2dvEXT(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3x2dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3x2dvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix3x2dvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix3x2dvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniformMatrix3x2dvEXT(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3x2dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3x2dvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix3x2dvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix3x2fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3x2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3x2fv\" not available");
    }
        dispatch_glProgramUniformMatrix3x2fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix3x2fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniformMatrix3x2fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3x2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3x2fv\" not available");
    }
        dispatch_glProgramUniformMatrix3x2fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix3x2fvEXT(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3x2fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3x2fvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix3x2fvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix3x2fvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniformMatrix3x2fvEXT(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3x2fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3x2fvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix3x2fvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix3x4dv(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3x4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3x4dv\" not available");
    }
        dispatch_glProgramUniformMatrix3x4dv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix3x4dv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniformMatrix3x4dv(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3x4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3x4dv\" not available");
    }
        dispatch_glProgramUniformMatrix3x4dv1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix3x4dvEXT(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3x4dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3x4dvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix3x4dvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix3x4dvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniformMatrix3x4dvEXT(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3x4dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3x4dvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix3x4dvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix3x4fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3x4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3x4fv\" not available");
    }
        dispatch_glProgramUniformMatrix3x4fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix3x4fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniformMatrix3x4fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3x4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3x4fv\" not available");
    }
        dispatch_glProgramUniformMatrix3x4fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix3x4fvEXT(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3x4fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3x4fvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix3x4fvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix3x4fvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniformMatrix3x4fvEXT(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix3x4fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix3x4fvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix3x4fvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix4dv(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4dv\" not available");
    }
        dispatch_glProgramUniformMatrix4dv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix4dv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniformMatrix4dv(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4dv\" not available");
    }
        dispatch_glProgramUniformMatrix4dv1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix4dvEXT(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4dvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix4dvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix4dvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniformMatrix4dvEXT(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4dvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix4dvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix4fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4fv\" not available");
    }
        dispatch_glProgramUniformMatrix4fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix4fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniformMatrix4fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4fv\" not available");
    }
        dispatch_glProgramUniformMatrix4fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix4fvEXT(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4fvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix4fvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix4fvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniformMatrix4fvEXT(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4fvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix4fvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix4x2dv(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4x2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4x2dv\" not available");
    }
        dispatch_glProgramUniformMatrix4x2dv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix4x2dv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniformMatrix4x2dv(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4x2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4x2dv\" not available");
    }
        dispatch_glProgramUniformMatrix4x2dv1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix4x2dvEXT(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4x2dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4x2dvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix4x2dvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix4x2dvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniformMatrix4x2dvEXT(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4x2dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4x2dvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix4x2dvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix4x2fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4x2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4x2fv\" not available");
    }
        dispatch_glProgramUniformMatrix4x2fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix4x2fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniformMatrix4x2fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4x2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4x2fv\" not available");
    }
        dispatch_glProgramUniformMatrix4x2fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix4x2fvEXT(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4x2fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4x2fvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix4x2fvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix4x2fvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniformMatrix4x2fvEXT(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4x2fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4x2fvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix4x2fvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix4x3dv(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4x3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4x3dv\" not available");
    }
        dispatch_glProgramUniformMatrix4x3dv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix4x3dv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniformMatrix4x3dv(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4x3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4x3dv\" not available");
    }
        dispatch_glProgramUniformMatrix4x3dv1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix4x3dvEXT(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4x3dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4x3dvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix4x3dvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix4x3dvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniformMatrix4x3dvEXT(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4x3dvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4x3dvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix4x3dvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix4x3fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4x3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4x3fv\" not available");
    }
        dispatch_glProgramUniformMatrix4x3fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix4x3fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glProgramUniformMatrix4x3fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4x3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4x3fv\" not available");
    }
        dispatch_glProgramUniformMatrix4x3fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix4x3fvEXT(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4x3fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4x3fvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix4x3fvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix4x3fvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3fvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glProgramUniformMatrix4x3fvEXT(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformMatrix4x3fvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformMatrix4x3fvEXT\" not available");
    }
        dispatch_glProgramUniformMatrix4x3fvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformui64NV}(GLuint program, GLint location, GLuint64EXT value); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>   */
  public void glProgramUniformui64NV(int program, int location, long value)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformui64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformui64NV\" not available");
    }
        dispatch_glProgramUniformui64NV1(program, location, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformui64NV}(GLuint program, GLint location, GLuint64EXT value); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>   */
  public native void dispatch_glProgramUniformui64NV1(int program, int location, long value, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniformui64vNV(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformui64vNV\" not available");
    }
        dispatch_glProgramUniformui64vNV1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniformui64vNV1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>   */
  public void glProgramUniformui64vNV(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramUniformui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramUniformui64vNV\" not available");
    }
        dispatch_glProgramUniformui64vNV1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramVertexLimitNV}(GLenum target, GLint limit); </code> <br>Part of <code>GL_NV_geometry_program4</code>   */
  public void glProgramVertexLimitNV(int target, int limit)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramVertexLimitNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramVertexLimitNV\" not available");
    }
        dispatch_glProgramVertexLimitNV1(target, limit, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramVertexLimitNV}(GLenum target, GLint limit); </code> <br>Part of <code>GL_NV_geometry_program4</code>   */
  public native void dispatch_glProgramVertexLimitNV1(int target, int limit, long procAddress);

  /** Entry point to C language function: <code> void {@native glProvokingVertex}(GLenum mode); </code> <br>Part of <code>GL_ARB_provoking_vertex</code>   */
  public void glProvokingVertex(int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProvokingVertex;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProvokingVertex\" not available");
    }
        dispatch_glProvokingVertex1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProvokingVertex}(GLenum mode); </code> <br>Part of <code>GL_ARB_provoking_vertex</code>   */
  public native void dispatch_glProvokingVertex1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glProvokingVertexEXT}(GLenum mode); </code> <br>Part of <code>GL_EXT_provoking_vertex</code>   */
  public void glProvokingVertexEXT(int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glProvokingVertexEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProvokingVertexEXT\" not available");
    }
        dispatch_glProvokingVertexEXT1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProvokingVertexEXT}(GLenum mode); </code> <br>Part of <code>GL_EXT_provoking_vertex</code>   */
  public native void dispatch_glProvokingVertexEXT1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glPushAttrib}(GLbitfield mask); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glPushAttrib(int mask)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPushAttrib;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPushAttrib\" not available");
    }
        dispatch_glPushAttrib1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPushAttrib}(GLbitfield mask); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glPushAttrib1(int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glPushClientAttrib}(GLbitfield mask); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public void glPushClientAttrib(int mask)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPushClientAttrib;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPushClientAttrib\" not available");
    }
        dispatch_glPushClientAttrib1(mask, __addr_);
    bufferStateTracker.clearBufferObjectState();
    glStateTracker.pushAttrib(mask);
  }

  /** Entry point to C language function: <code> void {@native glPushClientAttrib}(GLbitfield mask); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  private native void dispatch_glPushClientAttrib1(int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glPushClientAttribDefaultEXT}(GLbitfield mask); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glPushClientAttribDefaultEXT(int mask)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPushClientAttribDefaultEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPushClientAttribDefaultEXT\" not available");
    }
        dispatch_glPushClientAttribDefaultEXT1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPushClientAttribDefaultEXT}(GLbitfield mask); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glPushClientAttribDefaultEXT1(int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glPushMatrix}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glPushMatrix()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPushMatrix;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPushMatrix\" not available");
    }
        dispatch_glPushMatrix1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPushMatrix}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glPushMatrix1(long procAddress);

  /** Entry point to C language function: <code> void {@native glPushName}(GLuint name); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glPushName(int name)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glPushName;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPushName\" not available");
    }
        dispatch_glPushName1(name, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPushName}(GLuint name); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glPushName1(int name, long procAddress);

  /** Entry point to C language function: <code> void {@native glQueryCounter}(GLuint id, GLenum target); </code> <br>Part of <code>GL_ARB_timer_query</code>   */
  public void glQueryCounter(int id, int target)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glQueryCounter;
    if (__addr_ == 0) {
      throw new GLException("Method \"glQueryCounter\" not available");
    }
        dispatch_glQueryCounter1(id, target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glQueryCounter}(GLuint id, GLenum target); </code> <br>Part of <code>GL_ARB_timer_query</code>   */
  public native void dispatch_glQueryCounter1(int id, int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos2d}(GLdouble x, GLdouble y); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos2d(double x, double y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos2d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos2d\" not available");
    }
        dispatch_glRasterPos2d1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos2d}(GLdouble x, GLdouble y); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glRasterPos2d1(double x, double y, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos2dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glRasterPos2dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos2dv\" not available");
    }
        dispatch_glRasterPos2dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos2dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glRasterPos2dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos2dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos2dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos2dv\" not available");
    }
        dispatch_glRasterPos2dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos2f}(GLfloat x, GLfloat y); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos2f(float x, float y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos2f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos2f\" not available");
    }
        dispatch_glRasterPos2f1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos2f}(GLfloat x, GLfloat y); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glRasterPos2f1(float x, float y, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos2fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glRasterPos2fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos2fv\" not available");
    }
        dispatch_glRasterPos2fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos2fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glRasterPos2fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos2fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos2fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos2fv\" not available");
    }
        dispatch_glRasterPos2fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos2i}(GLint x, GLint y); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos2i(int x, int y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos2i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos2i\" not available");
    }
        dispatch_glRasterPos2i1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos2i}(GLint x, GLint y); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glRasterPos2i1(int x, int y, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos2iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glRasterPos2iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos2iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos2iv\" not available");
    }
        dispatch_glRasterPos2iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos2iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glRasterPos2iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos2iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos2iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos2iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos2iv\" not available");
    }
        dispatch_glRasterPos2iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos2s}(GLshort x, GLshort y); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos2s(short x, short y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos2s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos2s\" not available");
    }
        dispatch_glRasterPos2s1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos2s}(GLshort x, GLshort y); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glRasterPos2s1(short x, short y, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos2sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glRasterPos2sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos2sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos2sv\" not available");
    }
        dispatch_glRasterPos2sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos2sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glRasterPos2sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos2sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos2sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos2sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos2sv\" not available");
    }
        dispatch_glRasterPos2sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3d}(GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos3d(double x, double y, double z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos3d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos3d\" not available");
    }
        dispatch_glRasterPos3d1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3d}(GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glRasterPos3d1(double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos3dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glRasterPos3dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos3dv\" not available");
    }
        dispatch_glRasterPos3dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glRasterPos3dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos3dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos3dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos3dv\" not available");
    }
        dispatch_glRasterPos3dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3f}(GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos3f(float x, float y, float z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos3f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos3f\" not available");
    }
        dispatch_glRasterPos3f1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3f}(GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glRasterPos3f1(float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos3fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glRasterPos3fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos3fv\" not available");
    }
        dispatch_glRasterPos3fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glRasterPos3fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos3fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos3fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos3fv\" not available");
    }
        dispatch_glRasterPos3fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3i}(GLint x, GLint y, GLint z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos3i(int x, int y, int z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos3i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos3i\" not available");
    }
        dispatch_glRasterPos3i1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3i}(GLint x, GLint y, GLint z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glRasterPos3i1(int x, int y, int z, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos3iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glRasterPos3iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos3iv\" not available");
    }
        dispatch_glRasterPos3iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glRasterPos3iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos3iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos3iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos3iv\" not available");
    }
        dispatch_glRasterPos3iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3s}(GLshort x, GLshort y, GLshort z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos3s(short x, short y, short z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos3s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos3s\" not available");
    }
        dispatch_glRasterPos3s1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3s}(GLshort x, GLshort y, GLshort z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glRasterPos3s1(short x, short y, short z, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos3sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glRasterPos3sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos3sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos3sv\" not available");
    }
        dispatch_glRasterPos3sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glRasterPos3sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos3sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos3sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos3sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos3sv\" not available");
    }
        dispatch_glRasterPos3sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4d}(GLdouble x, GLdouble y, GLdouble z, GLdouble w); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos4d(double x, double y, double z, double w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos4d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos4d\" not available");
    }
        dispatch_glRasterPos4d1(x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4d}(GLdouble x, GLdouble y, GLdouble z, GLdouble w); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glRasterPos4d1(double x, double y, double z, double w, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos4dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glRasterPos4dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos4dv\" not available");
    }
        dispatch_glRasterPos4dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glRasterPos4dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos4dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos4dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos4dv\" not available");
    }
        dispatch_glRasterPos4dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4f}(GLfloat x, GLfloat y, GLfloat z, GLfloat w); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos4f(float x, float y, float z, float w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos4f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos4f\" not available");
    }
        dispatch_glRasterPos4f1(x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4f}(GLfloat x, GLfloat y, GLfloat z, GLfloat w); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glRasterPos4f1(float x, float y, float z, float w, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos4fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glRasterPos4fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos4fv\" not available");
    }
        dispatch_glRasterPos4fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glRasterPos4fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos4fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos4fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos4fv\" not available");
    }
        dispatch_glRasterPos4fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4i}(GLint x, GLint y, GLint z, GLint w); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos4i(int x, int y, int z, int w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos4i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos4i\" not available");
    }
        dispatch_glRasterPos4i1(x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4i}(GLint x, GLint y, GLint z, GLint w); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glRasterPos4i1(int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos4iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glRasterPos4iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos4iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos4iv\" not available");
    }
        dispatch_glRasterPos4iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glRasterPos4iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos4iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos4iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos4iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos4iv\" not available");
    }
        dispatch_glRasterPos4iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4s}(GLshort x, GLshort y, GLshort z, GLshort w); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos4s(short x, short y, short z, short w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos4s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos4s\" not available");
    }
        dispatch_glRasterPos4s1(x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4s}(GLshort x, GLshort y, GLshort z, GLshort w); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glRasterPos4s1(short x, short y, short z, short w, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos4sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glRasterPos4sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos4sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos4sv\" not available");
    }
        dispatch_glRasterPos4sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glRasterPos4sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos4sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRasterPos4sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRasterPos4sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRasterPos4sv\" not available");
    }
        dispatch_glRasterPos4sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadBuffer}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glReadBuffer(int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glReadBuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glReadBuffer\" not available");
    }
        dispatch_glReadBuffer1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadBuffer}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glReadBuffer1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glReadPixels(int x, int y, int width, int height, int format, int type, Buffer pixels)  {

    checkPackPBODisabled(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width            , height            , 1    , true));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glReadPixels;
    if (__addr_ == 0) {
      throw new GLException("Method \"glReadPixels\" not available");
    }
        dispatch_glReadPixels1(x, y, width, height, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glReadPixels1(int x, int y, int width, int height, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glReadPixels(int x, int y, int width, int height, int format, int type, long pixels_buffer_offset)  {

    checkPackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glReadPixels;
    if (__addr_ == 0) {
      throw new GLException("Method \"glReadPixels\" not available");
    }
        dispatch_glReadPixels1(x, y, width, height, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  private native void dispatch_glReadPixels1(int x, int y, int width, int height, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glReadnPixelsARB}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid *  data); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glReadnPixels(int x, int y, int width, int height, int format, int type, int bufSize, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glReadnPixels;
    if (__addr_ == 0) {
      throw new GLException("Method \"glReadnPixels\" not available");
    }
        dispatch_glReadnPixels1(x, y, width, height, format, type, bufSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadnPixelsARB}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid *  data); </code> <br>Part of <code>GL_ARB_robustness</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glReadnPixels1(int x, int y, int width, int height, int format, int type, int bufSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRectd}(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRectd(double x1, double y1, double x2, double y2)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRectd;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRectd\" not available");
    }
        dispatch_glRectd1(x1, y1, x2, y2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRectd}(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glRectd1(double x1, double y1, double x2, double y2, long procAddress);

  /** Entry point to C language function: <code> void {@native glRectdv}(const GLdouble *  v1, const GLdouble *  v2); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v1 a direct or array-backed {@link java.nio.DoubleBuffer}
      @param v2 a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glRectdv(DoubleBuffer v1, DoubleBuffer v2)  {

    final boolean v1_is_direct = Buffers.isDirect(v1);
    final boolean v2_is_direct = Buffers.isDirect(v2);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRectdv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRectdv\" not available");
    }
        dispatch_glRectdv1(v1_is_direct ? v1 : Buffers.getArray(v1), v1_is_direct ? Buffers.getDirectBufferByteOffset(v1) : Buffers.getIndirectBufferByteOffset(v1), v1_is_direct, v2_is_direct ? v2 : Buffers.getArray(v2), v2_is_direct ? Buffers.getDirectBufferByteOffset(v2) : Buffers.getIndirectBufferByteOffset(v2), v2_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRectdv}(const GLdouble *  v1, const GLdouble *  v2); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v1 a direct or array-backed {@link java.nio.DoubleBuffer}
      @param v2 a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glRectdv1(Object v1, int v1_byte_offset, boolean v1_is_direct, Object v2, int v2_byte_offset, boolean v2_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRectdv}(const GLdouble *  v1, const GLdouble *  v2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRectdv(double[] v1, int v1_offset, double[] v2, int v2_offset)  {

    if(v1 != null && v1.length <= v1_offset)
      throw new GLException("array offset argument \"v1_offset\" (" + v1_offset + ") equals or exceeds array length (" + v1.length + ")");
    if(v2 != null && v2.length <= v2_offset)
      throw new GLException("array offset argument \"v2_offset\" (" + v2_offset + ") equals or exceeds array length (" + v2.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRectdv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRectdv\" not available");
    }
        dispatch_glRectdv1(v1, Buffers.SIZEOF_DOUBLE * v1_offset, false, v2, Buffers.SIZEOF_DOUBLE * v2_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRectf}(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRectf(float x1, float y1, float x2, float y2)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRectf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRectf\" not available");
    }
        dispatch_glRectf1(x1, y1, x2, y2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRectf}(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glRectf1(float x1, float y1, float x2, float y2, long procAddress);

  /** Entry point to C language function: <code> void {@native glRectfv}(const GLfloat *  v1, const GLfloat *  v2); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v1 a direct or array-backed {@link java.nio.FloatBuffer}
      @param v2 a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glRectfv(FloatBuffer v1, FloatBuffer v2)  {

    final boolean v1_is_direct = Buffers.isDirect(v1);
    final boolean v2_is_direct = Buffers.isDirect(v2);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRectfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRectfv\" not available");
    }
        dispatch_glRectfv1(v1_is_direct ? v1 : Buffers.getArray(v1), v1_is_direct ? Buffers.getDirectBufferByteOffset(v1) : Buffers.getIndirectBufferByteOffset(v1), v1_is_direct, v2_is_direct ? v2 : Buffers.getArray(v2), v2_is_direct ? Buffers.getDirectBufferByteOffset(v2) : Buffers.getIndirectBufferByteOffset(v2), v2_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRectfv}(const GLfloat *  v1, const GLfloat *  v2); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v1 a direct or array-backed {@link java.nio.FloatBuffer}
      @param v2 a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glRectfv1(Object v1, int v1_byte_offset, boolean v1_is_direct, Object v2, int v2_byte_offset, boolean v2_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRectfv}(const GLfloat *  v1, const GLfloat *  v2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRectfv(float[] v1, int v1_offset, float[] v2, int v2_offset)  {

    if(v1 != null && v1.length <= v1_offset)
      throw new GLException("array offset argument \"v1_offset\" (" + v1_offset + ") equals or exceeds array length (" + v1.length + ")");
    if(v2 != null && v2.length <= v2_offset)
      throw new GLException("array offset argument \"v2_offset\" (" + v2_offset + ") equals or exceeds array length (" + v2.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRectfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRectfv\" not available");
    }
        dispatch_glRectfv1(v1, Buffers.SIZEOF_FLOAT * v1_offset, false, v2, Buffers.SIZEOF_FLOAT * v2_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRecti}(GLint x1, GLint y1, GLint x2, GLint y2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRecti(int x1, int y1, int x2, int y2)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRecti;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRecti\" not available");
    }
        dispatch_glRecti1(x1, y1, x2, y2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRecti}(GLint x1, GLint y1, GLint x2, GLint y2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glRecti1(int x1, int y1, int x2, int y2, long procAddress);

  /** Entry point to C language function: <code> void {@native glRectiv}(const GLint *  v1, const GLint *  v2); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v1 a direct or array-backed {@link java.nio.IntBuffer}
      @param v2 a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glRectiv(IntBuffer v1, IntBuffer v2)  {

    final boolean v1_is_direct = Buffers.isDirect(v1);
    final boolean v2_is_direct = Buffers.isDirect(v2);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRectiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRectiv\" not available");
    }
        dispatch_glRectiv1(v1_is_direct ? v1 : Buffers.getArray(v1), v1_is_direct ? Buffers.getDirectBufferByteOffset(v1) : Buffers.getIndirectBufferByteOffset(v1), v1_is_direct, v2_is_direct ? v2 : Buffers.getArray(v2), v2_is_direct ? Buffers.getDirectBufferByteOffset(v2) : Buffers.getIndirectBufferByteOffset(v2), v2_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRectiv}(const GLint *  v1, const GLint *  v2); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v1 a direct or array-backed {@link java.nio.IntBuffer}
      @param v2 a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glRectiv1(Object v1, int v1_byte_offset, boolean v1_is_direct, Object v2, int v2_byte_offset, boolean v2_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRectiv}(const GLint *  v1, const GLint *  v2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRectiv(int[] v1, int v1_offset, int[] v2, int v2_offset)  {

    if(v1 != null && v1.length <= v1_offset)
      throw new GLException("array offset argument \"v1_offset\" (" + v1_offset + ") equals or exceeds array length (" + v1.length + ")");
    if(v2 != null && v2.length <= v2_offset)
      throw new GLException("array offset argument \"v2_offset\" (" + v2_offset + ") equals or exceeds array length (" + v2.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRectiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRectiv\" not available");
    }
        dispatch_glRectiv1(v1, Buffers.SIZEOF_INT * v1_offset, false, v2, Buffers.SIZEOF_INT * v2_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRects}(GLshort x1, GLshort y1, GLshort x2, GLshort y2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRects(short x1, short y1, short x2, short y2)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRects;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRects\" not available");
    }
        dispatch_glRects1(x1, y1, x2, y2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRects}(GLshort x1, GLshort y1, GLshort x2, GLshort y2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glRects1(short x1, short y1, short x2, short y2, long procAddress);

  /** Entry point to C language function: <code> void {@native glRectsv}(const GLshort *  v1, const GLshort *  v2); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v1 a direct or array-backed {@link java.nio.ShortBuffer}
      @param v2 a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glRectsv(ShortBuffer v1, ShortBuffer v2)  {

    final boolean v1_is_direct = Buffers.isDirect(v1);
    final boolean v2_is_direct = Buffers.isDirect(v2);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRectsv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRectsv\" not available");
    }
        dispatch_glRectsv1(v1_is_direct ? v1 : Buffers.getArray(v1), v1_is_direct ? Buffers.getDirectBufferByteOffset(v1) : Buffers.getIndirectBufferByteOffset(v1), v1_is_direct, v2_is_direct ? v2 : Buffers.getArray(v2), v2_is_direct ? Buffers.getDirectBufferByteOffset(v2) : Buffers.getIndirectBufferByteOffset(v2), v2_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRectsv}(const GLshort *  v1, const GLshort *  v2); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v1 a direct or array-backed {@link java.nio.ShortBuffer}
      @param v2 a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glRectsv1(Object v1, int v1_byte_offset, boolean v1_is_direct, Object v2, int v2_byte_offset, boolean v2_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRectsv}(const GLshort *  v1, const GLshort *  v2); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRectsv(short[] v1, int v1_offset, short[] v2, int v2_offset)  {

    if(v1 != null && v1.length <= v1_offset)
      throw new GLException("array offset argument \"v1_offset\" (" + v1_offset + ") equals or exceeds array length (" + v1.length + ")");
    if(v2 != null && v2.length <= v2_offset)
      throw new GLException("array offset argument \"v2_offset\" (" + v2_offset + ") equals or exceeds array length (" + v2.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRectsv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRectsv\" not available");
    }
        dispatch_glRectsv1(v1, Buffers.SIZEOF_SHORT * v1_offset, false, v2, Buffers.SIZEOF_SHORT * v2_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReleaseShaderCompiler}(void); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>   */
  public void glReleaseShaderCompiler()  {

    if ( !_context.isGLES2Compatible() ) {
    return;
    }
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glReleaseShaderCompiler;
    if (__addr_ == 0) {
      throw new GLException("Method \"glReleaseShaderCompiler\" not available");
    }
        dispatch_glReleaseShaderCompiler1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glReleaseShaderCompiler}(void); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>   */
  private native void dispatch_glReleaseShaderCompiler1(long procAddress);

  /** Entry point to C language function: <code> GLint {@native glRenderMode}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public int glRenderMode(int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRenderMode;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRenderMode\" not available");
    }
        return dispatch_glRenderMode1(mode, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glRenderMode}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native int dispatch_glRenderMode1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorage}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public void glRenderbufferStorage(int target, int internalformat, int width, int height)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRenderbufferStorage;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRenderbufferStorage\" not available");
    }
        dispatch_glRenderbufferStorage1(target, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorage}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public native void dispatch_glRenderbufferStorage1(int target, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisample}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public void glRenderbufferStorageMultisample(int target, int samples, int internalformat, int width, int height)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRenderbufferStorageMultisample;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRenderbufferStorageMultisample\" not available");
    }
        dispatch_glRenderbufferStorageMultisample1(target, samples, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisample}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>   */
  public native void dispatch_glRenderbufferStorageMultisample1(int target, int samples, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleCoverageNV}(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_NV_framebuffer_multisample_coverage</code>   */
  public void glRenderbufferStorageMultisampleCoverageNV(int target, int coverageSamples, int colorSamples, int internalformat, int width, int height)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRenderbufferStorageMultisampleCoverageNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRenderbufferStorageMultisampleCoverageNV\" not available");
    }
        dispatch_glRenderbufferStorageMultisampleCoverageNV1(target, coverageSamples, colorSamples, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleCoverageNV}(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_NV_framebuffer_multisample_coverage</code>   */
  public native void dispatch_glRenderbufferStorageMultisampleCoverageNV1(int target, int coverageSamples, int colorSamples, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glResetHistogram}(GLenum target); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glResetHistogram(int target)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glResetHistogram;
    if (__addr_ == 0) {
      throw new GLException("Method \"glResetHistogram\" not available");
    }
        dispatch_glResetHistogram1(target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glResetHistogram}(GLenum target); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public native void dispatch_glResetHistogram1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glResetMinmax}(GLenum target); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glResetMinmax(int target)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glResetMinmax;
    if (__addr_ == 0) {
      throw new GLException("Method \"glResetMinmax\" not available");
    }
        dispatch_glResetMinmax1(target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glResetMinmax}(GLenum target); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public native void dispatch_glResetMinmax1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glResumeTransformFeedback}(void); </code> <br>Part of <code>GL_ARB_transform_feedback2</code>   */
  public void glResumeTransformFeedback()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glResumeTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException("Method \"glResumeTransformFeedback\" not available");
    }
        dispatch_glResumeTransformFeedback1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glResumeTransformFeedback}(void); </code> <br>Part of <code>GL_ARB_transform_feedback2</code>   */
  public native void dispatch_glResumeTransformFeedback1(long procAddress);

  /** Entry point to C language function: <code> void {@native glResumeTransformFeedbackNV}(void); </code> <br>Part of <code>GL_NV_transform_feedback2</code>   */
  public void glResumeTransformFeedbackNV()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glResumeTransformFeedbackNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glResumeTransformFeedbackNV\" not available");
    }
        dispatch_glResumeTransformFeedbackNV1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glResumeTransformFeedbackNV}(void); </code> <br>Part of <code>GL_NV_transform_feedback2</code>   */
  public native void dispatch_glResumeTransformFeedbackNV1(long procAddress);

  /** Entry point to C language function: <code> void {@native glRotated}(GLdouble angle, GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRotated(double angle, double x, double y, double z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRotated;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRotated\" not available");
    }
        dispatch_glRotated1(angle, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRotated}(GLdouble angle, GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glRotated1(double angle, double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glRotatef}(GLfloat angle, GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glRotatef(float angle, float x, float y, float z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glRotatef;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRotatef\" not available");
    }
        dispatch_glRotatef1(angle, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRotatef}(GLfloat angle, GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glRotatef1(float angle, float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glSampleCoverage}(GLclampf value, GLboolean invert); </code> <br>Part of <code>GL_VERSION_1_3</code>   */
  public void glSampleCoverage(float value, boolean invert)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSampleCoverage;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSampleCoverage\" not available");
    }
        dispatch_glSampleCoverage1(value, invert, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSampleCoverage}(GLclampf value, GLboolean invert); </code> <br>Part of <code>GL_VERSION_1_3</code>   */
  public native void dispatch_glSampleCoverage1(float value, boolean invert, long procAddress);

  /** Entry point to C language function: <code> void {@native glSampleMaskIndexedNV}(GLuint index, GLbitfield mask); </code> <br>Part of <code>GL_NV_explicit_multisample</code>   */
  public void glSampleMaskIndexedNV(int index, int mask)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSampleMaskIndexedNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSampleMaskIndexedNV\" not available");
    }
        dispatch_glSampleMaskIndexedNV1(index, mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSampleMaskIndexedNV}(GLuint index, GLbitfield mask); </code> <br>Part of <code>GL_NV_explicit_multisample</code>   */
  public native void dispatch_glSampleMaskIndexedNV1(int index, int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glSampleMaski}(GLuint index, GLbitfield mask); </code> <br>Part of <code>GL_ARB_texture_multisample</code>   */
  public void glSampleMaski(int index, int mask)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSampleMaski;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSampleMaski\" not available");
    }
        dispatch_glSampleMaski1(index, mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSampleMaski}(GLuint index, GLbitfield mask); </code> <br>Part of <code>GL_ARB_texture_multisample</code>   */
  public native void dispatch_glSampleMaski1(int index, int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameterIiv}(GLuint sampler, GLenum pname, const GLint *  param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glSamplerParameterIiv(int sampler, int pname, IntBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSamplerParameterIiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSamplerParameterIiv\" not available");
    }
        dispatch_glSamplerParameterIiv1(sampler, pname, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameterIiv}(GLuint sampler, GLenum pname, const GLint *  param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glSamplerParameterIiv1(int sampler, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameterIiv}(GLuint sampler, GLenum pname, const GLint *  param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>   */
  public void glSamplerParameterIiv(int sampler, int pname, int[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSamplerParameterIiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSamplerParameterIiv\" not available");
    }
        dispatch_glSamplerParameterIiv1(sampler, pname, param, Buffers.SIZEOF_INT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameterIuiv}(GLuint sampler, GLenum pname, const GLuint *  param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glSamplerParameterIuiv(int sampler, int pname, IntBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSamplerParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSamplerParameterIuiv\" not available");
    }
        dispatch_glSamplerParameterIuiv1(sampler, pname, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameterIuiv}(GLuint sampler, GLenum pname, const GLuint *  param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glSamplerParameterIuiv1(int sampler, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameterIuiv}(GLuint sampler, GLenum pname, const GLuint *  param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>   */
  public void glSamplerParameterIuiv(int sampler, int pname, int[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSamplerParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSamplerParameterIuiv\" not available");
    }
        dispatch_glSamplerParameterIuiv1(sampler, pname, param, Buffers.SIZEOF_INT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameterf}(GLuint sampler, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>   */
  public void glSamplerParameterf(int sampler, int pname, float param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSamplerParameterf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSamplerParameterf\" not available");
    }
        dispatch_glSamplerParameterf1(sampler, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameterf}(GLuint sampler, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>   */
  public native void dispatch_glSamplerParameterf1(int sampler, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameterfv}(GLuint sampler, GLenum pname, const GLfloat *  param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>
      @param param a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glSamplerParameterfv(int sampler, int pname, FloatBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSamplerParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSamplerParameterfv\" not available");
    }
        dispatch_glSamplerParameterfv1(sampler, pname, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameterfv}(GLuint sampler, GLenum pname, const GLfloat *  param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>
      @param param a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glSamplerParameterfv1(int sampler, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameterfv}(GLuint sampler, GLenum pname, const GLfloat *  param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>   */
  public void glSamplerParameterfv(int sampler, int pname, float[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSamplerParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSamplerParameterfv\" not available");
    }
        dispatch_glSamplerParameterfv1(sampler, pname, param, Buffers.SIZEOF_FLOAT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameteri}(GLuint sampler, GLenum pname, GLint param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>   */
  public void glSamplerParameteri(int sampler, int pname, int param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSamplerParameteri;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSamplerParameteri\" not available");
    }
        dispatch_glSamplerParameteri1(sampler, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameteri}(GLuint sampler, GLenum pname, GLint param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>   */
  public native void dispatch_glSamplerParameteri1(int sampler, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameteriv}(GLuint sampler, GLenum pname, const GLint *  param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glSamplerParameteriv(int sampler, int pname, IntBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSamplerParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSamplerParameteriv\" not available");
    }
        dispatch_glSamplerParameteriv1(sampler, pname, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameteriv}(GLuint sampler, GLenum pname, const GLint *  param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glSamplerParameteriv1(int sampler, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameteriv}(GLuint sampler, GLenum pname, const GLint *  param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>   */
  public void glSamplerParameteriv(int sampler, int pname, int[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSamplerParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSamplerParameteriv\" not available");
    }
        dispatch_glSamplerParameteriv1(sampler, pname, param, Buffers.SIZEOF_INT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScaled}(GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glScaled(double x, double y, double z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glScaled;
    if (__addr_ == 0) {
      throw new GLException("Method \"glScaled\" not available");
    }
        dispatch_glScaled1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScaled}(GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glScaled1(double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glScalef}(GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glScalef(float x, float y, float z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glScalef;
    if (__addr_ == 0) {
      throw new GLException("Method \"glScalef\" not available");
    }
        dispatch_glScalef1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScalef}(GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glScalef1(float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glScissor}(GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glScissor(int x, int y, int width, int height)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glScissor;
    if (__addr_ == 0) {
      throw new GLException("Method \"glScissor\" not available");
    }
        dispatch_glScissor1(x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScissor}(GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glScissor1(int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glScissorArrayv}(GLuint first, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_ARB_viewport_array</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glScissorArrayv(int first, int count, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glScissorArrayv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glScissorArrayv\" not available");
    }
        dispatch_glScissorArrayv1(first, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScissorArrayv}(GLuint first, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_ARB_viewport_array</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glScissorArrayv1(int first, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glScissorArrayv}(GLuint first, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_ARB_viewport_array</code>   */
  public void glScissorArrayv(int first, int count, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glScissorArrayv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glScissorArrayv\" not available");
    }
        dispatch_glScissorArrayv1(first, count, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScissorIndexed}(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ARB_viewport_array</code>   */
  public void glScissorIndexed(int index, int left, int bottom, int width, int height)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glScissorIndexed;
    if (__addr_ == 0) {
      throw new GLException("Method \"glScissorIndexed\" not available");
    }
        dispatch_glScissorIndexed1(index, left, bottom, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScissorIndexed}(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ARB_viewport_array</code>   */
  public native void dispatch_glScissorIndexed1(int index, int left, int bottom, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glScissorIndexedv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_ARB_viewport_array</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glScissorIndexedv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glScissorIndexedv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glScissorIndexedv\" not available");
    }
        dispatch_glScissorIndexedv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScissorIndexedv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_ARB_viewport_array</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glScissorIndexedv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glScissorIndexedv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_ARB_viewport_array</code>   */
  public void glScissorIndexedv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glScissorIndexedv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glScissorIndexedv\" not available");
    }
        dispatch_glScissorIndexedv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3b}(GLbyte red, GLbyte green, GLbyte blue); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glSecondaryColor3b(byte red, byte green, byte blue)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3b;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3b\" not available");
    }
        dispatch_glSecondaryColor3b1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3b}(GLbyte red, GLbyte green, GLbyte blue); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public native void dispatch_glSecondaryColor3b1(byte red, byte green, byte blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3bv}(const GLbyte *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glSecondaryColor3bv(ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3bv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3bv\" not available");
    }
        dispatch_glSecondaryColor3bv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3bv}(const GLbyte *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glSecondaryColor3bv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3bv}(const GLbyte *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glSecondaryColor3bv(byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3bv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3bv\" not available");
    }
        dispatch_glSecondaryColor3bv1(v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3d}(GLdouble red, GLdouble green, GLdouble blue); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glSecondaryColor3d(double red, double green, double blue)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3d\" not available");
    }
        dispatch_glSecondaryColor3d1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3d}(GLdouble red, GLdouble green, GLdouble blue); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public native void dispatch_glSecondaryColor3d1(double red, double green, double blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glSecondaryColor3dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3dv\" not available");
    }
        dispatch_glSecondaryColor3dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glSecondaryColor3dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glSecondaryColor3dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3dv\" not available");
    }
        dispatch_glSecondaryColor3dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3f}(GLfloat red, GLfloat green, GLfloat blue); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glSecondaryColor3f(float red, float green, float blue)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3f\" not available");
    }
        dispatch_glSecondaryColor3f1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3f}(GLfloat red, GLfloat green, GLfloat blue); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public native void dispatch_glSecondaryColor3f1(float red, float green, float blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glSecondaryColor3fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3fv\" not available");
    }
        dispatch_glSecondaryColor3fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glSecondaryColor3fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glSecondaryColor3fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3fv\" not available");
    }
        dispatch_glSecondaryColor3fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3hNV}(GLhalfNV red, GLhalfNV green, GLhalfNV blue); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glSecondaryColor3h(short red, short green, short blue)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3h;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3h\" not available");
    }
        dispatch_glSecondaryColor3h1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3hNV}(GLhalfNV red, GLhalfNV green, GLhalfNV blue); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public native void dispatch_glSecondaryColor3h1(short red, short green, short blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glSecondaryColor3hv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3hv\" not available");
    }
        dispatch_glSecondaryColor3hv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glSecondaryColor3hv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glSecondaryColor3hv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3hv\" not available");
    }
        dispatch_glSecondaryColor3hv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3i}(GLint red, GLint green, GLint blue); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glSecondaryColor3i(int red, int green, int blue)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3i\" not available");
    }
        dispatch_glSecondaryColor3i1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3i}(GLint red, GLint green, GLint blue); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public native void dispatch_glSecondaryColor3i1(int red, int green, int blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glSecondaryColor3iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3iv\" not available");
    }
        dispatch_glSecondaryColor3iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glSecondaryColor3iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glSecondaryColor3iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3iv\" not available");
    }
        dispatch_glSecondaryColor3iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3s}(GLshort red, GLshort green, GLshort blue); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glSecondaryColor3s(short red, short green, short blue)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3s\" not available");
    }
        dispatch_glSecondaryColor3s1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3s}(GLshort red, GLshort green, GLshort blue); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public native void dispatch_glSecondaryColor3s1(short red, short green, short blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glSecondaryColor3sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3sv\" not available");
    }
        dispatch_glSecondaryColor3sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glSecondaryColor3sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glSecondaryColor3sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3sv\" not available");
    }
        dispatch_glSecondaryColor3sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3ub}(GLubyte red, GLubyte green, GLubyte blue); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glSecondaryColor3ub(byte red, byte green, byte blue)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3ub;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3ub\" not available");
    }
        dispatch_glSecondaryColor3ub1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3ub}(GLubyte red, GLubyte green, GLubyte blue); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public native void dispatch_glSecondaryColor3ub1(byte red, byte green, byte blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3ubv}(const GLubyte *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glSecondaryColor3ubv(ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3ubv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3ubv\" not available");
    }
        dispatch_glSecondaryColor3ubv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3ubv}(const GLubyte *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glSecondaryColor3ubv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3ubv}(const GLubyte *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glSecondaryColor3ubv(byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3ubv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3ubv\" not available");
    }
        dispatch_glSecondaryColor3ubv1(v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3ui}(GLuint red, GLuint green, GLuint blue); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glSecondaryColor3ui(int red, int green, int blue)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3ui\" not available");
    }
        dispatch_glSecondaryColor3ui1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3ui}(GLuint red, GLuint green, GLuint blue); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public native void dispatch_glSecondaryColor3ui1(int red, int green, int blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3uiv}(const GLuint *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glSecondaryColor3uiv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3uiv\" not available");
    }
        dispatch_glSecondaryColor3uiv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3uiv}(const GLuint *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glSecondaryColor3uiv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3uiv}(const GLuint *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glSecondaryColor3uiv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3uiv\" not available");
    }
        dispatch_glSecondaryColor3uiv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3us}(GLushort red, GLushort green, GLushort blue); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glSecondaryColor3us(short red, short green, short blue)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3us;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3us\" not available");
    }
        dispatch_glSecondaryColor3us1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3us}(GLushort red, GLushort green, GLushort blue); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public native void dispatch_glSecondaryColor3us1(short red, short green, short blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3usv}(const GLushort *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glSecondaryColor3usv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3usv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3usv\" not available");
    }
        dispatch_glSecondaryColor3usv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3usv}(const GLushort *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glSecondaryColor3usv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3usv}(const GLushort *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glSecondaryColor3usv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColor3usv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColor3usv\" not available");
    }
        dispatch_glSecondaryColor3usv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColorFormatNV}(GLint size, GLenum type, GLsizei stride); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public void glSecondaryColorFormatNV(int size, int type, int stride)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColorFormatNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColorFormatNV\" not available");
    }
        dispatch_glSecondaryColorFormatNV1(size, type, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColorFormatNV}(GLint size, GLenum type, GLsizei stride); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public native void dispatch_glSecondaryColorFormatNV1(int size, int type, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColorP3ui}(GLenum type, GLuint color); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glSecondaryColorP3ui(int type, int color)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColorP3ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColorP3ui\" not available");
    }
        dispatch_glSecondaryColorP3ui1(type, color, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColorP3ui}(GLenum type, GLuint color); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public native void dispatch_glSecondaryColorP3ui1(int type, int color, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColorP3uiv}(GLenum type, const GLuint *  color); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param color a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glSecondaryColorP3uiv(int type, IntBuffer color)  {

    final boolean color_is_direct = Buffers.isDirect(color);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColorP3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColorP3uiv\" not available");
    }
        dispatch_glSecondaryColorP3uiv1(type, color_is_direct ? color : Buffers.getArray(color), color_is_direct ? Buffers.getDirectBufferByteOffset(color) : Buffers.getIndirectBufferByteOffset(color), color_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColorP3uiv}(GLenum type, const GLuint *  color); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param color a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glSecondaryColorP3uiv1(int type, Object color, int color_byte_offset, boolean color_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColorP3uiv}(GLenum type, const GLuint *  color); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glSecondaryColorP3uiv(int type, int[] color, int color_offset)  {

    if(color != null && color.length <= color_offset)
      throw new GLException("array offset argument \"color_offset\" (" + color_offset + ") equals or exceeds array length (" + color.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColorP3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColorP3uiv\" not available");
    }
        dispatch_glSecondaryColorP3uiv1(type, color, Buffers.SIZEOF_INT * color_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColorPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glSecondaryColorPointer(int size, int type, int stride, Buffer pointer)  {

    checkArrayVBODisabled(true);
    Buffers.rangeCheck(pointer, 1);
    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColorPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColorPointer\" not available");
    }
        dispatch_glSecondaryColorPointer1(size, type, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColorPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glSecondaryColorPointer1(int size, int type, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColorPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glSecondaryColorPointer(int size, int type, int stride, long pointer_buffer_offset)  {

    checkArrayVBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSecondaryColorPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSecondaryColorPointer\" not available");
    }
        dispatch_glSecondaryColorPointer1(size, type, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColorPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  private native void dispatch_glSecondaryColorPointer1(int size, int type, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glSelectBuffer}(GLsizei size, GLuint *  buffer); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param buffer a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glSelectBuffer(int size, IntBuffer buffer)  {

    final boolean buffer_is_direct = Buffers.isDirect(buffer);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSelectBuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSelectBuffer\" not available");
    }
        dispatch_glSelectBuffer1(size, buffer_is_direct ? buffer : Buffers.getArray(buffer), buffer_is_direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), buffer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSelectBuffer}(GLsizei size, GLuint *  buffer); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param buffer a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glSelectBuffer1(int size, Object buffer, int buffer_byte_offset, boolean buffer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSelectBuffer}(GLsizei size, GLuint *  buffer); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glSelectBuffer(int size, int[] buffer, int buffer_offset)  {

    if(buffer != null && buffer.length <= buffer_offset)
      throw new GLException("array offset argument \"buffer_offset\" (" + buffer_offset + ") equals or exceeds array length (" + buffer.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSelectBuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSelectBuffer\" not available");
    }
        dispatch_glSelectBuffer1(size, buffer, Buffers.SIZEOF_INT * buffer_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSelectPerfMonitorCountersAMD}(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *  counterList); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param counterList a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glSelectPerfMonitorCountersAMD(int monitor, boolean enable, int group, int numCounters, IntBuffer counterList)  {

    final boolean counterList_is_direct = Buffers.isDirect(counterList);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSelectPerfMonitorCountersAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSelectPerfMonitorCountersAMD\" not available");
    }
        dispatch_glSelectPerfMonitorCountersAMD1(monitor, enable, group, numCounters, counterList_is_direct ? counterList : Buffers.getArray(counterList), counterList_is_direct ? Buffers.getDirectBufferByteOffset(counterList) : Buffers.getIndirectBufferByteOffset(counterList), counterList_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSelectPerfMonitorCountersAMD}(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *  counterList); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param counterList a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glSelectPerfMonitorCountersAMD1(int monitor, boolean enable, int group, int numCounters, Object counterList, int counterList_byte_offset, boolean counterList_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSelectPerfMonitorCountersAMD}(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *  counterList); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glSelectPerfMonitorCountersAMD(int monitor, boolean enable, int group, int numCounters, int[] counterList, int counterList_offset)  {

    if(counterList != null && counterList.length <= counterList_offset)
      throw new GLException("array offset argument \"counterList_offset\" (" + counterList_offset + ") equals or exceeds array length (" + counterList.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSelectPerfMonitorCountersAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSelectPerfMonitorCountersAMD\" not available");
    }
        dispatch_glSelectPerfMonitorCountersAMD1(monitor, enable, group, numCounters, counterList, Buffers.SIZEOF_INT * counterList_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSeparableFilter2D}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  row, const GLvoid *  column); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param row a direct or array-backed {@link java.nio.Buffer}
      @param column a direct or array-backed {@link java.nio.Buffer}   */
  public void glSeparableFilter2D(int target, int internalformat, int width, int height, int format, int type, Buffer row, Buffer column)  {

    checkUnpackPBODisabled(true);
    final boolean row_is_direct = Buffers.isDirect(row);
    final boolean column_is_direct = Buffers.isDirect(column);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSeparableFilter2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSeparableFilter2D\" not available");
    }
        dispatch_glSeparableFilter2D1(target, internalformat, width, height, format, type, row_is_direct ? row : Buffers.getArray(row), row_is_direct ? Buffers.getDirectBufferByteOffset(row) : Buffers.getIndirectBufferByteOffset(row), row_is_direct, column_is_direct ? column : Buffers.getArray(column), column_is_direct ? Buffers.getDirectBufferByteOffset(column) : Buffers.getIndirectBufferByteOffset(column), column_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSeparableFilter2D}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  row, const GLvoid *  column); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>
      @param row a direct or array-backed {@link java.nio.Buffer}
      @param column a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glSeparableFilter2D1(int target, int internalformat, int width, int height, int format, int type, Object row, int row_byte_offset, boolean row_is_direct, Object column, int column_byte_offset, boolean column_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSeparableFilter2D}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  row, const GLvoid *  column); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  public void glSeparableFilter2D(int target, int internalformat, int width, int height, int format, int type, long row_buffer_offset, long column_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSeparableFilter2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSeparableFilter2D\" not available");
    }
        dispatch_glSeparableFilter2D1(target, internalformat, width, height, format, type, row_buffer_offset, column_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSeparableFilter2D}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  row, const GLvoid *  column); </code> <br>Part of <code>GL_VERSION_1_2_DEPRECATED</code>   */
  private native void dispatch_glSeparableFilter2D1(int target, int internalformat, int width, int height, int format, int type, long row_buffer_offset, long column_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glSetFenceAPPLE}(GLuint fence); </code> <br>Part of <code>GL_APPLE_fence</code>   */
  public void glSetFenceAPPLE(int fence)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSetFenceAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSetFenceAPPLE\" not available");
    }
        dispatch_glSetFenceAPPLE1(fence, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSetFenceAPPLE}(GLuint fence); </code> <br>Part of <code>GL_APPLE_fence</code>   */
  public native void dispatch_glSetFenceAPPLE1(int fence, long procAddress);

  /** Entry point to C language function: <code> void {@native glSetFenceNV}(GLuint fence, GLenum condition); </code> <br>Part of <code>GL_NV_fence</code>   */
  public void glSetFenceNV(int fence, int condition)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSetFenceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSetFenceNV\" not available");
    }
        dispatch_glSetFenceNV1(fence, condition, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSetFenceNV}(GLuint fence, GLenum condition); </code> <br>Part of <code>GL_NV_fence</code>   */
  public native void dispatch_glSetFenceNV1(int fence, int condition, long procAddress);

  /** Entry point to C language function: <code> void {@native glSetInvariantEXT}(GLuint id, GLenum type, const GLvoid *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param addr a direct or array-backed {@link java.nio.Buffer}   */
  public void glSetInvariantEXT(int id, int type, Buffer addr)  {

    final boolean addr_is_direct = Buffers.isDirect(addr);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSetInvariantEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSetInvariantEXT\" not available");
    }
        dispatch_glSetInvariantEXT1(id, type, addr_is_direct ? addr : Buffers.getArray(addr), addr_is_direct ? Buffers.getDirectBufferByteOffset(addr) : Buffers.getIndirectBufferByteOffset(addr), addr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSetInvariantEXT}(GLuint id, GLenum type, const GLvoid *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param addr a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glSetInvariantEXT1(int id, int type, Object addr, int addr_byte_offset, boolean addr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSetLocalConstantEXT}(GLuint id, GLenum type, const GLvoid *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param addr a direct or array-backed {@link java.nio.Buffer}   */
  public void glSetLocalConstantEXT(int id, int type, Buffer addr)  {

    final boolean addr_is_direct = Buffers.isDirect(addr);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSetLocalConstantEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSetLocalConstantEXT\" not available");
    }
        dispatch_glSetLocalConstantEXT1(id, type, addr_is_direct ? addr : Buffers.getArray(addr), addr_is_direct ? Buffers.getDirectBufferByteOffset(addr) : Buffers.getIndirectBufferByteOffset(addr), addr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSetLocalConstantEXT}(GLuint id, GLenum type, const GLvoid *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param addr a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glSetLocalConstantEXT1(int id, int type, Object addr, int addr_byte_offset, boolean addr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSetMultisamplefvAMD}(GLenum pname, GLuint index, const GLfloat *  val); </code> <br>Part of <code>GL_AMD_sample_positions</code>
      @param val a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glSetMultisamplefvAMD(int pname, int index, FloatBuffer val)  {

    final boolean val_is_direct = Buffers.isDirect(val);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSetMultisamplefvAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSetMultisamplefvAMD\" not available");
    }
        dispatch_glSetMultisamplefvAMD1(pname, index, val_is_direct ? val : Buffers.getArray(val), val_is_direct ? Buffers.getDirectBufferByteOffset(val) : Buffers.getIndirectBufferByteOffset(val), val_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSetMultisamplefvAMD}(GLenum pname, GLuint index, const GLfloat *  val); </code> <br>Part of <code>GL_AMD_sample_positions</code>
      @param val a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glSetMultisamplefvAMD1(int pname, int index, Object val, int val_byte_offset, boolean val_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSetMultisamplefvAMD}(GLenum pname, GLuint index, const GLfloat *  val); </code> <br>Part of <code>GL_AMD_sample_positions</code>   */
  public void glSetMultisamplefvAMD(int pname, int index, float[] val, int val_offset)  {

    if(val != null && val.length <= val_offset)
      throw new GLException("array offset argument \"val_offset\" (" + val_offset + ") equals or exceeds array length (" + val.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSetMultisamplefvAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSetMultisamplefvAMD\" not available");
    }
        dispatch_glSetMultisamplefvAMD1(pname, index, val, Buffers.SIZEOF_FLOAT * val_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShadeModel}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glShadeModel(int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glShadeModel;
    if (__addr_ == 0) {
      throw new GLException("Method \"glShadeModel\" not available");
    }
        dispatch_glShadeModel1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShadeModel}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glShadeModel1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderBinary}(GLsizei count, const GLuint *  shaders, GLenum binaryformat, const GLvoid *  binary, GLsizei length); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glShaderBinary(int count, IntBuffer shaders, int binaryformat, Buffer binary, int length)  {

    if ( !_context.isGLES2Compatible() ) {
    throw new GLException("Method \"glShaderBinary\" not available");
    }
    final boolean shaders_is_direct = Buffers.isDirect(shaders);
    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glShaderBinary;
    if (__addr_ == 0) {
      throw new GLException("Method \"glShaderBinary\" not available");
    }
        dispatch_glShaderBinary1(count, shaders_is_direct ? shaders : Buffers.getArray(shaders), shaders_is_direct ? Buffers.getDirectBufferByteOffset(shaders) : Buffers.getIndirectBufferByteOffset(shaders), shaders_is_direct, binaryformat, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderBinary}(GLsizei count, const GLuint *  shaders, GLenum binaryformat, const GLvoid *  binary, GLsizei length); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glShaderBinary1(int count, Object shaders, int shaders_byte_offset, boolean shaders_is_direct, int binaryformat, Object binary, int binary_byte_offset, boolean binary_is_direct, int length, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderBinary}(GLsizei count, const GLuint *  shaders, GLenum binaryformat, const GLvoid *  binary, GLsizei length); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glShaderBinary(int count, int[] shaders, int shaders_offset, int binaryformat, Buffer binary, int length)  {

    if ( !_context.isGLES2Compatible() ) {
    throw new GLException("Method \"glShaderBinary\" not available");
    }
    if(shaders != null && shaders.length <= shaders_offset)
      throw new GLException("array offset argument \"shaders_offset\" (" + shaders_offset + ") equals or exceeds array length (" + shaders.length + ")");
    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glShaderBinary;
    if (__addr_ == 0) {
      throw new GLException("Method \"glShaderBinary\" not available");
    }
        dispatch_glShaderBinary1(count, shaders, Buffers.SIZEOF_INT * shaders_offset, false, binaryformat, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderOp1EXT}(GLenum op, GLuint res, GLuint arg1); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glShaderOp1EXT(int op, int res, int arg1)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glShaderOp1EXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glShaderOp1EXT\" not available");
    }
        dispatch_glShaderOp1EXT1(op, res, arg1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderOp1EXT}(GLenum op, GLuint res, GLuint arg1); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public native void dispatch_glShaderOp1EXT1(int op, int res, int arg1, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderOp2EXT}(GLenum op, GLuint res, GLuint arg1, GLuint arg2); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glShaderOp2EXT(int op, int res, int arg1, int arg2)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glShaderOp2EXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glShaderOp2EXT\" not available");
    }
        dispatch_glShaderOp2EXT1(op, res, arg1, arg2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderOp2EXT}(GLenum op, GLuint res, GLuint arg1, GLuint arg2); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public native void dispatch_glShaderOp2EXT1(int op, int res, int arg1, int arg2, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderOp3EXT}(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glShaderOp3EXT(int op, int res, int arg1, int arg2, int arg3)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glShaderOp3EXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glShaderOp3EXT\" not available");
    }
        dispatch_glShaderOp3EXT1(op, res, arg1, arg2, arg3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderOp3EXT}(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public native void dispatch_glShaderOp3EXT1(int op, int res, int arg1, int arg2, int arg3, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderSource}(GLuint shader, GLsizei count, const GLchar *  *  string, const GLint *  length); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glShaderSource(int shader, int count, String[] string, IntBuffer length)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glShaderSource;
    if (__addr_ == 0) {
      throw new GLException("Method \"glShaderSource\" not available");
    }
        dispatch_glShaderSource1(shader, count, string, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderSource}(GLuint shader, GLsizei count, const GLchar *  *  string, const GLint *  length); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glShaderSource1(int shader, int count, String[] string, Object length, int length_byte_offset, boolean length_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderSource}(GLuint shader, GLsizei count, const GLchar *  *  string, const GLint *  length); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glShaderSource(int shader, int count, String[] string, int[] length, int length_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glShaderSource;
    if (__addr_ == 0) {
      throw new GLException("Method \"glShaderSource\" not available");
    }
        dispatch_glShaderSource1(shader, count, string, length, Buffers.SIZEOF_INT * length_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderSourceARB}(GLhandleARB shaderObj, GLsizei count, const GLcharARB *  *  string, const GLint *  length); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glShaderSourceARB(int shaderObj, int count, String[] string, IntBuffer length)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glShaderSourceARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glShaderSourceARB\" not available");
    }
        dispatch_glShaderSourceARB1(shaderObj, count, string, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderSourceARB}(GLhandleARB shaderObj, GLsizei count, const GLcharARB *  *  string, const GLint *  length); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glShaderSourceARB1(int shaderObj, int count, String[] string, Object length, int length_byte_offset, boolean length_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderSourceARB}(GLhandleARB shaderObj, GLsizei count, const GLcharARB *  *  string, const GLint *  length); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glShaderSourceARB(int shaderObj, int count, String[] string, int[] length, int length_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glShaderSourceARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glShaderSourceARB\" not available");
    }
        dispatch_glShaderSourceARB1(shaderObj, count, string, length, Buffers.SIZEOF_INT * length_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilClearTagEXT}(GLsizei stencilTagBits, GLuint stencilClearTag); </code> <br>Part of <code>GL_EXT_stencil_clear_tag</code>   */
  public void glStencilClearTagEXT(int stencilTagBits, int stencilClearTag)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glStencilClearTagEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glStencilClearTagEXT\" not available");
    }
        dispatch_glStencilClearTagEXT1(stencilTagBits, stencilClearTag, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilClearTagEXT}(GLsizei stencilTagBits, GLuint stencilClearTag); </code> <br>Part of <code>GL_EXT_stencil_clear_tag</code>   */
  public native void dispatch_glStencilClearTagEXT1(int stencilTagBits, int stencilClearTag, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilFunc}(GLenum func, GLint ref, GLuint mask); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glStencilFunc(int func, int ref, int mask)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glStencilFunc;
    if (__addr_ == 0) {
      throw new GLException("Method \"glStencilFunc\" not available");
    }
        dispatch_glStencilFunc1(func, ref, mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilFunc}(GLenum func, GLint ref, GLuint mask); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glStencilFunc1(int func, int ref, int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilFuncSeparate}(GLenum face, GLenum func, GLint ref, GLuint mask); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glStencilFuncSeparate(int face, int func, int ref, int mask)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glStencilFuncSeparate;
    if (__addr_ == 0) {
      throw new GLException("Method \"glStencilFuncSeparate\" not available");
    }
        dispatch_glStencilFuncSeparate1(face, func, ref, mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilFuncSeparate}(GLenum face, GLenum func, GLint ref, GLuint mask); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glStencilFuncSeparate1(int face, int func, int ref, int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilMask}(GLuint mask); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glStencilMask(int mask)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glStencilMask;
    if (__addr_ == 0) {
      throw new GLException("Method \"glStencilMask\" not available");
    }
        dispatch_glStencilMask1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilMask}(GLuint mask); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glStencilMask1(int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilMaskSeparate}(GLenum face, GLuint mask); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glStencilMaskSeparate(int face, int mask)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glStencilMaskSeparate;
    if (__addr_ == 0) {
      throw new GLException("Method \"glStencilMaskSeparate\" not available");
    }
        dispatch_glStencilMaskSeparate1(face, mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilMaskSeparate}(GLenum face, GLuint mask); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glStencilMaskSeparate1(int face, int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilOp}(GLenum fail, GLenum zfail, GLenum zpass); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glStencilOp(int fail, int zfail, int zpass)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glStencilOp;
    if (__addr_ == 0) {
      throw new GLException("Method \"glStencilOp\" not available");
    }
        dispatch_glStencilOp1(fail, zfail, zpass, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilOp}(GLenum fail, GLenum zfail, GLenum zpass); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glStencilOp1(int fail, int zfail, int zpass, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilOpSeparate}(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glStencilOpSeparate(int face, int sfail, int dpfail, int dppass)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glStencilOpSeparate;
    if (__addr_ == 0) {
      throw new GLException("Method \"glStencilOpSeparate\" not available");
    }
        dispatch_glStencilOpSeparate1(face, sfail, dpfail, dppass, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilOpSeparate}(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glStencilOpSeparate1(int face, int sfail, int dpfail, int dppass, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilOpValueAMD}(GLenum face, GLuint value); </code> <br>Part of <code>GL_AMD_stencil_operation_extended</code>   */
  public void glStencilOpValueAMD(int face, int value)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glStencilOpValueAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glStencilOpValueAMD\" not available");
    }
        dispatch_glStencilOpValueAMD1(face, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilOpValueAMD}(GLenum face, GLuint value); </code> <br>Part of <code>GL_AMD_stencil_operation_extended</code>   */
  public native void dispatch_glStencilOpValueAMD1(int face, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glStringMarkerGREMEDY}(GLsizei len, const GLvoid *  string); </code> <br>Part of <code>GL_GREMEDY_string_marker</code>
      @param string a direct or array-backed {@link java.nio.Buffer}   */
  public void glStringMarkerGREMEDY(int len, Buffer string)  {

    final boolean string_is_direct = Buffers.isDirect(string);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glStringMarkerGREMEDY;
    if (__addr_ == 0) {
      throw new GLException("Method \"glStringMarkerGREMEDY\" not available");
    }
        dispatch_glStringMarkerGREMEDY1(len, string_is_direct ? string : Buffers.getArray(string), string_is_direct ? Buffers.getDirectBufferByteOffset(string) : Buffers.getIndirectBufferByteOffset(string), string_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStringMarkerGREMEDY}(GLsizei len, const GLvoid *  string); </code> <br>Part of <code>GL_GREMEDY_string_marker</code>
      @param string a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glStringMarkerGREMEDY1(int len, Object string, int string_byte_offset, boolean string_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSwapAPPLE}(void); </code> <br>Part of <code>GL_APPLE_flush_render</code>   */
  public void glSwapAPPLE()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSwapAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSwapAPPLE\" not available");
    }
        dispatch_glSwapAPPLE1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glSwapAPPLE}(void); </code> <br>Part of <code>GL_APPLE_flush_render</code>   */
  public native void dispatch_glSwapAPPLE1(long procAddress);

  /** Entry point to C language function: <code> void {@native glSwizzleEXT}(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glSwizzleEXT(int res, int in, int outX, int outY, int outZ, int outW)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glSwizzleEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSwizzleEXT\" not available");
    }
        dispatch_glSwizzleEXT1(res, in, outX, outY, outZ, outW, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSwizzleEXT}(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public native void dispatch_glSwizzleEXT1(int res, int in, int outX, int outY, int outZ, int outW, long procAddress);

  /** Entry point to C language function: <code> void {@native glTessellationFactorAMD}(GLfloat factor); </code> <br>Part of <code>GL_AMD_vertex_shader_tesselator</code>, <code>GL_AMD_vertex_shader_tessellator</code>   */
  public void glTessellationFactorAMD(float factor)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTessellationFactorAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTessellationFactorAMD\" not available");
    }
        dispatch_glTessellationFactorAMD1(factor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTessellationFactorAMD}(GLfloat factor); </code> <br>Part of <code>GL_AMD_vertex_shader_tesselator</code>, <code>GL_AMD_vertex_shader_tessellator</code>   */
  public native void dispatch_glTessellationFactorAMD1(float factor, long procAddress);

  /** Entry point to C language function: <code> void {@native glTessellationModeAMD}(GLenum mode); </code> <br>Part of <code>GL_AMD_vertex_shader_tesselator</code>, <code>GL_AMD_vertex_shader_tessellator</code>   */
  public void glTessellationModeAMD(int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTessellationModeAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTessellationModeAMD\" not available");
    }
        dispatch_glTessellationModeAMD1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTessellationModeAMD}(GLenum mode); </code> <br>Part of <code>GL_AMD_vertex_shader_tesselator</code>, <code>GL_AMD_vertex_shader_tessellator</code>   */
  public native void dispatch_glTessellationModeAMD1(int mode, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glTestFenceAPPLE}(GLuint fence); </code> <br>Part of <code>GL_APPLE_fence</code>   */
  public boolean glTestFenceAPPLE(int fence)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTestFenceAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTestFenceAPPLE\" not available");
    }
        return dispatch_glTestFenceAPPLE1(fence, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glTestFenceAPPLE}(GLuint fence); </code> <br>Part of <code>GL_APPLE_fence</code>   */
  public native boolean dispatch_glTestFenceAPPLE1(int fence, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glTestFenceNV}(GLuint fence); </code> <br>Part of <code>GL_NV_fence</code>   */
  public boolean glTestFenceNV(int fence)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTestFenceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTestFenceNV\" not available");
    }
        return dispatch_glTestFenceNV1(fence, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glTestFenceNV}(GLuint fence); </code> <br>Part of <code>GL_NV_fence</code>   */
  public native boolean dispatch_glTestFenceNV1(int fence, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glTestObjectAPPLE}(GLenum object, GLuint name); </code> <br>Part of <code>GL_APPLE_fence</code>   */
  public boolean glTestObjectAPPLE(int object, int name)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTestObjectAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTestObjectAPPLE\" not available");
    }
        return dispatch_glTestObjectAPPLE1(object, name, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glTestObjectAPPLE}(GLenum object, GLuint name); </code> <br>Part of <code>GL_APPLE_fence</code>   */
  public native boolean dispatch_glTestObjectAPPLE1(int object, int name, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexBufferARB}(GLenum target, GLenum internalformat, GLuint buffer); </code> <br>Part of <code>GL_ARB_texture_buffer_object</code>   */
  public void glTexBuffer(int target, int internalformat, int buffer)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexBuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexBuffer\" not available");
    }
        dispatch_glTexBuffer1(target, internalformat, buffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexBufferARB}(GLenum target, GLenum internalformat, GLuint buffer); </code> <br>Part of <code>GL_ARB_texture_buffer_object</code>   */
  public native void dispatch_glTexBuffer1(int target, int internalformat, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord1d}(GLdouble s); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord1d(double s)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord1d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord1d\" not available");
    }
        dispatch_glTexCoord1d1(s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1d}(GLdouble s); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexCoord1d1(double s, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord1dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glTexCoord1dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord1dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord1dv\" not available");
    }
        dispatch_glTexCoord1dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glTexCoord1dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord1dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord1dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord1dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord1dv\" not available");
    }
        dispatch_glTexCoord1dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1f}(GLfloat s); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord1f(float s)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord1f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord1f\" not available");
    }
        dispatch_glTexCoord1f1(s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1f}(GLfloat s); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexCoord1f1(float s, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord1fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTexCoord1fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord1fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord1fv\" not available");
    }
        dispatch_glTexCoord1fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTexCoord1fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord1fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord1fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord1fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord1fv\" not available");
    }
        dispatch_glTexCoord1fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1hNV}(GLhalfNV s); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glTexCoord1h(short s)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord1h;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord1h\" not available");
    }
        dispatch_glTexCoord1h1(s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1hNV}(GLhalfNV s); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public native void dispatch_glTexCoord1h1(short s, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord1hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glTexCoord1hv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord1hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord1hv\" not available");
    }
        dispatch_glTexCoord1hv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glTexCoord1hv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord1hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glTexCoord1hv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord1hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord1hv\" not available");
    }
        dispatch_glTexCoord1hv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1i}(GLint s); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord1i(int s)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord1i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord1i\" not available");
    }
        dispatch_glTexCoord1i1(s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1i}(GLint s); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexCoord1i1(int s, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord1iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexCoord1iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord1iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord1iv\" not available");
    }
        dispatch_glTexCoord1iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexCoord1iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord1iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord1iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord1iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord1iv\" not available");
    }
        dispatch_glTexCoord1iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1s}(GLshort s); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord1s(short s)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord1s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord1s\" not available");
    }
        dispatch_glTexCoord1s1(s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1s}(GLshort s); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexCoord1s1(short s, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord1sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glTexCoord1sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord1sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord1sv\" not available");
    }
        dispatch_glTexCoord1sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glTexCoord1sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord1sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord1sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord1sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord1sv\" not available");
    }
        dispatch_glTexCoord1sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2d}(GLdouble s, GLdouble t); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord2d(double s, double t)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord2d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord2d\" not available");
    }
        dispatch_glTexCoord2d1(s, t, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2d}(GLdouble s, GLdouble t); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexCoord2d1(double s, double t, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord2dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glTexCoord2dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord2dv\" not available");
    }
        dispatch_glTexCoord2dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glTexCoord2dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord2dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord2dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord2dv\" not available");
    }
        dispatch_glTexCoord2dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2f}(GLfloat s, GLfloat t); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord2f(float s, float t)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord2f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord2f\" not available");
    }
        dispatch_glTexCoord2f1(s, t, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2f}(GLfloat s, GLfloat t); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexCoord2f1(float s, float t, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord2fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTexCoord2fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord2fv\" not available");
    }
        dispatch_glTexCoord2fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTexCoord2fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord2fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord2fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord2fv\" not available");
    }
        dispatch_glTexCoord2fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2hNV}(GLhalfNV s, GLhalfNV t); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glTexCoord2h(short s, short t)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord2h;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord2h\" not available");
    }
        dispatch_glTexCoord2h1(s, t, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2hNV}(GLhalfNV s, GLhalfNV t); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public native void dispatch_glTexCoord2h1(short s, short t, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord2hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glTexCoord2hv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord2hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord2hv\" not available");
    }
        dispatch_glTexCoord2hv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glTexCoord2hv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord2hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glTexCoord2hv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord2hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord2hv\" not available");
    }
        dispatch_glTexCoord2hv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2i}(GLint s, GLint t); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord2i(int s, int t)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord2i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord2i\" not available");
    }
        dispatch_glTexCoord2i1(s, t, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2i}(GLint s, GLint t); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexCoord2i1(int s, int t, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord2iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexCoord2iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord2iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord2iv\" not available");
    }
        dispatch_glTexCoord2iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexCoord2iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord2iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord2iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord2iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord2iv\" not available");
    }
        dispatch_glTexCoord2iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2s}(GLshort s, GLshort t); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord2s(short s, short t)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord2s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord2s\" not available");
    }
        dispatch_glTexCoord2s1(s, t, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2s}(GLshort s, GLshort t); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexCoord2s1(short s, short t, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord2sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glTexCoord2sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord2sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord2sv\" not available");
    }
        dispatch_glTexCoord2sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glTexCoord2sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord2sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord2sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord2sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord2sv\" not available");
    }
        dispatch_glTexCoord2sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3d}(GLdouble s, GLdouble t, GLdouble r); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord3d(double s, double t, double r)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord3d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord3d\" not available");
    }
        dispatch_glTexCoord3d1(s, t, r, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3d}(GLdouble s, GLdouble t, GLdouble r); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexCoord3d1(double s, double t, double r, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord3dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glTexCoord3dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord3dv\" not available");
    }
        dispatch_glTexCoord3dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glTexCoord3dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord3dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord3dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord3dv\" not available");
    }
        dispatch_glTexCoord3dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3f}(GLfloat s, GLfloat t, GLfloat r); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord3f(float s, float t, float r)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord3f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord3f\" not available");
    }
        dispatch_glTexCoord3f1(s, t, r, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3f}(GLfloat s, GLfloat t, GLfloat r); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexCoord3f1(float s, float t, float r, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord3fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTexCoord3fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord3fv\" not available");
    }
        dispatch_glTexCoord3fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTexCoord3fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord3fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord3fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord3fv\" not available");
    }
        dispatch_glTexCoord3fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3hNV}(GLhalfNV s, GLhalfNV t, GLhalfNV r); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glTexCoord3h(short s, short t, short r)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord3h;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord3h\" not available");
    }
        dispatch_glTexCoord3h1(s, t, r, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3hNV}(GLhalfNV s, GLhalfNV t, GLhalfNV r); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public native void dispatch_glTexCoord3h1(short s, short t, short r, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord3hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glTexCoord3hv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord3hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord3hv\" not available");
    }
        dispatch_glTexCoord3hv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glTexCoord3hv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord3hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glTexCoord3hv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord3hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord3hv\" not available");
    }
        dispatch_glTexCoord3hv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3i}(GLint s, GLint t, GLint r); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord3i(int s, int t, int r)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord3i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord3i\" not available");
    }
        dispatch_glTexCoord3i1(s, t, r, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3i}(GLint s, GLint t, GLint r); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexCoord3i1(int s, int t, int r, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord3iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexCoord3iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord3iv\" not available");
    }
        dispatch_glTexCoord3iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexCoord3iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord3iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord3iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord3iv\" not available");
    }
        dispatch_glTexCoord3iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3s}(GLshort s, GLshort t, GLshort r); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord3s(short s, short t, short r)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord3s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord3s\" not available");
    }
        dispatch_glTexCoord3s1(s, t, r, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3s}(GLshort s, GLshort t, GLshort r); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexCoord3s1(short s, short t, short r, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord3sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glTexCoord3sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord3sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord3sv\" not available");
    }
        dispatch_glTexCoord3sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glTexCoord3sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord3sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord3sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord3sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord3sv\" not available");
    }
        dispatch_glTexCoord3sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4d}(GLdouble s, GLdouble t, GLdouble r, GLdouble q); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord4d(double s, double t, double r, double q)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord4d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord4d\" not available");
    }
        dispatch_glTexCoord4d1(s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4d}(GLdouble s, GLdouble t, GLdouble r, GLdouble q); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexCoord4d1(double s, double t, double r, double q, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord4dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glTexCoord4dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord4dv\" not available");
    }
        dispatch_glTexCoord4dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glTexCoord4dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord4dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord4dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord4dv\" not available");
    }
        dispatch_glTexCoord4dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4f}(GLfloat s, GLfloat t, GLfloat r, GLfloat q); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord4f(float s, float t, float r, float q)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord4f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord4f\" not available");
    }
        dispatch_glTexCoord4f1(s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4f}(GLfloat s, GLfloat t, GLfloat r, GLfloat q); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexCoord4f1(float s, float t, float r, float q, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord4fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTexCoord4fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord4fv\" not available");
    }
        dispatch_glTexCoord4fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTexCoord4fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord4fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord4fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord4fv\" not available");
    }
        dispatch_glTexCoord4fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4hNV}(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glTexCoord4h(short s, short t, short r, short q)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord4h;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord4h\" not available");
    }
        dispatch_glTexCoord4h1(s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4hNV}(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public native void dispatch_glTexCoord4h1(short s, short t, short r, short q, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord4hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glTexCoord4hv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord4hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord4hv\" not available");
    }
        dispatch_glTexCoord4hv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glTexCoord4hv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord4hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glTexCoord4hv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord4hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord4hv\" not available");
    }
        dispatch_glTexCoord4hv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4i}(GLint s, GLint t, GLint r, GLint q); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord4i(int s, int t, int r, int q)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord4i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord4i\" not available");
    }
        dispatch_glTexCoord4i1(s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4i}(GLint s, GLint t, GLint r, GLint q); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexCoord4i1(int s, int t, int r, int q, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord4iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexCoord4iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord4iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord4iv\" not available");
    }
        dispatch_glTexCoord4iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexCoord4iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord4iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord4iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord4iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord4iv\" not available");
    }
        dispatch_glTexCoord4iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4s}(GLshort s, GLshort t, GLshort r, GLshort q); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord4s(short s, short t, short r, short q)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord4s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord4s\" not available");
    }
        dispatch_glTexCoord4s1(s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4s}(GLshort s, GLshort t, GLshort r, GLshort q); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexCoord4s1(short s, short t, short r, short q, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord4sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glTexCoord4sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord4sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord4sv\" not available");
    }
        dispatch_glTexCoord4sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glTexCoord4sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord4sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexCoord4sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoord4sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoord4sv\" not available");
    }
        dispatch_glTexCoord4sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordFormatNV}(GLint size, GLenum type, GLsizei stride); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public void glTexCoordFormatNV(int size, int type, int stride)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoordFormatNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoordFormatNV\" not available");
    }
        dispatch_glTexCoordFormatNV1(size, type, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordFormatNV}(GLint size, GLenum type, GLsizei stride); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public native void dispatch_glTexCoordFormatNV1(int size, int type, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordP1ui}(GLenum type, GLuint coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glTexCoordP1ui(int type, int coords)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoordP1ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoordP1ui\" not available");
    }
        dispatch_glTexCoordP1ui1(type, coords, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordP1ui}(GLenum type, GLuint coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public native void dispatch_glTexCoordP1ui1(int type, int coords, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordP1uiv}(GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexCoordP1uiv(int type, IntBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoordP1uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoordP1uiv\" not available");
    }
        dispatch_glTexCoordP1uiv1(type, coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordP1uiv}(GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexCoordP1uiv1(int type, Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordP1uiv}(GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glTexCoordP1uiv(int type, int[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoordP1uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoordP1uiv\" not available");
    }
        dispatch_glTexCoordP1uiv1(type, coords, Buffers.SIZEOF_INT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordP2ui}(GLenum type, GLuint coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glTexCoordP2ui(int type, int coords)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoordP2ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoordP2ui\" not available");
    }
        dispatch_glTexCoordP2ui1(type, coords, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordP2ui}(GLenum type, GLuint coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public native void dispatch_glTexCoordP2ui1(int type, int coords, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordP2uiv}(GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexCoordP2uiv(int type, IntBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoordP2uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoordP2uiv\" not available");
    }
        dispatch_glTexCoordP2uiv1(type, coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordP2uiv}(GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexCoordP2uiv1(int type, Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordP2uiv}(GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glTexCoordP2uiv(int type, int[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoordP2uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoordP2uiv\" not available");
    }
        dispatch_glTexCoordP2uiv1(type, coords, Buffers.SIZEOF_INT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordP3ui}(GLenum type, GLuint coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glTexCoordP3ui(int type, int coords)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoordP3ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoordP3ui\" not available");
    }
        dispatch_glTexCoordP3ui1(type, coords, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordP3ui}(GLenum type, GLuint coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public native void dispatch_glTexCoordP3ui1(int type, int coords, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordP3uiv}(GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexCoordP3uiv(int type, IntBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoordP3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoordP3uiv\" not available");
    }
        dispatch_glTexCoordP3uiv1(type, coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordP3uiv}(GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexCoordP3uiv1(int type, Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordP3uiv}(GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glTexCoordP3uiv(int type, int[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoordP3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoordP3uiv\" not available");
    }
        dispatch_glTexCoordP3uiv1(type, coords, Buffers.SIZEOF_INT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordP4ui}(GLenum type, GLuint coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glTexCoordP4ui(int type, int coords)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoordP4ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoordP4ui\" not available");
    }
        dispatch_glTexCoordP4ui1(type, coords, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordP4ui}(GLenum type, GLuint coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public native void dispatch_glTexCoordP4ui1(int type, int coords, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordP4uiv}(GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexCoordP4uiv(int type, IntBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoordP4uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoordP4uiv\" not available");
    }
        dispatch_glTexCoordP4uiv1(type, coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordP4uiv}(GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexCoordP4uiv1(int type, Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordP4uiv}(GLenum type, const GLuint *  coords); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glTexCoordP4uiv(int type, int[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoordP4uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoordP4uiv\" not available");
    }
        dispatch_glTexCoordP4uiv1(type, coords, Buffers.SIZEOF_INT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexCoordPointer(int size, int type, int stride, Buffer ptr)  {

    checkArrayVBODisabled(true);
    Buffers.rangeCheck(ptr, 1);
    final boolean ptr_is_direct = Buffers.isDirect(ptr);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoordPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoordPointer\" not available");
    }
        dispatch_glTexCoordPointer1(size, type, stride, ptr_is_direct ? ptr : Buffers.getArray(ptr), ptr_is_direct ? Buffers.getDirectBufferByteOffset(ptr) : Buffers.getIndirectBufferByteOffset(ptr), ptr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexCoordPointer1(int size, int type, int stride, Object ptr, int ptr_byte_offset, boolean ptr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public void glTexCoordPointer(int size, int type, int stride, long ptr_buffer_offset)  {

    checkArrayVBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoordPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoordPointer\" not available");
    }
        dispatch_glTexCoordPointer1(size, type, stride, ptr_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  private native void dispatch_glTexCoordPointer1(int size, int type, int stride, long ptr_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnvf}(GLenum target, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexEnvf(int target, int pname, float param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexEnvf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexEnvf\" not available");
    }
        dispatch_glTexEnvf1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnvf}(GLenum target, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexEnvf1(int target, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnvfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTexEnvfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexEnvfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexEnvfv\" not available");
    }
        dispatch_glTexEnvfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnvfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTexEnvfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnvfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexEnvfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexEnvfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexEnvfv\" not available");
    }
        dispatch_glTexEnvfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnvi}(GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexEnvi(int target, int pname, int param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexEnvi;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexEnvi\" not available");
    }
        dispatch_glTexEnvi1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnvi}(GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexEnvi1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnviv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexEnviv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexEnviv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexEnviv\" not available");
    }
        dispatch_glTexEnviv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnviv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexEnviv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnviv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexEnviv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexEnviv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexEnviv\" not available");
    }
        dispatch_glTexEnviv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGend}(GLenum coord, GLenum pname, GLdouble param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexGend(int coord, int pname, double param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexGend;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexGend\" not available");
    }
        dispatch_glTexGend1(coord, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGend}(GLenum coord, GLenum pname, GLdouble param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexGend1(int coord, int pname, double param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGendv}(GLenum coord, GLenum pname, const GLdouble *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glTexGendv(int coord, int pname, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexGendv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexGendv\" not available");
    }
        dispatch_glTexGendv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGendv}(GLenum coord, GLenum pname, const GLdouble *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glTexGendv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGendv}(GLenum coord, GLenum pname, const GLdouble *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexGendv(int coord, int pname, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexGendv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexGendv\" not available");
    }
        dispatch_glTexGendv1(coord, pname, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGenf}(GLenum coord, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexGenf(int coord, int pname, float param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexGenf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexGenf\" not available");
    }
        dispatch_glTexGenf1(coord, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGenf}(GLenum coord, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexGenf1(int coord, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGenfv}(GLenum coord, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTexGenfv(int coord, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexGenfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexGenfv\" not available");
    }
        dispatch_glTexGenfv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGenfv}(GLenum coord, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTexGenfv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGenfv}(GLenum coord, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexGenfv(int coord, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexGenfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexGenfv\" not available");
    }
        dispatch_glTexGenfv1(coord, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGeni}(GLenum coord, GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexGeni(int coord, int pname, int param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexGeni;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexGeni\" not available");
    }
        dispatch_glTexGeni1(coord, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGeni}(GLenum coord, GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexGeni1(int coord, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGeniv}(GLenum coord, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexGeniv(int coord, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexGeniv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexGeniv\" not available");
    }
        dispatch_glTexGeniv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGeniv}(GLenum coord, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexGeniv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGeniv}(GLenum coord, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexGeniv(int coord, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexGeniv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexGeniv\" not available");
    }
        dispatch_glTexGeniv1(coord, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage1D}(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexImage1D(int target, int level, int internalFormat, int width, int border, int format, int type, Buffer pixels)  {

    checkUnpackPBODisabled(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width            , 1              , 1    , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexImage1D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexImage1D\" not available");
    }
        dispatch_glTexImage1D1(target, level, internalFormat, width, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage1D}(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexImage1D1(int target, int level, int internalFormat, int width, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage1D}(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexImage1D(int target, int level, int internalFormat, int width, int border, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexImage1D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexImage1D\" not available");
    }
        dispatch_glTexImage1D1(target, level, internalFormat, width, border, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage1D}(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  private native void dispatch_glTexImage1D1(int target, int level, int internalFormat, int width, int border, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexImage2D(int target, int level, int internalFormat, int width, int height, int border, int format, int type, Buffer pixels)  {

    checkUnpackPBODisabled(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width            , height            , 1    , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexImage2D\" not available");
    }
        dispatch_glTexImage2D1(target, level, internalFormat, width, height, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexImage2D1(int target, int level, int internalFormat, int width, int height, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexImage2D(int target, int level, int internalFormat, int width, int height, int border, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexImage2D\" not available");
    }
        dispatch_glTexImage2D1(target, level, internalFormat, width, height, border, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  private native void dispatch_glTexImage2D1(int target, int level, int internalFormat, int width, int height, int border, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage2DMultisample}(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations); </code> <br>Part of <code>GL_ARB_texture_multisample</code>   */
  public void glTexImage2DMultisample(int target, int samples, int internalformat, int width, int height, boolean fixedsamplelocations)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexImage2DMultisample;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexImage2DMultisample\" not available");
    }
        dispatch_glTexImage2DMultisample1(target, samples, internalformat, width, height, fixedsamplelocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage2DMultisample}(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations); </code> <br>Part of <code>GL_ARB_texture_multisample</code>   */
  public native void dispatch_glTexImage2DMultisample1(int target, int samples, int internalformat, int width, int height, boolean fixedsamplelocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage2DMultisampleCoverageNV}(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations); </code> <br>Part of <code>GL_NV_texture_multisample</code>   */
  public void glTexImage2DMultisampleCoverageNV(int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, boolean fixedSampleLocations)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexImage2DMultisampleCoverageNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexImage2DMultisampleCoverageNV\" not available");
    }
        dispatch_glTexImage2DMultisampleCoverageNV1(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage2DMultisampleCoverageNV}(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations); </code> <br>Part of <code>GL_NV_texture_multisample</code>   */
  public native void dispatch_glTexImage2DMultisampleCoverageNV1(int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, boolean fixedSampleLocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage3D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, Buffer pixels)  {

    checkUnpackPBODisabled(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width            , height            , depth  , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexImage3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexImage3D\" not available");
    }
        dispatch_glTexImage3D1(target, level, internalformat, width, height, depth, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage3D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexImage3D1(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage3D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>   */
  public void glTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexImage3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexImage3D\" not available");
    }
        dispatch_glTexImage3D1(target, level, internalformat, width, height, depth, border, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage3D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>   */
  private native void dispatch_glTexImage3D1(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage3DMultisample}(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations); </code> <br>Part of <code>GL_ARB_texture_multisample</code>   */
  public void glTexImage3DMultisample(int target, int samples, int internalformat, int width, int height, int depth, boolean fixedsamplelocations)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexImage3DMultisample;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexImage3DMultisample\" not available");
    }
        dispatch_glTexImage3DMultisample1(target, samples, internalformat, width, height, depth, fixedsamplelocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage3DMultisample}(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations); </code> <br>Part of <code>GL_ARB_texture_multisample</code>   */
  public native void dispatch_glTexImage3DMultisample1(int target, int samples, int internalformat, int width, int height, int depth, boolean fixedsamplelocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage3DMultisampleCoverageNV}(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations); </code> <br>Part of <code>GL_NV_texture_multisample</code>   */
  public void glTexImage3DMultisampleCoverageNV(int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, boolean fixedSampleLocations)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexImage3DMultisampleCoverageNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexImage3DMultisampleCoverageNV\" not available");
    }
        dispatch_glTexImage3DMultisampleCoverageNV1(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage3DMultisampleCoverageNV}(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations); </code> <br>Part of <code>GL_NV_texture_multisample</code>   */
  public native void dispatch_glTexImage3DMultisampleCoverageNV1(int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, boolean fixedSampleLocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterIiv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_texture_integer</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexParameterIiv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameterIiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameterIiv\" not available");
    }
        dispatch_glTexParameterIiv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterIiv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_texture_integer</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexParameterIiv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterIiv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_texture_integer</code>   */
  public void glTexParameterIiv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameterIiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameterIiv\" not available");
    }
        dispatch_glTexParameterIiv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterIuiv}(GLenum target, GLenum pname, const GLuint *  params); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_texture_integer</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexParameterIuiv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameterIuiv\" not available");
    }
        dispatch_glTexParameterIuiv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterIuiv}(GLenum target, GLenum pname, const GLuint *  params); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_texture_integer</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexParameterIuiv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterIuiv}(GLenum target, GLenum pname, const GLuint *  params); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_texture_integer</code>   */
  public void glTexParameterIuiv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameterIuiv\" not available");
    }
        dispatch_glTexParameterIuiv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterf}(GLenum target, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexParameterf(int target, int pname, float param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameterf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameterf\" not available");
    }
        dispatch_glTexParameterf1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterf}(GLenum target, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexParameterf1(int target, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTexParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameterfv\" not available");
    }
        dispatch_glTexParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTexParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameterfv\" not available");
    }
        dispatch_glTexParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameteri}(GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexParameteri(int target, int pname, int param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameteri;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameteri\" not available");
    }
        dispatch_glTexParameteri1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameteri}(GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexParameteri1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameteriv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameteriv\" not available");
    }
        dispatch_glTexParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameteriv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameteriv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTexParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameteriv\" not available");
    }
        dispatch_glTexParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexRenderbufferNV}(GLenum target, GLuint renderbuffer); </code> <br>Part of <code>GL_NV_explicit_multisample</code>   */
  public void glTexRenderbufferNV(int target, int renderbuffer)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexRenderbufferNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexRenderbufferNV\" not available");
    }
        dispatch_glTexRenderbufferNV1(target, renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexRenderbufferNV}(GLenum target, GLuint renderbuffer); </code> <br>Part of <code>GL_NV_explicit_multisample</code>   */
  public native void dispatch_glTexRenderbufferNV1(int target, int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexStorage1D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width); </code> <br>Part of <code>GL_ARB_texture_storage</code>;    */
  public void glTexStorage1D(int target, int levels, int internalformat, int width)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexStorage1D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexStorage1D\" not available");
    }
        dispatch_glTexStorage1D1(target, levels, internalformat, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage1D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width); </code> <br>Part of <code>GL_ARB_texture_storage</code>;    */
  public native void dispatch_glTexStorage1D1(int target, int levels, int internalformat, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexStorage2D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ARB_texture_storage</code>;    */
  public void glTexStorage2D(int target, int levels, int internalformat, int width, int height)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexStorage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexStorage2D\" not available");
    }
        dispatch_glTexStorage2D1(target, levels, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage2D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ARB_texture_storage</code>;    */
  public native void dispatch_glTexStorage2D1(int target, int levels, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexStorage3D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); </code> <br>Part of <code>GL_ARB_texture_storage</code>;    */
  public void glTexStorage3D(int target, int levels, int internalformat, int width, int height, int depth)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexStorage3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexStorage3D\" not available");
    }
        dispatch_glTexStorage3D1(target, levels, internalformat, width, height, depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage3D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); </code> <br>Part of <code>GL_ARB_texture_storage</code>;    */
  public native void dispatch_glTexStorage3D1(int target, int levels, int internalformat, int width, int height, int depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage1D}(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexSubImage1D(int target, int level, int xoffset, int width, int format, int type, Buffer pixels)  {

    checkUnpackPBODisabled(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width            , 1              , 1    , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexSubImage1D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexSubImage1D\" not available");
    }
        dispatch_glTexSubImage1D1(target, level, xoffset, width, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage1D}(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexSubImage1D1(int target, int level, int xoffset, int width, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage1D}(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public void glTexSubImage1D(int target, int level, int xoffset, int width, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexSubImage1D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexSubImage1D\" not available");
    }
        dispatch_glTexSubImage1D1(target, level, xoffset, width, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage1D}(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  private native void dispatch_glTexSubImage1D1(int target, int level, int xoffset, int width, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Buffer pixels)  {

    checkUnpackPBODisabled(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width            , height            , 1    , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexSubImage2D\" not available");
    }
        dispatch_glTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public void glTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexSubImage2D\" not available");
    }
        dispatch_glTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  private native void dispatch_glTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Buffer pixels)  {

    checkUnpackPBODisabled(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width            , height            , depth  , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexSubImage3D\" not available");
    }
        dispatch_glTexSubImage3D1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>   */
  public void glTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexSubImage3D\" not available");
    }
        dispatch_glTexSubImage3D1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>   */
  private native void dispatch_glTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureBarrierNV}(void); </code> <br>Part of <code>GL_NV_texture_barrier</code>   */
  public void glTextureBarrierNV()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureBarrierNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureBarrierNV\" not available");
    }
        dispatch_glTextureBarrierNV1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureBarrierNV}(void); </code> <br>Part of <code>GL_NV_texture_barrier</code>   */
  public native void dispatch_glTextureBarrierNV1(long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureBufferEXT}(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glTextureBufferEXT(int texture, int target, int internalformat, int buffer)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureBufferEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureBufferEXT\" not available");
    }
        dispatch_glTextureBufferEXT1(texture, target, internalformat, buffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureBufferEXT}(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glTextureBufferEXT1(int texture, int target, int internalformat, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureImage1DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTextureImage1DEXT(int texture, int target, int level, int internalformat, int width, int border, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureImage1DEXT\" not available");
    }
        dispatch_glTextureImage1DEXT1(texture, target, level, internalformat, width, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureImage1DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTextureImage1DEXT1(int texture, int target, int level, int internalformat, int width, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureImage2DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTextureImage2DEXT(int texture, int target, int level, int internalformat, int width, int height, int border, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureImage2DEXT\" not available");
    }
        dispatch_glTextureImage2DEXT1(texture, target, level, internalformat, width, height, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureImage2DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTextureImage2DEXT1(int texture, int target, int level, int internalformat, int width, int height, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureImage2DMultisampleCoverageNV}(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations); </code> <br>Part of <code>GL_NV_texture_multisample</code>   */
  public void glTextureImage2DMultisampleCoverageNV(int texture, int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, boolean fixedSampleLocations)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureImage2DMultisampleCoverageNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureImage2DMultisampleCoverageNV\" not available");
    }
        dispatch_glTextureImage2DMultisampleCoverageNV1(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureImage2DMultisampleCoverageNV}(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations); </code> <br>Part of <code>GL_NV_texture_multisample</code>   */
  public native void dispatch_glTextureImage2DMultisampleCoverageNV1(int texture, int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, boolean fixedSampleLocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureImage2DMultisampleNV}(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations); </code> <br>Part of <code>GL_NV_texture_multisample</code>   */
  public void glTextureImage2DMultisampleNV(int texture, int target, int samples, int internalFormat, int width, int height, boolean fixedSampleLocations)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureImage2DMultisampleNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureImage2DMultisampleNV\" not available");
    }
        dispatch_glTextureImage2DMultisampleNV1(texture, target, samples, internalFormat, width, height, fixedSampleLocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureImage2DMultisampleNV}(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations); </code> <br>Part of <code>GL_NV_texture_multisample</code>   */
  public native void dispatch_glTextureImage2DMultisampleNV1(int texture, int target, int samples, int internalFormat, int width, int height, boolean fixedSampleLocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureImage3DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTextureImage3DEXT(int texture, int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureImage3DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureImage3DEXT\" not available");
    }
        dispatch_glTextureImage3DEXT1(texture, target, level, internalformat, width, height, depth, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureImage3DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTextureImage3DEXT1(int texture, int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureImage3DMultisampleCoverageNV}(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations); </code> <br>Part of <code>GL_NV_texture_multisample</code>   */
  public void glTextureImage3DMultisampleCoverageNV(int texture, int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, boolean fixedSampleLocations)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureImage3DMultisampleCoverageNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureImage3DMultisampleCoverageNV\" not available");
    }
        dispatch_glTextureImage3DMultisampleCoverageNV1(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureImage3DMultisampleCoverageNV}(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations); </code> <br>Part of <code>GL_NV_texture_multisample</code>   */
  public native void dispatch_glTextureImage3DMultisampleCoverageNV1(int texture, int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, boolean fixedSampleLocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureImage3DMultisampleNV}(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations); </code> <br>Part of <code>GL_NV_texture_multisample</code>   */
  public void glTextureImage3DMultisampleNV(int texture, int target, int samples, int internalFormat, int width, int height, int depth, boolean fixedSampleLocations)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureImage3DMultisampleNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureImage3DMultisampleNV\" not available");
    }
        dispatch_glTextureImage3DMultisampleNV1(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureImage3DMultisampleNV}(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations); </code> <br>Part of <code>GL_NV_texture_multisample</code>   */
  public native void dispatch_glTextureImage3DMultisampleNV1(int texture, int target, int samples, int internalFormat, int width, int height, int depth, boolean fixedSampleLocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureLightEXT}(GLenum pname); </code> <br>Part of <code>GL_EXT_light_texture</code>   */
  public void glTextureLightEXT(int pname)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureLightEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureLightEXT\" not available");
    }
        dispatch_glTextureLightEXT1(pname, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureLightEXT}(GLenum pname); </code> <br>Part of <code>GL_EXT_light_texture</code>   */
  public native void dispatch_glTextureLightEXT1(int pname, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureMaterialEXT}(GLenum face, GLenum mode); </code> <br>Part of <code>GL_EXT_light_texture</code>   */
  public void glTextureMaterialEXT(int face, int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureMaterialEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureMaterialEXT\" not available");
    }
        dispatch_glTextureMaterialEXT1(face, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureMaterialEXT}(GLenum face, GLenum mode); </code> <br>Part of <code>GL_EXT_light_texture</code>   */
  public native void dispatch_glTextureMaterialEXT1(int face, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureNormalEXT}(GLenum mode); </code> <br>Part of <code>GL_EXT_texture_perturb_normal</code>   */
  public void glTextureNormalEXT(int mode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureNormalEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureNormalEXT\" not available");
    }
        dispatch_glTextureNormalEXT1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureNormalEXT}(GLenum mode); </code> <br>Part of <code>GL_EXT_texture_perturb_normal</code>   */
  public native void dispatch_glTextureNormalEXT1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureParameterIivEXT}(GLuint texture, GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTextureParameterIivEXT(int texture, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureParameterIivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureParameterIivEXT\" not available");
    }
        dispatch_glTextureParameterIivEXT1(texture, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameterIivEXT}(GLuint texture, GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTextureParameterIivEXT1(int texture, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureParameterIivEXT}(GLuint texture, GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glTextureParameterIivEXT(int texture, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureParameterIivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureParameterIivEXT\" not available");
    }
        dispatch_glTextureParameterIivEXT1(texture, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameterIuivEXT}(GLuint texture, GLenum target, GLenum pname, const GLuint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTextureParameterIuivEXT(int texture, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureParameterIuivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureParameterIuivEXT\" not available");
    }
        dispatch_glTextureParameterIuivEXT1(texture, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameterIuivEXT}(GLuint texture, GLenum target, GLenum pname, const GLuint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTextureParameterIuivEXT1(int texture, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureParameterIuivEXT}(GLuint texture, GLenum target, GLenum pname, const GLuint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glTextureParameterIuivEXT(int texture, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureParameterIuivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureParameterIuivEXT\" not available");
    }
        dispatch_glTextureParameterIuivEXT1(texture, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameterfEXT}(GLuint texture, GLenum target, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glTextureParameterfEXT(int texture, int target, int pname, float param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureParameterfEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureParameterfEXT\" not available");
    }
        dispatch_glTextureParameterfEXT1(texture, target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameterfEXT}(GLuint texture, GLenum target, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glTextureParameterfEXT1(int texture, int target, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureParameterfvEXT}(GLuint texture, GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTextureParameterfvEXT(int texture, int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureParameterfvEXT\" not available");
    }
        dispatch_glTextureParameterfvEXT1(texture, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameterfvEXT}(GLuint texture, GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTextureParameterfvEXT1(int texture, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureParameterfvEXT}(GLuint texture, GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glTextureParameterfvEXT(int texture, int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureParameterfvEXT\" not available");
    }
        dispatch_glTextureParameterfvEXT1(texture, target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameteriEXT}(GLuint texture, GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glTextureParameteriEXT(int texture, int target, int pname, int param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureParameteriEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureParameteriEXT\" not available");
    }
        dispatch_glTextureParameteriEXT1(texture, target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameteriEXT}(GLuint texture, GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glTextureParameteriEXT1(int texture, int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureParameterivEXT}(GLuint texture, GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTextureParameterivEXT(int texture, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureParameterivEXT\" not available");
    }
        dispatch_glTextureParameterivEXT1(texture, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameterivEXT}(GLuint texture, GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTextureParameterivEXT1(int texture, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureParameterivEXT}(GLuint texture, GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glTextureParameterivEXT(int texture, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureParameterivEXT\" not available");
    }
        dispatch_glTextureParameterivEXT1(texture, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureRangeAPPLE}(GLenum target, GLsizei length, const GLvoid *  pointer); </code> <br>Part of <code>GL_APPLE_texture_range</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glTextureRangeAPPLE(int target, int length, Buffer pointer)  {

    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureRangeAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureRangeAPPLE\" not available");
    }
        dispatch_glTextureRangeAPPLE1(target, length, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureRangeAPPLE}(GLenum target, GLsizei length, const GLvoid *  pointer); </code> <br>Part of <code>GL_APPLE_texture_range</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTextureRangeAPPLE1(int target, int length, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureRenderbufferEXT}(GLuint texture, GLenum target, GLuint renderbuffer); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public void glTextureRenderbufferEXT(int texture, int target, int renderbuffer)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureRenderbufferEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureRenderbufferEXT\" not available");
    }
        dispatch_glTextureRenderbufferEXT1(texture, target, renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureRenderbufferEXT}(GLuint texture, GLenum target, GLuint renderbuffer); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native void dispatch_glTextureRenderbufferEXT1(int texture, int target, int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage1DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width); </code> <br>Part of <code>GL_ARB_texture_storage</code>   */
  public void glTextureStorage1DEXT(int texture, int target, int levels, int internalformat, int width)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureStorage1DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureStorage1DEXT\" not available");
    }
        dispatch_glTextureStorage1DEXT1(texture, target, levels, internalformat, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage1DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width); </code> <br>Part of <code>GL_ARB_texture_storage</code>   */
  public native void dispatch_glTextureStorage1DEXT1(int texture, int target, int levels, int internalformat, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage2DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ARB_texture_storage</code>   */
  public void glTextureStorage2DEXT(int texture, int target, int levels, int internalformat, int width, int height)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureStorage2DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureStorage2DEXT\" not available");
    }
        dispatch_glTextureStorage2DEXT1(texture, target, levels, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage2DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ARB_texture_storage</code>   */
  public native void dispatch_glTextureStorage2DEXT1(int texture, int target, int levels, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage3DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); </code> <br>Part of <code>GL_ARB_texture_storage</code>   */
  public void glTextureStorage3DEXT(int texture, int target, int levels, int internalformat, int width, int height, int depth)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureStorage3DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureStorage3DEXT\" not available");
    }
        dispatch_glTextureStorage3DEXT1(texture, target, levels, internalformat, width, height, depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage3DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); </code> <br>Part of <code>GL_ARB_texture_storage</code>   */
  public native void dispatch_glTextureStorage3DEXT1(int texture, int target, int levels, int internalformat, int width, int height, int depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureSubImage1DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTextureSubImage1DEXT(int texture, int target, int level, int xoffset, int width, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureSubImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureSubImage1DEXT\" not available");
    }
        dispatch_glTextureSubImage1DEXT1(texture, target, level, xoffset, width, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureSubImage1DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTextureSubImage1DEXT1(int texture, int target, int level, int xoffset, int width, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureSubImage2DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTextureSubImage2DEXT(int texture, int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureSubImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureSubImage2DEXT\" not available");
    }
        dispatch_glTextureSubImage2DEXT1(texture, target, level, xoffset, yoffset, width, height, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureSubImage2DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTextureSubImage2DEXT1(int texture, int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureSubImage3DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTextureSubImage3DEXT(int texture, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureSubImage3DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureSubImage3DEXT\" not available");
    }
        dispatch_glTextureSubImage3DEXT1(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureSubImage3DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_EXT_direct_state_access</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTextureSubImage3DEXT1(int texture, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTransformFeedbackVaryings}(GLuint program, GLsizei count, const GLchar *  *  varyings, GLenum bufferMode); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_transform_feedback</code>   */
  public void glTransformFeedbackVaryings(int program, int count, String[] varyings, int bufferMode)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTransformFeedbackVaryings;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTransformFeedbackVaryings\" not available");
    }
        dispatch_glTransformFeedbackVaryings1(program, count, varyings, bufferMode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTransformFeedbackVaryings}(GLuint program, GLsizei count, const GLchar *  *  varyings, GLenum bufferMode); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_transform_feedback</code>   */
  public native void dispatch_glTransformFeedbackVaryings1(int program, int count, String[] varyings, int bufferMode, long procAddress);

  /** Entry point to C language function: <code> void {@native glTranslated}(GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTranslated(double x, double y, double z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTranslated;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTranslated\" not available");
    }
        dispatch_glTranslated1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTranslated}(GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTranslated1(double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glTranslatef}(GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glTranslatef(float x, float y, float z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glTranslatef;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTranslatef\" not available");
    }
        dispatch_glTranslatef1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTranslatef}(GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTranslatef1(float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1d}(GLint location, GLdouble x); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>   */
  public void glUniform1d(int location, double x)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1d\" not available");
    }
        dispatch_glUniform1d1(location, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1d}(GLint location, GLdouble x); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>   */
  public native void dispatch_glUniform1d1(int location, double x, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1dv}(GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniform1dv(int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1dv\" not available");
    }
        dispatch_glUniform1dv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1dv}(GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniform1dv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1dv}(GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>   */
  public void glUniform1dv(int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1dv\" not available");
    }
        dispatch_glUniform1dv1(location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1f}(GLint location, GLfloat v0); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glUniform1f(int location, float v0)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1f\" not available");
    }
        dispatch_glUniform1f1(location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1f}(GLint location, GLfloat v0); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glUniform1f1(int location, float v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1fARB}(GLint location, GLfloat v0); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glUniform1fARB(int location, float v0)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1fARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1fARB\" not available");
    }
        dispatch_glUniform1fARB1(location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1fARB}(GLint location, GLfloat v0); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public native void dispatch_glUniform1fARB1(int location, float v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1fv}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform1fv(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1fv\" not available");
    }
        dispatch_glUniform1fv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1fv}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform1fv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1fv}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glUniform1fv(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1fv\" not available");
    }
        dispatch_glUniform1fv1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1fvARB}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform1fvARB(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1fvARB\" not available");
    }
        dispatch_glUniform1fvARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1fvARB}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform1fvARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1fvARB}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glUniform1fvARB(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1fvARB\" not available");
    }
        dispatch_glUniform1fvARB1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1i}(GLint location, GLint v0); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glUniform1i(int location, int v0)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1i\" not available");
    }
        dispatch_glUniform1i1(location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1i}(GLint location, GLint v0); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glUniform1i1(int location, int v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1i64NV}(GLint location, GLint64EXT x); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glUniform1i64NV(int location, long x)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1i64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1i64NV\" not available");
    }
        dispatch_glUniform1i64NV1(location, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1i64NV}(GLint location, GLint64EXT x); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public native void dispatch_glUniform1i64NV1(int location, long x, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform1i64vNV(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1i64vNV\" not available");
    }
        dispatch_glUniform1i64vNV1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform1i64vNV1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glUniform1i64vNV(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1i64vNV\" not available");
    }
        dispatch_glUniform1i64vNV1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1iARB}(GLint location, GLint v0); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glUniform1iARB(int location, int v0)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1iARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1iARB\" not available");
    }
        dispatch_glUniform1iARB1(location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1iARB}(GLint location, GLint v0); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public native void dispatch_glUniform1iARB1(int location, int v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1iv}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform1iv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1iv\" not available");
    }
        dispatch_glUniform1iv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1iv}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform1iv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1iv}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glUniform1iv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1iv\" not available");
    }
        dispatch_glUniform1iv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1ivARB}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform1ivARB(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1ivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1ivARB\" not available");
    }
        dispatch_glUniform1ivARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1ivARB}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform1ivARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1ivARB}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glUniform1ivARB(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1ivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1ivARB\" not available");
    }
        dispatch_glUniform1ivARB1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1ui}(GLint location, GLuint v0); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public void glUniform1ui(int location, int v0)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1ui\" not available");
    }
        dispatch_glUniform1ui1(location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1ui}(GLint location, GLuint v0); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public native void dispatch_glUniform1ui1(int location, int v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1ui64NV}(GLint location, GLuint64EXT x); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glUniform1ui64NV(int location, long x)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1ui64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1ui64NV\" not available");
    }
        dispatch_glUniform1ui64NV1(location, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1ui64NV}(GLint location, GLuint64EXT x); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public native void dispatch_glUniform1ui64NV1(int location, long x, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform1ui64vNV(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1ui64vNV\" not available");
    }
        dispatch_glUniform1ui64vNV1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform1ui64vNV1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glUniform1ui64vNV(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1ui64vNV\" not available");
    }
        dispatch_glUniform1ui64vNV1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform1uiv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1uiv\" not available");
    }
        dispatch_glUniform1uiv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform1uiv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public void glUniform1uiv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1uiv\" not available");
    }
        dispatch_glUniform1uiv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2d}(GLint location, GLdouble x, GLdouble y); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>   */
  public void glUniform2d(int location, double x, double y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2d\" not available");
    }
        dispatch_glUniform2d1(location, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2d}(GLint location, GLdouble x, GLdouble y); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>   */
  public native void dispatch_glUniform2d1(int location, double x, double y, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2dv}(GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniform2dv(int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2dv\" not available");
    }
        dispatch_glUniform2dv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2dv}(GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniform2dv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2dv}(GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>   */
  public void glUniform2dv(int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2dv\" not available");
    }
        dispatch_glUniform2dv1(location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2f}(GLint location, GLfloat v0, GLfloat v1); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glUniform2f(int location, float v0, float v1)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2f\" not available");
    }
        dispatch_glUniform2f1(location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2f}(GLint location, GLfloat v0, GLfloat v1); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glUniform2f1(int location, float v0, float v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2fARB}(GLint location, GLfloat v0, GLfloat v1); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glUniform2fARB(int location, float v0, float v1)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2fARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2fARB\" not available");
    }
        dispatch_glUniform2fARB1(location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2fARB}(GLint location, GLfloat v0, GLfloat v1); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public native void dispatch_glUniform2fARB1(int location, float v0, float v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2fv}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform2fv(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2fv\" not available");
    }
        dispatch_glUniform2fv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2fv}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform2fv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2fv}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glUniform2fv(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2fv\" not available");
    }
        dispatch_glUniform2fv1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2fvARB}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform2fvARB(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2fvARB\" not available");
    }
        dispatch_glUniform2fvARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2fvARB}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform2fvARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2fvARB}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glUniform2fvARB(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2fvARB\" not available");
    }
        dispatch_glUniform2fvARB1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2i}(GLint location, GLint v0, GLint v1); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glUniform2i(int location, int v0, int v1)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2i\" not available");
    }
        dispatch_glUniform2i1(location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2i}(GLint location, GLint v0, GLint v1); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glUniform2i1(int location, int v0, int v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2i64NV}(GLint location, GLint64EXT x, GLint64EXT y); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glUniform2i64NV(int location, long x, long y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2i64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2i64NV\" not available");
    }
        dispatch_glUniform2i64NV1(location, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2i64NV}(GLint location, GLint64EXT x, GLint64EXT y); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public native void dispatch_glUniform2i64NV1(int location, long x, long y, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform2i64vNV(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2i64vNV\" not available");
    }
        dispatch_glUniform2i64vNV1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform2i64vNV1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glUniform2i64vNV(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2i64vNV\" not available");
    }
        dispatch_glUniform2i64vNV1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2iARB}(GLint location, GLint v0, GLint v1); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glUniform2iARB(int location, int v0, int v1)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2iARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2iARB\" not available");
    }
        dispatch_glUniform2iARB1(location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2iARB}(GLint location, GLint v0, GLint v1); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public native void dispatch_glUniform2iARB1(int location, int v0, int v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2iv}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform2iv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2iv\" not available");
    }
        dispatch_glUniform2iv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2iv}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform2iv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2iv}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glUniform2iv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2iv\" not available");
    }
        dispatch_glUniform2iv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2ivARB}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform2ivARB(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2ivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2ivARB\" not available");
    }
        dispatch_glUniform2ivARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2ivARB}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform2ivARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2ivARB}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glUniform2ivARB(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2ivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2ivARB\" not available");
    }
        dispatch_glUniform2ivARB1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2ui}(GLint location, GLuint v0, GLuint v1); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public void glUniform2ui(int location, int v0, int v1)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2ui\" not available");
    }
        dispatch_glUniform2ui1(location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2ui}(GLint location, GLuint v0, GLuint v1); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public native void dispatch_glUniform2ui1(int location, int v0, int v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2ui64NV}(GLint location, GLuint64EXT x, GLuint64EXT y); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glUniform2ui64NV(int location, long x, long y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2ui64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2ui64NV\" not available");
    }
        dispatch_glUniform2ui64NV1(location, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2ui64NV}(GLint location, GLuint64EXT x, GLuint64EXT y); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public native void dispatch_glUniform2ui64NV1(int location, long x, long y, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform2ui64vNV(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2ui64vNV\" not available");
    }
        dispatch_glUniform2ui64vNV1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform2ui64vNV1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glUniform2ui64vNV(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2ui64vNV\" not available");
    }
        dispatch_glUniform2ui64vNV1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform2uiv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2uiv\" not available");
    }
        dispatch_glUniform2uiv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform2uiv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public void glUniform2uiv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2uiv\" not available");
    }
        dispatch_glUniform2uiv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3d}(GLint location, GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>   */
  public void glUniform3d(int location, double x, double y, double z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3d\" not available");
    }
        dispatch_glUniform3d1(location, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3d}(GLint location, GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>   */
  public native void dispatch_glUniform3d1(int location, double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3dv}(GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniform3dv(int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3dv\" not available");
    }
        dispatch_glUniform3dv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3dv}(GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniform3dv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3dv}(GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>   */
  public void glUniform3dv(int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3dv\" not available");
    }
        dispatch_glUniform3dv1(location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3f}(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glUniform3f(int location, float v0, float v1, float v2)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3f\" not available");
    }
        dispatch_glUniform3f1(location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3f}(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glUniform3f1(int location, float v0, float v1, float v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3fARB}(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glUniform3fARB(int location, float v0, float v1, float v2)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3fARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3fARB\" not available");
    }
        dispatch_glUniform3fARB1(location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3fARB}(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public native void dispatch_glUniform3fARB1(int location, float v0, float v1, float v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3fv}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform3fv(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3fv\" not available");
    }
        dispatch_glUniform3fv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3fv}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform3fv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3fv}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glUniform3fv(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3fv\" not available");
    }
        dispatch_glUniform3fv1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3fvARB}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform3fvARB(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3fvARB\" not available");
    }
        dispatch_glUniform3fvARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3fvARB}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform3fvARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3fvARB}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glUniform3fvARB(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3fvARB\" not available");
    }
        dispatch_glUniform3fvARB1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3i}(GLint location, GLint v0, GLint v1, GLint v2); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glUniform3i(int location, int v0, int v1, int v2)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3i\" not available");
    }
        dispatch_glUniform3i1(location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3i}(GLint location, GLint v0, GLint v1, GLint v2); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glUniform3i1(int location, int v0, int v1, int v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3i64NV}(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glUniform3i64NV(int location, long x, long y, long z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3i64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3i64NV\" not available");
    }
        dispatch_glUniform3i64NV1(location, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3i64NV}(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public native void dispatch_glUniform3i64NV1(int location, long x, long y, long z, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform3i64vNV(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3i64vNV\" not available");
    }
        dispatch_glUniform3i64vNV1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform3i64vNV1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glUniform3i64vNV(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3i64vNV\" not available");
    }
        dispatch_glUniform3i64vNV1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3iARB}(GLint location, GLint v0, GLint v1, GLint v2); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glUniform3iARB(int location, int v0, int v1, int v2)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3iARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3iARB\" not available");
    }
        dispatch_glUniform3iARB1(location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3iARB}(GLint location, GLint v0, GLint v1, GLint v2); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public native void dispatch_glUniform3iARB1(int location, int v0, int v1, int v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3iv}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform3iv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3iv\" not available");
    }
        dispatch_glUniform3iv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3iv}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform3iv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3iv}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glUniform3iv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3iv\" not available");
    }
        dispatch_glUniform3iv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3ivARB}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform3ivARB(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3ivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3ivARB\" not available");
    }
        dispatch_glUniform3ivARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3ivARB}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform3ivARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3ivARB}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glUniform3ivARB(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3ivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3ivARB\" not available");
    }
        dispatch_glUniform3ivARB1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3ui}(GLint location, GLuint v0, GLuint v1, GLuint v2); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public void glUniform3ui(int location, int v0, int v1, int v2)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3ui\" not available");
    }
        dispatch_glUniform3ui1(location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3ui}(GLint location, GLuint v0, GLuint v1, GLuint v2); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public native void dispatch_glUniform3ui1(int location, int v0, int v1, int v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3ui64NV}(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glUniform3ui64NV(int location, long x, long y, long z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3ui64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3ui64NV\" not available");
    }
        dispatch_glUniform3ui64NV1(location, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3ui64NV}(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public native void dispatch_glUniform3ui64NV1(int location, long x, long y, long z, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform3ui64vNV(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3ui64vNV\" not available");
    }
        dispatch_glUniform3ui64vNV1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform3ui64vNV1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glUniform3ui64vNV(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3ui64vNV\" not available");
    }
        dispatch_glUniform3ui64vNV1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform3uiv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3uiv\" not available");
    }
        dispatch_glUniform3uiv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform3uiv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public void glUniform3uiv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3uiv\" not available");
    }
        dispatch_glUniform3uiv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4d}(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>   */
  public void glUniform4d(int location, double x, double y, double z, double w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4d\" not available");
    }
        dispatch_glUniform4d1(location, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4d}(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>   */
  public native void dispatch_glUniform4d1(int location, double x, double y, double z, double w, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4dv}(GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniform4dv(int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4dv\" not available");
    }
        dispatch_glUniform4dv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4dv}(GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniform4dv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4dv}(GLint location, GLsizei count, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>   */
  public void glUniform4dv(int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4dv\" not available");
    }
        dispatch_glUniform4dv1(location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4f}(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glUniform4f(int location, float v0, float v1, float v2, float v3)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4f\" not available");
    }
        dispatch_glUniform4f1(location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4f}(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glUniform4f1(int location, float v0, float v1, float v2, float v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4fARB}(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glUniform4fARB(int location, float v0, float v1, float v2, float v3)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4fARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4fARB\" not available");
    }
        dispatch_glUniform4fARB1(location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4fARB}(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public native void dispatch_glUniform4fARB1(int location, float v0, float v1, float v2, float v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4fv}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform4fv(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4fv\" not available");
    }
        dispatch_glUniform4fv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4fv}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform4fv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4fv}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glUniform4fv(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4fv\" not available");
    }
        dispatch_glUniform4fv1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4fvARB}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform4fvARB(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4fvARB\" not available");
    }
        dispatch_glUniform4fvARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4fvARB}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform4fvARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4fvARB}(GLint location, GLsizei count, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glUniform4fvARB(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4fvARB\" not available");
    }
        dispatch_glUniform4fvARB1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4i}(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glUniform4i(int location, int v0, int v1, int v2, int v3)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4i\" not available");
    }
        dispatch_glUniform4i1(location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4i}(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glUniform4i1(int location, int v0, int v1, int v2, int v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4i64NV}(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glUniform4i64NV(int location, long x, long y, long z, long w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4i64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4i64NV\" not available");
    }
        dispatch_glUniform4i64NV1(location, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4i64NV}(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public native void dispatch_glUniform4i64NV1(int location, long x, long y, long z, long w, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform4i64vNV(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4i64vNV\" not available");
    }
        dispatch_glUniform4i64vNV1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform4i64vNV1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glUniform4i64vNV(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4i64vNV\" not available");
    }
        dispatch_glUniform4i64vNV1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4iARB}(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glUniform4iARB(int location, int v0, int v1, int v2, int v3)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4iARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4iARB\" not available");
    }
        dispatch_glUniform4iARB1(location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4iARB}(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public native void dispatch_glUniform4iARB1(int location, int v0, int v1, int v2, int v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4iv}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform4iv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4iv\" not available");
    }
        dispatch_glUniform4iv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4iv}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform4iv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4iv}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glUniform4iv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4iv\" not available");
    }
        dispatch_glUniform4iv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4ivARB}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform4ivARB(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4ivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4ivARB\" not available");
    }
        dispatch_glUniform4ivARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4ivARB}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform4ivARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4ivARB}(GLint location, GLsizei count, const GLint *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glUniform4ivARB(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4ivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4ivARB\" not available");
    }
        dispatch_glUniform4ivARB1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4ui}(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public void glUniform4ui(int location, int v0, int v1, int v2, int v3)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4ui\" not available");
    }
        dispatch_glUniform4ui1(location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4ui}(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public native void dispatch_glUniform4ui1(int location, int v0, int v1, int v2, int v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4ui64NV}(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glUniform4ui64NV(int location, long x, long y, long z, long w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4ui64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4ui64NV\" not available");
    }
        dispatch_glUniform4ui64NV1(location, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4ui64NV}(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public native void dispatch_glUniform4ui64NV1(int location, long x, long y, long z, long w, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform4ui64vNV(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4ui64vNV\" not available");
    }
        dispatch_glUniform4ui64vNV1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform4ui64vNV1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_gpu_shader5</code>   */
  public void glUniform4ui64vNV(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4ui64vNV\" not available");
    }
        dispatch_glUniform4ui64vNV1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform4uiv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4uiv\" not available");
    }
        dispatch_glUniform4uiv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform4uiv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public void glUniform4uiv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4uiv\" not available");
    }
        dispatch_glUniform4uiv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformBlockBinding}(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding); </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>   */
  public void glUniformBlockBinding(int program, int uniformBlockIndex, int uniformBlockBinding)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformBlockBinding;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformBlockBinding\" not available");
    }
        dispatch_glUniformBlockBinding1(program, uniformBlockIndex, uniformBlockBinding, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformBlockBinding}(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding); </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>   */
  public native void dispatch_glUniformBlockBinding1(int program, int uniformBlockIndex, int uniformBlockBinding, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformBufferEXT}(GLuint program, GLint location, GLuint buffer); </code> <br>Part of <code>GL_EXT_bindable_uniform</code>   */
  public void glUniformBufferEXT(int program, int location, int buffer)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformBufferEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformBufferEXT\" not available");
    }
        dispatch_glUniformBufferEXT1(program, location, buffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformBufferEXT}(GLuint program, GLint location, GLuint buffer); </code> <br>Part of <code>GL_EXT_bindable_uniform</code>   */
  public native void dispatch_glUniformBufferEXT1(int program, int location, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniformMatrix2dv(int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix2dv\" not available");
    }
        dispatch_glUniformMatrix2dv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniformMatrix2dv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>   */
  public void glUniformMatrix2dv(int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix2dv\" not available");
    }
        dispatch_glUniformMatrix2dv1(location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix2fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix2fv\" not available");
    }
        dispatch_glUniformMatrix2fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix2fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glUniformMatrix2fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix2fv\" not available");
    }
        dispatch_glUniformMatrix2fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2fvARB}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix2fvARB(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix2fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix2fvARB\" not available");
    }
        dispatch_glUniformMatrix2fvARB1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2fvARB}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix2fvARB1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2fvARB}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glUniformMatrix2fvARB(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix2fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix2fvARB\" not available");
    }
        dispatch_glUniformMatrix2fvARB1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x3dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniformMatrix2x3dv(int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix2x3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix2x3dv\" not available");
    }
        dispatch_glUniformMatrix2x3dv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x3dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniformMatrix2x3dv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x3dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>   */
  public void glUniformMatrix2x3dv(int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix2x3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix2x3dv\" not available");
    }
        dispatch_glUniformMatrix2x3dv1(location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix2x3fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix2x3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix2x3fv\" not available");
    }
        dispatch_glUniformMatrix2x3fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix2x3fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_1</code>   */
  public void glUniformMatrix2x3fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix2x3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix2x3fv\" not available");
    }
        dispatch_glUniformMatrix2x3fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x4dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniformMatrix2x4dv(int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix2x4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix2x4dv\" not available");
    }
        dispatch_glUniformMatrix2x4dv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x4dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniformMatrix2x4dv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x4dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>   */
  public void glUniformMatrix2x4dv(int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix2x4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix2x4dv\" not available");
    }
        dispatch_glUniformMatrix2x4dv1(location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix2x4fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix2x4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix2x4fv\" not available");
    }
        dispatch_glUniformMatrix2x4fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix2x4fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_1</code>   */
  public void glUniformMatrix2x4fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix2x4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix2x4fv\" not available");
    }
        dispatch_glUniformMatrix2x4fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniformMatrix3dv(int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix3dv\" not available");
    }
        dispatch_glUniformMatrix3dv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniformMatrix3dv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix3dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>   */
  public void glUniformMatrix3dv(int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix3dv\" not available");
    }
        dispatch_glUniformMatrix3dv1(location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix3fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix3fv\" not available");
    }
        dispatch_glUniformMatrix3fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix3fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glUniformMatrix3fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix3fv\" not available");
    }
        dispatch_glUniformMatrix3fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3fvARB}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix3fvARB(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix3fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix3fvARB\" not available");
    }
        dispatch_glUniformMatrix3fvARB1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3fvARB}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix3fvARB1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix3fvARB}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glUniformMatrix3fvARB(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix3fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix3fvARB\" not available");
    }
        dispatch_glUniformMatrix3fvARB1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x2dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniformMatrix3x2dv(int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix3x2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix3x2dv\" not available");
    }
        dispatch_glUniformMatrix3x2dv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x2dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniformMatrix3x2dv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x2dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>   */
  public void glUniformMatrix3x2dv(int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix3x2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix3x2dv\" not available");
    }
        dispatch_glUniformMatrix3x2dv1(location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix3x2fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix3x2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix3x2fv\" not available");
    }
        dispatch_glUniformMatrix3x2fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix3x2fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_1</code>   */
  public void glUniformMatrix3x2fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix3x2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix3x2fv\" not available");
    }
        dispatch_glUniformMatrix3x2fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x4dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniformMatrix3x4dv(int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix3x4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix3x4dv\" not available");
    }
        dispatch_glUniformMatrix3x4dv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x4dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniformMatrix3x4dv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x4dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>   */
  public void glUniformMatrix3x4dv(int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix3x4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix3x4dv\" not available");
    }
        dispatch_glUniformMatrix3x4dv1(location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix3x4fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix3x4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix3x4fv\" not available");
    }
        dispatch_glUniformMatrix3x4fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix3x4fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_1</code>   */
  public void glUniformMatrix3x4fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix3x4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix3x4fv\" not available");
    }
        dispatch_glUniformMatrix3x4fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniformMatrix4dv(int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix4dv\" not available");
    }
        dispatch_glUniformMatrix4dv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniformMatrix4dv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix4dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>   */
  public void glUniformMatrix4dv(int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix4dv\" not available");
    }
        dispatch_glUniformMatrix4dv1(location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix4fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix4fv\" not available");
    }
        dispatch_glUniformMatrix4fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix4fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glUniformMatrix4fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix4fv\" not available");
    }
        dispatch_glUniformMatrix4fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4fvARB}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix4fvARB(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix4fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix4fvARB\" not available");
    }
        dispatch_glUniformMatrix4fvARB1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4fvARB}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix4fvARB1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix4fvARB}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glUniformMatrix4fvARB(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix4fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix4fvARB\" not available");
    }
        dispatch_glUniformMatrix4fvARB1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x2dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniformMatrix4x2dv(int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix4x2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix4x2dv\" not available");
    }
        dispatch_glUniformMatrix4x2dv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x2dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniformMatrix4x2dv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x2dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>   */
  public void glUniformMatrix4x2dv(int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix4x2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix4x2dv\" not available");
    }
        dispatch_glUniformMatrix4x2dv1(location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix4x2fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix4x2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix4x2fv\" not available");
    }
        dispatch_glUniformMatrix4x2fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix4x2fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_1</code>   */
  public void glUniformMatrix4x2fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix4x2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix4x2fv\" not available");
    }
        dispatch_glUniformMatrix4x2fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x3dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniformMatrix4x3dv(int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix4x3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix4x3dv\" not available");
    }
        dispatch_glUniformMatrix4x3dv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x3dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniformMatrix4x3dv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x3dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value); </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>   */
  public void glUniformMatrix4x3dv(int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix4x3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix4x3dv\" not available");
    }
        dispatch_glUniformMatrix4x3dv1(location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix4x3fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix4x3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix4x3fv\" not available");
    }
        dispatch_glUniformMatrix4x3fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix4x3fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_1</code>   */
  public void glUniformMatrix4x3fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix4x3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix4x3fv\" not available");
    }
        dispatch_glUniformMatrix4x3fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformSubroutinesuiv}(GLenum shadertype, GLsizei count, const GLuint *  indices); </code> <br>Part of <code>GL_ARB_shader_subroutine</code>
      @param indices a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniformSubroutinesuiv(int shadertype, int count, IntBuffer indices)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformSubroutinesuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformSubroutinesuiv\" not available");
    }
        dispatch_glUniformSubroutinesuiv1(shadertype, count, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformSubroutinesuiv}(GLenum shadertype, GLsizei count, const GLuint *  indices); </code> <br>Part of <code>GL_ARB_shader_subroutine</code>
      @param indices a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniformSubroutinesuiv1(int shadertype, int count, Object indices, int indices_byte_offset, boolean indices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformSubroutinesuiv}(GLenum shadertype, GLsizei count, const GLuint *  indices); </code> <br>Part of <code>GL_ARB_shader_subroutine</code>   */
  public void glUniformSubroutinesuiv(int shadertype, int count, int[] indices, int indices_offset)  {

    if(indices != null && indices.length <= indices_offset)
      throw new GLException("array offset argument \"indices_offset\" (" + indices_offset + ") equals or exceeds array length (" + indices.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformSubroutinesuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformSubroutinesuiv\" not available");
    }
        dispatch_glUniformSubroutinesuiv1(shadertype, count, indices, Buffers.SIZEOF_INT * indices_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformui64NV}(GLint location, GLuint64EXT value); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>   */
  public void glUniformui64NV(int location, long value)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformui64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformui64NV\" not available");
    }
        dispatch_glUniformui64NV1(location, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformui64NV}(GLint location, GLuint64EXT value); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>   */
  public native void dispatch_glUniformui64NV1(int location, long value, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniformui64vNV(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformui64vNV\" not available");
    }
        dispatch_glUniformui64vNV1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniformui64vNV1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value); </code> <br>Part of <code>GL_NV_shader_buffer_load</code>   */
  public void glUniformui64vNV(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformui64vNV\" not available");
    }
        dispatch_glUniformui64vNV1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUnlockArraysEXT}(void); </code> <br>Part of <code>GL_EXT_compiled_vertex_array</code>   */
  public void glUnlockArraysEXT()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUnlockArraysEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUnlockArraysEXT\" not available");
    }
        dispatch_glUnlockArraysEXT1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glUnlockArraysEXT}(void); </code> <br>Part of <code>GL_EXT_compiled_vertex_array</code>   */
  public native void dispatch_glUnlockArraysEXT1(long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glUnmapBuffer}(GLenum target); </code> <br>Part of <code>GL_VERSION_1_5</code>   */
  public boolean glUnmapBuffer(int target)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUnmapBuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUnmapBuffer\" not available");
    }
        return dispatch_glUnmapBuffer1(target, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glUnmapBuffer}(GLenum target); </code> <br>Part of <code>GL_VERSION_1_5</code>   */
  public native boolean dispatch_glUnmapBuffer1(int target, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glUnmapNamedBufferEXT}(GLuint buffer); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public boolean glUnmapNamedBufferEXT(int buffer)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUnmapNamedBufferEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUnmapNamedBufferEXT\" not available");
    }
        return dispatch_glUnmapNamedBufferEXT1(buffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glUnmapNamedBufferEXT}(GLuint buffer); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public native boolean dispatch_glUnmapNamedBufferEXT1(int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glUseProgram}(GLuint program); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glUseProgram(int program)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUseProgram;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUseProgram\" not available");
    }
        dispatch_glUseProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUseProgram}(GLuint program); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glUseProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glUseProgramObjectARB}(GLhandleARB programObj); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glUseProgramObjectARB(int programObj)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUseProgramObjectARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUseProgramObjectARB\" not available");
    }
        dispatch_glUseProgramObjectARB1(programObj, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUseProgramObjectARB}(GLhandleARB programObj); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public native void dispatch_glUseProgramObjectARB1(int programObj, long procAddress);

  /** Entry point to C language function: <code> void {@native glUseProgramStages}(GLuint pipeline, GLbitfield stages, GLuint program); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glUseProgramStages(int pipeline, int stages, int program)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glUseProgramStages;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUseProgramStages\" not available");
    }
        dispatch_glUseProgramStages1(pipeline, stages, program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUseProgramStages}(GLuint pipeline, GLbitfield stages, GLuint program); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public native void dispatch_glUseProgramStages1(int pipeline, int stages, int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glVDPAUFiniNV}(void); </code> <br>Part of <code>GL_NV_vdpau_interop</code>   */
  public void glVDPAUFiniNV()  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVDPAUFiniNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVDPAUFiniNV\" not available");
    }
        dispatch_glVDPAUFiniNV1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glVDPAUFiniNV}(void); </code> <br>Part of <code>GL_NV_vdpau_interop</code>   */
  public native void dispatch_glVDPAUFiniNV1(long procAddress);

  /** Entry point to C language function: <code> void {@native glVDPAUGetSurfaceivNV}(GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei *  length, GLint *  values); </code> <br>Part of <code>GL_NV_vdpau_interop</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVDPAUGetSurfaceivNV(long surface, int pname, int bufSize, IntBuffer length, IntBuffer values)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVDPAUGetSurfaceivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVDPAUGetSurfaceivNV\" not available");
    }
        dispatch_glVDPAUGetSurfaceivNV1(surface, pname, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVDPAUGetSurfaceivNV}(GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei *  length, GLint *  values); </code> <br>Part of <code>GL_NV_vdpau_interop</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVDPAUGetSurfaceivNV1(long surface, int pname, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVDPAUGetSurfaceivNV}(GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei *  length, GLint *  values); </code> <br>Part of <code>GL_NV_vdpau_interop</code>   */
  public void glVDPAUGetSurfaceivNV(long surface, int pname, int bufSize, int[] length, int length_offset, int[] values, int values_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVDPAUGetSurfaceivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVDPAUGetSurfaceivNV\" not available");
    }
        dispatch_glVDPAUGetSurfaceivNV1(surface, pname, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVDPAUInitNV}(const GLvoid *  vdpDevice, const GLvoid *  getProcAddress); </code> <br>Part of <code>GL_NV_vdpau_interop</code>
      @param vdpDevice a direct or array-backed {@link java.nio.Buffer}
      @param getProcAddress a direct or array-backed {@link java.nio.Buffer}   */
  public void glVDPAUInitNV(Buffer vdpDevice, Buffer getProcAddress)  {

    final boolean vdpDevice_is_direct = Buffers.isDirect(vdpDevice);
    final boolean getProcAddress_is_direct = Buffers.isDirect(getProcAddress);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVDPAUInitNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVDPAUInitNV\" not available");
    }
        dispatch_glVDPAUInitNV1(vdpDevice_is_direct ? vdpDevice : Buffers.getArray(vdpDevice), vdpDevice_is_direct ? Buffers.getDirectBufferByteOffset(vdpDevice) : Buffers.getIndirectBufferByteOffset(vdpDevice), vdpDevice_is_direct, getProcAddress_is_direct ? getProcAddress : Buffers.getArray(getProcAddress), getProcAddress_is_direct ? Buffers.getDirectBufferByteOffset(getProcAddress) : Buffers.getIndirectBufferByteOffset(getProcAddress), getProcAddress_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVDPAUInitNV}(const GLvoid *  vdpDevice, const GLvoid *  getProcAddress); </code> <br>Part of <code>GL_NV_vdpau_interop</code>
      @param vdpDevice a direct or array-backed {@link java.nio.Buffer}
      @param getProcAddress a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glVDPAUInitNV1(Object vdpDevice, int vdpDevice_byte_offset, boolean vdpDevice_is_direct, Object getProcAddress, int getProcAddress_byte_offset, boolean getProcAddress_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVDPAUIsSurfaceNV}(GLvdpauSurfaceNV surface); </code> <br>Part of <code>GL_NV_vdpau_interop</code>   */
  public void glVDPAUIsSurfaceNV(long surface)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVDPAUIsSurfaceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVDPAUIsSurfaceNV\" not available");
    }
        dispatch_glVDPAUIsSurfaceNV1(surface, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVDPAUIsSurfaceNV}(GLvdpauSurfaceNV surface); </code> <br>Part of <code>GL_NV_vdpau_interop</code>   */
  public native void dispatch_glVDPAUIsSurfaceNV1(long surface, long procAddress);

  /** Entry point to C language function: <code> void {@native glVDPAUMapSurfacesNV}(GLsizei numSurfaces, const GLvdpauSurfaceNV *  surfaces); </code> <br>Part of <code>GL_NV_vdpau_interop</code>
      @param surfaces a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glVDPAUMapSurfacesNV(int numSurfaces, LongBuffer surfaces)  {

    final boolean surfaces_is_direct = Buffers.isDirect(surfaces);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVDPAUMapSurfacesNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVDPAUMapSurfacesNV\" not available");
    }
        dispatch_glVDPAUMapSurfacesNV1(numSurfaces, surfaces_is_direct ? surfaces : Buffers.getArray(surfaces), surfaces_is_direct ? Buffers.getDirectBufferByteOffset(surfaces) : Buffers.getIndirectBufferByteOffset(surfaces), surfaces_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVDPAUMapSurfacesNV}(GLsizei numSurfaces, const GLvdpauSurfaceNV *  surfaces); </code> <br>Part of <code>GL_NV_vdpau_interop</code>
      @param surfaces a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glVDPAUMapSurfacesNV1(int numSurfaces, Object surfaces, int surfaces_byte_offset, boolean surfaces_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVDPAUMapSurfacesNV}(GLsizei numSurfaces, const GLvdpauSurfaceNV *  surfaces); </code> <br>Part of <code>GL_NV_vdpau_interop</code>   */
  public void glVDPAUMapSurfacesNV(int numSurfaces, long[] surfaces, int surfaces_offset)  {

    if(surfaces != null && surfaces.length <= surfaces_offset)
      throw new GLException("array offset argument \"surfaces_offset\" (" + surfaces_offset + ") equals or exceeds array length (" + surfaces.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVDPAUMapSurfacesNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVDPAUMapSurfacesNV\" not available");
    }
        dispatch_glVDPAUMapSurfacesNV1(numSurfaces, surfaces, Buffers.SIZEOF_LONG * surfaces_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLvdpauSurfaceNV {@native glVDPAURegisterOutputSurfaceNV}(GLvoid *  vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *  textureNames); </code> <br>Part of <code>GL_NV_vdpau_interop</code>
      @param vdpSurface a direct or array-backed {@link java.nio.Buffer}
      @param textureNames a direct or array-backed {@link java.nio.IntBuffer}   */
  public long glVDPAURegisterOutputSurfaceNV(Buffer vdpSurface, int target, int numTextureNames, IntBuffer textureNames)  {

    final boolean vdpSurface_is_direct = Buffers.isDirect(vdpSurface);
    final boolean textureNames_is_direct = Buffers.isDirect(textureNames);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVDPAURegisterOutputSurfaceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVDPAURegisterOutputSurfaceNV\" not available");
    }
        return dispatch_glVDPAURegisterOutputSurfaceNV1(vdpSurface_is_direct ? vdpSurface : Buffers.getArray(vdpSurface), vdpSurface_is_direct ? Buffers.getDirectBufferByteOffset(vdpSurface) : Buffers.getIndirectBufferByteOffset(vdpSurface), vdpSurface_is_direct, target, numTextureNames, textureNames_is_direct ? textureNames : Buffers.getArray(textureNames), textureNames_is_direct ? Buffers.getDirectBufferByteOffset(textureNames) : Buffers.getIndirectBufferByteOffset(textureNames), textureNames_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLvdpauSurfaceNV {@native glVDPAURegisterOutputSurfaceNV}(GLvoid *  vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *  textureNames); </code> <br>Part of <code>GL_NV_vdpau_interop</code>
      @param vdpSurface a direct or array-backed {@link java.nio.Buffer}
      @param textureNames a direct or array-backed {@link java.nio.IntBuffer}   */
  private native long dispatch_glVDPAURegisterOutputSurfaceNV1(Object vdpSurface, int vdpSurface_byte_offset, boolean vdpSurface_is_direct, int target, int numTextureNames, Object textureNames, int textureNames_byte_offset, boolean textureNames_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLvdpauSurfaceNV {@native glVDPAURegisterOutputSurfaceNV}(GLvoid *  vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *  textureNames); </code> <br>Part of <code>GL_NV_vdpau_interop</code>
      @param vdpSurface a direct or array-backed {@link java.nio.Buffer}   */
  public long glVDPAURegisterOutputSurfaceNV(Buffer vdpSurface, int target, int numTextureNames, int[] textureNames, int textureNames_offset)  {

    final boolean vdpSurface_is_direct = Buffers.isDirect(vdpSurface);
    if(textureNames != null && textureNames.length <= textureNames_offset)
      throw new GLException("array offset argument \"textureNames_offset\" (" + textureNames_offset + ") equals or exceeds array length (" + textureNames.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVDPAURegisterOutputSurfaceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVDPAURegisterOutputSurfaceNV\" not available");
    }
        return dispatch_glVDPAURegisterOutputSurfaceNV1(vdpSurface_is_direct ? vdpSurface : Buffers.getArray(vdpSurface), vdpSurface_is_direct ? Buffers.getDirectBufferByteOffset(vdpSurface) : Buffers.getIndirectBufferByteOffset(vdpSurface), vdpSurface_is_direct, target, numTextureNames, textureNames, Buffers.SIZEOF_INT * textureNames_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLvdpauSurfaceNV {@native glVDPAURegisterVideoSurfaceNV}(GLvoid *  vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *  textureNames); </code> <br>Part of <code>GL_NV_vdpau_interop</code>
      @param vdpSurface a direct or array-backed {@link java.nio.Buffer}
      @param textureNames a direct or array-backed {@link java.nio.IntBuffer}   */
  public long glVDPAURegisterVideoSurfaceNV(Buffer vdpSurface, int target, int numTextureNames, IntBuffer textureNames)  {

    final boolean vdpSurface_is_direct = Buffers.isDirect(vdpSurface);
    final boolean textureNames_is_direct = Buffers.isDirect(textureNames);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVDPAURegisterVideoSurfaceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVDPAURegisterVideoSurfaceNV\" not available");
    }
        return dispatch_glVDPAURegisterVideoSurfaceNV1(vdpSurface_is_direct ? vdpSurface : Buffers.getArray(vdpSurface), vdpSurface_is_direct ? Buffers.getDirectBufferByteOffset(vdpSurface) : Buffers.getIndirectBufferByteOffset(vdpSurface), vdpSurface_is_direct, target, numTextureNames, textureNames_is_direct ? textureNames : Buffers.getArray(textureNames), textureNames_is_direct ? Buffers.getDirectBufferByteOffset(textureNames) : Buffers.getIndirectBufferByteOffset(textureNames), textureNames_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLvdpauSurfaceNV {@native glVDPAURegisterVideoSurfaceNV}(GLvoid *  vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *  textureNames); </code> <br>Part of <code>GL_NV_vdpau_interop</code>
      @param vdpSurface a direct or array-backed {@link java.nio.Buffer}
      @param textureNames a direct or array-backed {@link java.nio.IntBuffer}   */
  private native long dispatch_glVDPAURegisterVideoSurfaceNV1(Object vdpSurface, int vdpSurface_byte_offset, boolean vdpSurface_is_direct, int target, int numTextureNames, Object textureNames, int textureNames_byte_offset, boolean textureNames_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLvdpauSurfaceNV {@native glVDPAURegisterVideoSurfaceNV}(GLvoid *  vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *  textureNames); </code> <br>Part of <code>GL_NV_vdpau_interop</code>
      @param vdpSurface a direct or array-backed {@link java.nio.Buffer}   */
  public long glVDPAURegisterVideoSurfaceNV(Buffer vdpSurface, int target, int numTextureNames, int[] textureNames, int textureNames_offset)  {

    final boolean vdpSurface_is_direct = Buffers.isDirect(vdpSurface);
    if(textureNames != null && textureNames.length <= textureNames_offset)
      throw new GLException("array offset argument \"textureNames_offset\" (" + textureNames_offset + ") equals or exceeds array length (" + textureNames.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVDPAURegisterVideoSurfaceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVDPAURegisterVideoSurfaceNV\" not available");
    }
        return dispatch_glVDPAURegisterVideoSurfaceNV1(vdpSurface_is_direct ? vdpSurface : Buffers.getArray(vdpSurface), vdpSurface_is_direct ? Buffers.getDirectBufferByteOffset(vdpSurface) : Buffers.getIndirectBufferByteOffset(vdpSurface), vdpSurface_is_direct, target, numTextureNames, textureNames, Buffers.SIZEOF_INT * textureNames_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVDPAUSurfaceAccessNV}(GLvdpauSurfaceNV surface, GLenum access); </code> <br>Part of <code>GL_NV_vdpau_interop</code>   */
  public void glVDPAUSurfaceAccessNV(long surface, int access)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVDPAUSurfaceAccessNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVDPAUSurfaceAccessNV\" not available");
    }
        dispatch_glVDPAUSurfaceAccessNV1(surface, access, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVDPAUSurfaceAccessNV}(GLvdpauSurfaceNV surface, GLenum access); </code> <br>Part of <code>GL_NV_vdpau_interop</code>   */
  public native void dispatch_glVDPAUSurfaceAccessNV1(long surface, int access, long procAddress);

  /** Entry point to C language function: <code> void {@native glVDPAUUnmapSurfacesNV}(GLsizei numSurface, const GLvdpauSurfaceNV *  surfaces); </code> <br>Part of <code>GL_NV_vdpau_interop</code>
      @param surfaces a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glVDPAUUnmapSurfacesNV(int numSurface, LongBuffer surfaces)  {

    final boolean surfaces_is_direct = Buffers.isDirect(surfaces);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVDPAUUnmapSurfacesNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVDPAUUnmapSurfacesNV\" not available");
    }
        dispatch_glVDPAUUnmapSurfacesNV1(numSurface, surfaces_is_direct ? surfaces : Buffers.getArray(surfaces), surfaces_is_direct ? Buffers.getDirectBufferByteOffset(surfaces) : Buffers.getIndirectBufferByteOffset(surfaces), surfaces_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVDPAUUnmapSurfacesNV}(GLsizei numSurface, const GLvdpauSurfaceNV *  surfaces); </code> <br>Part of <code>GL_NV_vdpau_interop</code>
      @param surfaces a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glVDPAUUnmapSurfacesNV1(int numSurface, Object surfaces, int surfaces_byte_offset, boolean surfaces_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVDPAUUnmapSurfacesNV}(GLsizei numSurface, const GLvdpauSurfaceNV *  surfaces); </code> <br>Part of <code>GL_NV_vdpau_interop</code>   */
  public void glVDPAUUnmapSurfacesNV(int numSurface, long[] surfaces, int surfaces_offset)  {

    if(surfaces != null && surfaces.length <= surfaces_offset)
      throw new GLException("array offset argument \"surfaces_offset\" (" + surfaces_offset + ") equals or exceeds array length (" + surfaces.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVDPAUUnmapSurfacesNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVDPAUUnmapSurfacesNV\" not available");
    }
        dispatch_glVDPAUUnmapSurfacesNV1(numSurface, surfaces, Buffers.SIZEOF_LONG * surfaces_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVDPAUUnregisterSurfaceNV}(GLvdpauSurfaceNV surface); </code> <br>Part of <code>GL_NV_vdpau_interop</code>   */
  public void glVDPAUUnregisterSurfaceNV(long surface)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVDPAUUnregisterSurfaceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVDPAUUnregisterSurfaceNV\" not available");
    }
        dispatch_glVDPAUUnregisterSurfaceNV1(surface, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVDPAUUnregisterSurfaceNV}(GLvdpauSurfaceNV surface); </code> <br>Part of <code>GL_NV_vdpau_interop</code>   */
  public native void dispatch_glVDPAUUnregisterSurfaceNV1(long surface, long procAddress);

  /** Entry point to C language function: <code> void {@native glValidateProgram}(GLuint program); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glValidateProgram(int program)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glValidateProgram;
    if (__addr_ == 0) {
      throw new GLException("Method \"glValidateProgram\" not available");
    }
        dispatch_glValidateProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glValidateProgram}(GLuint program); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glValidateProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glValidateProgramARB}(GLhandleARB programObj); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public void glValidateProgramARB(int programObj)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glValidateProgramARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glValidateProgramARB\" not available");
    }
        dispatch_glValidateProgramARB1(programObj, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glValidateProgramARB}(GLhandleARB programObj); </code> <br>Part of <code>GL_ARB_shader_objects</code>   */
  public native void dispatch_glValidateProgramARB1(int programObj, long procAddress);

  /** Entry point to C language function: <code> void {@native glValidateProgramPipeline}(GLuint pipeline); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public void glValidateProgramPipeline(int pipeline)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glValidateProgramPipeline;
    if (__addr_ == 0) {
      throw new GLException("Method \"glValidateProgramPipeline\" not available");
    }
        dispatch_glValidateProgramPipeline1(pipeline, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glValidateProgramPipeline}(GLuint pipeline); </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>   */
  public native void dispatch_glValidateProgramPipeline1(int pipeline, long procAddress);

  /** Entry point to C language function: <code> void {@native glVariantPointerEXT}(GLuint id, GLenum type, GLuint stride, const GLvoid *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param addr a direct or array-backed {@link java.nio.Buffer}   */
  public void glVariantPointerEXT(int id, int type, int stride, Buffer addr)  {

    checkArrayVBODisabled(true);
    Buffers.rangeCheck(addr, 1);
    final boolean addr_is_direct = Buffers.isDirect(addr);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVariantPointerEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVariantPointerEXT\" not available");
    }
        dispatch_glVariantPointerEXT1(id, type, stride, addr_is_direct ? addr : Buffers.getArray(addr), addr_is_direct ? Buffers.getDirectBufferByteOffset(addr) : Buffers.getIndirectBufferByteOffset(addr), addr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantPointerEXT}(GLuint id, GLenum type, GLuint stride, const GLvoid *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param addr a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glVariantPointerEXT1(int id, int type, int stride, Object addr, int addr_byte_offset, boolean addr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVariantPointerEXT}(GLuint id, GLenum type, GLuint stride, const GLvoid *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glVariantPointerEXT(int id, int type, int stride, long addr_buffer_offset)  {

    checkArrayVBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVariantPointerEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVariantPointerEXT\" not available");
    }
        dispatch_glVariantPointerEXT1(id, type, stride, addr_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantPointerEXT}(GLuint id, GLenum type, GLuint stride, const GLvoid *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  private native void dispatch_glVariantPointerEXT1(int id, int type, int stride, long addr_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVariantbvEXT}(GLuint id, const GLbyte *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param addr a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVariantbvEXT(int id, ByteBuffer addr)  {

    final boolean addr_is_direct = Buffers.isDirect(addr);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVariantbvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVariantbvEXT\" not available");
    }
        dispatch_glVariantbvEXT1(id, addr_is_direct ? addr : Buffers.getArray(addr), addr_is_direct ? Buffers.getDirectBufferByteOffset(addr) : Buffers.getIndirectBufferByteOffset(addr), addr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantbvEXT}(GLuint id, const GLbyte *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param addr a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVariantbvEXT1(int id, Object addr, int addr_byte_offset, boolean addr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVariantbvEXT}(GLuint id, const GLbyte *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glVariantbvEXT(int id, byte[] addr, int addr_offset)  {

    if(addr != null && addr.length <= addr_offset)
      throw new GLException("array offset argument \"addr_offset\" (" + addr_offset + ") equals or exceeds array length (" + addr.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVariantbvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVariantbvEXT\" not available");
    }
        dispatch_glVariantbvEXT1(id, addr, addr_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantdvEXT}(GLuint id, const GLdouble *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param addr a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVariantdvEXT(int id, DoubleBuffer addr)  {

    final boolean addr_is_direct = Buffers.isDirect(addr);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVariantdvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVariantdvEXT\" not available");
    }
        dispatch_glVariantdvEXT1(id, addr_is_direct ? addr : Buffers.getArray(addr), addr_is_direct ? Buffers.getDirectBufferByteOffset(addr) : Buffers.getIndirectBufferByteOffset(addr), addr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantdvEXT}(GLuint id, const GLdouble *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param addr a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVariantdvEXT1(int id, Object addr, int addr_byte_offset, boolean addr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVariantdvEXT}(GLuint id, const GLdouble *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glVariantdvEXT(int id, double[] addr, int addr_offset)  {

    if(addr != null && addr.length <= addr_offset)
      throw new GLException("array offset argument \"addr_offset\" (" + addr_offset + ") equals or exceeds array length (" + addr.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVariantdvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVariantdvEXT\" not available");
    }
        dispatch_glVariantdvEXT1(id, addr, Buffers.SIZEOF_DOUBLE * addr_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantfvEXT}(GLuint id, const GLfloat *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param addr a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVariantfvEXT(int id, FloatBuffer addr)  {

    final boolean addr_is_direct = Buffers.isDirect(addr);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVariantfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVariantfvEXT\" not available");
    }
        dispatch_glVariantfvEXT1(id, addr_is_direct ? addr : Buffers.getArray(addr), addr_is_direct ? Buffers.getDirectBufferByteOffset(addr) : Buffers.getIndirectBufferByteOffset(addr), addr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantfvEXT}(GLuint id, const GLfloat *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param addr a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVariantfvEXT1(int id, Object addr, int addr_byte_offset, boolean addr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVariantfvEXT}(GLuint id, const GLfloat *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glVariantfvEXT(int id, float[] addr, int addr_offset)  {

    if(addr != null && addr.length <= addr_offset)
      throw new GLException("array offset argument \"addr_offset\" (" + addr_offset + ") equals or exceeds array length (" + addr.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVariantfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVariantfvEXT\" not available");
    }
        dispatch_glVariantfvEXT1(id, addr, Buffers.SIZEOF_FLOAT * addr_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantivEXT}(GLuint id, const GLint *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param addr a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVariantivEXT(int id, IntBuffer addr)  {

    final boolean addr_is_direct = Buffers.isDirect(addr);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVariantivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVariantivEXT\" not available");
    }
        dispatch_glVariantivEXT1(id, addr_is_direct ? addr : Buffers.getArray(addr), addr_is_direct ? Buffers.getDirectBufferByteOffset(addr) : Buffers.getIndirectBufferByteOffset(addr), addr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantivEXT}(GLuint id, const GLint *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param addr a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVariantivEXT1(int id, Object addr, int addr_byte_offset, boolean addr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVariantivEXT}(GLuint id, const GLint *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glVariantivEXT(int id, int[] addr, int addr_offset)  {

    if(addr != null && addr.length <= addr_offset)
      throw new GLException("array offset argument \"addr_offset\" (" + addr_offset + ") equals or exceeds array length (" + addr.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVariantivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVariantivEXT\" not available");
    }
        dispatch_glVariantivEXT1(id, addr, Buffers.SIZEOF_INT * addr_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantsvEXT}(GLuint id, const GLshort *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param addr a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVariantsvEXT(int id, ShortBuffer addr)  {

    final boolean addr_is_direct = Buffers.isDirect(addr);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVariantsvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVariantsvEXT\" not available");
    }
        dispatch_glVariantsvEXT1(id, addr_is_direct ? addr : Buffers.getArray(addr), addr_is_direct ? Buffers.getDirectBufferByteOffset(addr) : Buffers.getIndirectBufferByteOffset(addr), addr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantsvEXT}(GLuint id, const GLshort *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param addr a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVariantsvEXT1(int id, Object addr, int addr_byte_offset, boolean addr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVariantsvEXT}(GLuint id, const GLshort *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glVariantsvEXT(int id, short[] addr, int addr_offset)  {

    if(addr != null && addr.length <= addr_offset)
      throw new GLException("array offset argument \"addr_offset\" (" + addr_offset + ") equals or exceeds array length (" + addr.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVariantsvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVariantsvEXT\" not available");
    }
        dispatch_glVariantsvEXT1(id, addr, Buffers.SIZEOF_SHORT * addr_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantubvEXT}(GLuint id, const GLubyte *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param addr a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVariantubvEXT(int id, ByteBuffer addr)  {

    final boolean addr_is_direct = Buffers.isDirect(addr);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVariantubvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVariantubvEXT\" not available");
    }
        dispatch_glVariantubvEXT1(id, addr_is_direct ? addr : Buffers.getArray(addr), addr_is_direct ? Buffers.getDirectBufferByteOffset(addr) : Buffers.getIndirectBufferByteOffset(addr), addr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantubvEXT}(GLuint id, const GLubyte *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param addr a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVariantubvEXT1(int id, Object addr, int addr_byte_offset, boolean addr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVariantubvEXT}(GLuint id, const GLubyte *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glVariantubvEXT(int id, byte[] addr, int addr_offset)  {

    if(addr != null && addr.length <= addr_offset)
      throw new GLException("array offset argument \"addr_offset\" (" + addr_offset + ") equals or exceeds array length (" + addr.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVariantubvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVariantubvEXT\" not available");
    }
        dispatch_glVariantubvEXT1(id, addr, addr_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantuivEXT}(GLuint id, const GLuint *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param addr a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVariantuivEXT(int id, IntBuffer addr)  {

    final boolean addr_is_direct = Buffers.isDirect(addr);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVariantuivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVariantuivEXT\" not available");
    }
        dispatch_glVariantuivEXT1(id, addr_is_direct ? addr : Buffers.getArray(addr), addr_is_direct ? Buffers.getDirectBufferByteOffset(addr) : Buffers.getIndirectBufferByteOffset(addr), addr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantuivEXT}(GLuint id, const GLuint *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param addr a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVariantuivEXT1(int id, Object addr, int addr_byte_offset, boolean addr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVariantuivEXT}(GLuint id, const GLuint *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glVariantuivEXT(int id, int[] addr, int addr_offset)  {

    if(addr != null && addr.length <= addr_offset)
      throw new GLException("array offset argument \"addr_offset\" (" + addr_offset + ") equals or exceeds array length (" + addr.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVariantuivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVariantuivEXT\" not available");
    }
        dispatch_glVariantuivEXT1(id, addr, Buffers.SIZEOF_INT * addr_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantusvEXT}(GLuint id, const GLushort *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param addr a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVariantusvEXT(int id, ShortBuffer addr)  {

    final boolean addr_is_direct = Buffers.isDirect(addr);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVariantusvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVariantusvEXT\" not available");
    }
        dispatch_glVariantusvEXT1(id, addr_is_direct ? addr : Buffers.getArray(addr), addr_is_direct ? Buffers.getDirectBufferByteOffset(addr) : Buffers.getIndirectBufferByteOffset(addr), addr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantusvEXT}(GLuint id, const GLushort *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>
      @param addr a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVariantusvEXT1(int id, Object addr, int addr_byte_offset, boolean addr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVariantusvEXT}(GLuint id, const GLushort *  addr); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glVariantusvEXT(int id, short[] addr, int addr_offset)  {

    if(addr != null && addr.length <= addr_offset)
      throw new GLException("array offset argument \"addr_offset\" (" + addr_offset + ") equals or exceeds array length (" + addr.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVariantusvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVariantusvEXT\" not available");
    }
        dispatch_glVariantusvEXT1(id, addr, Buffers.SIZEOF_SHORT * addr_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2d}(GLdouble x, GLdouble y); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex2d(double x, double y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex2d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex2d\" not available");
    }
        dispatch_glVertex2d1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2d}(GLdouble x, GLdouble y); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glVertex2d1(double x, double y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex2dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertex2dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex2dv\" not available");
    }
        dispatch_glVertex2dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertex2dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex2dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex2dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex2dv\" not available");
    }
        dispatch_glVertex2dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2f}(GLfloat x, GLfloat y); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex2f(float x, float y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex2f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex2f\" not available");
    }
        dispatch_glVertex2f1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2f}(GLfloat x, GLfloat y); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glVertex2f1(float x, float y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex2fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertex2fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex2fv\" not available");
    }
        dispatch_glVertex2fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertex2fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex2fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex2fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex2fv\" not available");
    }
        dispatch_glVertex2fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2hNV}(GLhalfNV x, GLhalfNV y); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glVertex2h(short x, short y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex2h;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex2h\" not available");
    }
        dispatch_glVertex2h1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2hNV}(GLhalfNV x, GLhalfNV y); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public native void dispatch_glVertex2h1(short x, short y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex2hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertex2hv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex2hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex2hv\" not available");
    }
        dispatch_glVertex2hv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertex2hv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex2hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glVertex2hv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex2hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex2hv\" not available");
    }
        dispatch_glVertex2hv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2i}(GLint x, GLint y); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex2i(int x, int y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex2i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex2i\" not available");
    }
        dispatch_glVertex2i1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2i}(GLint x, GLint y); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glVertex2i1(int x, int y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex2iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertex2iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex2iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex2iv\" not available");
    }
        dispatch_glVertex2iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertex2iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex2iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex2iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex2iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex2iv\" not available");
    }
        dispatch_glVertex2iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2s}(GLshort x, GLshort y); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex2s(short x, short y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex2s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex2s\" not available");
    }
        dispatch_glVertex2s1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2s}(GLshort x, GLshort y); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glVertex2s1(short x, short y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex2sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertex2sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex2sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex2sv\" not available");
    }
        dispatch_glVertex2sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertex2sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex2sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex2sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex2sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex2sv\" not available");
    }
        dispatch_glVertex2sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3d}(GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex3d(double x, double y, double z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex3d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex3d\" not available");
    }
        dispatch_glVertex3d1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3d}(GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glVertex3d1(double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex3dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertex3dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex3dv\" not available");
    }
        dispatch_glVertex3dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertex3dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex3dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex3dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex3dv\" not available");
    }
        dispatch_glVertex3dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3f}(GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex3f(float x, float y, float z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex3f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex3f\" not available");
    }
        dispatch_glVertex3f1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3f}(GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glVertex3f1(float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex3fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertex3fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex3fv\" not available");
    }
        dispatch_glVertex3fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertex3fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex3fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex3fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex3fv\" not available");
    }
        dispatch_glVertex3fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3hNV}(GLhalfNV x, GLhalfNV y, GLhalfNV z); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glVertex3h(short x, short y, short z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex3h;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex3h\" not available");
    }
        dispatch_glVertex3h1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3hNV}(GLhalfNV x, GLhalfNV y, GLhalfNV z); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public native void dispatch_glVertex3h1(short x, short y, short z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex3hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertex3hv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex3hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex3hv\" not available");
    }
        dispatch_glVertex3hv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertex3hv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex3hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glVertex3hv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex3hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex3hv\" not available");
    }
        dispatch_glVertex3hv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3i}(GLint x, GLint y, GLint z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex3i(int x, int y, int z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex3i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex3i\" not available");
    }
        dispatch_glVertex3i1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3i}(GLint x, GLint y, GLint z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glVertex3i1(int x, int y, int z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex3iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertex3iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex3iv\" not available");
    }
        dispatch_glVertex3iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertex3iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex3iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex3iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex3iv\" not available");
    }
        dispatch_glVertex3iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3s}(GLshort x, GLshort y, GLshort z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex3s(short x, short y, short z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex3s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex3s\" not available");
    }
        dispatch_glVertex3s1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3s}(GLshort x, GLshort y, GLshort z); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glVertex3s1(short x, short y, short z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex3sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertex3sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex3sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex3sv\" not available");
    }
        dispatch_glVertex3sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertex3sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex3sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex3sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex3sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex3sv\" not available");
    }
        dispatch_glVertex3sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4d}(GLdouble x, GLdouble y, GLdouble z, GLdouble w); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex4d(double x, double y, double z, double w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex4d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex4d\" not available");
    }
        dispatch_glVertex4d1(x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4d}(GLdouble x, GLdouble y, GLdouble z, GLdouble w); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glVertex4d1(double x, double y, double z, double w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex4dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertex4dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex4dv\" not available");
    }
        dispatch_glVertex4dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertex4dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex4dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex4dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex4dv\" not available");
    }
        dispatch_glVertex4dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4f}(GLfloat x, GLfloat y, GLfloat z, GLfloat w); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex4f(float x, float y, float z, float w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex4f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex4f\" not available");
    }
        dispatch_glVertex4f1(x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4f}(GLfloat x, GLfloat y, GLfloat z, GLfloat w); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glVertex4f1(float x, float y, float z, float w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex4fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertex4fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex4fv\" not available");
    }
        dispatch_glVertex4fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertex4fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex4fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex4fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex4fv\" not available");
    }
        dispatch_glVertex4fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4hNV}(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glVertex4h(short x, short y, short z, short w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex4h;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex4h\" not available");
    }
        dispatch_glVertex4h1(x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4hNV}(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public native void dispatch_glVertex4h1(short x, short y, short z, short w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex4hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertex4hv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex4hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex4hv\" not available");
    }
        dispatch_glVertex4hv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertex4hv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex4hvNV}(const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glVertex4hv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex4hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex4hv\" not available");
    }
        dispatch_glVertex4hv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4i}(GLint x, GLint y, GLint z, GLint w); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex4i(int x, int y, int z, int w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex4i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex4i\" not available");
    }
        dispatch_glVertex4i1(x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4i}(GLint x, GLint y, GLint z, GLint w); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glVertex4i1(int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex4iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertex4iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex4iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex4iv\" not available");
    }
        dispatch_glVertex4iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertex4iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex4iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex4iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex4iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex4iv\" not available");
    }
        dispatch_glVertex4iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4s}(GLshort x, GLshort y, GLshort z, GLshort w); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex4s(short x, short y, short z, short w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex4s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex4s\" not available");
    }
        dispatch_glVertex4s1(x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4s}(GLshort x, GLshort y, GLshort z, GLshort w); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glVertex4s1(short x, short y, short z, short w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex4sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertex4sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex4sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex4sv\" not available");
    }
        dispatch_glVertex4sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertex4sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex4sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glVertex4sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertex4sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertex4sv\" not available");
    }
        dispatch_glVertex4sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayParameteriAPPLE}(GLenum pname, GLint param); </code> <br>Part of <code>GL_APPLE_vertex_array_range</code>   */
  public void glVertexArrayParameteriAPPLE(int pname, int param)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexArrayParameteriAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexArrayParameteriAPPLE\" not available");
    }
        dispatch_glVertexArrayParameteriAPPLE1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayParameteriAPPLE}(GLenum pname, GLint param); </code> <br>Part of <code>GL_APPLE_vertex_array_range</code>   */
  public native void dispatch_glVertexArrayParameteriAPPLE1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayRangeAPPLE}(GLsizei length, GLvoid *  pointer); </code> <br>Part of <code>GL_APPLE_vertex_array_range</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glVertexArrayRangeAPPLE(int length, Buffer pointer)  {

    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexArrayRangeAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexArrayRangeAPPLE\" not available");
    }
        dispatch_glVertexArrayRangeAPPLE1(length, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayRangeAPPLE}(GLsizei length, GLvoid *  pointer); </code> <br>Part of <code>GL_APPLE_vertex_array_range</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glVertexArrayRangeAPPLE1(int length, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayRangeNV}(GLsizei length, const GLvoid *  pointer); </code> <br>Part of <code>GL_NV_vertex_array_range</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void glVertexArrayRangeNV(int length, Buffer pointer)  {

    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexArrayRangeNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexArrayRangeNV\" not available");
    }
        dispatch_glVertexArrayRangeNV0(length, pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayRangeNV}(GLsizei length, const GLvoid *  pointer); </code> <br>Part of <code>GL_NV_vertex_array_range</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glVertexArrayRangeNV0(int length, Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1d}(GLuint index, GLdouble x); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib1d(int index, double x)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1d\" not available");
    }
        dispatch_glVertexAttrib1d1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1d}(GLuint index, GLdouble x); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glVertexAttrib1d1(int index, double x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1dARB}(GLuint index, GLdouble x); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib1dARB(int index, double x)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1dARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1dARB\" not available");
    }
        dispatch_glVertexAttrib1dARB1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1dARB}(GLuint index, GLdouble x); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public native void dispatch_glVertexAttrib1dARB1(int index, double x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttrib1dv(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1dv\" not available");
    }
        dispatch_glVertexAttrib1dv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttrib1dv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib1dv(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1dv\" not available");
    }
        dispatch_glVertexAttrib1dv1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1dvARB}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttrib1dvARB(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1dvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1dvARB\" not available");
    }
        dispatch_glVertexAttrib1dvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1dvARB}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttrib1dvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1dvARB}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib1dvARB(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1dvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1dvARB\" not available");
    }
        dispatch_glVertexAttrib1dvARB1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1f}(GLuint index, GLfloat x); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib1f(int index, float x)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1f\" not available");
    }
        dispatch_glVertexAttrib1f1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1f}(GLuint index, GLfloat x); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glVertexAttrib1f1(int index, float x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fARB}(GLuint index, GLfloat x); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib1fARB(int index, float x)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1fARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1fARB\" not available");
    }
        dispatch_glVertexAttrib1fARB1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fARB}(GLuint index, GLfloat x); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public native void dispatch_glVertexAttrib1fARB1(int index, float x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fv}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib1fv(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1fv\" not available");
    }
        dispatch_glVertexAttrib1fv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fv}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib1fv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fv}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib1fv(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1fv\" not available");
    }
        dispatch_glVertexAttrib1fv1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fvARB}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib1fvARB(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1fvARB\" not available");
    }
        dispatch_glVertexAttrib1fvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fvARB}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib1fvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fvARB}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib1fvARB(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1fvARB\" not available");
    }
        dispatch_glVertexAttrib1fvARB1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1hNV}(GLuint index, GLhalfNV x); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glVertexAttrib1h(int index, short x)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1h;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1h\" not available");
    }
        dispatch_glVertexAttrib1h1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1hNV}(GLuint index, GLhalfNV x); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public native void dispatch_glVertexAttrib1h1(int index, short x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1hvNV}(GLuint index, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib1hv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1hv\" not available");
    }
        dispatch_glVertexAttrib1hv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1hvNV}(GLuint index, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib1hv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1hvNV}(GLuint index, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glVertexAttrib1hv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1hv\" not available");
    }
        dispatch_glVertexAttrib1hv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1s}(GLuint index, GLshort x); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib1s(int index, short x)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1s\" not available");
    }
        dispatch_glVertexAttrib1s1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1s}(GLuint index, GLshort x); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glVertexAttrib1s1(int index, short x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1sARB}(GLuint index, GLshort x); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib1sARB(int index, short x)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1sARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1sARB\" not available");
    }
        dispatch_glVertexAttrib1sARB1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1sARB}(GLuint index, GLshort x); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public native void dispatch_glVertexAttrib1sARB1(int index, short x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1sv}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib1sv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1sv\" not available");
    }
        dispatch_glVertexAttrib1sv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1sv}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib1sv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1sv}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib1sv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1sv\" not available");
    }
        dispatch_glVertexAttrib1sv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1svARB}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib1svARB(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1svARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1svARB\" not available");
    }
        dispatch_glVertexAttrib1svARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1svARB}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib1svARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1svARB}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib1svARB(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1svARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1svARB\" not available");
    }
        dispatch_glVertexAttrib1svARB1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2d}(GLuint index, GLdouble x, GLdouble y); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib2d(int index, double x, double y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2d\" not available");
    }
        dispatch_glVertexAttrib2d1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2d}(GLuint index, GLdouble x, GLdouble y); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glVertexAttrib2d1(int index, double x, double y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2dARB}(GLuint index, GLdouble x, GLdouble y); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib2dARB(int index, double x, double y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2dARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2dARB\" not available");
    }
        dispatch_glVertexAttrib2dARB1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2dARB}(GLuint index, GLdouble x, GLdouble y); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public native void dispatch_glVertexAttrib2dARB1(int index, double x, double y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttrib2dv(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2dv\" not available");
    }
        dispatch_glVertexAttrib2dv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttrib2dv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib2dv(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2dv\" not available");
    }
        dispatch_glVertexAttrib2dv1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2dvARB}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttrib2dvARB(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2dvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2dvARB\" not available");
    }
        dispatch_glVertexAttrib2dvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2dvARB}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttrib2dvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2dvARB}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib2dvARB(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2dvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2dvARB\" not available");
    }
        dispatch_glVertexAttrib2dvARB1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2f}(GLuint index, GLfloat x, GLfloat y); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib2f(int index, float x, float y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2f\" not available");
    }
        dispatch_glVertexAttrib2f1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2f}(GLuint index, GLfloat x, GLfloat y); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glVertexAttrib2f1(int index, float x, float y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fARB}(GLuint index, GLfloat x, GLfloat y); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib2fARB(int index, float x, float y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2fARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2fARB\" not available");
    }
        dispatch_glVertexAttrib2fARB1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fARB}(GLuint index, GLfloat x, GLfloat y); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public native void dispatch_glVertexAttrib2fARB1(int index, float x, float y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fv}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib2fv(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2fv\" not available");
    }
        dispatch_glVertexAttrib2fv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fv}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib2fv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fv}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib2fv(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2fv\" not available");
    }
        dispatch_glVertexAttrib2fv1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fvARB}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib2fvARB(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2fvARB\" not available");
    }
        dispatch_glVertexAttrib2fvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fvARB}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib2fvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fvARB}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib2fvARB(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2fvARB\" not available");
    }
        dispatch_glVertexAttrib2fvARB1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2hNV}(GLuint index, GLhalfNV x, GLhalfNV y); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glVertexAttrib2h(int index, short x, short y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2h;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2h\" not available");
    }
        dispatch_glVertexAttrib2h1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2hNV}(GLuint index, GLhalfNV x, GLhalfNV y); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public native void dispatch_glVertexAttrib2h1(int index, short x, short y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2hvNV}(GLuint index, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib2hv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2hv\" not available");
    }
        dispatch_glVertexAttrib2hv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2hvNV}(GLuint index, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib2hv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2hvNV}(GLuint index, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glVertexAttrib2hv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2hv\" not available");
    }
        dispatch_glVertexAttrib2hv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2s}(GLuint index, GLshort x, GLshort y); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib2s(int index, short x, short y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2s\" not available");
    }
        dispatch_glVertexAttrib2s1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2s}(GLuint index, GLshort x, GLshort y); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glVertexAttrib2s1(int index, short x, short y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2sARB}(GLuint index, GLshort x, GLshort y); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib2sARB(int index, short x, short y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2sARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2sARB\" not available");
    }
        dispatch_glVertexAttrib2sARB1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2sARB}(GLuint index, GLshort x, GLshort y); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public native void dispatch_glVertexAttrib2sARB1(int index, short x, short y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2sv}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib2sv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2sv\" not available");
    }
        dispatch_glVertexAttrib2sv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2sv}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib2sv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2sv}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib2sv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2sv\" not available");
    }
        dispatch_glVertexAttrib2sv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2svARB}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib2svARB(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2svARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2svARB\" not available");
    }
        dispatch_glVertexAttrib2svARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2svARB}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib2svARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2svARB}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib2svARB(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2svARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2svARB\" not available");
    }
        dispatch_glVertexAttrib2svARB1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3d}(GLuint index, GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib3d(int index, double x, double y, double z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3d\" not available");
    }
        dispatch_glVertexAttrib3d1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3d}(GLuint index, GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glVertexAttrib3d1(int index, double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3dARB}(GLuint index, GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib3dARB(int index, double x, double y, double z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3dARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3dARB\" not available");
    }
        dispatch_glVertexAttrib3dARB1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3dARB}(GLuint index, GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public native void dispatch_glVertexAttrib3dARB1(int index, double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttrib3dv(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3dv\" not available");
    }
        dispatch_glVertexAttrib3dv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttrib3dv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib3dv(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3dv\" not available");
    }
        dispatch_glVertexAttrib3dv1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3dvARB}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttrib3dvARB(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3dvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3dvARB\" not available");
    }
        dispatch_glVertexAttrib3dvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3dvARB}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttrib3dvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3dvARB}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib3dvARB(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3dvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3dvARB\" not available");
    }
        dispatch_glVertexAttrib3dvARB1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3f}(GLuint index, GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib3f(int index, float x, float y, float z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3f\" not available");
    }
        dispatch_glVertexAttrib3f1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3f}(GLuint index, GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glVertexAttrib3f1(int index, float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fARB}(GLuint index, GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib3fARB(int index, float x, float y, float z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3fARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3fARB\" not available");
    }
        dispatch_glVertexAttrib3fARB1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fARB}(GLuint index, GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public native void dispatch_glVertexAttrib3fARB1(int index, float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fv}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib3fv(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3fv\" not available");
    }
        dispatch_glVertexAttrib3fv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fv}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib3fv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fv}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib3fv(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3fv\" not available");
    }
        dispatch_glVertexAttrib3fv1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fvARB}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib3fvARB(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3fvARB\" not available");
    }
        dispatch_glVertexAttrib3fvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fvARB}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib3fvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fvARB}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib3fvARB(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3fvARB\" not available");
    }
        dispatch_glVertexAttrib3fvARB1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3hNV}(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glVertexAttrib3h(int index, short x, short y, short z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3h;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3h\" not available");
    }
        dispatch_glVertexAttrib3h1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3hNV}(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public native void dispatch_glVertexAttrib3h1(int index, short x, short y, short z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3hvNV}(GLuint index, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib3hv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3hv\" not available");
    }
        dispatch_glVertexAttrib3hv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3hvNV}(GLuint index, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib3hv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3hvNV}(GLuint index, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glVertexAttrib3hv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3hv\" not available");
    }
        dispatch_glVertexAttrib3hv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3s}(GLuint index, GLshort x, GLshort y, GLshort z); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib3s(int index, short x, short y, short z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3s\" not available");
    }
        dispatch_glVertexAttrib3s1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3s}(GLuint index, GLshort x, GLshort y, GLshort z); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glVertexAttrib3s1(int index, short x, short y, short z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3sARB}(GLuint index, GLshort x, GLshort y, GLshort z); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib3sARB(int index, short x, short y, short z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3sARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3sARB\" not available");
    }
        dispatch_glVertexAttrib3sARB1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3sARB}(GLuint index, GLshort x, GLshort y, GLshort z); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public native void dispatch_glVertexAttrib3sARB1(int index, short x, short y, short z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3sv}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib3sv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3sv\" not available");
    }
        dispatch_glVertexAttrib3sv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3sv}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib3sv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3sv}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib3sv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3sv\" not available");
    }
        dispatch_glVertexAttrib3sv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3svARB}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib3svARB(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3svARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3svARB\" not available");
    }
        dispatch_glVertexAttrib3svARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3svARB}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib3svARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3svARB}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib3svARB(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3svARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3svARB\" not available");
    }
        dispatch_glVertexAttrib3svARB1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nbv}(GLuint index, const GLbyte *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttrib4Nbv(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4Nbv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4Nbv\" not available");
    }
        dispatch_glVertexAttrib4Nbv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nbv}(GLuint index, const GLbyte *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttrib4Nbv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nbv}(GLuint index, const GLbyte *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib4Nbv(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4Nbv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4Nbv\" not available");
    }
        dispatch_glVertexAttrib4Nbv1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NbvARB}(GLuint index, const GLbyte *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttrib4NbvARB(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4NbvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4NbvARB\" not available");
    }
        dispatch_glVertexAttrib4NbvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NbvARB}(GLuint index, const GLbyte *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttrib4NbvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NbvARB}(GLuint index, const GLbyte *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib4NbvARB(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4NbvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4NbvARB\" not available");
    }
        dispatch_glVertexAttrib4NbvARB1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Niv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttrib4Niv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4Niv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4Niv\" not available");
    }
        dispatch_glVertexAttrib4Niv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Niv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttrib4Niv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Niv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib4Niv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4Niv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4Niv\" not available");
    }
        dispatch_glVertexAttrib4Niv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NivARB}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttrib4NivARB(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4NivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4NivARB\" not available");
    }
        dispatch_glVertexAttrib4NivARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NivARB}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttrib4NivARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NivARB}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib4NivARB(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4NivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4NivARB\" not available");
    }
        dispatch_glVertexAttrib4NivARB1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nsv}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib4Nsv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4Nsv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4Nsv\" not available");
    }
        dispatch_glVertexAttrib4Nsv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nsv}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib4Nsv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nsv}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib4Nsv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4Nsv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4Nsv\" not available");
    }
        dispatch_glVertexAttrib4Nsv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NsvARB}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib4NsvARB(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4NsvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4NsvARB\" not available");
    }
        dispatch_glVertexAttrib4NsvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NsvARB}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib4NsvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NsvARB}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib4NsvARB(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4NsvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4NsvARB\" not available");
    }
        dispatch_glVertexAttrib4NsvARB1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nub}(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib4Nub(int index, byte x, byte y, byte z, byte w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4Nub;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4Nub\" not available");
    }
        dispatch_glVertexAttrib4Nub1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nub}(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glVertexAttrib4Nub1(int index, byte x, byte y, byte z, byte w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NubARB}(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib4NubARB(int index, byte x, byte y, byte z, byte w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4NubARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4NubARB\" not available");
    }
        dispatch_glVertexAttrib4NubARB1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NubARB}(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public native void dispatch_glVertexAttrib4NubARB1(int index, byte x, byte y, byte z, byte w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nubv}(GLuint index, const GLubyte *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttrib4Nubv(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4Nubv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4Nubv\" not available");
    }
        dispatch_glVertexAttrib4Nubv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nubv}(GLuint index, const GLubyte *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttrib4Nubv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nubv}(GLuint index, const GLubyte *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib4Nubv(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4Nubv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4Nubv\" not available");
    }
        dispatch_glVertexAttrib4Nubv1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NubvARB}(GLuint index, const GLubyte *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttrib4NubvARB(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4NubvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4NubvARB\" not available");
    }
        dispatch_glVertexAttrib4NubvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NubvARB}(GLuint index, const GLubyte *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttrib4NubvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NubvARB}(GLuint index, const GLubyte *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib4NubvARB(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4NubvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4NubvARB\" not available");
    }
        dispatch_glVertexAttrib4NubvARB1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nuiv}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttrib4Nuiv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4Nuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4Nuiv\" not available");
    }
        dispatch_glVertexAttrib4Nuiv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nuiv}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttrib4Nuiv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nuiv}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib4Nuiv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4Nuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4Nuiv\" not available");
    }
        dispatch_glVertexAttrib4Nuiv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NuivARB}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttrib4NuivARB(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4NuivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4NuivARB\" not available");
    }
        dispatch_glVertexAttrib4NuivARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NuivARB}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttrib4NuivARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NuivARB}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib4NuivARB(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4NuivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4NuivARB\" not available");
    }
        dispatch_glVertexAttrib4NuivARB1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nusv}(GLuint index, const GLushort *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib4Nusv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4Nusv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4Nusv\" not available");
    }
        dispatch_glVertexAttrib4Nusv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nusv}(GLuint index, const GLushort *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib4Nusv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nusv}(GLuint index, const GLushort *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib4Nusv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4Nusv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4Nusv\" not available");
    }
        dispatch_glVertexAttrib4Nusv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NusvARB}(GLuint index, const GLushort *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib4NusvARB(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4NusvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4NusvARB\" not available");
    }
        dispatch_glVertexAttrib4NusvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NusvARB}(GLuint index, const GLushort *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib4NusvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NusvARB}(GLuint index, const GLushort *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib4NusvARB(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4NusvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4NusvARB\" not available");
    }
        dispatch_glVertexAttrib4NusvARB1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4bv}(GLuint index, const GLbyte *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttrib4bv(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4bv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4bv\" not available");
    }
        dispatch_glVertexAttrib4bv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4bv}(GLuint index, const GLbyte *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttrib4bv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4bv}(GLuint index, const GLbyte *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib4bv(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4bv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4bv\" not available");
    }
        dispatch_glVertexAttrib4bv1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4bvARB}(GLuint index, const GLbyte *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttrib4bvARB(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4bvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4bvARB\" not available");
    }
        dispatch_glVertexAttrib4bvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4bvARB}(GLuint index, const GLbyte *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttrib4bvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4bvARB}(GLuint index, const GLbyte *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib4bvARB(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4bvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4bvARB\" not available");
    }
        dispatch_glVertexAttrib4bvARB1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4d}(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib4d(int index, double x, double y, double z, double w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4d\" not available");
    }
        dispatch_glVertexAttrib4d1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4d}(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glVertexAttrib4d1(int index, double x, double y, double z, double w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4dARB}(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib4dARB(int index, double x, double y, double z, double w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4dARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4dARB\" not available");
    }
        dispatch_glVertexAttrib4dARB1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4dARB}(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public native void dispatch_glVertexAttrib4dARB1(int index, double x, double y, double z, double w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttrib4dv(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4dv\" not available");
    }
        dispatch_glVertexAttrib4dv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttrib4dv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib4dv(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4dv\" not available");
    }
        dispatch_glVertexAttrib4dv1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4dvARB}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttrib4dvARB(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4dvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4dvARB\" not available");
    }
        dispatch_glVertexAttrib4dvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4dvARB}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttrib4dvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4dvARB}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib4dvARB(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4dvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4dvARB\" not available");
    }
        dispatch_glVertexAttrib4dvARB1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4f}(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib4f(int index, float x, float y, float z, float w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4f\" not available");
    }
        dispatch_glVertexAttrib4f1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4f}(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glVertexAttrib4f1(int index, float x, float y, float z, float w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fARB}(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib4fARB(int index, float x, float y, float z, float w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4fARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4fARB\" not available");
    }
        dispatch_glVertexAttrib4fARB1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fARB}(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public native void dispatch_glVertexAttrib4fARB1(int index, float x, float y, float z, float w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fv}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib4fv(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4fv\" not available");
    }
        dispatch_glVertexAttrib4fv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fv}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib4fv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fv}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib4fv(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4fv\" not available");
    }
        dispatch_glVertexAttrib4fv1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fvARB}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib4fvARB(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4fvARB\" not available");
    }
        dispatch_glVertexAttrib4fvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fvARB}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib4fvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fvARB}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib4fvARB(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4fvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4fvARB\" not available");
    }
        dispatch_glVertexAttrib4fvARB1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4hNV}(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glVertexAttrib4h(int index, short x, short y, short z, short w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4h;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4h\" not available");
    }
        dispatch_glVertexAttrib4h1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4hNV}(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public native void dispatch_glVertexAttrib4h1(int index, short x, short y, short z, short w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4hvNV}(GLuint index, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib4hv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4hv\" not available");
    }
        dispatch_glVertexAttrib4hv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4hvNV}(GLuint index, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib4hv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4hvNV}(GLuint index, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glVertexAttrib4hv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4hv\" not available");
    }
        dispatch_glVertexAttrib4hv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4iv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttrib4iv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4iv\" not available");
    }
        dispatch_glVertexAttrib4iv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4iv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttrib4iv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4iv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib4iv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4iv\" not available");
    }
        dispatch_glVertexAttrib4iv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4ivARB}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttrib4ivARB(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4ivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4ivARB\" not available");
    }
        dispatch_glVertexAttrib4ivARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4ivARB}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttrib4ivARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4ivARB}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib4ivARB(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4ivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4ivARB\" not available");
    }
        dispatch_glVertexAttrib4ivARB1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4s}(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib4s(int index, short x, short y, short z, short w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4s\" not available");
    }
        dispatch_glVertexAttrib4s1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4s}(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public native void dispatch_glVertexAttrib4s1(int index, short x, short y, short z, short w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4sARB}(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib4sARB(int index, short x, short y, short z, short w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4sARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4sARB\" not available");
    }
        dispatch_glVertexAttrib4sARB1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4sARB}(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public native void dispatch_glVertexAttrib4sARB1(int index, short x, short y, short z, short w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4sv}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib4sv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4sv\" not available");
    }
        dispatch_glVertexAttrib4sv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4sv}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib4sv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4sv}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib4sv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4sv\" not available");
    }
        dispatch_glVertexAttrib4sv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4svARB}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib4svARB(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4svARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4svARB\" not available");
    }
        dispatch_glVertexAttrib4svARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4svARB}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib4svARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4svARB}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib4svARB(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4svARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4svARB\" not available");
    }
        dispatch_glVertexAttrib4svARB1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4ubv}(GLuint index, const GLubyte *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttrib4ubv(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4ubv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4ubv\" not available");
    }
        dispatch_glVertexAttrib4ubv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4ubv}(GLuint index, const GLubyte *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttrib4ubv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4ubv}(GLuint index, const GLubyte *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib4ubv(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4ubv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4ubv\" not available");
    }
        dispatch_glVertexAttrib4ubv1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4ubvARB}(GLuint index, const GLubyte *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttrib4ubvARB(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4ubvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4ubvARB\" not available");
    }
        dispatch_glVertexAttrib4ubvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4ubvARB}(GLuint index, const GLubyte *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttrib4ubvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4ubvARB}(GLuint index, const GLubyte *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib4ubvARB(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4ubvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4ubvARB\" not available");
    }
        dispatch_glVertexAttrib4ubvARB1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4uiv}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttrib4uiv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4uiv\" not available");
    }
        dispatch_glVertexAttrib4uiv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4uiv}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttrib4uiv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4uiv}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib4uiv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4uiv\" not available");
    }
        dispatch_glVertexAttrib4uiv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4uivARB}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttrib4uivARB(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4uivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4uivARB\" not available");
    }
        dispatch_glVertexAttrib4uivARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4uivARB}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttrib4uivARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4uivARB}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib4uivARB(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4uivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4uivARB\" not available");
    }
        dispatch_glVertexAttrib4uivARB1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4usv}(GLuint index, const GLushort *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib4usv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4usv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4usv\" not available");
    }
        dispatch_glVertexAttrib4usv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4usv}(GLuint index, const GLushort *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib4usv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4usv}(GLuint index, const GLushort *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib4usv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4usv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4usv\" not available");
    }
        dispatch_glVertexAttrib4usv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4usvARB}(GLuint index, const GLushort *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib4usvARB(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4usvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4usvARB\" not available");
    }
        dispatch_glVertexAttrib4usvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4usvARB}(GLuint index, const GLushort *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib4usvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4usvARB}(GLuint index, const GLushort *  v); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttrib4usvARB(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4usvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4usvARB\" not available");
    }
        dispatch_glVertexAttrib4usvARB1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribDivisor}(GLuint index, GLuint divisor); </code> <br>Part of <code>GL_VERSION_3_3</code>; <code>GL_ARB_instanced_arrays</code>   */
  public void glVertexAttribDivisor(int index, int divisor)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribDivisor;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribDivisor\" not available");
    }
        dispatch_glVertexAttribDivisor1(index, divisor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribDivisor}(GLuint index, GLuint divisor); </code> <br>Part of <code>GL_VERSION_3_3</code>; <code>GL_ARB_instanced_arrays</code>   */
  public native void dispatch_glVertexAttribDivisor1(int index, int divisor, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribFormatNV}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public void glVertexAttribFormatNV(int index, int size, int type, boolean normalized, int stride)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribFormatNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribFormatNV\" not available");
    }
        dispatch_glVertexAttribFormatNV1(index, size, type, normalized, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribFormatNV}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public native void dispatch_glVertexAttribFormatNV1(int index, int size, int type, boolean normalized, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI1i}(GLuint index, GLint x); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI1i(int index, int x)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI1i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI1i\" not available");
    }
        dispatch_glVertexAttribI1i1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI1i}(GLuint index, GLint x); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public native void dispatch_glVertexAttribI1i1(int index, int x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI1iEXT}(GLuint index, GLint x); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public void glVertexAttribI1iEXT(int index, int x)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI1iEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI1iEXT\" not available");
    }
        dispatch_glVertexAttribI1iEXT1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI1iEXT}(GLuint index, GLint x); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public native void dispatch_glVertexAttribI1iEXT1(int index, int x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI1iv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI1iv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI1iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI1iv\" not available");
    }
        dispatch_glVertexAttribI1iv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI1iv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI1iv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI1iv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI1iv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI1iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI1iv\" not available");
    }
        dispatch_glVertexAttribI1iv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI1ivEXT}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI1ivEXT(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI1ivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI1ivEXT\" not available");
    }
        dispatch_glVertexAttribI1ivEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI1ivEXT}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI1ivEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI1ivEXT}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public void glVertexAttribI1ivEXT(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI1ivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI1ivEXT\" not available");
    }
        dispatch_glVertexAttribI1ivEXT1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI1ui}(GLuint index, GLuint x); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI1ui(int index, int x)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI1ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI1ui\" not available");
    }
        dispatch_glVertexAttribI1ui1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI1ui}(GLuint index, GLuint x); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public native void dispatch_glVertexAttribI1ui1(int index, int x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI1uiEXT}(GLuint index, GLuint x); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public void glVertexAttribI1uiEXT(int index, int x)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI1uiEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI1uiEXT\" not available");
    }
        dispatch_glVertexAttribI1uiEXT1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI1uiEXT}(GLuint index, GLuint x); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public native void dispatch_glVertexAttribI1uiEXT1(int index, int x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI1uiv}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI1uiv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI1uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI1uiv\" not available");
    }
        dispatch_glVertexAttribI1uiv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI1uiv}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI1uiv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI1uiv}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI1uiv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI1uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI1uiv\" not available");
    }
        dispatch_glVertexAttribI1uiv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI1uivEXT}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI1uivEXT(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI1uivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI1uivEXT\" not available");
    }
        dispatch_glVertexAttribI1uivEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI1uivEXT}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI1uivEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI1uivEXT}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public void glVertexAttribI1uivEXT(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI1uivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI1uivEXT\" not available");
    }
        dispatch_glVertexAttribI1uivEXT1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2i}(GLuint index, GLint x, GLint y); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI2i(int index, int x, int y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI2i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI2i\" not available");
    }
        dispatch_glVertexAttribI2i1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2i}(GLuint index, GLint x, GLint y); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public native void dispatch_glVertexAttribI2i1(int index, int x, int y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI2iEXT}(GLuint index, GLint x, GLint y); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public void glVertexAttribI2iEXT(int index, int x, int y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI2iEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI2iEXT\" not available");
    }
        dispatch_glVertexAttribI2iEXT1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2iEXT}(GLuint index, GLint x, GLint y); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public native void dispatch_glVertexAttribI2iEXT1(int index, int x, int y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI2iv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI2iv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI2iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI2iv\" not available");
    }
        dispatch_glVertexAttribI2iv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2iv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI2iv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI2iv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI2iv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI2iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI2iv\" not available");
    }
        dispatch_glVertexAttribI2iv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2ivEXT}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI2ivEXT(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI2ivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI2ivEXT\" not available");
    }
        dispatch_glVertexAttribI2ivEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2ivEXT}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI2ivEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI2ivEXT}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public void glVertexAttribI2ivEXT(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI2ivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI2ivEXT\" not available");
    }
        dispatch_glVertexAttribI2ivEXT1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2ui}(GLuint index, GLuint x, GLuint y); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI2ui(int index, int x, int y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI2ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI2ui\" not available");
    }
        dispatch_glVertexAttribI2ui1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2ui}(GLuint index, GLuint x, GLuint y); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public native void dispatch_glVertexAttribI2ui1(int index, int x, int y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI2uiEXT}(GLuint index, GLuint x, GLuint y); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public void glVertexAttribI2uiEXT(int index, int x, int y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI2uiEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI2uiEXT\" not available");
    }
        dispatch_glVertexAttribI2uiEXT1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2uiEXT}(GLuint index, GLuint x, GLuint y); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public native void dispatch_glVertexAttribI2uiEXT1(int index, int x, int y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI2uiv}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI2uiv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI2uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI2uiv\" not available");
    }
        dispatch_glVertexAttribI2uiv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2uiv}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI2uiv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI2uiv}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI2uiv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI2uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI2uiv\" not available");
    }
        dispatch_glVertexAttribI2uiv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2uivEXT}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI2uivEXT(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI2uivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI2uivEXT\" not available");
    }
        dispatch_glVertexAttribI2uivEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2uivEXT}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI2uivEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI2uivEXT}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public void glVertexAttribI2uivEXT(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI2uivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI2uivEXT\" not available");
    }
        dispatch_glVertexAttribI2uivEXT1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3i}(GLuint index, GLint x, GLint y, GLint z); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI3i(int index, int x, int y, int z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI3i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI3i\" not available");
    }
        dispatch_glVertexAttribI3i1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3i}(GLuint index, GLint x, GLint y, GLint z); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public native void dispatch_glVertexAttribI3i1(int index, int x, int y, int z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI3iEXT}(GLuint index, GLint x, GLint y, GLint z); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public void glVertexAttribI3iEXT(int index, int x, int y, int z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI3iEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI3iEXT\" not available");
    }
        dispatch_glVertexAttribI3iEXT1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3iEXT}(GLuint index, GLint x, GLint y, GLint z); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public native void dispatch_glVertexAttribI3iEXT1(int index, int x, int y, int z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI3iv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI3iv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI3iv\" not available");
    }
        dispatch_glVertexAttribI3iv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3iv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI3iv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI3iv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI3iv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI3iv\" not available");
    }
        dispatch_glVertexAttribI3iv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3ivEXT}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI3ivEXT(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI3ivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI3ivEXT\" not available");
    }
        dispatch_glVertexAttribI3ivEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3ivEXT}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI3ivEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI3ivEXT}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public void glVertexAttribI3ivEXT(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI3ivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI3ivEXT\" not available");
    }
        dispatch_glVertexAttribI3ivEXT1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3ui}(GLuint index, GLuint x, GLuint y, GLuint z); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI3ui(int index, int x, int y, int z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI3ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI3ui\" not available");
    }
        dispatch_glVertexAttribI3ui1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3ui}(GLuint index, GLuint x, GLuint y, GLuint z); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public native void dispatch_glVertexAttribI3ui1(int index, int x, int y, int z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI3uiEXT}(GLuint index, GLuint x, GLuint y, GLuint z); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public void glVertexAttribI3uiEXT(int index, int x, int y, int z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI3uiEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI3uiEXT\" not available");
    }
        dispatch_glVertexAttribI3uiEXT1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3uiEXT}(GLuint index, GLuint x, GLuint y, GLuint z); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public native void dispatch_glVertexAttribI3uiEXT1(int index, int x, int y, int z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI3uiv}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI3uiv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI3uiv\" not available");
    }
        dispatch_glVertexAttribI3uiv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3uiv}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI3uiv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI3uiv}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI3uiv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI3uiv\" not available");
    }
        dispatch_glVertexAttribI3uiv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3uivEXT}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI3uivEXT(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI3uivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI3uivEXT\" not available");
    }
        dispatch_glVertexAttribI3uivEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3uivEXT}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI3uivEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI3uivEXT}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public void glVertexAttribI3uivEXT(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI3uivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI3uivEXT\" not available");
    }
        dispatch_glVertexAttribI3uivEXT1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4bv}(GLuint index, const GLbyte *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttribI4bv(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4bv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4bv\" not available");
    }
        dispatch_glVertexAttribI4bv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4bv}(GLuint index, const GLbyte *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttribI4bv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4bv}(GLuint index, const GLbyte *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI4bv(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4bv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4bv\" not available");
    }
        dispatch_glVertexAttribI4bv1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4bvEXT}(GLuint index, const GLbyte *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttribI4bvEXT(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4bvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4bvEXT\" not available");
    }
        dispatch_glVertexAttribI4bvEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4bvEXT}(GLuint index, const GLbyte *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttribI4bvEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4bvEXT}(GLuint index, const GLbyte *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public void glVertexAttribI4bvEXT(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4bvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4bvEXT\" not available");
    }
        dispatch_glVertexAttribI4bvEXT1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4i}(GLuint index, GLint x, GLint y, GLint z, GLint w); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI4i(int index, int x, int y, int z, int w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4i\" not available");
    }
        dispatch_glVertexAttribI4i1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4i}(GLuint index, GLint x, GLint y, GLint z, GLint w); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public native void dispatch_glVertexAttribI4i1(int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4iEXT}(GLuint index, GLint x, GLint y, GLint z, GLint w); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public void glVertexAttribI4iEXT(int index, int x, int y, int z, int w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4iEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4iEXT\" not available");
    }
        dispatch_glVertexAttribI4iEXT1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4iEXT}(GLuint index, GLint x, GLint y, GLint z, GLint w); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public native void dispatch_glVertexAttribI4iEXT1(int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4iv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI4iv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4iv\" not available");
    }
        dispatch_glVertexAttribI4iv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4iv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI4iv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4iv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI4iv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4iv\" not available");
    }
        dispatch_glVertexAttribI4iv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ivEXT}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI4ivEXT(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4ivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4ivEXT\" not available");
    }
        dispatch_glVertexAttribI4ivEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ivEXT}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI4ivEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ivEXT}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public void glVertexAttribI4ivEXT(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4ivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4ivEXT\" not available");
    }
        dispatch_glVertexAttribI4ivEXT1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4sv}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttribI4sv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4sv\" not available");
    }
        dispatch_glVertexAttribI4sv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4sv}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttribI4sv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4sv}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI4sv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4sv\" not available");
    }
        dispatch_glVertexAttribI4sv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4svEXT}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttribI4svEXT(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4svEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4svEXT\" not available");
    }
        dispatch_glVertexAttribI4svEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4svEXT}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttribI4svEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4svEXT}(GLuint index, const GLshort *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public void glVertexAttribI4svEXT(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4svEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4svEXT\" not available");
    }
        dispatch_glVertexAttribI4svEXT1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ubv}(GLuint index, const GLubyte *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttribI4ubv(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4ubv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4ubv\" not available");
    }
        dispatch_glVertexAttribI4ubv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ubv}(GLuint index, const GLubyte *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttribI4ubv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ubv}(GLuint index, const GLubyte *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI4ubv(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4ubv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4ubv\" not available");
    }
        dispatch_glVertexAttribI4ubv1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ubvEXT}(GLuint index, const GLubyte *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttribI4ubvEXT(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4ubvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4ubvEXT\" not available");
    }
        dispatch_glVertexAttribI4ubvEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ubvEXT}(GLuint index, const GLubyte *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttribI4ubvEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ubvEXT}(GLuint index, const GLubyte *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public void glVertexAttribI4ubvEXT(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4ubvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4ubvEXT\" not available");
    }
        dispatch_glVertexAttribI4ubvEXT1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ui}(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI4ui(int index, int x, int y, int z, int w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4ui\" not available");
    }
        dispatch_glVertexAttribI4ui1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ui}(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public native void dispatch_glVertexAttribI4ui1(int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4uiEXT}(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public void glVertexAttribI4uiEXT(int index, int x, int y, int z, int w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4uiEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4uiEXT\" not available");
    }
        dispatch_glVertexAttribI4uiEXT1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4uiEXT}(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public native void dispatch_glVertexAttribI4uiEXT1(int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4uiv}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI4uiv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4uiv\" not available");
    }
        dispatch_glVertexAttribI4uiv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4uiv}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI4uiv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4uiv}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI4uiv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4uiv\" not available");
    }
        dispatch_glVertexAttribI4uiv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4uivEXT}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI4uivEXT(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4uivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4uivEXT\" not available");
    }
        dispatch_glVertexAttribI4uivEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4uivEXT}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI4uivEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4uivEXT}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public void glVertexAttribI4uivEXT(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4uivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4uivEXT\" not available");
    }
        dispatch_glVertexAttribI4uivEXT1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4usv}(GLuint index, const GLushort *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttribI4usv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4usv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4usv\" not available");
    }
        dispatch_glVertexAttribI4usv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4usv}(GLuint index, const GLushort *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttribI4usv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4usv}(GLuint index, const GLushort *  v); </code> <br>Part of <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI4usv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4usv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4usv\" not available");
    }
        dispatch_glVertexAttribI4usv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4usvEXT}(GLuint index, const GLushort *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttribI4usvEXT(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4usvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4usvEXT\" not available");
    }
        dispatch_glVertexAttribI4usvEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4usvEXT}(GLuint index, const GLushort *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttribI4usvEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4usvEXT}(GLuint index, const GLushort *  v); </code> <br>Part of <code>GL_NV_vertex_program4</code>   */
  public void glVertexAttribI4usvEXT(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4usvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribI4usvEXT\" not available");
    }
        dispatch_glVertexAttribI4usvEXT1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribIFormatNV}(GLuint index, GLint size, GLenum type, GLsizei stride); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public void glVertexAttribIFormatNV(int index, int size, int type, int stride)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribIFormatNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribIFormatNV\" not available");
    }
        dispatch_glVertexAttribIFormatNV1(index, size, type, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribIFormatNV}(GLuint index, GLint size, GLenum type, GLsizei stride); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public native void dispatch_glVertexAttribIFormatNV1(int index, int size, int type, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribIPointer}(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glVertexAttribIPointer(int index, int size, int type, int stride, Buffer pointer)  {

    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribIPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribIPointer\" not available");
    }
        dispatch_glVertexAttribIPointer1(index, size, type, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribIPointer}(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_3_0</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glVertexAttribIPointer1(int index, int size, int type, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribIPointerEXT}(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glVertexAttribIPointerEXT(int index, int size, int type, int stride, Buffer pointer)  {

    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribIPointerEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribIPointerEXT\" not available");
    }
        dispatch_glVertexAttribIPointerEXT1(index, size, type, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribIPointerEXT}(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_NV_vertex_program4</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glVertexAttribIPointerEXT1(int index, int size, int type, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL1d}(GLuint index, GLdouble x); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>   */
  public void glVertexAttribL1d(int index, double x)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL1d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL1d\" not available");
    }
        dispatch_glVertexAttribL1d1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL1d}(GLuint index, GLdouble x); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>   */
  public native void dispatch_glVertexAttribL1d1(int index, double x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL1dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttribL1dv(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL1dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL1dv\" not available");
    }
        dispatch_glVertexAttribL1dv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL1dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttribL1dv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL1dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>   */
  public void glVertexAttribL1dv(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL1dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL1dv\" not available");
    }
        dispatch_glVertexAttribL1dv1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL1i64NV}(GLuint index, GLint64EXT x); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public void glVertexAttribL1i64NV(int index, long x)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL1i64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL1i64NV\" not available");
    }
        dispatch_glVertexAttribL1i64NV1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL1i64NV}(GLuint index, GLint64EXT x); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public native void dispatch_glVertexAttribL1i64NV1(int index, long x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL1i64vNV}(GLuint index, const GLint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glVertexAttribL1i64vNV(int index, LongBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL1i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL1i64vNV\" not available");
    }
        dispatch_glVertexAttribL1i64vNV1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL1i64vNV}(GLuint index, const GLint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glVertexAttribL1i64vNV1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL1i64vNV}(GLuint index, const GLint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public void glVertexAttribL1i64vNV(int index, long[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL1i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL1i64vNV\" not available");
    }
        dispatch_glVertexAttribL1i64vNV1(index, v, Buffers.SIZEOF_LONG * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL1ui64NV}(GLuint index, GLuint64EXT x); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public void glVertexAttribL1ui64NV(int index, long x)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL1ui64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL1ui64NV\" not available");
    }
        dispatch_glVertexAttribL1ui64NV1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL1ui64NV}(GLuint index, GLuint64EXT x); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public native void dispatch_glVertexAttribL1ui64NV1(int index, long x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL1ui64vNV}(GLuint index, const GLuint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glVertexAttribL1ui64vNV(int index, LongBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL1ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL1ui64vNV\" not available");
    }
        dispatch_glVertexAttribL1ui64vNV1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL1ui64vNV}(GLuint index, const GLuint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glVertexAttribL1ui64vNV1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL1ui64vNV}(GLuint index, const GLuint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public void glVertexAttribL1ui64vNV(int index, long[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL1ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL1ui64vNV\" not available");
    }
        dispatch_glVertexAttribL1ui64vNV1(index, v, Buffers.SIZEOF_LONG * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL2d}(GLuint index, GLdouble x, GLdouble y); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>   */
  public void glVertexAttribL2d(int index, double x, double y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL2d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL2d\" not available");
    }
        dispatch_glVertexAttribL2d1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL2d}(GLuint index, GLdouble x, GLdouble y); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>   */
  public native void dispatch_glVertexAttribL2d1(int index, double x, double y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL2dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttribL2dv(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL2dv\" not available");
    }
        dispatch_glVertexAttribL2dv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL2dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttribL2dv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL2dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>   */
  public void glVertexAttribL2dv(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL2dv\" not available");
    }
        dispatch_glVertexAttribL2dv1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL2i64NV}(GLuint index, GLint64EXT x, GLint64EXT y); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public void glVertexAttribL2i64NV(int index, long x, long y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL2i64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL2i64NV\" not available");
    }
        dispatch_glVertexAttribL2i64NV1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL2i64NV}(GLuint index, GLint64EXT x, GLint64EXT y); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public native void dispatch_glVertexAttribL2i64NV1(int index, long x, long y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL2i64vNV}(GLuint index, const GLint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glVertexAttribL2i64vNV(int index, LongBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL2i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL2i64vNV\" not available");
    }
        dispatch_glVertexAttribL2i64vNV1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL2i64vNV}(GLuint index, const GLint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glVertexAttribL2i64vNV1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL2i64vNV}(GLuint index, const GLint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public void glVertexAttribL2i64vNV(int index, long[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL2i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL2i64vNV\" not available");
    }
        dispatch_glVertexAttribL2i64vNV1(index, v, Buffers.SIZEOF_LONG * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL2ui64NV}(GLuint index, GLuint64EXT x, GLuint64EXT y); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public void glVertexAttribL2ui64NV(int index, long x, long y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL2ui64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL2ui64NV\" not available");
    }
        dispatch_glVertexAttribL2ui64NV1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL2ui64NV}(GLuint index, GLuint64EXT x, GLuint64EXT y); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public native void dispatch_glVertexAttribL2ui64NV1(int index, long x, long y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL2ui64vNV}(GLuint index, const GLuint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glVertexAttribL2ui64vNV(int index, LongBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL2ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL2ui64vNV\" not available");
    }
        dispatch_glVertexAttribL2ui64vNV1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL2ui64vNV}(GLuint index, const GLuint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glVertexAttribL2ui64vNV1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL2ui64vNV}(GLuint index, const GLuint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public void glVertexAttribL2ui64vNV(int index, long[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL2ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL2ui64vNV\" not available");
    }
        dispatch_glVertexAttribL2ui64vNV1(index, v, Buffers.SIZEOF_LONG * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL3d}(GLuint index, GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>   */
  public void glVertexAttribL3d(int index, double x, double y, double z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL3d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL3d\" not available");
    }
        dispatch_glVertexAttribL3d1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL3d}(GLuint index, GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>   */
  public native void dispatch_glVertexAttribL3d1(int index, double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL3dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttribL3dv(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL3dv\" not available");
    }
        dispatch_glVertexAttribL3dv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL3dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttribL3dv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL3dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>   */
  public void glVertexAttribL3dv(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL3dv\" not available");
    }
        dispatch_glVertexAttribL3dv1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL3i64NV}(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public void glVertexAttribL3i64NV(int index, long x, long y, long z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL3i64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL3i64NV\" not available");
    }
        dispatch_glVertexAttribL3i64NV1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL3i64NV}(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public native void dispatch_glVertexAttribL3i64NV1(int index, long x, long y, long z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL3i64vNV}(GLuint index, const GLint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glVertexAttribL3i64vNV(int index, LongBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL3i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL3i64vNV\" not available");
    }
        dispatch_glVertexAttribL3i64vNV1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL3i64vNV}(GLuint index, const GLint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glVertexAttribL3i64vNV1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL3i64vNV}(GLuint index, const GLint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public void glVertexAttribL3i64vNV(int index, long[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL3i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL3i64vNV\" not available");
    }
        dispatch_glVertexAttribL3i64vNV1(index, v, Buffers.SIZEOF_LONG * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL3ui64NV}(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public void glVertexAttribL3ui64NV(int index, long x, long y, long z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL3ui64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL3ui64NV\" not available");
    }
        dispatch_glVertexAttribL3ui64NV1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL3ui64NV}(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public native void dispatch_glVertexAttribL3ui64NV1(int index, long x, long y, long z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL3ui64vNV}(GLuint index, const GLuint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glVertexAttribL3ui64vNV(int index, LongBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL3ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL3ui64vNV\" not available");
    }
        dispatch_glVertexAttribL3ui64vNV1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL3ui64vNV}(GLuint index, const GLuint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glVertexAttribL3ui64vNV1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL3ui64vNV}(GLuint index, const GLuint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public void glVertexAttribL3ui64vNV(int index, long[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL3ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL3ui64vNV\" not available");
    }
        dispatch_glVertexAttribL3ui64vNV1(index, v, Buffers.SIZEOF_LONG * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL4d}(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>   */
  public void glVertexAttribL4d(int index, double x, double y, double z, double w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL4d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL4d\" not available");
    }
        dispatch_glVertexAttribL4d1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL4d}(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>   */
  public native void dispatch_glVertexAttribL4d1(int index, double x, double y, double z, double w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL4dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttribL4dv(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL4dv\" not available");
    }
        dispatch_glVertexAttribL4dv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL4dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttribL4dv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL4dv}(GLuint index, const GLdouble *  v); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>   */
  public void glVertexAttribL4dv(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL4dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL4dv\" not available");
    }
        dispatch_glVertexAttribL4dv1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL4i64NV}(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public void glVertexAttribL4i64NV(int index, long x, long y, long z, long w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL4i64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL4i64NV\" not available");
    }
        dispatch_glVertexAttribL4i64NV1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL4i64NV}(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public native void dispatch_glVertexAttribL4i64NV1(int index, long x, long y, long z, long w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL4i64vNV}(GLuint index, const GLint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glVertexAttribL4i64vNV(int index, LongBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL4i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL4i64vNV\" not available");
    }
        dispatch_glVertexAttribL4i64vNV1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL4i64vNV}(GLuint index, const GLint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glVertexAttribL4i64vNV1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL4i64vNV}(GLuint index, const GLint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public void glVertexAttribL4i64vNV(int index, long[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL4i64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL4i64vNV\" not available");
    }
        dispatch_glVertexAttribL4i64vNV1(index, v, Buffers.SIZEOF_LONG * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL4ui64NV}(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public void glVertexAttribL4ui64NV(int index, long x, long y, long z, long w)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL4ui64NV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL4ui64NV\" not available");
    }
        dispatch_glVertexAttribL4ui64NV1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL4ui64NV}(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public native void dispatch_glVertexAttribL4ui64NV1(int index, long x, long y, long z, long w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL4ui64vNV}(GLuint index, const GLuint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glVertexAttribL4ui64vNV(int index, LongBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL4ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL4ui64vNV\" not available");
    }
        dispatch_glVertexAttribL4ui64vNV1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL4ui64vNV}(GLuint index, const GLuint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glVertexAttribL4ui64vNV1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL4ui64vNV}(GLuint index, const GLuint64EXT *  v); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public void glVertexAttribL4ui64vNV(int index, long[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribL4ui64vNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribL4ui64vNV\" not available");
    }
        dispatch_glVertexAttribL4ui64vNV1(index, v, Buffers.SIZEOF_LONG * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribLFormatNV}(GLuint index, GLint size, GLenum type, GLsizei stride); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public void glVertexAttribLFormatNV(int index, int size, int type, int stride)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribLFormatNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribLFormatNV\" not available");
    }
        dispatch_glVertexAttribLFormatNV1(index, size, type, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribLFormatNV}(GLuint index, GLint size, GLenum type, GLsizei stride); </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code>   */
  public native void dispatch_glVertexAttribLFormatNV1(int index, int size, int type, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribLPointer}(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glVertexAttribLPointer(int index, int size, int type, int stride, Buffer pointer)  {

    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribLPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribLPointer\" not available");
    }
        dispatch_glVertexAttribLPointer1(index, size, type, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribLPointer}(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glVertexAttribLPointer1(int index, int size, int type, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribP1ui}(GLuint index, GLenum type, GLboolean normalized, GLuint value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glVertexAttribP1ui(int index, int type, boolean normalized, int value)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribP1ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribP1ui\" not available");
    }
        dispatch_glVertexAttribP1ui1(index, type, normalized, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribP1ui}(GLuint index, GLenum type, GLboolean normalized, GLuint value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public native void dispatch_glVertexAttribP1ui1(int index, int type, boolean normalized, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribP1uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribP1uiv(int index, int type, boolean normalized, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribP1uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribP1uiv\" not available");
    }
        dispatch_glVertexAttribP1uiv1(index, type, normalized, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribP1uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribP1uiv1(int index, int type, boolean normalized, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribP1uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glVertexAttribP1uiv(int index, int type, boolean normalized, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribP1uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribP1uiv\" not available");
    }
        dispatch_glVertexAttribP1uiv1(index, type, normalized, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribP2ui}(GLuint index, GLenum type, GLboolean normalized, GLuint value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glVertexAttribP2ui(int index, int type, boolean normalized, int value)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribP2ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribP2ui\" not available");
    }
        dispatch_glVertexAttribP2ui1(index, type, normalized, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribP2ui}(GLuint index, GLenum type, GLboolean normalized, GLuint value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public native void dispatch_glVertexAttribP2ui1(int index, int type, boolean normalized, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribP2uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribP2uiv(int index, int type, boolean normalized, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribP2uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribP2uiv\" not available");
    }
        dispatch_glVertexAttribP2uiv1(index, type, normalized, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribP2uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribP2uiv1(int index, int type, boolean normalized, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribP2uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glVertexAttribP2uiv(int index, int type, boolean normalized, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribP2uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribP2uiv\" not available");
    }
        dispatch_glVertexAttribP2uiv1(index, type, normalized, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribP3ui}(GLuint index, GLenum type, GLboolean normalized, GLuint value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glVertexAttribP3ui(int index, int type, boolean normalized, int value)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribP3ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribP3ui\" not available");
    }
        dispatch_glVertexAttribP3ui1(index, type, normalized, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribP3ui}(GLuint index, GLenum type, GLboolean normalized, GLuint value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public native void dispatch_glVertexAttribP3ui1(int index, int type, boolean normalized, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribP3uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribP3uiv(int index, int type, boolean normalized, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribP3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribP3uiv\" not available");
    }
        dispatch_glVertexAttribP3uiv1(index, type, normalized, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribP3uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribP3uiv1(int index, int type, boolean normalized, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribP3uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glVertexAttribP3uiv(int index, int type, boolean normalized, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribP3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribP3uiv\" not available");
    }
        dispatch_glVertexAttribP3uiv1(index, type, normalized, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribP4ui}(GLuint index, GLenum type, GLboolean normalized, GLuint value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glVertexAttribP4ui(int index, int type, boolean normalized, int value)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribP4ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribP4ui\" not available");
    }
        dispatch_glVertexAttribP4ui1(index, type, normalized, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribP4ui}(GLuint index, GLenum type, GLboolean normalized, GLuint value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public native void dispatch_glVertexAttribP4ui1(int index, int type, boolean normalized, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribP4uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribP4uiv(int index, int type, boolean normalized, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribP4uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribP4uiv\" not available");
    }
        dispatch_glVertexAttribP4uiv1(index, type, normalized, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribP4uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribP4uiv1(int index, int type, boolean normalized, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribP4uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glVertexAttribP4uiv(int index, int type, boolean normalized, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribP4uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribP4uiv\" not available");
    }
        dispatch_glVertexAttribP4uiv1(index, type, normalized, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribPointer}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glVertexAttribPointer(int index, int size, int type, boolean normalized, int stride, Buffer pointer)  {

    checkArrayVBODisabled(true);
    Buffers.rangeCheck(pointer, 1);
    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribPointer\" not available");
    }
        dispatch_glVertexAttribPointer1(index, size, type, normalized, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribPointer}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_2_0</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glVertexAttribPointer1(int index, int size, int type, boolean normalized, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribPointer}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  public void glVertexAttribPointer(int index, int size, int type, boolean normalized, int stride, long pointer_buffer_offset)  {

    checkArrayVBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribPointer\" not available");
    }
        dispatch_glVertexAttribPointer1(index, size, type, normalized, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribPointer}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glVertexAttribPointer1(int index, int size, int type, boolean normalized, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribPointerARB}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glVertexAttribPointerARB(int index, int size, int type, boolean normalized, int stride, Buffer pointer)  {

    checkArrayVBODisabled(true);
    Buffers.rangeCheck(pointer, 1);
    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribPointerARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribPointerARB\" not available");
    }
        dispatch_glVertexAttribPointerARB1(index, size, type, normalized, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribPointerARB}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_ARB_vertex_program</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glVertexAttribPointerARB1(int index, int size, int type, boolean normalized, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribPointerARB}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  public void glVertexAttribPointerARB(int index, int size, int type, boolean normalized, int stride, long pointer_buffer_offset)  {

    checkArrayVBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribPointerARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribPointerARB\" not available");
    }
        dispatch_glVertexAttribPointerARB1(index, size, type, normalized, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribPointerARB}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_ARB_vertex_program</code>   */
  private native void dispatch_glVertexAttribPointerARB1(int index, int size, int type, boolean normalized, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribs1hvNV}(GLuint index, GLsizei n, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttribs1hv(int index, int n, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribs1hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribs1hv\" not available");
    }
        dispatch_glVertexAttribs1hv1(index, n, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribs1hvNV}(GLuint index, GLsizei n, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttribs1hv1(int index, int n, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribs1hvNV}(GLuint index, GLsizei n, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glVertexAttribs1hv(int index, int n, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribs1hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribs1hv\" not available");
    }
        dispatch_glVertexAttribs1hv1(index, n, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribs2hvNV}(GLuint index, GLsizei n, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttribs2hv(int index, int n, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribs2hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribs2hv\" not available");
    }
        dispatch_glVertexAttribs2hv1(index, n, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribs2hvNV}(GLuint index, GLsizei n, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttribs2hv1(int index, int n, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribs2hvNV}(GLuint index, GLsizei n, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glVertexAttribs2hv(int index, int n, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribs2hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribs2hv\" not available");
    }
        dispatch_glVertexAttribs2hv1(index, n, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribs3hvNV}(GLuint index, GLsizei n, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttribs3hv(int index, int n, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribs3hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribs3hv\" not available");
    }
        dispatch_glVertexAttribs3hv1(index, n, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribs3hvNV}(GLuint index, GLsizei n, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttribs3hv1(int index, int n, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribs3hvNV}(GLuint index, GLsizei n, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glVertexAttribs3hv(int index, int n, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribs3hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribs3hv\" not available");
    }
        dispatch_glVertexAttribs3hv1(index, n, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribs4hvNV}(GLuint index, GLsizei n, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttribs4hv(int index, int n, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribs4hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribs4hv\" not available");
    }
        dispatch_glVertexAttribs4hv1(index, n, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribs4hvNV}(GLuint index, GLsizei n, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttribs4hv1(int index, int n, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribs4hvNV}(GLuint index, GLsizei n, const GLhalfNV *  v); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glVertexAttribs4hv(int index, int n, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribs4hv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribs4hv\" not available");
    }
        dispatch_glVertexAttribs4hv1(index, n, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexBlendARB}(GLint count); </code> <br>Part of <code>GL_ARB_vertex_blend</code>   */
  public void glVertexBlendARB(int count)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexBlendARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexBlendARB\" not available");
    }
        dispatch_glVertexBlendARB1(count, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexBlendARB}(GLint count); </code> <br>Part of <code>GL_ARB_vertex_blend</code>   */
  public native void dispatch_glVertexBlendARB1(int count, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexFormatNV}(GLint size, GLenum type, GLsizei stride); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public void glVertexFormatNV(int size, int type, int stride)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexFormatNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexFormatNV\" not available");
    }
        dispatch_glVertexFormatNV1(size, type, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexFormatNV}(GLint size, GLenum type, GLsizei stride); </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>   */
  public native void dispatch_glVertexFormatNV1(int size, int type, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexP2ui}(GLenum type, GLuint value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glVertexP2ui(int type, int value)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexP2ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexP2ui\" not available");
    }
        dispatch_glVertexP2ui1(type, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexP2ui}(GLenum type, GLuint value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public native void dispatch_glVertexP2ui1(int type, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexP2uiv}(GLenum type, const GLuint *  value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexP2uiv(int type, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexP2uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexP2uiv\" not available");
    }
        dispatch_glVertexP2uiv1(type, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexP2uiv}(GLenum type, const GLuint *  value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexP2uiv1(int type, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexP2uiv}(GLenum type, const GLuint *  value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glVertexP2uiv(int type, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexP2uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexP2uiv\" not available");
    }
        dispatch_glVertexP2uiv1(type, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexP3ui}(GLenum type, GLuint value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glVertexP3ui(int type, int value)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexP3ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexP3ui\" not available");
    }
        dispatch_glVertexP3ui1(type, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexP3ui}(GLenum type, GLuint value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public native void dispatch_glVertexP3ui1(int type, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexP3uiv}(GLenum type, const GLuint *  value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexP3uiv(int type, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexP3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexP3uiv\" not available");
    }
        dispatch_glVertexP3uiv1(type, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexP3uiv}(GLenum type, const GLuint *  value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexP3uiv1(int type, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexP3uiv}(GLenum type, const GLuint *  value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glVertexP3uiv(int type, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexP3uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexP3uiv\" not available");
    }
        dispatch_glVertexP3uiv1(type, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexP4ui}(GLenum type, GLuint value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glVertexP4ui(int type, int value)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexP4ui;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexP4ui\" not available");
    }
        dispatch_glVertexP4ui1(type, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexP4ui}(GLenum type, GLuint value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public native void dispatch_glVertexP4ui1(int type, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexP4uiv}(GLenum type, const GLuint *  value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexP4uiv(int type, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexP4uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexP4uiv\" not available");
    }
        dispatch_glVertexP4uiv1(type, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexP4uiv}(GLenum type, const GLuint *  value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexP4uiv1(int type, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexP4uiv}(GLenum type, const GLuint *  value); </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>   */
  public void glVertexP4uiv(int type, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexP4uiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexP4uiv\" not available");
    }
        dispatch_glVertexP4uiv1(type, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}   */
  public void glVertexPointer(int size, int type, int stride, Buffer ptr)  {

    checkArrayVBODisabled(true);
    Buffers.rangeCheck(ptr, 1);
    final boolean ptr_is_direct = Buffers.isDirect(ptr);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexPointer\" not available");
    }
        dispatch_glVertexPointer1(size, type, stride, ptr_is_direct ? ptr : Buffers.getArray(ptr), ptr_is_direct ? Buffers.getDirectBufferByteOffset(ptr) : Buffers.getIndirectBufferByteOffset(ptr), ptr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_1_1</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glVertexPointer1(int size, int type, int stride, Object ptr, int ptr_byte_offset, boolean ptr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  public void glVertexPointer(int size, int type, int stride, long ptr_buffer_offset)  {

    checkArrayVBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexPointer\" not available");
    }
        dispatch_glVertexPointer1(size, type, stride, ptr_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_1_1</code>   */
  private native void dispatch_glVertexPointer1(int size, int type, int stride, long ptr_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexWeightPointerEXT}(GLsizei size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_EXT_vertex_weighting</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glVertexWeightPointerEXT(int size, int type, int stride, Buffer pointer)  {

    checkArrayVBODisabled(true);
    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexWeightPointerEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexWeightPointerEXT\" not available");
    }
        dispatch_glVertexWeightPointerEXT1(size, type, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexWeightPointerEXT}(GLsizei size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_EXT_vertex_weighting</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glVertexWeightPointerEXT1(int size, int type, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexWeightPointerEXT}(GLsizei size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_EXT_vertex_weighting</code>   */
  public void glVertexWeightPointerEXT(int size, int type, int stride, long pointer_buffer_offset)  {

    checkArrayVBOEnabled(true);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexWeightPointerEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexWeightPointerEXT\" not available");
    }
        dispatch_glVertexWeightPointerEXT1(size, type, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexWeightPointerEXT}(GLsizei size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_EXT_vertex_weighting</code>   */
  private native void dispatch_glVertexWeightPointerEXT1(int size, int type, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexWeightfEXT}(GLfloat weight); </code> <br>Part of <code>GL_EXT_vertex_weighting</code>   */
  public void glVertexWeightfEXT(float weight)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexWeightfEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexWeightfEXT\" not available");
    }
        dispatch_glVertexWeightfEXT1(weight, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexWeightfEXT}(GLfloat weight); </code> <br>Part of <code>GL_EXT_vertex_weighting</code>   */
  public native void dispatch_glVertexWeightfEXT1(float weight, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexWeightfvEXT}(const GLfloat *  weight); </code> <br>Part of <code>GL_EXT_vertex_weighting</code>
      @param weight a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexWeightfvEXT(FloatBuffer weight)  {

    final boolean weight_is_direct = Buffers.isDirect(weight);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexWeightfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexWeightfvEXT\" not available");
    }
        dispatch_glVertexWeightfvEXT1(weight_is_direct ? weight : Buffers.getArray(weight), weight_is_direct ? Buffers.getDirectBufferByteOffset(weight) : Buffers.getIndirectBufferByteOffset(weight), weight_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexWeightfvEXT}(const GLfloat *  weight); </code> <br>Part of <code>GL_EXT_vertex_weighting</code>
      @param weight a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexWeightfvEXT1(Object weight, int weight_byte_offset, boolean weight_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexWeightfvEXT}(const GLfloat *  weight); </code> <br>Part of <code>GL_EXT_vertex_weighting</code>   */
  public void glVertexWeightfvEXT(float[] weight, int weight_offset)  {

    if(weight != null && weight.length <= weight_offset)
      throw new GLException("array offset argument \"weight_offset\" (" + weight_offset + ") equals or exceeds array length (" + weight.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexWeightfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexWeightfvEXT\" not available");
    }
        dispatch_glVertexWeightfvEXT1(weight, Buffers.SIZEOF_FLOAT * weight_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexWeighthNV}(GLhalfNV weight); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glVertexWeighth(short weight)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexWeighth;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexWeighth\" not available");
    }
        dispatch_glVertexWeighth1(weight, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexWeighthNV}(GLhalfNV weight); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public native void dispatch_glVertexWeighth1(short weight, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexWeighthvNV}(const GLhalfNV *  weight); </code> <br>Part of <code>GL_NV_half_float</code>
      @param weight a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexWeighthv(ShortBuffer weight)  {

    final boolean weight_is_direct = Buffers.isDirect(weight);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexWeighthv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexWeighthv\" not available");
    }
        dispatch_glVertexWeighthv1(weight_is_direct ? weight : Buffers.getArray(weight), weight_is_direct ? Buffers.getDirectBufferByteOffset(weight) : Buffers.getIndirectBufferByteOffset(weight), weight_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexWeighthvNV}(const GLhalfNV *  weight); </code> <br>Part of <code>GL_NV_half_float</code>
      @param weight a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexWeighthv1(Object weight, int weight_byte_offset, boolean weight_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexWeighthvNV}(const GLhalfNV *  weight); </code> <br>Part of <code>GL_NV_half_float</code>   */
  public void glVertexWeighthv(short[] weight, int weight_offset)  {

    if(weight != null && weight.length <= weight_offset)
      throw new GLException("array offset argument \"weight_offset\" (" + weight_offset + ") equals or exceeds array length (" + weight.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexWeighthv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexWeighthv\" not available");
    }
        dispatch_glVertexWeighthv1(weight, Buffers.SIZEOF_SHORT * weight_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glVideoCaptureNV}(GLuint video_capture_slot, GLuint *  sequence_num, GLuint64EXT *  capture_time); </code> <br>Part of <code>GL_NV_video_capture</code>
      @param sequence_num a direct or array-backed {@link java.nio.IntBuffer}
      @param capture_time a direct or array-backed {@link java.nio.LongBuffer}   */
  public int glVideoCaptureNV(int video_capture_slot, IntBuffer sequence_num, LongBuffer capture_time)  {

    final boolean sequence_num_is_direct = Buffers.isDirect(sequence_num);
    final boolean capture_time_is_direct = Buffers.isDirect(capture_time);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVideoCaptureNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVideoCaptureNV\" not available");
    }
        return dispatch_glVideoCaptureNV1(video_capture_slot, sequence_num_is_direct ? sequence_num : Buffers.getArray(sequence_num), sequence_num_is_direct ? Buffers.getDirectBufferByteOffset(sequence_num) : Buffers.getIndirectBufferByteOffset(sequence_num), sequence_num_is_direct, capture_time_is_direct ? capture_time : Buffers.getArray(capture_time), capture_time_is_direct ? Buffers.getDirectBufferByteOffset(capture_time) : Buffers.getIndirectBufferByteOffset(capture_time), capture_time_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glVideoCaptureNV}(GLuint video_capture_slot, GLuint *  sequence_num, GLuint64EXT *  capture_time); </code> <br>Part of <code>GL_NV_video_capture</code>
      @param sequence_num a direct or array-backed {@link java.nio.IntBuffer}
      @param capture_time a direct or array-backed {@link java.nio.LongBuffer}   */
  private native int dispatch_glVideoCaptureNV1(int video_capture_slot, Object sequence_num, int sequence_num_byte_offset, boolean sequence_num_is_direct, Object capture_time, int capture_time_byte_offset, boolean capture_time_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLenum {@native glVideoCaptureNV}(GLuint video_capture_slot, GLuint *  sequence_num, GLuint64EXT *  capture_time); </code> <br>Part of <code>GL_NV_video_capture</code>   */
  public int glVideoCaptureNV(int video_capture_slot, int[] sequence_num, int sequence_num_offset, long[] capture_time, int capture_time_offset)  {

    if(sequence_num != null && sequence_num.length <= sequence_num_offset)
      throw new GLException("array offset argument \"sequence_num_offset\" (" + sequence_num_offset + ") equals or exceeds array length (" + sequence_num.length + ")");
    if(capture_time != null && capture_time.length <= capture_time_offset)
      throw new GLException("array offset argument \"capture_time_offset\" (" + capture_time_offset + ") equals or exceeds array length (" + capture_time.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVideoCaptureNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVideoCaptureNV\" not available");
    }
        return dispatch_glVideoCaptureNV1(video_capture_slot, sequence_num, Buffers.SIZEOF_INT * sequence_num_offset, false, capture_time, Buffers.SIZEOF_LONG * capture_time_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVideoCaptureStreamParameterdvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *  params); </code> <br>Part of <code>GL_NV_video_capture</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVideoCaptureStreamParameterdvNV(int video_capture_slot, int stream, int pname, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVideoCaptureStreamParameterdvNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVideoCaptureStreamParameterdvNV\" not available");
    }
        dispatch_glVideoCaptureStreamParameterdvNV1(video_capture_slot, stream, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVideoCaptureStreamParameterdvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *  params); </code> <br>Part of <code>GL_NV_video_capture</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVideoCaptureStreamParameterdvNV1(int video_capture_slot, int stream, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVideoCaptureStreamParameterdvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *  params); </code> <br>Part of <code>GL_NV_video_capture</code>   */
  public void glVideoCaptureStreamParameterdvNV(int video_capture_slot, int stream, int pname, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVideoCaptureStreamParameterdvNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVideoCaptureStreamParameterdvNV\" not available");
    }
        dispatch_glVideoCaptureStreamParameterdvNV1(video_capture_slot, stream, pname, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVideoCaptureStreamParameterfvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_NV_video_capture</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVideoCaptureStreamParameterfvNV(int video_capture_slot, int stream, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVideoCaptureStreamParameterfvNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVideoCaptureStreamParameterfvNV\" not available");
    }
        dispatch_glVideoCaptureStreamParameterfvNV1(video_capture_slot, stream, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVideoCaptureStreamParameterfvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_NV_video_capture</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVideoCaptureStreamParameterfvNV1(int video_capture_slot, int stream, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVideoCaptureStreamParameterfvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_NV_video_capture</code>   */
  public void glVideoCaptureStreamParameterfvNV(int video_capture_slot, int stream, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVideoCaptureStreamParameterfvNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVideoCaptureStreamParameterfvNV\" not available");
    }
        dispatch_glVideoCaptureStreamParameterfvNV1(video_capture_slot, stream, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVideoCaptureStreamParameterivNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_NV_video_capture</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVideoCaptureStreamParameterivNV(int video_capture_slot, int stream, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVideoCaptureStreamParameterivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVideoCaptureStreamParameterivNV\" not available");
    }
        dispatch_glVideoCaptureStreamParameterivNV1(video_capture_slot, stream, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVideoCaptureStreamParameterivNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_NV_video_capture</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVideoCaptureStreamParameterivNV1(int video_capture_slot, int stream, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVideoCaptureStreamParameterivNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_NV_video_capture</code>   */
  public void glVideoCaptureStreamParameterivNV(int video_capture_slot, int stream, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glVideoCaptureStreamParameterivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVideoCaptureStreamParameterivNV\" not available");
    }
        dispatch_glVideoCaptureStreamParameterivNV1(video_capture_slot, stream, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glViewport}(GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public void glViewport(int x, int y, int width, int height)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glViewport;
    if (__addr_ == 0) {
      throw new GLException("Method \"glViewport\" not available");
    }
        dispatch_glViewport1(x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glViewport}(GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glViewport1(int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glViewportArrayv}(GLuint first, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_ARB_viewport_array</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glViewportArrayv(int first, int count, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glViewportArrayv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glViewportArrayv\" not available");
    }
        dispatch_glViewportArrayv1(first, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glViewportArrayv}(GLuint first, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_ARB_viewport_array</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glViewportArrayv1(int first, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glViewportArrayv}(GLuint first, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_ARB_viewport_array</code>   */
  public void glViewportArrayv(int first, int count, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glViewportArrayv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glViewportArrayv\" not available");
    }
        dispatch_glViewportArrayv1(first, count, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glViewportIndexedf}(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h); </code> <br>Part of <code>GL_ARB_viewport_array</code>   */
  public void glViewportIndexedf(int index, float x, float y, float w, float h)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glViewportIndexedf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glViewportIndexedf\" not available");
    }
        dispatch_glViewportIndexedf1(index, x, y, w, h, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glViewportIndexedf}(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h); </code> <br>Part of <code>GL_ARB_viewport_array</code>   */
  public native void dispatch_glViewportIndexedf1(int index, float x, float y, float w, float h, long procAddress);

  /** Entry point to C language function: <code> void {@native glViewportIndexedfv}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_ARB_viewport_array</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glViewportIndexedfv(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glViewportIndexedfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glViewportIndexedfv\" not available");
    }
        dispatch_glViewportIndexedfv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glViewportIndexedfv}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_ARB_viewport_array</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glViewportIndexedfv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glViewportIndexedfv}(GLuint index, const GLfloat *  v); </code> <br>Part of <code>GL_ARB_viewport_array</code>   */
  public void glViewportIndexedfv(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glViewportIndexedfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glViewportIndexedfv\" not available");
    }
        dispatch_glViewportIndexedfv1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWaitSync}(GLsync sync, GLbitfield flags, GLuint64 timeout); </code> <br>Part of <code>GL_ARB_sync</code>   */
  public void glWaitSync(long sync, int flags, long timeout)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWaitSync;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWaitSync\" not available");
    }
        dispatch_glWaitSync1(sync, flags, timeout, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWaitSync}(GLsync sync, GLbitfield flags, GLuint64 timeout); </code> <br>Part of <code>GL_ARB_sync</code>   */
  public native void dispatch_glWaitSync1(long sync, int flags, long timeout, long procAddress);

  /** Entry point to C language function: <code> void {@native glWeightPointerARB}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_ARB_vertex_blend</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glWeightPointer(int size, int type, int stride, Buffer pointer)  {

    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWeightPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWeightPointer\" not available");
    }
        dispatch_glWeightPointer1(size, type, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightPointerARB}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_ARB_vertex_blend</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glWeightPointer1(int size, int type, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWeightbvARB}(GLint size, const GLbyte *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>
      @param weights a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glWeightbvARB(int size, ByteBuffer weights)  {

    final boolean weights_is_direct = Buffers.isDirect(weights);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWeightbvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWeightbvARB\" not available");
    }
        dispatch_glWeightbvARB1(size, weights_is_direct ? weights : Buffers.getArray(weights), weights_is_direct ? Buffers.getDirectBufferByteOffset(weights) : Buffers.getIndirectBufferByteOffset(weights), weights_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightbvARB}(GLint size, const GLbyte *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>
      @param weights a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glWeightbvARB1(int size, Object weights, int weights_byte_offset, boolean weights_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWeightbvARB}(GLint size, const GLbyte *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>   */
  public void glWeightbvARB(int size, byte[] weights, int weights_offset)  {

    if(weights != null && weights.length <= weights_offset)
      throw new GLException("array offset argument \"weights_offset\" (" + weights_offset + ") equals or exceeds array length (" + weights.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWeightbvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWeightbvARB\" not available");
    }
        dispatch_glWeightbvARB1(size, weights, weights_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightdvARB}(GLint size, const GLdouble *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>
      @param weights a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glWeightdvARB(int size, DoubleBuffer weights)  {

    final boolean weights_is_direct = Buffers.isDirect(weights);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWeightdvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWeightdvARB\" not available");
    }
        dispatch_glWeightdvARB1(size, weights_is_direct ? weights : Buffers.getArray(weights), weights_is_direct ? Buffers.getDirectBufferByteOffset(weights) : Buffers.getIndirectBufferByteOffset(weights), weights_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightdvARB}(GLint size, const GLdouble *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>
      @param weights a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glWeightdvARB1(int size, Object weights, int weights_byte_offset, boolean weights_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWeightdvARB}(GLint size, const GLdouble *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>   */
  public void glWeightdvARB(int size, double[] weights, int weights_offset)  {

    if(weights != null && weights.length <= weights_offset)
      throw new GLException("array offset argument \"weights_offset\" (" + weights_offset + ") equals or exceeds array length (" + weights.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWeightdvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWeightdvARB\" not available");
    }
        dispatch_glWeightdvARB1(size, weights, Buffers.SIZEOF_DOUBLE * weights_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightfvARB}(GLint size, const GLfloat *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>
      @param weights a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glWeightfvARB(int size, FloatBuffer weights)  {

    final boolean weights_is_direct = Buffers.isDirect(weights);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWeightfvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWeightfvARB\" not available");
    }
        dispatch_glWeightfvARB1(size, weights_is_direct ? weights : Buffers.getArray(weights), weights_is_direct ? Buffers.getDirectBufferByteOffset(weights) : Buffers.getIndirectBufferByteOffset(weights), weights_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightfvARB}(GLint size, const GLfloat *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>
      @param weights a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glWeightfvARB1(int size, Object weights, int weights_byte_offset, boolean weights_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWeightfvARB}(GLint size, const GLfloat *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>   */
  public void glWeightfvARB(int size, float[] weights, int weights_offset)  {

    if(weights != null && weights.length <= weights_offset)
      throw new GLException("array offset argument \"weights_offset\" (" + weights_offset + ") equals or exceeds array length (" + weights.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWeightfvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWeightfvARB\" not available");
    }
        dispatch_glWeightfvARB1(size, weights, Buffers.SIZEOF_FLOAT * weights_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightivARB}(GLint size, const GLint *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>
      @param weights a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glWeightivARB(int size, IntBuffer weights)  {

    final boolean weights_is_direct = Buffers.isDirect(weights);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWeightivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWeightivARB\" not available");
    }
        dispatch_glWeightivARB1(size, weights_is_direct ? weights : Buffers.getArray(weights), weights_is_direct ? Buffers.getDirectBufferByteOffset(weights) : Buffers.getIndirectBufferByteOffset(weights), weights_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightivARB}(GLint size, const GLint *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>
      @param weights a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glWeightivARB1(int size, Object weights, int weights_byte_offset, boolean weights_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWeightivARB}(GLint size, const GLint *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>   */
  public void glWeightivARB(int size, int[] weights, int weights_offset)  {

    if(weights != null && weights.length <= weights_offset)
      throw new GLException("array offset argument \"weights_offset\" (" + weights_offset + ") equals or exceeds array length (" + weights.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWeightivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWeightivARB\" not available");
    }
        dispatch_glWeightivARB1(size, weights, Buffers.SIZEOF_INT * weights_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightsvARB}(GLint size, const GLshort *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>
      @param weights a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glWeightsvARB(int size, ShortBuffer weights)  {

    final boolean weights_is_direct = Buffers.isDirect(weights);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWeightsvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWeightsvARB\" not available");
    }
        dispatch_glWeightsvARB1(size, weights_is_direct ? weights : Buffers.getArray(weights), weights_is_direct ? Buffers.getDirectBufferByteOffset(weights) : Buffers.getIndirectBufferByteOffset(weights), weights_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightsvARB}(GLint size, const GLshort *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>
      @param weights a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glWeightsvARB1(int size, Object weights, int weights_byte_offset, boolean weights_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWeightsvARB}(GLint size, const GLshort *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>   */
  public void glWeightsvARB(int size, short[] weights, int weights_offset)  {

    if(weights != null && weights.length <= weights_offset)
      throw new GLException("array offset argument \"weights_offset\" (" + weights_offset + ") equals or exceeds array length (" + weights.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWeightsvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWeightsvARB\" not available");
    }
        dispatch_glWeightsvARB1(size, weights, Buffers.SIZEOF_SHORT * weights_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightubvARB}(GLint size, const GLubyte *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>
      @param weights a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glWeightubvARB(int size, ByteBuffer weights)  {

    final boolean weights_is_direct = Buffers.isDirect(weights);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWeightubvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWeightubvARB\" not available");
    }
        dispatch_glWeightubvARB1(size, weights_is_direct ? weights : Buffers.getArray(weights), weights_is_direct ? Buffers.getDirectBufferByteOffset(weights) : Buffers.getIndirectBufferByteOffset(weights), weights_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightubvARB}(GLint size, const GLubyte *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>
      @param weights a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glWeightubvARB1(int size, Object weights, int weights_byte_offset, boolean weights_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWeightubvARB}(GLint size, const GLubyte *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>   */
  public void glWeightubvARB(int size, byte[] weights, int weights_offset)  {

    if(weights != null && weights.length <= weights_offset)
      throw new GLException("array offset argument \"weights_offset\" (" + weights_offset + ") equals or exceeds array length (" + weights.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWeightubvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWeightubvARB\" not available");
    }
        dispatch_glWeightubvARB1(size, weights, weights_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightuivARB}(GLint size, const GLuint *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>
      @param weights a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glWeightuivARB(int size, IntBuffer weights)  {

    final boolean weights_is_direct = Buffers.isDirect(weights);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWeightuivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWeightuivARB\" not available");
    }
        dispatch_glWeightuivARB1(size, weights_is_direct ? weights : Buffers.getArray(weights), weights_is_direct ? Buffers.getDirectBufferByteOffset(weights) : Buffers.getIndirectBufferByteOffset(weights), weights_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightuivARB}(GLint size, const GLuint *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>
      @param weights a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glWeightuivARB1(int size, Object weights, int weights_byte_offset, boolean weights_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWeightuivARB}(GLint size, const GLuint *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>   */
  public void glWeightuivARB(int size, int[] weights, int weights_offset)  {

    if(weights != null && weights.length <= weights_offset)
      throw new GLException("array offset argument \"weights_offset\" (" + weights_offset + ") equals or exceeds array length (" + weights.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWeightuivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWeightuivARB\" not available");
    }
        dispatch_glWeightuivARB1(size, weights, Buffers.SIZEOF_INT * weights_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightusvARB}(GLint size, const GLushort *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>
      @param weights a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glWeightusvARB(int size, ShortBuffer weights)  {

    final boolean weights_is_direct = Buffers.isDirect(weights);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWeightusvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWeightusvARB\" not available");
    }
        dispatch_glWeightusvARB1(size, weights_is_direct ? weights : Buffers.getArray(weights), weights_is_direct ? Buffers.getDirectBufferByteOffset(weights) : Buffers.getIndirectBufferByteOffset(weights), weights_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightusvARB}(GLint size, const GLushort *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>
      @param weights a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glWeightusvARB1(int size, Object weights, int weights_byte_offset, boolean weights_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWeightusvARB}(GLint size, const GLushort *  weights); </code> <br>Part of <code>GL_ARB_vertex_blend</code>   */
  public void glWeightusvARB(int size, short[] weights, int weights_offset)  {

    if(weights != null && weights.length <= weights_offset)
      throw new GLException("array offset argument \"weights_offset\" (" + weights_offset + ") equals or exceeds array length (" + weights.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWeightusvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWeightusvARB\" not available");
    }
        dispatch_glWeightusvARB1(size, weights, Buffers.SIZEOF_SHORT * weights_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos2d}(GLdouble x, GLdouble y); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glWindowPos2d(double x, double y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos2d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos2d\" not available");
    }
        dispatch_glWindowPos2d1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos2d}(GLdouble x, GLdouble y); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public native void dispatch_glWindowPos2d1(double x, double y, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos2dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glWindowPos2dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos2dv\" not available");
    }
        dispatch_glWindowPos2dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos2dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glWindowPos2dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos2dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glWindowPos2dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos2dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos2dv\" not available");
    }
        dispatch_glWindowPos2dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos2f}(GLfloat x, GLfloat y); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glWindowPos2f(float x, float y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos2f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos2f\" not available");
    }
        dispatch_glWindowPos2f1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos2f}(GLfloat x, GLfloat y); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public native void dispatch_glWindowPos2f1(float x, float y, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos2fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glWindowPos2fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos2fv\" not available");
    }
        dispatch_glWindowPos2fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos2fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glWindowPos2fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos2fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glWindowPos2fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos2fv\" not available");
    }
        dispatch_glWindowPos2fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos2i}(GLint x, GLint y); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glWindowPos2i(int x, int y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos2i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos2i\" not available");
    }
        dispatch_glWindowPos2i1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos2i}(GLint x, GLint y); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public native void dispatch_glWindowPos2i1(int x, int y, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos2iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glWindowPos2iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos2iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos2iv\" not available");
    }
        dispatch_glWindowPos2iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos2iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glWindowPos2iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos2iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glWindowPos2iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos2iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos2iv\" not available");
    }
        dispatch_glWindowPos2iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos2s}(GLshort x, GLshort y); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glWindowPos2s(short x, short y)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos2s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos2s\" not available");
    }
        dispatch_glWindowPos2s1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos2s}(GLshort x, GLshort y); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public native void dispatch_glWindowPos2s1(short x, short y, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos2sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glWindowPos2sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos2sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos2sv\" not available");
    }
        dispatch_glWindowPos2sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos2sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glWindowPos2sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos2sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glWindowPos2sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos2sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos2sv\" not available");
    }
        dispatch_glWindowPos2sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3d}(GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glWindowPos3d(double x, double y, double z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos3d;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos3d\" not available");
    }
        dispatch_glWindowPos3d1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3d}(GLdouble x, GLdouble y, GLdouble z); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public native void dispatch_glWindowPos3d1(double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos3dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glWindowPos3dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos3dv\" not available");
    }
        dispatch_glWindowPos3dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glWindowPos3dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos3dv}(const GLdouble *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glWindowPos3dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos3dv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos3dv\" not available");
    }
        dispatch_glWindowPos3dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3f}(GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glWindowPos3f(float x, float y, float z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos3f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos3f\" not available");
    }
        dispatch_glWindowPos3f1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3f}(GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public native void dispatch_glWindowPos3f1(float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos3fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glWindowPos3fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos3fv\" not available");
    }
        dispatch_glWindowPos3fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glWindowPos3fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos3fv}(const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glWindowPos3fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos3fv\" not available");
    }
        dispatch_glWindowPos3fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3i}(GLint x, GLint y, GLint z); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glWindowPos3i(int x, int y, int z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos3i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos3i\" not available");
    }
        dispatch_glWindowPos3i1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3i}(GLint x, GLint y, GLint z); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public native void dispatch_glWindowPos3i1(int x, int y, int z, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos3iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glWindowPos3iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos3iv\" not available");
    }
        dispatch_glWindowPos3iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glWindowPos3iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos3iv}(const GLint *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glWindowPos3iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos3iv\" not available");
    }
        dispatch_glWindowPos3iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3s}(GLshort x, GLshort y, GLshort z); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glWindowPos3s(short x, short y, short z)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos3s;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos3s\" not available");
    }
        dispatch_glWindowPos3s1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3s}(GLshort x, GLshort y, GLshort z); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public native void dispatch_glWindowPos3s1(short x, short y, short z, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos3sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glWindowPos3sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos3sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos3sv\" not available");
    }
        dispatch_glWindowPos3sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glWindowPos3sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos3sv}(const GLshort *  v); </code> <br>Part of <code>GL_VERSION_1_4_DEPRECATED</code>   */
  public void glWindowPos3sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWindowPos3sv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWindowPos3sv\" not available");
    }
        dispatch_glWindowPos3sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWriteMaskEXT}(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public void glWriteMaskEXT(int res, int in, int outX, int outY, int outZ, int outW)  {

    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glWriteMaskEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWriteMaskEXT\" not available");
    }
        dispatch_glWriteMaskEXT1(res, in, outX, outY, outZ, outW, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWriteMaskEXT}(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW); </code> <br>Part of <code>GL_EXT_vertex_shader</code>   */
  public native void dispatch_glWriteMaskEXT1(int res, int in, int outX, int outY, int outZ, int outW, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
 private static final int params_offset = 0; // just a helper for JavaPrologue ..
 public void glFrustumf(float left, float right, float bottom, float top, float zNear, float zFar) {
   glFrustum((double)left, (double)right, (double)bottom, (double)top, (double)zNear, (double)zFar); }
 public void glOrthof(float left, float right, float bottom, float top, float zNear, float zFar) {
   glOrtho((double)left, (double)right, (double)bottom, (double)top, (double)zNear, (double)zFar); }
      @Override
      public GLProfile getGLProfile() {
          return this.glProfile;
      }
      private final GLProfile glProfile;
  
      @Override
      public final int glGetBoundBuffer(int target) {
          return bufferStateTracker.getBoundBufferObject(target, this);
      }
  
      @Override
      public final long glGetBufferSize(int buffer) {
          return bufferSizeTracker.getDirectStateBufferSize(buffer, this);
      }
  
      @Override
      public final boolean glIsVBOArrayEnabled() {
          return checkArrayVBOEnabled(false);
      }
  
      @Override
      public final boolean glIsVBOElementArrayEnabled() {
          return checkElementVBOEnabled(false);
      }
  
      @Override
      public final boolean isGL() {
          return true;
      }
        
      @Override
      public final GL getGL() throws GLException {
          return this;
      }
  
      @Override
      public final boolean isFunctionAvailable(String glFunctionName) {
        return _context.isFunctionAvailable(glFunctionName);
      }
  
      @Override
      public final boolean isExtensionAvailable(String glExtensionName) {
        return _context.isExtensionAvailable(glExtensionName);
      }
  
      @Override
      public final Object getExtension(String extensionName) {
        // At this point we don't expose any extensions using this mechanism
        return null;
      }
  
      @Override
      public final GLContext getContext() {
        return _context;
      }
  
      private final GLContextImpl _context;
  
      /**
       * @see javax.media.opengl.GLContext#setSwapInterval(int)
       */
      @Override
      public final void setSwapInterval(int interval) {
        _context.setSwapInterval(interval);
      }
  
      /**
       * @see javax.media.opengl.GLContext#getSwapInterval()
       */
      @Override
      public final int getSwapInterval() {
        return _context.getSwapInterval();
      }
  
      @Override
      public final Object getPlatformGLExtensions() {
        return _context.getPlatformGLExtensions();
      }
  
      @Override
      public final int getBoundFramebuffer(int target) {
        return _context.getBoundFramebuffer(target);
      }
  
      @Override
      public final int getDefaultDrawFramebuffer() {
        return _context.getDefaultDrawFramebuffer();
      }
  
      @Override
      public final int getDefaultReadFramebuffer() {
        return _context.getDefaultReadFramebuffer();
      }
  
  // Tracks glBegin/glEnd calls to determine whether it is legal to
  // query Vertex Buffer Object state
  private boolean inBeginEndPair;
  
  /* FIXME: refactor dependence on Java 2D / JOGL bridge
  
  // Tracks creation and destruction of server-side OpenGL objects when
  // the Java2D/OpenGL pipeline is enabled and it is using frame buffer
  // objects (FBOs) to do its rendering
  private GLObjectTracker tracker;
  
  public void setObjectTracker(GLObjectTracker tracker) {
    this.tracker = tracker;
  }
  
  */
  
  public GL4bcImpl(GLProfile glp, GLContextImpl context) {
    this._context = context; 
    if(null != context) {
        this.bufferSizeTracker  = context.getBufferSizeTracker();
        this.bufferStateTracker = context.getBufferStateTracker();
        this.glStateTracker     = context.getGLStateTracker();
    } else {
        this.bufferSizeTracker  = null;
        this.bufferStateTracker = null;
        this.glStateTracker     = null;
    }
    this.glProfile = glp;
  }
  
  /**
   * Provides platform-independent access to the wglAllocateMemoryNV /
   * glXAllocateMemoryNV extension.
   */
  public final java.nio.ByteBuffer glAllocateMemoryNV(int arg0, float arg1, float arg2, float arg3) {
    return _context.glAllocateMemoryNV(arg0, arg1, arg2, arg3);
  }
  
  //
  // Helpers for ensuring the correct amount of texture data
  //
  
  private final GLBufferSizeTracker  bufferSizeTracker;
  private final GLBufferStateTracker bufferStateTracker;
  private final GLStateTracker       glStateTracker;
  
  private boolean bufferObjectExtensionsInitialized = false;
  private boolean haveARBPixelBufferObject;
  private boolean haveEXTPixelBufferObject;
  private boolean haveGL15;
  private boolean haveGL21;
  private boolean haveARBVertexBufferObject;
  
  private final void initBufferObjectExtensionChecks() {
    if (bufferObjectExtensionsInitialized)
      return;
    bufferObjectExtensionsInitialized = true;
    haveARBPixelBufferObject  = isExtensionAvailable("GL_ARB_pixel_buffer_object");
    haveEXTPixelBufferObject  = isExtensionAvailable("GL_EXT_pixel_buffer_object");
    haveGL15                  = isExtensionAvailable("GL_VERSION_1_5");
    haveGL21                  = isExtensionAvailable("GL_VERSION_2_1");
    haveARBVertexBufferObject = isExtensionAvailable("GL_ARB_vertex_buffer_object");
  }
  
  private final boolean checkBufferObject(boolean extension1,
                                          boolean extension2,
                                          boolean extension3,
                                          boolean enabled,
                                          int state,
                                          String kind, boolean throwException) {
    if (inBeginEndPair) {
      throw new GLException("May not call this between glBegin and glEnd");
    }
    boolean avail = (extension1 || extension2 || extension3);
    if (!avail) {
      if (!enabled)
        return true;
      if(throwException) {
          throw new GLException("Required extensions not available to call this function");
      }
      return false;
    }
    int buffer = bufferStateTracker.getBoundBufferObject(state, this);
    if (enabled) {
      if (buffer == 0) {
        if(throwException) {
            throw new GLException(kind + " must be enabled to call this method");
        }
        return false;
      }
    } else {
      if (buffer != 0) {
        if(throwException) {
            throw new GLException(kind + " must be disabled to call this method");
        }
        return false;
      }
    }
    return true;
  }  
  
  private final boolean checkArrayVBODisabled(boolean throwException) { 
    initBufferObjectExtensionChecks();
    return checkBufferObject(haveGL15,
                      haveARBVertexBufferObject,
                      false,
                      false,
                      GL.GL_ARRAY_BUFFER,
                      "array vertex_buffer_object", throwException);
  }
  
  private final boolean checkArrayVBOEnabled(boolean throwException) { 
    initBufferObjectExtensionChecks();
    return checkBufferObject(haveGL15,
                      haveARBVertexBufferObject,
                      false,
                      true,
                      GL.GL_ARRAY_BUFFER,
                      "array vertex_buffer_object", throwException);
  }
  
  private final boolean checkElementVBODisabled(boolean throwException) { 
    initBufferObjectExtensionChecks();
    return checkBufferObject(haveGL15,
                      haveARBVertexBufferObject,
                      false,
                      false,
                      GL.GL_ELEMENT_ARRAY_BUFFER,
                      "element vertex_buffer_object", throwException);
  }
  
  private final boolean checkElementVBOEnabled(boolean throwException) { 
    initBufferObjectExtensionChecks();
    return checkBufferObject(haveGL15,
                      haveARBVertexBufferObject,
                      false,
                      true,
                      GL.GL_ELEMENT_ARRAY_BUFFER,
                      "element vertex_buffer_object", throwException);
  }
  
  private final boolean checkUnpackPBODisabled(boolean throwException) { 
    initBufferObjectExtensionChecks();
    return checkBufferObject(haveARBPixelBufferObject,
                      haveEXTPixelBufferObject,
                      haveGL21,
                      false,
                      GL2.GL_PIXEL_UNPACK_BUFFER,
                      "unpack pixel_buffer_object", throwException);
  }
  
  private final boolean checkUnpackPBOEnabled(boolean throwException) { 
    initBufferObjectExtensionChecks();
    return checkBufferObject(haveARBPixelBufferObject,
                      haveEXTPixelBufferObject,
                      haveGL21,
                      true,
                      GL2.GL_PIXEL_UNPACK_BUFFER,
                      "unpack pixel_buffer_object", throwException);
  }
  
  private final boolean checkPackPBODisabled(boolean throwException) { 
    initBufferObjectExtensionChecks();
    return checkBufferObject(haveARBPixelBufferObject,
                      haveEXTPixelBufferObject,
                      haveGL21,
                      false,
                      GL2.GL_PIXEL_PACK_BUFFER,
                      "pack pixel_buffer_object", throwException);
  }
  
  private final boolean checkPackPBOEnabled(boolean throwException) { 
    initBufferObjectExtensionChecks();
    return checkBufferObject(haveARBPixelBufferObject,
                      haveEXTPixelBufferObject,
                      haveGL21,
                      true,
                      GL2.GL_PIXEL_PACK_BUFFER,
                      "pack pixel_buffer_object", throwException);
  }
  
  @Override
  public final boolean glIsPBOPackEnabled() {
      return checkPackPBOEnabled(false);
  }
  
  @Override
  public final boolean glIsPBOUnpackEnabled() {
      return checkUnpackPBOEnabled(false);
  }
  
  private final HashMap<MemoryObject, MemoryObject> arbMemCache = new HashMap<MemoryObject, MemoryObject>();
  
  /** Entry point to C language function: <br> <code> LPVOID glMapBuffer(GLenum target, GLenum access); </code>    */
  public final java.nio.ByteBuffer glMapBuffer(int target, int access) {
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapBuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMapBuffer\" not available");
    }
    final long sz = bufferSizeTracker.getBufferSize(bufferStateTracker, target, this);
    if (0 == sz) {
      return null;
    }
    final long addr = dispatch_glMapBuffer(target, access, __addr_);
    if (0 == addr) {
      return null;
    }
    ByteBuffer buffer;
    MemoryObject memObj0 = new MemoryObject(addr, sz); // object and key
    MemoryObject memObj1 = MemoryObject.getOrAddSafe(arbMemCache, memObj0);
    if(memObj0 == memObj1) {
      // just added ..
      if(null != memObj0.getBuffer()) {
          throw new InternalError();
      }
      buffer = newDirectByteBuffer(addr, sz);
      Buffers.nativeOrder(buffer);
      memObj0.setBuffer(buffer);
    } else {
      // already mapped
      buffer = memObj1.getBuffer();
      if(null == buffer) {
          throw new InternalError();
      }
    }
    buffer.position(0);
    return buffer;
  }
  
  /** Encapsulates function pointer for OpenGL function <br>: <code> LPVOID glMapBuffer(GLenum target, GLenum access); </code>    */
  native private long dispatch_glMapBuffer(int target, int access, long glProcAddress);
  
  /** Entry point to C language function: <code> GLvoid *  {@native glMapNamedBufferEXT}(GLuint buffer, GLenum access); </code> <br>Part of <code>GL_EXT_direct_state_access</code>   */
  public final java.nio.ByteBuffer glMapNamedBufferEXT(int bufferName, int access)  {
    final long __addr_ = ((GL4bcProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapNamedBufferEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMapNamedBufferEXT\" not available");
    }
    final long sz = bufferSizeTracker.getDirectStateBufferSize(bufferName, this);
    if (0 == sz) {
      return null;
    }
    final long addr = dispatch_glMapNamedBufferEXT(bufferName, access, __addr_);
    if (0 == addr) {
      return null;
    }
    ByteBuffer buffer;
    MemoryObject memObj0 = new MemoryObject(addr, sz); // object and key
    MemoryObject memObj1 = MemoryObject.getOrAddSafe(arbMemCache, memObj0);
    if(memObj0 == memObj1) {
      // just added ..
      if(null != memObj0.getBuffer()) {
          throw new InternalError();
      }
      buffer = newDirectByteBuffer(addr, sz);
      Buffers.nativeOrder(buffer);
      memObj0.setBuffer(buffer);
    } else {
      // already mapped
      buffer = memObj1.getBuffer();
      if(null == buffer) {
          throw new InternalError();
      }
    }
    buffer.position(0);
    return buffer;
  }
  
  private native long dispatch_glMapNamedBufferEXT(int buffer, int access, long procAddress);
  
  native private ByteBuffer newDirectByteBuffer(long addr, long capacity);
  
      @Override
      public final void glVertexPointer(GLArrayData array) {
        if(array.getComponentCount()==0) return;
        if(array.isVBO()) {
            glVertexPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getVBOOffset());
        } else {
            glVertexPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getBuffer());
        }
      }
      @Override
      public final void glColorPointer(GLArrayData array) {
        if(array.getComponentCount()==0) return;
        if(array.isVBO()) {
            glColorPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getVBOOffset());
        } else {
            glColorPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getBuffer());
        }
  
      }
      @Override
      public final void glNormalPointer(GLArrayData array) {
        if(array.getComponentCount()==0) return;
        if(array.getComponentCount()!=3) {
          throw new GLException("Only 3 components per normal allowed");
        }
        if(array.isVBO()) {
            glNormalPointer(array.getComponentType(), array.getStride(), array.getVBOOffset());
        } else {
            glNormalPointer(array.getComponentType(), array.getStride(), array.getBuffer());
        }
      }
      @Override
      public final void glTexCoordPointer(GLArrayData array) {
        if(array.getComponentCount()==0) return;
        if(array.isVBO()) {
            glTexCoordPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getVBOOffset());
        } else {
            glTexCoordPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getBuffer());
        }
      }
  
      private int[] imageSizeTemp = new int[1];
  
      private final int imageSizeInBytes(int format, int type, int width, int height, int depth, boolean pack) {
          return GLBuffers.sizeof(this, imageSizeTemp, format, type, width, height, depth, pack) ;                                    
      }
  
      @Override
      public final boolean isGL4bc() {
          return _context.isGL4bc();
      }
  
      @Override
      public final boolean isGL4() {
          return _context.isGL4();
      }
  
      @Override
      public final boolean isGL3bc() {
          return _context.isGL3bc();
      }
  
      @Override
      public final boolean isGL3() {
          return _context.isGL3();
      }
  
      @Override
      public final boolean isGL2() {
          return _context.isGL2();
      }
        
      @Override
      public final boolean isGL2ES1() {
          return _context.isGL2ES1();
      }
  
      @Override
      public final boolean isGL2ES2() {
          return _context.isGL2ES2();
      }
  
      @Override
      public final boolean isGLES2Compatible() {
          return _context.isGLES2Compatible();
      }
  
      public final boolean isGL2GL3() {
          return _context.isGL2GL3();
      }
  
      @Override
      public final boolean hasGLSL() {
          return _context.hasGLSL();
      }
  
      @Override
      public final GL4bc getGL4bc() throws GLException {
          if(!isGL4bc()) {
              throw new GLException("Not a GL4bc implementation");
          }
          return this;
      }
  
      @Override
      public final GL4 getGL4() throws GLException {
          if(!isGL4()) {
              throw new GLException("Not a GL4 implementation");
          }
          return this;
      }
  
      @Override
      public final GL3bc getGL3bc() throws GLException {
          if(!isGL3bc()) {
              throw new GLException("Not a GL3bc implementation");
          }
          return this;
      }
  
      @Override
      public final GL3 getGL3() throws GLException {
          if(!isGL3()) {
              throw new GLException("Not a GL3 implementation");
          }
          return this;
      }
  
      @Override
      public final GL2 getGL2() throws GLException {
          if(!isGL2()) {
              throw new GLException("Not a GL2 implementation");
          }
          return this;
      }
  
      @Override
      public final GL2ES1 getGL2ES1() throws GLException {
          if(!isGL2ES1()) {
              throw new GLException("Not a GL2ES1 implementation");
          }
          return this;
      }
  
      @Override
      public final GL2ES2 getGL2ES2() throws GLException {
          if(!isGL2ES2()) {
              throw new GLException("Not a GL2ES2 implementation");
          }
          return this;
      }
  
      @Override
      public final GL2GL3 getGL2GL3() throws GLException {
          if(!isGL2GL3()) {
              throw new GLException("Not a GL2GL3 implementation");
          }
          return this;
      }
  
      @Override
      public final boolean isGLES1() {
          return false;
      }
  
      @Override
      public final boolean isGLES2() {
          return false;
      }
  
      @Override
      public final boolean isGLES() {
          return false;
      }
  
      @Override
      public final GLES1 getGLES1() throws GLException {
          throw new GLException("Not a GLES1 implementation");
      }
  
      @Override
      public final GLES2 getGLES2() throws GLException {
          throw new GLException("Not a GLES2 implementation");
      }
  
      @Override
      public final boolean isNPOTTextureAvailable() {
        return _context.isNPOTTextureAvailable();
      }
    @Override
    public final void glVertexAttribPointer(GLArrayData array) {
      if(array.getComponentCount()==0) return;
      if(array.isVBO()) {
          glVertexAttribPointer(array.getLocation(), array.getComponentCount(), array.getComponentType(), 
                                array.getNormalized(), array.getStride(), array.getVBOOffset());
      } else {
          glVertexAttribPointer(array.getLocation(), array.getComponentCount(), array.getComponentType(), 
                                array.getNormalized(), array.getStride(), array.getBuffer());
      }
    }
  
    @Override
    public final void glUniform(GLUniformData data) {
      boolean done=false;
      if(data.isBuffer()) {
          Buffer buffer = data.getBuffer();
          if(data.isMatrix()) {
              if(buffer instanceof FloatBuffer) {
                  switch(data.columns()) {
                      case 2: glUniformMatrix2fv(data.getLocation(), data.count(), false, (FloatBuffer)buffer); done=true; break;
                      case 3: glUniformMatrix3fv(data.getLocation(), data.count(), false, (FloatBuffer)buffer); done=true; break;
                      case 4: glUniformMatrix4fv(data.getLocation(), data.count(), false, (FloatBuffer)buffer); done=true; break;
                  }
              }
              if(!done) {
                  throw new GLException("glUniformMatrix only available for 2fv, 3fv and 4fv");
              }
          } else {
              if(buffer instanceof IntBuffer) {
                  switch(data.components()) {
                      case 1: glUniform1iv(data.getLocation(), data.count(), (IntBuffer)buffer); done=true; break;
                      case 2: glUniform2iv(data.getLocation(), data.count(), (IntBuffer)buffer); done=true; break;
                      case 3: glUniform3iv(data.getLocation(), data.count(), (IntBuffer)buffer); done=true; break;
                      case 4: glUniform4iv(data.getLocation(), data.count(), (IntBuffer)buffer); done=true; break;
                  }
              } else if(buffer instanceof FloatBuffer) {
                  switch(data.components()) {
                      case 1: glUniform1fv(data.getLocation(), data.count(), (FloatBuffer)buffer); done=true; break;
                      case 2: glUniform2fv(data.getLocation(), data.count(), (FloatBuffer)buffer); done=true; break;
                      case 3: glUniform3fv(data.getLocation(), data.count(), (FloatBuffer)buffer); done=true; break;
                      case 4: glUniform4fv(data.getLocation(), data.count(), (FloatBuffer)buffer); done=true; break;
                  }
              }
              if(!done) {
                  throw new GLException("glUniform vector only available for 1[if]v 2[if]v, 3[if]v and 4[if]v");
              }
          }
      } else {
          Object obj = data.getObject();
          if(obj instanceof Integer) {
              glUniform1i(data.getLocation(), ((Integer)obj).intValue());
              done=true;
          } else if (obj instanceof Float) {
              glUniform1f(data.getLocation(), ((Float)obj).floatValue());
              done=true;
          }
          if(!done) {
              throw new GLException("glUniform atom only available for 1i and 1f");
          }
      }
    }
  
  // ---- End CustomJavaCode .cfg declarations

} // end of class GL4bcImpl
