/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Fri Aug 03 06:28:50 CEST 2012 ----! */

package jogamp.opengl.x11.glx;

import java.util.*;
import javax.media.opengl.*;
import javax.media.opengl.fixedfunc.*;
import jogamp.opengl.*;
import jogamp.nativewindow.x11.*;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class GLXExtImpl implements GLXExt{
  /** Entry point to C language function: <code> GLvoid *  glXAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority); </code> <br>Part of <code>GLX_NV_vertex_array_range</code>   */
  public ByteBuffer glXAllocateMemoryNV(int size, float readfreq, float writefreq, float priority)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXAllocateMemoryNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXAllocateMemoryNV\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_glXAllocateMemoryNV1(size, readfreq, writefreq, priority, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> GLvoid *  glXAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority); </code> <br>Part of <code>GLX_NV_vertex_array_range</code>   */
  private native ByteBuffer dispatch_glXAllocateMemoryNV1(int size, float readfreq, float writefreq, float priority, long procAddress);

  /** Entry point to C language function: <code> int glXBindChannelToWindowSGIX(Display *  display, int screen, int channel, XID window); </code> <br>Part of <code>GLX_SGIX_video_resize</code>   */
  public int glXBindChannelToWindowSGIX(long display, int screen, int channel, long window)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindChannelToWindowSGIX;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXBindChannelToWindowSGIX\" not available");
    }
        return dispatch_glXBindChannelToWindowSGIX1(display, screen, channel, window, __addr_);
  }

  /** Entry point to C language function: <code> int glXBindChannelToWindowSGIX(Display *  display, int screen, int channel, XID window); </code> <br>Part of <code>GLX_SGIX_video_resize</code>   */
  public native int dispatch_glXBindChannelToWindowSGIX1(long display, int screen, int channel, long window, long procAddress);

  /** Entry point to C language function: <code> Bool glXBindSwapBarrierNV(Display *  dpy, GLuint group, GLuint barrier); </code> <br>Part of <code>GLX_NV_swap_group</code>   */
  public boolean glXBindSwapBarrierNV(long dpy, int group, int barrier)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindSwapBarrierNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXBindSwapBarrierNV\" not available");
    }
        return dispatch_glXBindSwapBarrierNV1(dpy, group, barrier, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXBindSwapBarrierNV(Display *  dpy, GLuint group, GLuint barrier); </code> <br>Part of <code>GLX_NV_swap_group</code>   */
  public native boolean dispatch_glXBindSwapBarrierNV1(long dpy, int group, int barrier, long procAddress);

  /** Entry point to C language function: <code> void glXBindSwapBarrierSGIX(Display *  dpy, XID drawable, int barrier); </code> <br>Part of <code>GLX_SGIX_swap_barrier</code>   */
  public void glXBindSwapBarrierSGIX(long dpy, long drawable, int barrier)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindSwapBarrierSGIX;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXBindSwapBarrierSGIX\" not available");
    }
        dispatch_glXBindSwapBarrierSGIX1(dpy, drawable, barrier, __addr_);
  }

  /** Entry point to C language function: <code> void glXBindSwapBarrierSGIX(Display *  dpy, XID drawable, int barrier); </code> <br>Part of <code>GLX_SGIX_swap_barrier</code>   */
  public native void dispatch_glXBindSwapBarrierSGIX1(long dpy, long drawable, int barrier, long procAddress);

  /** Entry point to C language function: <code> void glXBindTexImageEXT(Display *  dpy, XID drawable, int buffer, const int *  attrib_list); </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glXBindTexImageEXT(long dpy, long drawable, int buffer, IntBuffer attrib_list)  {

    final boolean attrib_list_is_direct = Buffers.isDirect(attrib_list);
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindTexImageEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXBindTexImageEXT\" not available");
    }
        dispatch_glXBindTexImageEXT1(dpy, drawable, buffer, attrib_list_is_direct ? attrib_list : Buffers.getArray(attrib_list), attrib_list_is_direct ? Buffers.getDirectBufferByteOffset(attrib_list) : Buffers.getIndirectBufferByteOffset(attrib_list), attrib_list_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void glXBindTexImageEXT(Display *  dpy, XID drawable, int buffer, const int *  attrib_list); </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glXBindTexImageEXT1(long dpy, long drawable, int buffer, Object attrib_list, int attrib_list_byte_offset, boolean attrib_list_is_direct, long procAddress);

  /** Entry point to C language function: <code> void glXBindTexImageEXT(Display *  dpy, XID drawable, int buffer, const int *  attrib_list); </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code>   */
  public void glXBindTexImageEXT(long dpy, long drawable, int buffer, int[] attrib_list, int attrib_list_offset)  {

    if(attrib_list != null && attrib_list.length <= attrib_list_offset)
      throw new GLException("array offset argument \"attrib_list_offset\" (" + attrib_list_offset + ") equals or exceeds array length (" + attrib_list.length + ")");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindTexImageEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXBindTexImageEXT\" not available");
    }
        dispatch_glXBindTexImageEXT1(dpy, drawable, buffer, attrib_list, Buffers.SIZEOF_INT * attrib_list_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> int glXBindVideoDeviceNV(Display *  dpy, unsigned int video_slot, unsigned int video_device, const int *  attrib_list); </code> <br>Part of <code>GLX_NV_present_video</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  public int glXBindVideoDeviceNV(long dpy, int video_slot, int video_device, IntBuffer attrib_list)  {

    final boolean attrib_list_is_direct = Buffers.isDirect(attrib_list);
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindVideoDeviceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXBindVideoDeviceNV\" not available");
    }
        return dispatch_glXBindVideoDeviceNV1(dpy, video_slot, video_device, attrib_list_is_direct ? attrib_list : Buffers.getArray(attrib_list), attrib_list_is_direct ? Buffers.getDirectBufferByteOffset(attrib_list) : Buffers.getIndirectBufferByteOffset(attrib_list), attrib_list_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> int glXBindVideoDeviceNV(Display *  dpy, unsigned int video_slot, unsigned int video_device, const int *  attrib_list); </code> <br>Part of <code>GLX_NV_present_video</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  private native int dispatch_glXBindVideoDeviceNV1(long dpy, int video_slot, int video_device, Object attrib_list, int attrib_list_byte_offset, boolean attrib_list_is_direct, long procAddress);

  /** Entry point to C language function: <code> int glXBindVideoDeviceNV(Display *  dpy, unsigned int video_slot, unsigned int video_device, const int *  attrib_list); </code> <br>Part of <code>GLX_NV_present_video</code>   */
  public int glXBindVideoDeviceNV(long dpy, int video_slot, int video_device, int[] attrib_list, int attrib_list_offset)  {

    if(attrib_list != null && attrib_list.length <= attrib_list_offset)
      throw new GLException("array offset argument \"attrib_list_offset\" (" + attrib_list_offset + ") equals or exceeds array length (" + attrib_list.length + ")");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindVideoDeviceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXBindVideoDeviceNV\" not available");
    }
        return dispatch_glXBindVideoDeviceNV1(dpy, video_slot, video_device, attrib_list, Buffers.SIZEOF_INT * attrib_list_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> int glXBindVideoImageNV(Display *  dpy, GLXVideoDeviceNV VideoDevice, XID pbuf, int iVideoBuffer); </code> <br>Part of <code>GLX_NV_video_out</code>   */
  public int glXBindVideoImageNV(long dpy, int VideoDevice, long pbuf, int iVideoBuffer)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindVideoImageNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXBindVideoImageNV\" not available");
    }
        return dispatch_glXBindVideoImageNV1(dpy, VideoDevice, pbuf, iVideoBuffer, __addr_);
  }

  /** Entry point to C language function: <code> int glXBindVideoImageNV(Display *  dpy, GLXVideoDeviceNV VideoDevice, XID pbuf, int iVideoBuffer); </code> <br>Part of <code>GLX_NV_video_out</code>   */
  public native int dispatch_glXBindVideoImageNV1(long dpy, int VideoDevice, long pbuf, int iVideoBuffer, long procAddress);

  /** Entry point to C language function: <code> int glXChannelRectSGIX(Display *  display, int screen, int channel, int x, int y, int w, int h); </code> <br>Part of <code>GLX_SGIX_video_resize</code>   */
  public int glXChannelRectSGIX(long display, int screen, int channel, int x, int y, int w, int h)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXChannelRectSGIX;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXChannelRectSGIX\" not available");
    }
        return dispatch_glXChannelRectSGIX1(display, screen, channel, x, y, w, h, __addr_);
  }

  /** Entry point to C language function: <code> int glXChannelRectSGIX(Display *  display, int screen, int channel, int x, int y, int w, int h); </code> <br>Part of <code>GLX_SGIX_video_resize</code>   */
  public native int dispatch_glXChannelRectSGIX1(long display, int screen, int channel, int x, int y, int w, int h, long procAddress);

  /** Entry point to C language function: <code> int glXChannelRectSyncSGIX(Display *  display, int screen, int channel, GLenum synctype); </code> <br>Part of <code>GLX_SGIX_video_resize</code>   */
  public int glXChannelRectSyncSGIX(long display, int screen, int channel, int synctype)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXChannelRectSyncSGIX;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXChannelRectSyncSGIX\" not available");
    }
        return dispatch_glXChannelRectSyncSGIX1(display, screen, channel, synctype, __addr_);
  }

  /** Entry point to C language function: <code> int glXChannelRectSyncSGIX(Display *  display, int screen, int channel, GLenum synctype); </code> <br>Part of <code>GLX_SGIX_video_resize</code>   */
  public native int dispatch_glXChannelRectSyncSGIX1(long display, int screen, int channel, int synctype, long procAddress);

  /** Entry point to C language function: <code> void glXCopySubBufferMESA(Display *  dpy, XID drawable, int x, int y, int width, int height); </code> <br>Part of <code>GLX_MESA_copy_sub_buffer</code>   */
  public void glXCopySubBufferMESA(long dpy, long drawable, int x, int y, int width, int height)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXCopySubBufferMESA;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCopySubBufferMESA\" not available");
    }
        dispatch_glXCopySubBufferMESA1(dpy, drawable, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void glXCopySubBufferMESA(Display *  dpy, XID drawable, int x, int y, int width, int height); </code> <br>Part of <code>GLX_MESA_copy_sub_buffer</code>   */
  public native void dispatch_glXCopySubBufferMESA1(long dpy, long drawable, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> GLXContext glXCreateContextAttribsARB(Display *  dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *  attrib_list); </code> <br>Part of <code>GLX_ARB_create_context</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  public long glXCreateContextAttribsARB(long dpy, long config, long share_context, boolean direct, IntBuffer attrib_list)  {

    final boolean attrib_list_is_direct = Buffers.isDirect(attrib_list);
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXCreateContextAttribsARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCreateContextAttribsARB\" not available");
    }
        return dispatch_glXCreateContextAttribsARB1(dpy, config, share_context, direct, attrib_list_is_direct ? attrib_list : Buffers.getArray(attrib_list), attrib_list_is_direct ? Buffers.getDirectBufferByteOffset(attrib_list) : Buffers.getIndirectBufferByteOffset(attrib_list), attrib_list_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLXContext glXCreateContextAttribsARB(Display *  dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *  attrib_list); </code> <br>Part of <code>GLX_ARB_create_context</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  private native long dispatch_glXCreateContextAttribsARB1(long dpy, long config, long share_context, boolean direct, Object attrib_list, int attrib_list_byte_offset, boolean attrib_list_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLXContext glXCreateContextAttribsARB(Display *  dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *  attrib_list); </code> <br>Part of <code>GLX_ARB_create_context</code>   */
  public long glXCreateContextAttribsARB(long dpy, long config, long share_context, boolean direct, int[] attrib_list, int attrib_list_offset)  {

    if(attrib_list != null && attrib_list.length <= attrib_list_offset)
      throw new GLException("array offset argument \"attrib_list_offset\" (" + attrib_list_offset + ") equals or exceeds array length (" + attrib_list.length + ")");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXCreateContextAttribsARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCreateContextAttribsARB\" not available");
    }
        return dispatch_glXCreateContextAttribsARB1(dpy, config, share_context, direct, attrib_list, Buffers.SIZEOF_INT * attrib_list_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void glXCushionSGI(Display *  dpy, XID window, float cushion); </code> <br>Part of <code>GLX_SGI_cushion</code>   */
  public void glXCushionSGI(long dpy, long window, float cushion)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXCushionSGI;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCushionSGI\" not available");
    }
        dispatch_glXCushionSGI1(dpy, window, cushion, __addr_);
  }

  /** Entry point to C language function: <code> void glXCushionSGI(Display *  dpy, XID window, float cushion); </code> <br>Part of <code>GLX_SGI_cushion</code>   */
  public native void dispatch_glXCushionSGI1(long dpy, long window, float cushion, long procAddress);

  /** Entry point to C language function: <code> unsigned int *  glXEnumerateVideoDevicesNV(Display *  dpy, int screen, int *  nelements); </code> <br>Part of <code>GLX_NV_present_video</code>
      @param nelements a direct or array-backed {@link java.nio.IntBuffer}   */
  public IntBuffer glXEnumerateVideoDevicesNV(long dpy, int screen, IntBuffer nelements)  {

    final boolean nelements_is_direct = Buffers.isDirect(nelements);
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXEnumerateVideoDevicesNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXEnumerateVideoDevicesNV\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_glXEnumerateVideoDevicesNV1(dpy, screen, nelements_is_direct ? nelements : Buffers.getArray(nelements), nelements_is_direct ? Buffers.getDirectBufferByteOffset(nelements) : Buffers.getIndirectBufferByteOffset(nelements), nelements_is_direct, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res.asIntBuffer();
  }

  /** Entry point to C language function: <code> unsigned int *  glXEnumerateVideoDevicesNV(Display *  dpy, int screen, int *  nelements); </code> <br>Part of <code>GLX_NV_present_video</code>
      @param nelements a direct or array-backed {@link java.nio.IntBuffer}   */
  private native ByteBuffer dispatch_glXEnumerateVideoDevicesNV1(long dpy, int screen, Object nelements, int nelements_byte_offset, boolean nelements_is_direct, long procAddress);

  /** Entry point to C language function: <code> unsigned int *  glXEnumerateVideoDevicesNV(Display *  dpy, int screen, int *  nelements); </code> <br>Part of <code>GLX_NV_present_video</code>   */
  public IntBuffer glXEnumerateVideoDevicesNV(long dpy, int screen, int[] nelements, int nelements_offset)  {

    if(nelements != null && nelements.length <= nelements_offset)
      throw new GLException("array offset argument \"nelements_offset\" (" + nelements_offset + ") equals or exceeds array length (" + nelements.length + ")");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXEnumerateVideoDevicesNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXEnumerateVideoDevicesNV\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_glXEnumerateVideoDevicesNV1(dpy, screen, nelements, Buffers.SIZEOF_INT * nelements_offset, false, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res.asIntBuffer();
  }

  /** Entry point to C language function: <code> void glXFreeContextEXT(Display *  dpy, GLXContext context); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  public void glXFreeContextEXT(long dpy, long context)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXFreeContextEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXFreeContextEXT\" not available");
    }
        dispatch_glXFreeContextEXT1(dpy, context, __addr_);
  }

  /** Entry point to C language function: <code> void glXFreeContextEXT(Display *  dpy, GLXContext context); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  public native void dispatch_glXFreeContextEXT1(long dpy, long context, long procAddress);

  /** Entry point to C language function: <code> void glXFreeMemoryNV(GLvoid *  pointer); </code> <br>Part of <code>GLX_NV_vertex_array_range</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void glXFreeMemoryNV(Buffer pointer)  {

    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXFreeMemoryNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXFreeMemoryNV\" not available");
    }
        dispatch_glXFreeMemoryNV0(pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void glXFreeMemoryNV(GLvoid *  pointer); </code> <br>Part of <code>GLX_NV_vertex_array_range</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glXFreeMemoryNV0(Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> unsigned int glXGetAGPOffsetMESA(const void *  pointer); </code> <br>Part of <code>GLX_MESA_agp_offset</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public int glXGetAGPOffsetMESA(Buffer pointer)  {

    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetAGPOffsetMESA;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetAGPOffsetMESA\" not available");
    }
        return dispatch_glXGetAGPOffsetMESA1(pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> unsigned int glXGetAGPOffsetMESA(const void *  pointer); </code> <br>Part of <code>GLX_MESA_agp_offset</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native int dispatch_glXGetAGPOffsetMESA1(Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> XID glXGetContextIDEXT(GLXContext context); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  public long glXGetContextIDEXT(long context)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetContextIDEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetContextIDEXT\" not available");
    }
        return dispatch_glXGetContextIDEXT1(context, __addr_);
  }

  /** Entry point to C language function: <code> XID glXGetContextIDEXT(GLXContext context); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  public native long dispatch_glXGetContextIDEXT1(long context, long procAddress);

  /** Entry point to C language function: <code> Display *  glXGetCurrentDisplayEXT(void); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  public long glXGetCurrentDisplayEXT()  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetCurrentDisplayEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetCurrentDisplayEXT\" not available");
    }
        return dispatch_glXGetCurrentDisplayEXT1(__addr_);
  }

  /** Entry point to C language function: <code> Display *  glXGetCurrentDisplayEXT(void); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  public native long dispatch_glXGetCurrentDisplayEXT1(long procAddress);

  /** Entry point to C language function: <code> XID glXGetCurrentReadDrawableSGI(void); </code> <br>Part of <code>GLX_SGI_make_current_read</code>   */
  public long glXGetCurrentReadDrawableSGI()  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetCurrentReadDrawableSGI;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetCurrentReadDrawableSGI\" not available");
    }
        return dispatch_glXGetCurrentReadDrawableSGI1(__addr_);
  }

  /** Entry point to C language function: <code> XID glXGetCurrentReadDrawableSGI(void); </code> <br>Part of <code>GLX_SGI_make_current_read</code>   */
  public native long dispatch_glXGetCurrentReadDrawableSGI1(long procAddress);

  /** Entry point to C language function: <code> Bool glXGetMscRateOML(Display *  dpy, XID drawable, int32_t *  numerator, int32_t *  denominator); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param numerator a direct or array-backed {@link java.nio.IntBuffer}
      @param denominator a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean glXGetMscRateOML(long dpy, long drawable, IntBuffer numerator, IntBuffer denominator)  {

    final boolean numerator_is_direct = Buffers.isDirect(numerator);
    final boolean denominator_is_direct = Buffers.isDirect(denominator);
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetMscRateOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetMscRateOML\" not available");
    }
        return dispatch_glXGetMscRateOML1(dpy, drawable, numerator_is_direct ? numerator : Buffers.getArray(numerator), numerator_is_direct ? Buffers.getDirectBufferByteOffset(numerator) : Buffers.getIndirectBufferByteOffset(numerator), numerator_is_direct, denominator_is_direct ? denominator : Buffers.getArray(denominator), denominator_is_direct ? Buffers.getDirectBufferByteOffset(denominator) : Buffers.getIndirectBufferByteOffset(denominator), denominator_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXGetMscRateOML(Display *  dpy, XID drawable, int32_t *  numerator, int32_t *  denominator); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param numerator a direct or array-backed {@link java.nio.IntBuffer}
      @param denominator a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_glXGetMscRateOML1(long dpy, long drawable, Object numerator, int numerator_byte_offset, boolean numerator_is_direct, Object denominator, int denominator_byte_offset, boolean denominator_is_direct, long procAddress);

  /** Entry point to C language function: <code> Bool glXGetMscRateOML(Display *  dpy, XID drawable, int32_t *  numerator, int32_t *  denominator); </code> <br>Part of <code>GLX_OML_sync_control</code>   */
  public boolean glXGetMscRateOML(long dpy, long drawable, int[] numerator, int numerator_offset, int[] denominator, int denominator_offset)  {

    if(numerator != null && numerator.length <= numerator_offset)
      throw new GLException("array offset argument \"numerator_offset\" (" + numerator_offset + ") equals or exceeds array length (" + numerator.length + ")");
    if(denominator != null && denominator.length <= denominator_offset)
      throw new GLException("array offset argument \"denominator_offset\" (" + denominator_offset + ") equals or exceeds array length (" + denominator.length + ")");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetMscRateOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetMscRateOML\" not available");
    }
        return dispatch_glXGetMscRateOML1(dpy, drawable, numerator, Buffers.SIZEOF_INT * numerator_offset, false, denominator, Buffers.SIZEOF_INT * denominator_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> PFNGLENDTRANSFORMFEEDBACKPROC glXGetProcAddress(const GLubyte *  procName); </code> <br>Part of <code>GLX_ARB_get_proc_address</code>   */
  public long glXGetProcAddress(String procName)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetProcAddress;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetProcAddress\" not available");
    }
        return dispatch_glXGetProcAddress1(procName, __addr_);
  }

  /** Entry point to C language function: <code> PFNGLENDTRANSFORMFEEDBACKPROC glXGetProcAddress(const GLubyte *  procName); </code> <br>Part of <code>GLX_ARB_get_proc_address</code>   */
  public native long dispatch_glXGetProcAddress1(String procName, long procAddress);

  /** Entry point to C language function: <code> PFNGLENDTRANSFORMFEEDBACKPROC glXGetProcAddressARB(const GLubyte *  procName); </code> <br>Part of <code>GLX_ARB_get_proc_address</code>   */
  public long glXGetProcAddressARB(String procName)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetProcAddressARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetProcAddressARB\" not available");
    }
        return dispatch_glXGetProcAddressARB1(procName, __addr_);
  }

  /** Entry point to C language function: <code> PFNGLENDTRANSFORMFEEDBACKPROC glXGetProcAddressARB(const GLubyte *  procName); </code> <br>Part of <code>GLX_ARB_get_proc_address</code>   */
  public native long dispatch_glXGetProcAddressARB1(String procName, long procAddress);

  /** Entry point to C language function: <code> int glXGetRefreshRateSGI(unsigned int *  markerp); </code> <br>Part of <code>GLX_SGI_video_sync</code>
      @param markerp a direct or array-backed {@link java.nio.IntBuffer}   */
  public int glXGetRefreshRateSGI(IntBuffer markerp)  {

    final boolean markerp_is_direct = Buffers.isDirect(markerp);
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetRefreshRateSGI;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetRefreshRateSGI\" not available");
    }
        return dispatch_glXGetRefreshRateSGI1(markerp_is_direct ? markerp : Buffers.getArray(markerp), markerp_is_direct ? Buffers.getDirectBufferByteOffset(markerp) : Buffers.getIndirectBufferByteOffset(markerp), markerp_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> int glXGetRefreshRateSGI(unsigned int *  markerp); </code> <br>Part of <code>GLX_SGI_video_sync</code>
      @param markerp a direct or array-backed {@link java.nio.IntBuffer}   */
  private native int dispatch_glXGetRefreshRateSGI1(Object markerp, int markerp_byte_offset, boolean markerp_is_direct, long procAddress);

  /** Entry point to C language function: <code> int glXGetRefreshRateSGI(unsigned int *  markerp); </code> <br>Part of <code>GLX_SGI_video_sync</code>   */
  public int glXGetRefreshRateSGI(int[] markerp, int markerp_offset)  {

    if(markerp != null && markerp.length <= markerp_offset)
      throw new GLException("array offset argument \"markerp_offset\" (" + markerp_offset + ") equals or exceeds array length (" + markerp.length + ")");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetRefreshRateSGI;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetRefreshRateSGI\" not available");
    }
        return dispatch_glXGetRefreshRateSGI1(markerp, Buffers.SIZEOF_INT * markerp_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXGetSyncValuesOML(Display *  dpy, XID drawable, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param ust a direct or array-backed {@link java.nio.LongBuffer}
      @param msc a direct or array-backed {@link java.nio.LongBuffer}
      @param sbc a direct or array-backed {@link java.nio.LongBuffer}   */
  public boolean glXGetSyncValuesOML(long dpy, long drawable, LongBuffer ust, LongBuffer msc, LongBuffer sbc)  {

    final boolean ust_is_direct = Buffers.isDirect(ust);
    final boolean msc_is_direct = Buffers.isDirect(msc);
    final boolean sbc_is_direct = Buffers.isDirect(sbc);
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetSyncValuesOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetSyncValuesOML\" not available");
    }
        return dispatch_glXGetSyncValuesOML1(dpy, drawable, ust_is_direct ? ust : Buffers.getArray(ust), ust_is_direct ? Buffers.getDirectBufferByteOffset(ust) : Buffers.getIndirectBufferByteOffset(ust), ust_is_direct, msc_is_direct ? msc : Buffers.getArray(msc), msc_is_direct ? Buffers.getDirectBufferByteOffset(msc) : Buffers.getIndirectBufferByteOffset(msc), msc_is_direct, sbc_is_direct ? sbc : Buffers.getArray(sbc), sbc_is_direct ? Buffers.getDirectBufferByteOffset(sbc) : Buffers.getIndirectBufferByteOffset(sbc), sbc_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXGetSyncValuesOML(Display *  dpy, XID drawable, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param ust a direct or array-backed {@link java.nio.LongBuffer}
      @param msc a direct or array-backed {@link java.nio.LongBuffer}
      @param sbc a direct or array-backed {@link java.nio.LongBuffer}   */
  private native boolean dispatch_glXGetSyncValuesOML1(long dpy, long drawable, Object ust, int ust_byte_offset, boolean ust_is_direct, Object msc, int msc_byte_offset, boolean msc_is_direct, Object sbc, int sbc_byte_offset, boolean sbc_is_direct, long procAddress);

  /** Entry point to C language function: <code> Bool glXGetSyncValuesOML(Display *  dpy, XID drawable, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>   */
  public boolean glXGetSyncValuesOML(long dpy, long drawable, long[] ust, int ust_offset, long[] msc, int msc_offset, long[] sbc, int sbc_offset)  {

    if(ust != null && ust.length <= ust_offset)
      throw new GLException("array offset argument \"ust_offset\" (" + ust_offset + ") equals or exceeds array length (" + ust.length + ")");
    if(msc != null && msc.length <= msc_offset)
      throw new GLException("array offset argument \"msc_offset\" (" + msc_offset + ") equals or exceeds array length (" + msc.length + ")");
    if(sbc != null && sbc.length <= sbc_offset)
      throw new GLException("array offset argument \"sbc_offset\" (" + sbc_offset + ") equals or exceeds array length (" + sbc.length + ")");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetSyncValuesOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetSyncValuesOML\" not available");
    }
        return dispatch_glXGetSyncValuesOML1(dpy, drawable, ust, Buffers.SIZEOF_LONG * ust_offset, false, msc, Buffers.SIZEOF_LONG * msc_offset, false, sbc, Buffers.SIZEOF_LONG * sbc_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> Status glXGetTransparentIndexSUN(Display *  dpy, XID overlay, XID underlay, long *  pTransparentIndex); </code> <br>Part of <code>GLX_SUN_get_transparent_index</code>
      @param pTransparentIndex a direct or array-backed {@link java.nio.LongBuffer}   */
  public int glXGetTransparentIndexSUN(long dpy, long overlay, long underlay, LongBuffer pTransparentIndex)  {

    final boolean pTransparentIndex_is_direct = Buffers.isDirect(pTransparentIndex);
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetTransparentIndexSUN;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetTransparentIndexSUN\" not available");
    }
        return dispatch_glXGetTransparentIndexSUN1(dpy, overlay, underlay, pTransparentIndex_is_direct ? pTransparentIndex : Buffers.getArray(pTransparentIndex), pTransparentIndex_is_direct ? Buffers.getDirectBufferByteOffset(pTransparentIndex) : Buffers.getIndirectBufferByteOffset(pTransparentIndex), pTransparentIndex_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> Status glXGetTransparentIndexSUN(Display *  dpy, XID overlay, XID underlay, long *  pTransparentIndex); </code> <br>Part of <code>GLX_SUN_get_transparent_index</code>
      @param pTransparentIndex a direct or array-backed {@link java.nio.LongBuffer}   */
  private native int dispatch_glXGetTransparentIndexSUN1(long dpy, long overlay, long underlay, Object pTransparentIndex, int pTransparentIndex_byte_offset, boolean pTransparentIndex_is_direct, long procAddress);

  /** Entry point to C language function: <code> Status glXGetTransparentIndexSUN(Display *  dpy, XID overlay, XID underlay, long *  pTransparentIndex); </code> <br>Part of <code>GLX_SUN_get_transparent_index</code>   */
  public int glXGetTransparentIndexSUN(long dpy, long overlay, long underlay, long[] pTransparentIndex, int pTransparentIndex_offset)  {

    if(pTransparentIndex != null && pTransparentIndex.length <= pTransparentIndex_offset)
      throw new GLException("array offset argument \"pTransparentIndex_offset\" (" + pTransparentIndex_offset + ") equals or exceeds array length (" + pTransparentIndex.length + ")");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetTransparentIndexSUN;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetTransparentIndexSUN\" not available");
    }
        return dispatch_glXGetTransparentIndexSUN1(dpy, overlay, underlay, pTransparentIndex, Buffers.SIZEOF_LONG * pTransparentIndex_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> int glXGetVideoDeviceNV(Display *  dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *  pVideoDevice); </code> <br>Part of <code>GLX_NV_video_out</code>
      @param pVideoDevice a direct or array-backed {@link java.nio.IntBuffer}   */
  public int glXGetVideoDeviceNV(long dpy, int screen, int numVideoDevices, IntBuffer pVideoDevice)  {

    final boolean pVideoDevice_is_direct = Buffers.isDirect(pVideoDevice);
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetVideoDeviceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetVideoDeviceNV\" not available");
    }
        return dispatch_glXGetVideoDeviceNV1(dpy, screen, numVideoDevices, pVideoDevice_is_direct ? pVideoDevice : Buffers.getArray(pVideoDevice), pVideoDevice_is_direct ? Buffers.getDirectBufferByteOffset(pVideoDevice) : Buffers.getIndirectBufferByteOffset(pVideoDevice), pVideoDevice_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> int glXGetVideoDeviceNV(Display *  dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *  pVideoDevice); </code> <br>Part of <code>GLX_NV_video_out</code>
      @param pVideoDevice a direct or array-backed {@link java.nio.IntBuffer}   */
  private native int dispatch_glXGetVideoDeviceNV1(long dpy, int screen, int numVideoDevices, Object pVideoDevice, int pVideoDevice_byte_offset, boolean pVideoDevice_is_direct, long procAddress);

  /** Entry point to C language function: <code> int glXGetVideoDeviceNV(Display *  dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *  pVideoDevice); </code> <br>Part of <code>GLX_NV_video_out</code>   */
  public int glXGetVideoDeviceNV(long dpy, int screen, int numVideoDevices, int[] pVideoDevice, int pVideoDevice_offset)  {

    if(pVideoDevice != null && pVideoDevice.length <= pVideoDevice_offset)
      throw new GLException("array offset argument \"pVideoDevice_offset\" (" + pVideoDevice_offset + ") equals or exceeds array length (" + pVideoDevice.length + ")");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetVideoDeviceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetVideoDeviceNV\" not available");
    }
        return dispatch_glXGetVideoDeviceNV1(dpy, screen, numVideoDevices, pVideoDevice, Buffers.SIZEOF_INT * pVideoDevice_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> int glXGetVideoInfoNV(Display *  dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *  pulCounterOutputPbuffer, unsigned long *  pulCounterOutputVideo); </code> <br>Part of <code>GLX_NV_video_out</code>
      @param pulCounterOutputPbuffer a direct or array-backed {@link java.nio.LongBuffer}
      @param pulCounterOutputVideo a direct or array-backed {@link java.nio.LongBuffer}   */
  public int glXGetVideoInfoNV(long dpy, int screen, int VideoDevice, LongBuffer pulCounterOutputPbuffer, LongBuffer pulCounterOutputVideo)  {

    final boolean pulCounterOutputPbuffer_is_direct = Buffers.isDirect(pulCounterOutputPbuffer);
    final boolean pulCounterOutputVideo_is_direct = Buffers.isDirect(pulCounterOutputVideo);
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetVideoInfoNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetVideoInfoNV\" not available");
    }
        return dispatch_glXGetVideoInfoNV1(dpy, screen, VideoDevice, pulCounterOutputPbuffer_is_direct ? pulCounterOutputPbuffer : Buffers.getArray(pulCounterOutputPbuffer), pulCounterOutputPbuffer_is_direct ? Buffers.getDirectBufferByteOffset(pulCounterOutputPbuffer) : Buffers.getIndirectBufferByteOffset(pulCounterOutputPbuffer), pulCounterOutputPbuffer_is_direct, pulCounterOutputVideo_is_direct ? pulCounterOutputVideo : Buffers.getArray(pulCounterOutputVideo), pulCounterOutputVideo_is_direct ? Buffers.getDirectBufferByteOffset(pulCounterOutputVideo) : Buffers.getIndirectBufferByteOffset(pulCounterOutputVideo), pulCounterOutputVideo_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> int glXGetVideoInfoNV(Display *  dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *  pulCounterOutputPbuffer, unsigned long *  pulCounterOutputVideo); </code> <br>Part of <code>GLX_NV_video_out</code>
      @param pulCounterOutputPbuffer a direct or array-backed {@link java.nio.LongBuffer}
      @param pulCounterOutputVideo a direct or array-backed {@link java.nio.LongBuffer}   */
  private native int dispatch_glXGetVideoInfoNV1(long dpy, int screen, int VideoDevice, Object pulCounterOutputPbuffer, int pulCounterOutputPbuffer_byte_offset, boolean pulCounterOutputPbuffer_is_direct, Object pulCounterOutputVideo, int pulCounterOutputVideo_byte_offset, boolean pulCounterOutputVideo_is_direct, long procAddress);

  /** Entry point to C language function: <code> int glXGetVideoInfoNV(Display *  dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *  pulCounterOutputPbuffer, unsigned long *  pulCounterOutputVideo); </code> <br>Part of <code>GLX_NV_video_out</code>   */
  public int glXGetVideoInfoNV(long dpy, int screen, int VideoDevice, long[] pulCounterOutputPbuffer, int pulCounterOutputPbuffer_offset, long[] pulCounterOutputVideo, int pulCounterOutputVideo_offset)  {

    if(pulCounterOutputPbuffer != null && pulCounterOutputPbuffer.length <= pulCounterOutputPbuffer_offset)
      throw new GLException("array offset argument \"pulCounterOutputPbuffer_offset\" (" + pulCounterOutputPbuffer_offset + ") equals or exceeds array length (" + pulCounterOutputPbuffer.length + ")");
    if(pulCounterOutputVideo != null && pulCounterOutputVideo.length <= pulCounterOutputVideo_offset)
      throw new GLException("array offset argument \"pulCounterOutputVideo_offset\" (" + pulCounterOutputVideo_offset + ") equals or exceeds array length (" + pulCounterOutputVideo.length + ")");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetVideoInfoNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetVideoInfoNV\" not available");
    }
        return dispatch_glXGetVideoInfoNV1(dpy, screen, VideoDevice, pulCounterOutputPbuffer, Buffers.SIZEOF_LONG * pulCounterOutputPbuffer_offset, false, pulCounterOutputVideo, Buffers.SIZEOF_LONG * pulCounterOutputVideo_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> int glXGetVideoSyncSGI(unsigned int *  markerp); </code> <br>Part of <code>GLX_SGI_video_sync</code>
      @param markerp a direct or array-backed {@link java.nio.IntBuffer}   */
  public int glXGetVideoSyncSGI(IntBuffer markerp)  {

    final boolean markerp_is_direct = Buffers.isDirect(markerp);
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetVideoSyncSGI;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetVideoSyncSGI\" not available");
    }
        return dispatch_glXGetVideoSyncSGI1(markerp_is_direct ? markerp : Buffers.getArray(markerp), markerp_is_direct ? Buffers.getDirectBufferByteOffset(markerp) : Buffers.getIndirectBufferByteOffset(markerp), markerp_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> int glXGetVideoSyncSGI(unsigned int *  markerp); </code> <br>Part of <code>GLX_SGI_video_sync</code>
      @param markerp a direct or array-backed {@link java.nio.IntBuffer}   */
  private native int dispatch_glXGetVideoSyncSGI1(Object markerp, int markerp_byte_offset, boolean markerp_is_direct, long procAddress);

  /** Entry point to C language function: <code> int glXGetVideoSyncSGI(unsigned int *  markerp); </code> <br>Part of <code>GLX_SGI_video_sync</code>   */
  public int glXGetVideoSyncSGI(int[] markerp, int markerp_offset)  {

    if(markerp != null && markerp.length <= markerp_offset)
      throw new GLException("array offset argument \"markerp_offset\" (" + markerp_offset + ") equals or exceeds array length (" + markerp.length + ")");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetVideoSyncSGI;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetVideoSyncSGI\" not available");
    }
        return dispatch_glXGetVideoSyncSGI1(markerp, Buffers.SIZEOF_INT * markerp_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLXContext glXImportContextEXT(Display *  dpy, XID contextID); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  public long glXImportContextEXT(long dpy, long contextID)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXImportContextEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXImportContextEXT\" not available");
    }
        return dispatch_glXImportContextEXT1(dpy, contextID, __addr_);
  }

  /** Entry point to C language function: <code> GLXContext glXImportContextEXT(Display *  dpy, XID contextID); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  public native long dispatch_glXImportContextEXT1(long dpy, long contextID, long procAddress);

  /** Entry point to C language function: <code> Bool glXJoinSwapGroupNV(Display *  dpy, XID drawable, GLuint group); </code> <br>Part of <code>GLX_NV_swap_group</code>   */
  public boolean glXJoinSwapGroupNV(long dpy, long drawable, int group)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXJoinSwapGroupNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXJoinSwapGroupNV\" not available");
    }
        return dispatch_glXJoinSwapGroupNV1(dpy, drawable, group, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXJoinSwapGroupNV(Display *  dpy, XID drawable, GLuint group); </code> <br>Part of <code>GLX_NV_swap_group</code>   */
  public native boolean dispatch_glXJoinSwapGroupNV1(long dpy, long drawable, int group, long procAddress);

  /** Entry point to C language function: <code> void glXJoinSwapGroupSGIX(Display *  dpy, XID drawable, XID member); </code> <br>Part of <code>GLX_SGIX_swap_group</code>   */
  public void glXJoinSwapGroupSGIX(long dpy, long drawable, long member)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXJoinSwapGroupSGIX;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXJoinSwapGroupSGIX\" not available");
    }
        dispatch_glXJoinSwapGroupSGIX1(dpy, drawable, member, __addr_);
  }

  /** Entry point to C language function: <code> void glXJoinSwapGroupSGIX(Display *  dpy, XID drawable, XID member); </code> <br>Part of <code>GLX_SGIX_swap_group</code>   */
  public native void dispatch_glXJoinSwapGroupSGIX1(long dpy, long drawable, long member, long procAddress);

  /** Entry point to C language function: <code> Bool glXMakeCurrentReadSGI(Display *  dpy, XID draw, XID read, GLXContext ctx); </code> <br>Part of <code>GLX_SGI_make_current_read</code>   */
  public boolean glXMakeCurrentReadSGI(long dpy, long draw, long read, long ctx)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXMakeCurrentReadSGI;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXMakeCurrentReadSGI\" not available");
    }
        return dispatch_glXMakeCurrentReadSGI1(dpy, draw, read, ctx, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXMakeCurrentReadSGI(Display *  dpy, XID draw, XID read, GLXContext ctx); </code> <br>Part of <code>GLX_SGI_make_current_read</code>   */
  public native boolean dispatch_glXMakeCurrentReadSGI1(long dpy, long draw, long read, long ctx, long procAddress);

  /** Entry point to C language function: <code> int glXQueryChannelDeltasSGIX(Display *  display, int screen, int channel, int *  dx, int *  dy, int *  dw, int *  dh); </code> <br>Part of <code>GLX_SGIX_video_resize</code>
      @param dx a direct or array-backed {@link java.nio.IntBuffer}
      @param dy a direct or array-backed {@link java.nio.IntBuffer}
      @param dw a direct or array-backed {@link java.nio.IntBuffer}
      @param dh a direct or array-backed {@link java.nio.IntBuffer}   */
  public int glXQueryChannelDeltasSGIX(long display, int screen, int channel, IntBuffer dx, IntBuffer dy, IntBuffer dw, IntBuffer dh)  {

    final boolean dx_is_direct = Buffers.isDirect(dx);
    final boolean dy_is_direct = Buffers.isDirect(dy);
    final boolean dw_is_direct = Buffers.isDirect(dw);
    final boolean dh_is_direct = Buffers.isDirect(dh);
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryChannelDeltasSGIX;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryChannelDeltasSGIX\" not available");
    }
        return dispatch_glXQueryChannelDeltasSGIX1(display, screen, channel, dx_is_direct ? dx : Buffers.getArray(dx), dx_is_direct ? Buffers.getDirectBufferByteOffset(dx) : Buffers.getIndirectBufferByteOffset(dx), dx_is_direct, dy_is_direct ? dy : Buffers.getArray(dy), dy_is_direct ? Buffers.getDirectBufferByteOffset(dy) : Buffers.getIndirectBufferByteOffset(dy), dy_is_direct, dw_is_direct ? dw : Buffers.getArray(dw), dw_is_direct ? Buffers.getDirectBufferByteOffset(dw) : Buffers.getIndirectBufferByteOffset(dw), dw_is_direct, dh_is_direct ? dh : Buffers.getArray(dh), dh_is_direct ? Buffers.getDirectBufferByteOffset(dh) : Buffers.getIndirectBufferByteOffset(dh), dh_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> int glXQueryChannelDeltasSGIX(Display *  display, int screen, int channel, int *  dx, int *  dy, int *  dw, int *  dh); </code> <br>Part of <code>GLX_SGIX_video_resize</code>
      @param dx a direct or array-backed {@link java.nio.IntBuffer}
      @param dy a direct or array-backed {@link java.nio.IntBuffer}
      @param dw a direct or array-backed {@link java.nio.IntBuffer}
      @param dh a direct or array-backed {@link java.nio.IntBuffer}   */
  private native int dispatch_glXQueryChannelDeltasSGIX1(long display, int screen, int channel, Object dx, int dx_byte_offset, boolean dx_is_direct, Object dy, int dy_byte_offset, boolean dy_is_direct, Object dw, int dw_byte_offset, boolean dw_is_direct, Object dh, int dh_byte_offset, boolean dh_is_direct, long procAddress);

  /** Entry point to C language function: <code> int glXQueryChannelDeltasSGIX(Display *  display, int screen, int channel, int *  dx, int *  dy, int *  dw, int *  dh); </code> <br>Part of <code>GLX_SGIX_video_resize</code>   */
  public int glXQueryChannelDeltasSGIX(long display, int screen, int channel, int[] dx, int dx_offset, int[] dy, int dy_offset, int[] dw, int dw_offset, int[] dh, int dh_offset)  {

    if(dx != null && dx.length <= dx_offset)
      throw new GLException("array offset argument \"dx_offset\" (" + dx_offset + ") equals or exceeds array length (" + dx.length + ")");
    if(dy != null && dy.length <= dy_offset)
      throw new GLException("array offset argument \"dy_offset\" (" + dy_offset + ") equals or exceeds array length (" + dy.length + ")");
    if(dw != null && dw.length <= dw_offset)
      throw new GLException("array offset argument \"dw_offset\" (" + dw_offset + ") equals or exceeds array length (" + dw.length + ")");
    if(dh != null && dh.length <= dh_offset)
      throw new GLException("array offset argument \"dh_offset\" (" + dh_offset + ") equals or exceeds array length (" + dh.length + ")");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryChannelDeltasSGIX;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryChannelDeltasSGIX\" not available");
    }
        return dispatch_glXQueryChannelDeltasSGIX1(display, screen, channel, dx, Buffers.SIZEOF_INT * dx_offset, false, dy, Buffers.SIZEOF_INT * dy_offset, false, dw, Buffers.SIZEOF_INT * dw_offset, false, dh, Buffers.SIZEOF_INT * dh_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> int glXQueryChannelRectSGIX(Display *  display, int screen, int channel, int *  dx, int *  dy, int *  dw, int *  dh); </code> <br>Part of <code>GLX_SGIX_video_resize</code>
      @param dx a direct or array-backed {@link java.nio.IntBuffer}
      @param dy a direct or array-backed {@link java.nio.IntBuffer}
      @param dw a direct or array-backed {@link java.nio.IntBuffer}
      @param dh a direct or array-backed {@link java.nio.IntBuffer}   */
  public int glXQueryChannelRectSGIX(long display, int screen, int channel, IntBuffer dx, IntBuffer dy, IntBuffer dw, IntBuffer dh)  {

    final boolean dx_is_direct = Buffers.isDirect(dx);
    final boolean dy_is_direct = Buffers.isDirect(dy);
    final boolean dw_is_direct = Buffers.isDirect(dw);
    final boolean dh_is_direct = Buffers.isDirect(dh);
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryChannelRectSGIX;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryChannelRectSGIX\" not available");
    }
        return dispatch_glXQueryChannelRectSGIX1(display, screen, channel, dx_is_direct ? dx : Buffers.getArray(dx), dx_is_direct ? Buffers.getDirectBufferByteOffset(dx) : Buffers.getIndirectBufferByteOffset(dx), dx_is_direct, dy_is_direct ? dy : Buffers.getArray(dy), dy_is_direct ? Buffers.getDirectBufferByteOffset(dy) : Buffers.getIndirectBufferByteOffset(dy), dy_is_direct, dw_is_direct ? dw : Buffers.getArray(dw), dw_is_direct ? Buffers.getDirectBufferByteOffset(dw) : Buffers.getIndirectBufferByteOffset(dw), dw_is_direct, dh_is_direct ? dh : Buffers.getArray(dh), dh_is_direct ? Buffers.getDirectBufferByteOffset(dh) : Buffers.getIndirectBufferByteOffset(dh), dh_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> int glXQueryChannelRectSGIX(Display *  display, int screen, int channel, int *  dx, int *  dy, int *  dw, int *  dh); </code> <br>Part of <code>GLX_SGIX_video_resize</code>
      @param dx a direct or array-backed {@link java.nio.IntBuffer}
      @param dy a direct or array-backed {@link java.nio.IntBuffer}
      @param dw a direct or array-backed {@link java.nio.IntBuffer}
      @param dh a direct or array-backed {@link java.nio.IntBuffer}   */
  private native int dispatch_glXQueryChannelRectSGIX1(long display, int screen, int channel, Object dx, int dx_byte_offset, boolean dx_is_direct, Object dy, int dy_byte_offset, boolean dy_is_direct, Object dw, int dw_byte_offset, boolean dw_is_direct, Object dh, int dh_byte_offset, boolean dh_is_direct, long procAddress);

  /** Entry point to C language function: <code> int glXQueryChannelRectSGIX(Display *  display, int screen, int channel, int *  dx, int *  dy, int *  dw, int *  dh); </code> <br>Part of <code>GLX_SGIX_video_resize</code>   */
  public int glXQueryChannelRectSGIX(long display, int screen, int channel, int[] dx, int dx_offset, int[] dy, int dy_offset, int[] dw, int dw_offset, int[] dh, int dh_offset)  {

    if(dx != null && dx.length <= dx_offset)
      throw new GLException("array offset argument \"dx_offset\" (" + dx_offset + ") equals or exceeds array length (" + dx.length + ")");
    if(dy != null && dy.length <= dy_offset)
      throw new GLException("array offset argument \"dy_offset\" (" + dy_offset + ") equals or exceeds array length (" + dy.length + ")");
    if(dw != null && dw.length <= dw_offset)
      throw new GLException("array offset argument \"dw_offset\" (" + dw_offset + ") equals or exceeds array length (" + dw.length + ")");
    if(dh != null && dh.length <= dh_offset)
      throw new GLException("array offset argument \"dh_offset\" (" + dh_offset + ") equals or exceeds array length (" + dh.length + ")");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryChannelRectSGIX;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryChannelRectSGIX\" not available");
    }
        return dispatch_glXQueryChannelRectSGIX1(display, screen, channel, dx, Buffers.SIZEOF_INT * dx_offset, false, dy, Buffers.SIZEOF_INT * dy_offset, false, dw, Buffers.SIZEOF_INT * dw_offset, false, dh, Buffers.SIZEOF_INT * dh_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> int glXQueryContextInfoEXT(Display *  dpy, GLXContext context, int attribute, int *  value); </code> <br>Part of <code>GLX_EXT_import_context</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public int glXQueryContextInfoEXT(long dpy, long context, int attribute, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryContextInfoEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryContextInfoEXT\" not available");
    }
        return dispatch_glXQueryContextInfoEXT1(dpy, context, attribute, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> int glXQueryContextInfoEXT(Display *  dpy, GLXContext context, int attribute, int *  value); </code> <br>Part of <code>GLX_EXT_import_context</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native int dispatch_glXQueryContextInfoEXT1(long dpy, long context, int attribute, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> int glXQueryContextInfoEXT(Display *  dpy, GLXContext context, int attribute, int *  value); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  public int glXQueryContextInfoEXT(long dpy, long context, int attribute, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryContextInfoEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryContextInfoEXT\" not available");
    }
        return dispatch_glXQueryContextInfoEXT1(dpy, context, attribute, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryFrameCountNV(Display *  dpy, int screen, GLuint *  count); </code> <br>Part of <code>GLX_NV_swap_group</code>
      @param count a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean glXQueryFrameCountNV(long dpy, int screen, IntBuffer count)  {

    final boolean count_is_direct = Buffers.isDirect(count);
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryFrameCountNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryFrameCountNV\" not available");
    }
        return dispatch_glXQueryFrameCountNV1(dpy, screen, count_is_direct ? count : Buffers.getArray(count), count_is_direct ? Buffers.getDirectBufferByteOffset(count) : Buffers.getIndirectBufferByteOffset(count), count_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryFrameCountNV(Display *  dpy, int screen, GLuint *  count); </code> <br>Part of <code>GLX_NV_swap_group</code>
      @param count a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_glXQueryFrameCountNV1(long dpy, int screen, Object count, int count_byte_offset, boolean count_is_direct, long procAddress);

  /** Entry point to C language function: <code> Bool glXQueryFrameCountNV(Display *  dpy, int screen, GLuint *  count); </code> <br>Part of <code>GLX_NV_swap_group</code>   */
  public boolean glXQueryFrameCountNV(long dpy, int screen, int[] count, int count_offset)  {

    if(count != null && count.length <= count_offset)
      throw new GLException("array offset argument \"count_offset\" (" + count_offset + ") equals or exceeds array length (" + count.length + ")");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryFrameCountNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryFrameCountNV\" not available");
    }
        return dispatch_glXQueryFrameCountNV1(dpy, screen, count, Buffers.SIZEOF_INT * count_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryMaxSwapBarriersSGIX(Display *  dpy, int screen, int *  max); </code> <br>Part of <code>GLX_SGIX_swap_barrier</code>
      @param max a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean glXQueryMaxSwapBarriersSGIX(long dpy, int screen, IntBuffer max)  {

    final boolean max_is_direct = Buffers.isDirect(max);
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryMaxSwapBarriersSGIX;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryMaxSwapBarriersSGIX\" not available");
    }
        return dispatch_glXQueryMaxSwapBarriersSGIX1(dpy, screen, max_is_direct ? max : Buffers.getArray(max), max_is_direct ? Buffers.getDirectBufferByteOffset(max) : Buffers.getIndirectBufferByteOffset(max), max_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryMaxSwapBarriersSGIX(Display *  dpy, int screen, int *  max); </code> <br>Part of <code>GLX_SGIX_swap_barrier</code>
      @param max a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_glXQueryMaxSwapBarriersSGIX1(long dpy, int screen, Object max, int max_byte_offset, boolean max_is_direct, long procAddress);

  /** Entry point to C language function: <code> Bool glXQueryMaxSwapBarriersSGIX(Display *  dpy, int screen, int *  max); </code> <br>Part of <code>GLX_SGIX_swap_barrier</code>   */
  public boolean glXQueryMaxSwapBarriersSGIX(long dpy, int screen, int[] max, int max_offset)  {

    if(max != null && max.length <= max_offset)
      throw new GLException("array offset argument \"max_offset\" (" + max_offset + ") equals or exceeds array length (" + max.length + ")");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryMaxSwapBarriersSGIX;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryMaxSwapBarriersSGIX\" not available");
    }
        return dispatch_glXQueryMaxSwapBarriersSGIX1(dpy, screen, max, Buffers.SIZEOF_INT * max_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryMaxSwapGroupsNV(Display *  dpy, int screen, GLuint *  maxGroups, GLuint *  maxBarriers); </code> <br>Part of <code>GLX_NV_swap_group</code>
      @param maxGroups a direct or array-backed {@link java.nio.IntBuffer}
      @param maxBarriers a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean glXQueryMaxSwapGroupsNV(long dpy, int screen, IntBuffer maxGroups, IntBuffer maxBarriers)  {

    final boolean maxGroups_is_direct = Buffers.isDirect(maxGroups);
    final boolean maxBarriers_is_direct = Buffers.isDirect(maxBarriers);
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryMaxSwapGroupsNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryMaxSwapGroupsNV\" not available");
    }
        return dispatch_glXQueryMaxSwapGroupsNV1(dpy, screen, maxGroups_is_direct ? maxGroups : Buffers.getArray(maxGroups), maxGroups_is_direct ? Buffers.getDirectBufferByteOffset(maxGroups) : Buffers.getIndirectBufferByteOffset(maxGroups), maxGroups_is_direct, maxBarriers_is_direct ? maxBarriers : Buffers.getArray(maxBarriers), maxBarriers_is_direct ? Buffers.getDirectBufferByteOffset(maxBarriers) : Buffers.getIndirectBufferByteOffset(maxBarriers), maxBarriers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryMaxSwapGroupsNV(Display *  dpy, int screen, GLuint *  maxGroups, GLuint *  maxBarriers); </code> <br>Part of <code>GLX_NV_swap_group</code>
      @param maxGroups a direct or array-backed {@link java.nio.IntBuffer}
      @param maxBarriers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_glXQueryMaxSwapGroupsNV1(long dpy, int screen, Object maxGroups, int maxGroups_byte_offset, boolean maxGroups_is_direct, Object maxBarriers, int maxBarriers_byte_offset, boolean maxBarriers_is_direct, long procAddress);

  /** Entry point to C language function: <code> Bool glXQueryMaxSwapGroupsNV(Display *  dpy, int screen, GLuint *  maxGroups, GLuint *  maxBarriers); </code> <br>Part of <code>GLX_NV_swap_group</code>   */
  public boolean glXQueryMaxSwapGroupsNV(long dpy, int screen, int[] maxGroups, int maxGroups_offset, int[] maxBarriers, int maxBarriers_offset)  {

    if(maxGroups != null && maxGroups.length <= maxGroups_offset)
      throw new GLException("array offset argument \"maxGroups_offset\" (" + maxGroups_offset + ") equals or exceeds array length (" + maxGroups.length + ")");
    if(maxBarriers != null && maxBarriers.length <= maxBarriers_offset)
      throw new GLException("array offset argument \"maxBarriers_offset\" (" + maxBarriers_offset + ") equals or exceeds array length (" + maxBarriers.length + ")");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryMaxSwapGroupsNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryMaxSwapGroupsNV\" not available");
    }
        return dispatch_glXQueryMaxSwapGroupsNV1(dpy, screen, maxGroups, Buffers.SIZEOF_INT * maxGroups_offset, false, maxBarriers, Buffers.SIZEOF_INT * maxBarriers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQuerySwapGroupNV(Display *  dpy, XID drawable, GLuint *  group, GLuint *  barrier); </code> <br>Part of <code>GLX_NV_swap_group</code>
      @param group a direct or array-backed {@link java.nio.IntBuffer}
      @param barrier a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean glXQuerySwapGroupNV(long dpy, long drawable, IntBuffer group, IntBuffer barrier)  {

    final boolean group_is_direct = Buffers.isDirect(group);
    final boolean barrier_is_direct = Buffers.isDirect(barrier);
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQuerySwapGroupNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQuerySwapGroupNV\" not available");
    }
        return dispatch_glXQuerySwapGroupNV1(dpy, drawable, group_is_direct ? group : Buffers.getArray(group), group_is_direct ? Buffers.getDirectBufferByteOffset(group) : Buffers.getIndirectBufferByteOffset(group), group_is_direct, barrier_is_direct ? barrier : Buffers.getArray(barrier), barrier_is_direct ? Buffers.getDirectBufferByteOffset(barrier) : Buffers.getIndirectBufferByteOffset(barrier), barrier_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQuerySwapGroupNV(Display *  dpy, XID drawable, GLuint *  group, GLuint *  barrier); </code> <br>Part of <code>GLX_NV_swap_group</code>
      @param group a direct or array-backed {@link java.nio.IntBuffer}
      @param barrier a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_glXQuerySwapGroupNV1(long dpy, long drawable, Object group, int group_byte_offset, boolean group_is_direct, Object barrier, int barrier_byte_offset, boolean barrier_is_direct, long procAddress);

  /** Entry point to C language function: <code> Bool glXQuerySwapGroupNV(Display *  dpy, XID drawable, GLuint *  group, GLuint *  barrier); </code> <br>Part of <code>GLX_NV_swap_group</code>   */
  public boolean glXQuerySwapGroupNV(long dpy, long drawable, int[] group, int group_offset, int[] barrier, int barrier_offset)  {

    if(group != null && group.length <= group_offset)
      throw new GLException("array offset argument \"group_offset\" (" + group_offset + ") equals or exceeds array length (" + group.length + ")");
    if(barrier != null && barrier.length <= barrier_offset)
      throw new GLException("array offset argument \"barrier_offset\" (" + barrier_offset + ") equals or exceeds array length (" + barrier.length + ")");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQuerySwapGroupNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQuerySwapGroupNV\" not available");
    }
        return dispatch_glXQuerySwapGroupNV1(dpy, drawable, group, Buffers.SIZEOF_INT * group_offset, false, barrier, Buffers.SIZEOF_INT * barrier_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXReleaseBuffersMESA(Display *  dpy, XID drawable); </code> <br>Part of <code>GLX_MESA_release_buffers</code>   */
  public boolean glXReleaseBuffersMESA(long dpy, long drawable)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXReleaseBuffersMESA;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXReleaseBuffersMESA\" not available");
    }
        return dispatch_glXReleaseBuffersMESA1(dpy, drawable, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXReleaseBuffersMESA(Display *  dpy, XID drawable); </code> <br>Part of <code>GLX_MESA_release_buffers</code>   */
  public native boolean dispatch_glXReleaseBuffersMESA1(long dpy, long drawable, long procAddress);

  /** Entry point to C language function: <code> void glXReleaseTexImageEXT(Display *  dpy, XID drawable, int buffer); </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code>   */
  public void glXReleaseTexImageEXT(long dpy, long drawable, int buffer)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXReleaseTexImageEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXReleaseTexImageEXT\" not available");
    }
        dispatch_glXReleaseTexImageEXT1(dpy, drawable, buffer, __addr_);
  }

  /** Entry point to C language function: <code> void glXReleaseTexImageEXT(Display *  dpy, XID drawable, int buffer); </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code>   */
  public native void dispatch_glXReleaseTexImageEXT1(long dpy, long drawable, int buffer, long procAddress);

  /** Entry point to C language function: <code> int glXReleaseVideoDeviceNV(Display *  dpy, int screen, GLXVideoDeviceNV VideoDevice); </code> <br>Part of <code>GLX_NV_video_out</code>   */
  public int glXReleaseVideoDeviceNV(long dpy, int screen, int VideoDevice)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXReleaseVideoDeviceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXReleaseVideoDeviceNV\" not available");
    }
        return dispatch_glXReleaseVideoDeviceNV1(dpy, screen, VideoDevice, __addr_);
  }

  /** Entry point to C language function: <code> int glXReleaseVideoDeviceNV(Display *  dpy, int screen, GLXVideoDeviceNV VideoDevice); </code> <br>Part of <code>GLX_NV_video_out</code>   */
  public native int dispatch_glXReleaseVideoDeviceNV1(long dpy, int screen, int VideoDevice, long procAddress);

  /** Entry point to C language function: <code> int glXReleaseVideoImageNV(Display *  dpy, XID pbuf); </code> <br>Part of <code>GLX_NV_video_out</code>   */
  public int glXReleaseVideoImageNV(long dpy, long pbuf)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXReleaseVideoImageNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXReleaseVideoImageNV\" not available");
    }
        return dispatch_glXReleaseVideoImageNV1(dpy, pbuf, __addr_);
  }

  /** Entry point to C language function: <code> int glXReleaseVideoImageNV(Display *  dpy, XID pbuf); </code> <br>Part of <code>GLX_NV_video_out</code>   */
  public native int dispatch_glXReleaseVideoImageNV1(long dpy, long pbuf, long procAddress);

  /** Entry point to C language function: <code> Bool glXResetFrameCountNV(Display *  dpy, int screen); </code> <br>Part of <code>GLX_NV_swap_group</code>   */
  public boolean glXResetFrameCountNV(long dpy, int screen)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXResetFrameCountNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXResetFrameCountNV\" not available");
    }
        return dispatch_glXResetFrameCountNV1(dpy, screen, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXResetFrameCountNV(Display *  dpy, int screen); </code> <br>Part of <code>GLX_NV_swap_group</code>   */
  public native boolean dispatch_glXResetFrameCountNV1(long dpy, int screen, long procAddress);

  /** Entry point to C language function: <code> int glXSendPbufferToVideoNV(Display *  dpy, XID pbuf, int iBufferType, unsigned long *  pulCounterPbuffer, GLboolean bBlock); </code> <br>Part of <code>GLX_NV_video_out</code>
      @param pulCounterPbuffer a direct or array-backed {@link java.nio.LongBuffer}   */
  public int glXSendPbufferToVideoNV(long dpy, long pbuf, int iBufferType, LongBuffer pulCounterPbuffer, boolean bBlock)  {

    final boolean pulCounterPbuffer_is_direct = Buffers.isDirect(pulCounterPbuffer);
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXSendPbufferToVideoNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXSendPbufferToVideoNV\" not available");
    }
        return dispatch_glXSendPbufferToVideoNV1(dpy, pbuf, iBufferType, pulCounterPbuffer_is_direct ? pulCounterPbuffer : Buffers.getArray(pulCounterPbuffer), pulCounterPbuffer_is_direct ? Buffers.getDirectBufferByteOffset(pulCounterPbuffer) : Buffers.getIndirectBufferByteOffset(pulCounterPbuffer), pulCounterPbuffer_is_direct, bBlock, __addr_);
  }

  /** Entry point to C language function: <code> int glXSendPbufferToVideoNV(Display *  dpy, XID pbuf, int iBufferType, unsigned long *  pulCounterPbuffer, GLboolean bBlock); </code> <br>Part of <code>GLX_NV_video_out</code>
      @param pulCounterPbuffer a direct or array-backed {@link java.nio.LongBuffer}   */
  private native int dispatch_glXSendPbufferToVideoNV1(long dpy, long pbuf, int iBufferType, Object pulCounterPbuffer, int pulCounterPbuffer_byte_offset, boolean pulCounterPbuffer_is_direct, boolean bBlock, long procAddress);

  /** Entry point to C language function: <code> int glXSendPbufferToVideoNV(Display *  dpy, XID pbuf, int iBufferType, unsigned long *  pulCounterPbuffer, GLboolean bBlock); </code> <br>Part of <code>GLX_NV_video_out</code>   */
  public int glXSendPbufferToVideoNV(long dpy, long pbuf, int iBufferType, long[] pulCounterPbuffer, int pulCounterPbuffer_offset, boolean bBlock)  {

    if(pulCounterPbuffer != null && pulCounterPbuffer.length <= pulCounterPbuffer_offset)
      throw new GLException("array offset argument \"pulCounterPbuffer_offset\" (" + pulCounterPbuffer_offset + ") equals or exceeds array length (" + pulCounterPbuffer.length + ")");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXSendPbufferToVideoNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXSendPbufferToVideoNV\" not available");
    }
        return dispatch_glXSendPbufferToVideoNV1(dpy, pbuf, iBufferType, pulCounterPbuffer, Buffers.SIZEOF_LONG * pulCounterPbuffer_offset, false, bBlock, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXSet3DfxModeMESA(int interval); </code> <br>Part of <code>GLX_MESA_set_3dfx_mode</code>   */
  public boolean glXSet3DfxModeMESA(int interval)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXSet3DfxModeMESA;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXSet3DfxModeMESA\" not available");
    }
        return dispatch_glXSet3DfxModeMESA1(interval, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXSet3DfxModeMESA(int interval); </code> <br>Part of <code>GLX_MESA_set_3dfx_mode</code>   */
  public native boolean dispatch_glXSet3DfxModeMESA1(int interval, long procAddress);

  /** Entry point to C language function: <code> int64_t glXSwapBuffersMscOML(Display *  dpy, XID drawable, int64_t target_msc, int64_t divisor, int64_t remainder); </code> <br>Part of <code>GLX_OML_sync_control</code>   */
  public long glXSwapBuffersMscOML(long dpy, long drawable, long target_msc, long divisor, long remainder)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXSwapBuffersMscOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXSwapBuffersMscOML\" not available");
    }
        return dispatch_glXSwapBuffersMscOML1(dpy, drawable, target_msc, divisor, remainder, __addr_);
  }

  /** Entry point to C language function: <code> int64_t glXSwapBuffersMscOML(Display *  dpy, XID drawable, int64_t target_msc, int64_t divisor, int64_t remainder); </code> <br>Part of <code>GLX_OML_sync_control</code>   */
  public native long dispatch_glXSwapBuffersMscOML1(long dpy, long drawable, long target_msc, long divisor, long remainder, long procAddress);

  /** Entry point to C language function: <code> int glXSwapIntervalSGI(int interval); </code> <br>Part of <code>GLX_SGI_swap_control</code>   */
  public int glXSwapIntervalSGI(int interval)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXSwapIntervalSGI;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXSwapIntervalSGI\" not available");
    }
        return dispatch_glXSwapIntervalSGI1(interval, __addr_);
  }

  /** Entry point to C language function: <code> int glXSwapIntervalSGI(int interval); </code> <br>Part of <code>GLX_SGI_swap_control</code>   */
  public native int dispatch_glXSwapIntervalSGI1(int interval, long procAddress);

  /** Entry point to C language function: <code> Bool glXWaitForMscOML(Display *  dpy, XID drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param ust a direct or array-backed {@link java.nio.LongBuffer}
      @param msc a direct or array-backed {@link java.nio.LongBuffer}
      @param sbc a direct or array-backed {@link java.nio.LongBuffer}   */
  public boolean glXWaitForMscOML(long dpy, long drawable, long target_msc, long divisor, long remainder, LongBuffer ust, LongBuffer msc, LongBuffer sbc)  {

    final boolean ust_is_direct = Buffers.isDirect(ust);
    final boolean msc_is_direct = Buffers.isDirect(msc);
    final boolean sbc_is_direct = Buffers.isDirect(sbc);
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXWaitForMscOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXWaitForMscOML\" not available");
    }
        return dispatch_glXWaitForMscOML1(dpy, drawable, target_msc, divisor, remainder, ust_is_direct ? ust : Buffers.getArray(ust), ust_is_direct ? Buffers.getDirectBufferByteOffset(ust) : Buffers.getIndirectBufferByteOffset(ust), ust_is_direct, msc_is_direct ? msc : Buffers.getArray(msc), msc_is_direct ? Buffers.getDirectBufferByteOffset(msc) : Buffers.getIndirectBufferByteOffset(msc), msc_is_direct, sbc_is_direct ? sbc : Buffers.getArray(sbc), sbc_is_direct ? Buffers.getDirectBufferByteOffset(sbc) : Buffers.getIndirectBufferByteOffset(sbc), sbc_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXWaitForMscOML(Display *  dpy, XID drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param ust a direct or array-backed {@link java.nio.LongBuffer}
      @param msc a direct or array-backed {@link java.nio.LongBuffer}
      @param sbc a direct or array-backed {@link java.nio.LongBuffer}   */
  private native boolean dispatch_glXWaitForMscOML1(long dpy, long drawable, long target_msc, long divisor, long remainder, Object ust, int ust_byte_offset, boolean ust_is_direct, Object msc, int msc_byte_offset, boolean msc_is_direct, Object sbc, int sbc_byte_offset, boolean sbc_is_direct, long procAddress);

  /** Entry point to C language function: <code> Bool glXWaitForMscOML(Display *  dpy, XID drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>   */
  public boolean glXWaitForMscOML(long dpy, long drawable, long target_msc, long divisor, long remainder, long[] ust, int ust_offset, long[] msc, int msc_offset, long[] sbc, int sbc_offset)  {

    if(ust != null && ust.length <= ust_offset)
      throw new GLException("array offset argument \"ust_offset\" (" + ust_offset + ") equals or exceeds array length (" + ust.length + ")");
    if(msc != null && msc.length <= msc_offset)
      throw new GLException("array offset argument \"msc_offset\" (" + msc_offset + ") equals or exceeds array length (" + msc.length + ")");
    if(sbc != null && sbc.length <= sbc_offset)
      throw new GLException("array offset argument \"sbc_offset\" (" + sbc_offset + ") equals or exceeds array length (" + sbc.length + ")");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXWaitForMscOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXWaitForMscOML\" not available");
    }
        return dispatch_glXWaitForMscOML1(dpy, drawable, target_msc, divisor, remainder, ust, Buffers.SIZEOF_LONG * ust_offset, false, msc, Buffers.SIZEOF_LONG * msc_offset, false, sbc, Buffers.SIZEOF_LONG * sbc_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXWaitForSbcOML(Display *  dpy, XID drawable, int64_t target_sbc, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param ust a direct or array-backed {@link java.nio.LongBuffer}
      @param msc a direct or array-backed {@link java.nio.LongBuffer}
      @param sbc a direct or array-backed {@link java.nio.LongBuffer}   */
  public boolean glXWaitForSbcOML(long dpy, long drawable, long target_sbc, LongBuffer ust, LongBuffer msc, LongBuffer sbc)  {

    final boolean ust_is_direct = Buffers.isDirect(ust);
    final boolean msc_is_direct = Buffers.isDirect(msc);
    final boolean sbc_is_direct = Buffers.isDirect(sbc);
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXWaitForSbcOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXWaitForSbcOML\" not available");
    }
        return dispatch_glXWaitForSbcOML1(dpy, drawable, target_sbc, ust_is_direct ? ust : Buffers.getArray(ust), ust_is_direct ? Buffers.getDirectBufferByteOffset(ust) : Buffers.getIndirectBufferByteOffset(ust), ust_is_direct, msc_is_direct ? msc : Buffers.getArray(msc), msc_is_direct ? Buffers.getDirectBufferByteOffset(msc) : Buffers.getIndirectBufferByteOffset(msc), msc_is_direct, sbc_is_direct ? sbc : Buffers.getArray(sbc), sbc_is_direct ? Buffers.getDirectBufferByteOffset(sbc) : Buffers.getIndirectBufferByteOffset(sbc), sbc_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXWaitForSbcOML(Display *  dpy, XID drawable, int64_t target_sbc, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param ust a direct or array-backed {@link java.nio.LongBuffer}
      @param msc a direct or array-backed {@link java.nio.LongBuffer}
      @param sbc a direct or array-backed {@link java.nio.LongBuffer}   */
  private native boolean dispatch_glXWaitForSbcOML1(long dpy, long drawable, long target_sbc, Object ust, int ust_byte_offset, boolean ust_is_direct, Object msc, int msc_byte_offset, boolean msc_is_direct, Object sbc, int sbc_byte_offset, boolean sbc_is_direct, long procAddress);

  /** Entry point to C language function: <code> Bool glXWaitForSbcOML(Display *  dpy, XID drawable, int64_t target_sbc, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>   */
  public boolean glXWaitForSbcOML(long dpy, long drawable, long target_sbc, long[] ust, int ust_offset, long[] msc, int msc_offset, long[] sbc, int sbc_offset)  {

    if(ust != null && ust.length <= ust_offset)
      throw new GLException("array offset argument \"ust_offset\" (" + ust_offset + ") equals or exceeds array length (" + ust.length + ")");
    if(msc != null && msc.length <= msc_offset)
      throw new GLException("array offset argument \"msc_offset\" (" + msc_offset + ") equals or exceeds array length (" + msc.length + ")");
    if(sbc != null && sbc.length <= sbc_offset)
      throw new GLException("array offset argument \"sbc_offset\" (" + sbc_offset + ") equals or exceeds array length (" + sbc.length + ")");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXWaitForSbcOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXWaitForSbcOML\" not available");
    }
        return dispatch_glXWaitForSbcOML1(dpy, drawable, target_sbc, ust, Buffers.SIZEOF_LONG * ust_offset, false, msc, Buffers.SIZEOF_LONG * msc_offset, false, sbc, Buffers.SIZEOF_LONG * sbc_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> int glXWaitVideoSyncSGI(int divisor, int remainder, unsigned int *  count); </code> <br>Part of <code>GLX_SGI_video_sync</code>
      @param count a direct or array-backed {@link java.nio.IntBuffer}   */
  public int glXWaitVideoSyncSGI(int divisor, int remainder, IntBuffer count)  {

    final boolean count_is_direct = Buffers.isDirect(count);
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXWaitVideoSyncSGI;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXWaitVideoSyncSGI\" not available");
    }
        return dispatch_glXWaitVideoSyncSGI1(divisor, remainder, count_is_direct ? count : Buffers.getArray(count), count_is_direct ? Buffers.getDirectBufferByteOffset(count) : Buffers.getIndirectBufferByteOffset(count), count_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> int glXWaitVideoSyncSGI(int divisor, int remainder, unsigned int *  count); </code> <br>Part of <code>GLX_SGI_video_sync</code>
      @param count a direct or array-backed {@link java.nio.IntBuffer}   */
  private native int dispatch_glXWaitVideoSyncSGI1(int divisor, int remainder, Object count, int count_byte_offset, boolean count_is_direct, long procAddress);

  /** Entry point to C language function: <code> int glXWaitVideoSyncSGI(int divisor, int remainder, unsigned int *  count); </code> <br>Part of <code>GLX_SGI_video_sync</code>   */
  public int glXWaitVideoSyncSGI(int divisor, int remainder, int[] count, int count_offset)  {

    if(count != null && count.length <= count_offset)
      throw new GLException("array offset argument \"count_offset\" (" + count_offset + ") equals or exceeds array length (" + count.length + ")");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXWaitVideoSyncSGI;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXWaitVideoSyncSGI\" not available");
    }
        return dispatch_glXWaitVideoSyncSGI1(divisor, remainder, count, Buffers.SIZEOF_INT * count_offset, false, __addr_);
  }


  // --- Begin CustomJavaCode .cfg declarations
  public GLXExtImpl(X11GLXContext context) {
    this._context = context; 
  }
  public boolean isFunctionAvailable(String glFunctionName)
  {
    return _context.isFunctionAvailable(glFunctionName);
  }
  public boolean isExtensionAvailable(String glExtensionName)
  {
    return _context.isExtensionAvailable(glExtensionName);
  }
  private X11GLXContext _context;
  // ---- End CustomJavaCode .cfg declarations

} // end of class GLXExtImpl
