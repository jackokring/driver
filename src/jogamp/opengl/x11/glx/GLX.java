/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Fri Aug 03 06:28:39 CEST 2012 ----! */

package jogamp.opengl.x11.glx;

import java.util.*;
import javax.media.opengl.*;
import javax.media.opengl.fixedfunc.*;
import jogamp.opengl.*;
import jogamp.nativewindow.x11.*;
import com.jogamp.gluegen.runtime.opengl.GLProcAddressResolver;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

 /**
  * Provides access to the X11-specific OpenGL vendor extensions.
  * See {@link GLBase} for more information.
  */
public class GLX {

  /** Part of CORE DEF */
  public static final int HAS_STDDEF = 1;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_USE_GL = 1;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_BUFFER_SIZE = 2;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_LEVEL = 3;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_RGBA = 4;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_DOUBLEBUFFER = 5;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_STEREO = 6;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_AUX_BUFFERS = 7;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_RED_SIZE = 8;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_GREEN_SIZE = 9;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_BLUE_SIZE = 10;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_ALPHA_SIZE = 11;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_DEPTH_SIZE = 12;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_STENCIL_SIZE = 13;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_ACCUM_RED_SIZE = 14;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_ACCUM_GREEN_SIZE = 15;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_ACCUM_BLUE_SIZE = 16;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_ACCUM_ALPHA_SIZE = 17;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_BAD_SCREEN = 1;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_BAD_ATTRIBUTE = 2;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_NO_EXTENSION = 3;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_BAD_VISUAL = 4;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_BAD_CONTEXT = 5;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_BAD_VALUE = 6;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_BAD_ENUM = 7;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_VENDOR = 1;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_VERSION = 2;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_EXTENSIONS = 3;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_CONFIG_CAVEAT = 0x20;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final long GLX_DONT_CARE = 0xFFFFFFFF;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_SLOW_CONFIG = 0x8001;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_NON_CONFORMANT_CONFIG = 0x800D;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_X_VISUAL_TYPE = 0x22;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_TRANSPARENT_TYPE = 0x23;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_TRANSPARENT_INDEX_VALUE = 0x24;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_TRANSPARENT_RED_VALUE = 0x25;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_TRANSPARENT_GREEN_VALUE = 0x26;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_TRANSPARENT_BLUE_VALUE = 0x27;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_TRANSPARENT_ALPHA_VALUE = 0x28;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_MAX_PBUFFER_WIDTH = 0x8016;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_MAX_PBUFFER_HEIGHT = 0x8017;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_MAX_PBUFFER_PIXELS = 0x8018;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_PRESERVED_CONTENTS = 0x801B;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_LARGEST_PBUFFER = 0x801C;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_WIDTH = 0x801D;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_HEIGHT = 0x801E;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_EVENT_MASK = 0x801F;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_DRAWABLE_TYPE = 0x8010;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_FBCONFIG_ID = 0x8013;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_VISUAL_ID = 0x800B;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_WINDOW_BIT = 0x00000001;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_PIXMAP_BIT = 0x00000002;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_PBUFFER_BIT = 0x00000004;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_AUX_BUFFERS_BIT = 0x00000010;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_FRONT_LEFT_BUFFER_BIT = 0x00000001;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_FRONT_RIGHT_BUFFER_BIT = 0x00000002;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_BACK_LEFT_BUFFER_BIT = 0x00000004;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_BACK_RIGHT_BUFFER_BIT = 0x00000008;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_DEPTH_BUFFER_BIT = 0x00000020;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_STENCIL_BUFFER_BIT = 0x00000040;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_ACCUM_BUFFER_BIT = 0x00000080;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_RENDER_TYPE = 0x8011;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_X_RENDERABLE = 0x8012;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_NONE = 0x8000;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_TRUE_COLOR = 0x8002;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_DIRECT_COLOR = 0x8003;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_PSEUDO_COLOR = 0x8004;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_STATIC_COLOR = 0x8005;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_GRAY_SCALE = 0x8006;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_STATIC_GRAY = 0x8007;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_TRANSPARENT_RGB = 0x8008;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_TRANSPARENT_INDEX = 0x8009;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_RGBA_TYPE = 0x8014;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_COLOR_INDEX_TYPE = 0x8015;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_COLOR_INDEX_BIT = 0x00000002;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_RGBA_BIT = 0x00000001;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_SCREEN = 0x800C;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_PBUFFER_CLOBBER_MASK = 0x08000000;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_DAMAGED = 0x8020;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_SAVED = 0x8021;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_WINDOW = 0x8022;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_PBUFFER = 0x8023;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_PBUFFER_HEIGHT = 0x8040;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_PBUFFER_WIDTH = 0x8041;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_SAMPLE_BUFFERS = 0x186a0;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_SAMPLES = 0x186a1;
  /** Part of CORE DEF */
  public static final int GLX_VERSION_1_X = 1;
  /** Part of CORE DEF */
  public static final int GLX_GLXEXT_VERSION = 21;
  /** Part of <code>GLX_ARB_multisample</code> */
  public static final int GLX_SAMPLE_BUFFERS_ARB = 100000;
  /** Part of <code>GLX_ARB_multisample</code> */
  public static final int GLX_SAMPLES_ARB = 100001;
  /** Part of <code>GLX_ARB_fbconfig_float</code> */
  public static final int GLX_RGBA_FLOAT_TYPE_ARB = 0x20B9;
  /** Part of <code>GLX_ARB_fbconfig_float</code> */
  public static final int GLX_RGBA_FLOAT_BIT_ARB = 0x00000004;
  /** Part of <code>GLX_ARB_create_context</code> */
  public static final int GLX_CONTEXT_DEBUG_BIT_ARB = 0x00000001;
  /** Part of <code>GLX_ARB_create_context</code> */
  public static final int GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB = 0x00000002;
  /** Part of <code>GLX_ARB_create_context</code> */
  public static final int GLX_CONTEXT_CORE_PROFILE_BIT_ARB = 0x00000001;
  /** Part of <code>GLX_ARB_create_context</code> */
  public static final int GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB = 0x00000002;
  /** Part of <code>GLX_ARB_create_context</code> */
  public static final int GLX_CONTEXT_MAJOR_VERSION_ARB = 0x2091;
  /** Part of <code>GLX_ARB_create_context</code> */
  public static final int GLX_CONTEXT_MINOR_VERSION_ARB = 0x2092;
  /** Part of <code>GLX_ARB_create_context</code> */
  public static final int GLX_CONTEXT_FLAGS_ARB = 0x2094;
  /** Part of <code>GLX_ARB_create_context</code> */
  public static final int GLX_CONTEXT_PROFILE_MASK_ARB = 0x9126;
  /** Part of <code>GLX_ARB_create_context_robustness</code> */
  public static final int GLX_CONTEXT_ROBUST_ACCESS_BIT_ARB = 0x00000004;
  /** Part of <code>GLX_ARB_create_context_robustness</code> */
  public static final int GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB = 0x8256;
  /** Part of <code>GLX_ARB_create_context_robustness</code> */
  public static final int GLX_NO_RESET_NOTIFICATION_ARB = 0x8261;
  /** Part of <code>GLX_ARB_create_context_robustness</code> */
  public static final int GLX_LOSE_CONTEXT_ON_RESET_ARB = 0x8252;
  /** Part of <code>GLX_EXT_create_context_es2_profile</code> */
  public static final int GLX_CONTEXT_ES2_PROFILE_BIT_EXT = 0x00000004;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_X_VISUAL_TYPE_EXT = 0x22;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_TRANSPARENT_TYPE_EXT = 0x23;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_TRANSPARENT_INDEX_VALUE_EXT = 0x24;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_TRANSPARENT_RED_VALUE_EXT = 0x25;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_TRANSPARENT_GREEN_VALUE_EXT = 0x26;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_TRANSPARENT_BLUE_VALUE_EXT = 0x27;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_TRANSPARENT_ALPHA_VALUE_EXT = 0x28;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_NONE_EXT = 0x8000;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_TRUE_COLOR_EXT = 0x8002;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_DIRECT_COLOR_EXT = 0x8003;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_PSEUDO_COLOR_EXT = 0x8004;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_STATIC_COLOR_EXT = 0x8005;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_GRAY_SCALE_EXT = 0x8006;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_STATIC_GRAY_EXT = 0x8007;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_TRANSPARENT_RGB_EXT = 0x8008;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_TRANSPARENT_INDEX_EXT = 0x8009;
  /** Part of <code>GLX_EXT_visual_rating</code> */
  public static final int GLX_VISUAL_CAVEAT_EXT = 0x20;
  /** Part of <code>GLX_EXT_visual_rating</code> */
  public static final int GLX_SLOW_VISUAL_EXT = 0x8001;
  /** Part of <code>GLX_EXT_visual_rating</code> */
  public static final int GLX_NON_CONFORMANT_VISUAL_EXT = 0x800D;
  /** Part of <code>GLX_EXT_import_context</code> */
  public static final int GLX_SHARE_CONTEXT_EXT = 0x800A;
  /** Part of <code>GLX_EXT_import_context</code> */
  public static final int GLX_VISUAL_ID_EXT = 0x800B;
  /** Part of <code>GLX_EXT_import_context</code> */
  public static final int GLX_SCREEN_EXT = 0x800C;
  /** Part of <code>GLX_OML_swap_method</code> */
  public static final int GLX_SWAP_METHOD_OML = 0x8060;
  /** Part of <code>GLX_OML_swap_method</code> */
  public static final int GLX_SWAP_EXCHANGE_OML = 0x8061;
  /** Part of <code>GLX_OML_swap_method</code> */
  public static final int GLX_SWAP_COPY_OML = 0x8062;
  /** Part of <code>GLX_OML_swap_method</code> */
  public static final int GLX_SWAP_UNDEFINED_OML = 0x8063;
  /** Part of CORE DEF */
  public static final int GLX_ARB_get_proc_address = 1;
  /** Part of <code>GLX_EXT_fbconfig_packed_float</code> */
  public static final int GLX_RGBA_UNSIGNED_FLOAT_TYPE_EXT = 0x20B1;
  /** Part of <code>GLX_EXT_fbconfig_packed_float</code> */
  public static final int GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT = 0x00000008;
  /** Part of <code>GLX_EXT_framebuffer_sRGB</code> */
  public static final int GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT = 0x20B2;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_BIND_TO_TEXTURE_RGB_EXT = 0x20D0;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_BIND_TO_TEXTURE_RGBA_EXT = 0x20D1;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_BIND_TO_MIPMAP_TEXTURE_EXT = 0x20D2;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_BIND_TO_TEXTURE_TARGETS_EXT = 0x20D3;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_Y_INVERTED_EXT = 0x20D4;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_TEXTURE_FORMAT_EXT = 0x20D5;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_TEXTURE_TARGET_EXT = 0x20D6;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_MIPMAP_TEXTURE_EXT = 0x20D7;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_TEXTURE_FORMAT_NONE_EXT = 0x20D8;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_TEXTURE_FORMAT_RGB_EXT = 0x20D9;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_TEXTURE_FORMAT_RGBA_EXT = 0x20DA;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_TEXTURE_1D_BIT_EXT = 0x00000001;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_TEXTURE_2D_BIT_EXT = 0x00000002;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_TEXTURE_RECTANGLE_BIT_EXT = 0x00000004;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_TEXTURE_1D_EXT = 0x20DB;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_TEXTURE_2D_EXT = 0x20DC;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_TEXTURE_RECTANGLE_EXT = 0x20DD;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_FRONT_LEFT_EXT = 0x20DE;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_FRONT_RIGHT_EXT = 0x20DF;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_BACK_LEFT_EXT = 0x20E0;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_BACK_RIGHT_EXT = 0x20E1;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_FRONT_EXT = 0x20DE;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_BACK_EXT = 0x20E0;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_AUX0_EXT = 0x20E2;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_AUX1_EXT = 0x20E3;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_AUX2_EXT = 0x20E4;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_AUX3_EXT = 0x20E5;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_AUX4_EXT = 0x20E6;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_AUX5_EXT = 0x20E7;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_AUX6_EXT = 0x20E8;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_AUX7_EXT = 0x20E9;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_AUX8_EXT = 0x20EA;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_AUX9_EXT = 0x20EB;
  /** Part of CORE DEF */
  public static final int GLX_ARB_multisample = 1;
  /** Part of CORE DEF */
  public static final int GLX_ARB_fbconfig_float = 1;
  /** Part of CORE DEF */
  public static final int GLX_ARB_create_context = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGIS_multisample = 1;
  /** Part of <code>GLX_GLXEXT_LEGACY</code> */
  public static final int GLX_EXT_visual_info = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGI_swap_control = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGI_video_sync = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGI_make_current_read = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGIX_video_source = 1;
  /** Part of CORE DEF */
  public static final int GLX_EXT_visual_rating = 1;
  /** Part of CORE DEF */
  public static final int GLX_EXT_import_context = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGIX_fbconfig = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGIX_pbuffer = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGI_cushion = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGIX_video_resize = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGIX_dmbuffer = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGIX_swap_group = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGIX_swap_barrier = 1;
  /** Part of CORE DEF */
  public static final int GLX_SUN_get_transparent_index = 1;
  /** Part of CORE DEF */
  public static final int GLX_MESA_copy_sub_buffer = 1;
  /** Part of CORE DEF */
  public static final int GLX_MESA_pixmap_colormap = 1;
  /** Part of CORE DEF */
  public static final int GLX_MESA_release_buffers = 1;
  /** Part of CORE DEF */
  public static final int GLX_MESA_set_3dfx_mode = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGIX_visual_select_group = 1;
  /** Part of CORE DEF */
  public static final int GLX_OML_swap_method = 1;
  /** Part of CORE DEF */
  public static final int GLX_OML_sync_control = 1;
  /** Part of CORE DEF */
  public static final int GLX_NV_float_buffer = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGIX_hyperpipe = 1;
  /** Part of CORE DEF */
  public static final int GLX_MESA_agp_offset = 1;
  /** Part of CORE DEF */
  public static final int GLX_NV_vertex_array_range = 1;
  /** Part of CORE DEF */
  public static final int GLX_NV_swap_group = 1;
  /** Part of CORE DEF */
  public static final int GLX_NV_video_out = 1;
  /** Part of CORE DEF */
  public static final int GLX_EXT_fbconfig_packed_float = 1;
  /** Part of CORE DEF */
  public static final int GLX_EXT_framebuffer_sRGB = 1;
  /** Part of CORE DEF */
  public static final int GLX_NV_present_video = 1;
  /** Part of CORE DEF */
  public static final int GLX_NV_multisample_coverage = 1;

  /** Entry point to C language function: <code> void glXBindTexImageEXT(Display *  dpy, XID drawable, int buffer, const int *  attrib_list); </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glXBindTexImageEXT(long dpy, long drawable, int buffer, IntBuffer attrib_list)  {

    final boolean attrib_list_is_direct = Buffers.isDirect(attrib_list);
    final long __addr_ = glxProcAddressTable._addressof_glXBindTexImageEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXBindTexImageEXT\" not available");
    }
        dispatch_glXBindTexImageEXT1(dpy, drawable, buffer, attrib_list_is_direct ? attrib_list : Buffers.getArray(attrib_list), attrib_list_is_direct ? Buffers.getDirectBufferByteOffset(attrib_list) : Buffers.getIndirectBufferByteOffset(attrib_list), attrib_list_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void glXBindTexImageEXT(Display *  dpy, XID drawable, int buffer, const int *  attrib_list); </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code>
      @param attrib_list a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_glXBindTexImageEXT1(long dpy, long drawable, int buffer, Object attrib_list, int attrib_list_byte_offset, boolean attrib_list_is_direct, long procAddress);

  /** Entry point to C language function: <code> void glXBindTexImageEXT(Display *  dpy, XID drawable, int buffer, const int *  attrib_list); </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code>   */
  public static void glXBindTexImageEXT(long dpy, long drawable, int buffer, int[] attrib_list, int attrib_list_offset)  {

    if(attrib_list != null && attrib_list.length <= attrib_list_offset)
      throw new GLException("array offset argument \"attrib_list_offset\" (" + attrib_list_offset + ") equals or exceeds array length (" + attrib_list.length + ")");
    final long __addr_ = glxProcAddressTable._addressof_glXBindTexImageEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXBindTexImageEXT\" not available");
    }
        dispatch_glXBindTexImageEXT1(dpy, drawable, buffer, attrib_list, Buffers.SIZEOF_INT * attrib_list_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void glXCopyContext(Display *  dpy, GLXContext src, GLXContext dst, unsigned long mask); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXCopyContext(long dpy, long src, long dst, long mask)  {

    final long __addr_ = glxProcAddressTable._addressof_glXCopyContext;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCopyContext\" not available");
    }
        dispatch_glXCopyContext1(dpy, src, dst, mask, __addr_);
  }

  /** Entry point to C language function: <code> void glXCopyContext(Display *  dpy, GLXContext src, GLXContext dst, unsigned long mask); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native void dispatch_glXCopyContext1(long dpy, long src, long dst, long mask, long procAddress);

  /** Entry point to C language function: <code> GLXContext glXCreateContext(Display *  dpy, XVisualInfo *  vis, GLXContext shareList, Bool direct); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static long glXCreateContext(long dpy, XVisualInfo vis, long shareList, boolean direct)  {

    final long __addr_ = glxProcAddressTable._addressof_glXCreateContext;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCreateContext\" not available");
    }
        return dispatch_glXCreateContext1(dpy, ((vis == null) ? null : vis.getBuffer()), shareList, direct, __addr_);
  }

  /** Entry point to C language function: <code> GLXContext glXCreateContext(Display *  dpy, XVisualInfo *  vis, GLXContext shareList, Bool direct); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  private static native long dispatch_glXCreateContext1(long dpy, ByteBuffer vis, long shareList, boolean direct, long procAddress);

  /** Entry point to C language function: <code> XID glXCreateGLXPixmap(Display *  dpy, XVisualInfo *  visual, XID pixmap); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static long glXCreateGLXPixmap(long dpy, XVisualInfo visual, long pixmap)  {

    final long __addr_ = glxProcAddressTable._addressof_glXCreateGLXPixmap;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCreateGLXPixmap\" not available");
    }
        return dispatch_glXCreateGLXPixmap1(dpy, ((visual == null) ? null : visual.getBuffer()), pixmap, __addr_);
  }

  /** Entry point to C language function: <code> XID glXCreateGLXPixmap(Display *  dpy, XVisualInfo *  visual, XID pixmap); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  private static native long dispatch_glXCreateGLXPixmap1(long dpy, ByteBuffer visual, long pixmap, long procAddress);

  /** Entry point to C language function: <code> GLXContext glXCreateNewContext(Display *  dpy, GLXFBConfig config, int renderType, GLXContext shareList, Bool direct); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static long glXCreateNewContext(long dpy, long config, int renderType, long shareList, boolean direct)  {

    final long __addr_ = glxProcAddressTable._addressof_glXCreateNewContext;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCreateNewContext\" not available");
    }
        return dispatch_glXCreateNewContext1(dpy, config, renderType, shareList, direct, __addr_);
  }

  /** Entry point to C language function: <code> GLXContext glXCreateNewContext(Display *  dpy, GLXFBConfig config, int renderType, GLXContext shareList, Bool direct); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native long dispatch_glXCreateNewContext1(long dpy, long config, int renderType, long shareList, boolean direct, long procAddress);

  /** Entry point to C language function: <code> XID glXCreatePbuffer(Display *  dpy, GLXFBConfig config, const int *  attribList); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param attribList a direct or array-backed {@link java.nio.IntBuffer}   */
  public static long glXCreatePbuffer(long dpy, long config, IntBuffer attribList)  {

    final boolean attribList_is_direct = Buffers.isDirect(attribList);
    final long __addr_ = glxProcAddressTable._addressof_glXCreatePbuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCreatePbuffer\" not available");
    }
        return dispatch_glXCreatePbuffer1(dpy, config, attribList_is_direct ? attribList : Buffers.getArray(attribList), attribList_is_direct ? Buffers.getDirectBufferByteOffset(attribList) : Buffers.getIndirectBufferByteOffset(attribList), attribList_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> XID glXCreatePbuffer(Display *  dpy, GLXFBConfig config, const int *  attribList); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param attribList a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native long dispatch_glXCreatePbuffer1(long dpy, long config, Object attribList, int attribList_byte_offset, boolean attribList_is_direct, long procAddress);

  /** Entry point to C language function: <code> XID glXCreatePbuffer(Display *  dpy, GLXFBConfig config, const int *  attribList); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static long glXCreatePbuffer(long dpy, long config, int[] attribList, int attribList_offset)  {

    if(attribList != null && attribList.length <= attribList_offset)
      throw new GLException("array offset argument \"attribList_offset\" (" + attribList_offset + ") equals or exceeds array length (" + attribList.length + ")");
    final long __addr_ = glxProcAddressTable._addressof_glXCreatePbuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCreatePbuffer\" not available");
    }
        return dispatch_glXCreatePbuffer1(dpy, config, attribList, Buffers.SIZEOF_INT * attribList_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> XID glXCreatePixmap(Display *  dpy, GLXFBConfig config, XID pixmap, const int *  attribList); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param attribList a direct or array-backed {@link java.nio.IntBuffer}   */
  public static long glXCreatePixmap(long dpy, long config, long pixmap, IntBuffer attribList)  {

    final boolean attribList_is_direct = Buffers.isDirect(attribList);
    final long __addr_ = glxProcAddressTable._addressof_glXCreatePixmap;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCreatePixmap\" not available");
    }
        return dispatch_glXCreatePixmap1(dpy, config, pixmap, attribList_is_direct ? attribList : Buffers.getArray(attribList), attribList_is_direct ? Buffers.getDirectBufferByteOffset(attribList) : Buffers.getIndirectBufferByteOffset(attribList), attribList_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> XID glXCreatePixmap(Display *  dpy, GLXFBConfig config, XID pixmap, const int *  attribList); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param attribList a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native long dispatch_glXCreatePixmap1(long dpy, long config, long pixmap, Object attribList, int attribList_byte_offset, boolean attribList_is_direct, long procAddress);

  /** Entry point to C language function: <code> XID glXCreatePixmap(Display *  dpy, GLXFBConfig config, XID pixmap, const int *  attribList); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static long glXCreatePixmap(long dpy, long config, long pixmap, int[] attribList, int attribList_offset)  {

    if(attribList != null && attribList.length <= attribList_offset)
      throw new GLException("array offset argument \"attribList_offset\" (" + attribList_offset + ") equals or exceeds array length (" + attribList.length + ")");
    final long __addr_ = glxProcAddressTable._addressof_glXCreatePixmap;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCreatePixmap\" not available");
    }
        return dispatch_glXCreatePixmap1(dpy, config, pixmap, attribList, Buffers.SIZEOF_INT * attribList_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> XID glXCreateWindow(Display *  dpy, GLXFBConfig config, XID win, const int *  attribList); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param attribList a direct or array-backed {@link java.nio.IntBuffer}   */
  public static long glXCreateWindow(long dpy, long config, long win, IntBuffer attribList)  {

    final boolean attribList_is_direct = Buffers.isDirect(attribList);
    final long __addr_ = glxProcAddressTable._addressof_glXCreateWindow;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCreateWindow\" not available");
    }
        return dispatch_glXCreateWindow1(dpy, config, win, attribList_is_direct ? attribList : Buffers.getArray(attribList), attribList_is_direct ? Buffers.getDirectBufferByteOffset(attribList) : Buffers.getIndirectBufferByteOffset(attribList), attribList_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> XID glXCreateWindow(Display *  dpy, GLXFBConfig config, XID win, const int *  attribList); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param attribList a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native long dispatch_glXCreateWindow1(long dpy, long config, long win, Object attribList, int attribList_byte_offset, boolean attribList_is_direct, long procAddress);

  /** Entry point to C language function: <code> XID glXCreateWindow(Display *  dpy, GLXFBConfig config, XID win, const int *  attribList); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static long glXCreateWindow(long dpy, long config, long win, int[] attribList, int attribList_offset)  {

    if(attribList != null && attribList.length <= attribList_offset)
      throw new GLException("array offset argument \"attribList_offset\" (" + attribList_offset + ") equals or exceeds array length (" + attribList.length + ")");
    final long __addr_ = glxProcAddressTable._addressof_glXCreateWindow;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCreateWindow\" not available");
    }
        return dispatch_glXCreateWindow1(dpy, config, win, attribList, Buffers.SIZEOF_INT * attribList_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void glXDestroyContext(Display *  dpy, GLXContext ctx); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXDestroyContext(long dpy, long ctx)  {

    final long __addr_ = glxProcAddressTable._addressof_glXDestroyContext;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXDestroyContext\" not available");
    }
        dispatch_glXDestroyContext1(dpy, ctx, __addr_);
  }

  /** Entry point to C language function: <code> void glXDestroyContext(Display *  dpy, GLXContext ctx); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native void dispatch_glXDestroyContext1(long dpy, long ctx, long procAddress);

  /** Entry point to C language function: <code> void glXDestroyGLXPixmap(Display *  dpy, XID pixmap); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXDestroyGLXPixmap(long dpy, long pixmap)  {

    final long __addr_ = glxProcAddressTable._addressof_glXDestroyGLXPixmap;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXDestroyGLXPixmap\" not available");
    }
        dispatch_glXDestroyGLXPixmap1(dpy, pixmap, __addr_);
  }

  /** Entry point to C language function: <code> void glXDestroyGLXPixmap(Display *  dpy, XID pixmap); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native void dispatch_glXDestroyGLXPixmap1(long dpy, long pixmap, long procAddress);

  /** Entry point to C language function: <code> void glXDestroyPbuffer(Display *  dpy, XID pbuf); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXDestroyPbuffer(long dpy, long pbuf)  {

    final long __addr_ = glxProcAddressTable._addressof_glXDestroyPbuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXDestroyPbuffer\" not available");
    }
        dispatch_glXDestroyPbuffer1(dpy, pbuf, __addr_);
  }

  /** Entry point to C language function: <code> void glXDestroyPbuffer(Display *  dpy, XID pbuf); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native void dispatch_glXDestroyPbuffer1(long dpy, long pbuf, long procAddress);

  /** Entry point to C language function: <code> void glXDestroyPixmap(Display *  dpy, XID pixmap); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXDestroyPixmap(long dpy, long pixmap)  {

    final long __addr_ = glxProcAddressTable._addressof_glXDestroyPixmap;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXDestroyPixmap\" not available");
    }
        dispatch_glXDestroyPixmap1(dpy, pixmap, __addr_);
  }

  /** Entry point to C language function: <code> void glXDestroyPixmap(Display *  dpy, XID pixmap); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native void dispatch_glXDestroyPixmap1(long dpy, long pixmap, long procAddress);

  /** Entry point to C language function: <code> void glXDestroyWindow(Display *  dpy, XID window); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXDestroyWindow(long dpy, long window)  {

    final long __addr_ = glxProcAddressTable._addressof_glXDestroyWindow;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXDestroyWindow\" not available");
    }
        dispatch_glXDestroyWindow1(dpy, window, __addr_);
  }

  /** Entry point to C language function: <code> void glXDestroyWindow(Display *  dpy, XID window); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native void dispatch_glXDestroyWindow1(long dpy, long window, long procAddress);

  /** Entry point to C language function: <code> const char *  glXGetClientString(Display *  dpy, int name); </code> <br>Part of CORE FUNC   */
  public static String glXGetClientString(long dpy, int name)  {

    final long __addr_ = glxProcAddressTable._addressof_glXGetClientString;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetClientString\" not available");
    }
        return dispatch_glXGetClientString1(dpy, name, __addr_);
  }

  /** Entry point to C language function: <code> const char *  glXGetClientString(Display *  dpy, int name); </code> <br>Part of CORE FUNC   */
  public static native String dispatch_glXGetClientString1(long dpy, int name, long procAddress);

  /** Entry point to C language function: <code> int glXGetConfig(Display *  dpy, XVisualInfo *  visual, int attrib, int *  value); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public static int glXGetConfig(long dpy, XVisualInfo visual, int attrib, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = glxProcAddressTable._addressof_glXGetConfig;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetConfig\" not available");
    }
        return dispatch_glXGetConfig1(dpy, ((visual == null) ? null : visual.getBuffer()), attrib, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> int glXGetConfig(Display *  dpy, XVisualInfo *  visual, int attrib, int *  value); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native int dispatch_glXGetConfig1(long dpy, ByteBuffer visual, int attrib, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> int glXGetConfig(Display *  dpy, XVisualInfo *  visual, int attrib, int *  value); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static int glXGetConfig(long dpy, XVisualInfo visual, int attrib, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = glxProcAddressTable._addressof_glXGetConfig;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetConfig\" not available");
    }
        return dispatch_glXGetConfig1(dpy, ((visual == null) ? null : visual.getBuffer()), attrib, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLXContext glXGetCurrentContext(void); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static long glXGetCurrentContext()  {

    final long __addr_ = glxProcAddressTable._addressof_glXGetCurrentContext;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetCurrentContext\" not available");
    }
        return dispatch_glXGetCurrentContext1(__addr_);
  }

  /** Entry point to C language function: <code> GLXContext glXGetCurrentContext(void); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native long dispatch_glXGetCurrentContext1(long procAddress);

  /** Entry point to C language function: <code> Display *  glXGetCurrentDisplay(void); </code> <br>Part of CORE FUNC   */
  public static long glXGetCurrentDisplay()  {

    final long __addr_ = glxProcAddressTable._addressof_glXGetCurrentDisplay;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetCurrentDisplay\" not available");
    }
        return dispatch_glXGetCurrentDisplay1(__addr_);
  }

  /** Entry point to C language function: <code> Display *  glXGetCurrentDisplay(void); </code> <br>Part of CORE FUNC   */
  public static native long dispatch_glXGetCurrentDisplay1(long procAddress);

  /** Entry point to C language function: <code> XID glXGetCurrentDrawable(void); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static long glXGetCurrentDrawable()  {

    final long __addr_ = glxProcAddressTable._addressof_glXGetCurrentDrawable;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetCurrentDrawable\" not available");
    }
        return dispatch_glXGetCurrentDrawable1(__addr_);
  }

  /** Entry point to C language function: <code> XID glXGetCurrentDrawable(void); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native long dispatch_glXGetCurrentDrawable1(long procAddress);

  /** Entry point to C language function: <code> XID glXGetCurrentReadDrawable(void); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static long glXGetCurrentReadDrawable()  {

    final long __addr_ = glxProcAddressTable._addressof_glXGetCurrentReadDrawable;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetCurrentReadDrawable\" not available");
    }
        return dispatch_glXGetCurrentReadDrawable1(__addr_);
  }

  /** Entry point to C language function: <code> XID glXGetCurrentReadDrawable(void); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native long dispatch_glXGetCurrentReadDrawable1(long procAddress);

  /** Entry point to C language function: <code> int glXGetFBConfigAttrib(Display *  dpy, GLXFBConfig config, int attribute, int *  value); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public static int glXGetFBConfigAttrib(long dpy, long config, int attribute, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = glxProcAddressTable._addressof_glXGetFBConfigAttrib;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetFBConfigAttrib\" not available");
    }
        return dispatch_glXGetFBConfigAttrib1(dpy, config, attribute, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> int glXGetFBConfigAttrib(Display *  dpy, GLXFBConfig config, int attribute, int *  value); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native int dispatch_glXGetFBConfigAttrib1(long dpy, long config, int attribute, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> int glXGetFBConfigAttrib(Display *  dpy, GLXFBConfig config, int attribute, int *  value); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static int glXGetFBConfigAttrib(long dpy, long config, int attribute, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = glxProcAddressTable._addressof_glXGetFBConfigAttrib;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetFBConfigAttrib\" not available");
    }
        return dispatch_glXGetFBConfigAttrib1(dpy, config, attribute, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLXFBConfig *  glXGetFBConfigs(Display *  dpy, int screen, int *  nelements); </code> <br>Part of CORE FUNC
      @param nelements a direct or array-backed {@link java.nio.IntBuffer}   */
  public static PointerBuffer glXGetFBConfigs(long dpy, int screen, IntBuffer nelements)  {

    final boolean nelements_is_direct = Buffers.isDirect(nelements);
    final long __addr_ = glxProcAddressTable._addressof_glXGetFBConfigs;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetFBConfigs\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_glXGetFBConfigs1(dpy, screen, nelements_is_direct ? nelements : Buffers.getArray(nelements), nelements_is_direct ? Buffers.getDirectBufferByteOffset(nelements) : Buffers.getIndirectBufferByteOffset(nelements), nelements_is_direct, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return PointerBuffer.wrap(_res);
  }

  /** Entry point to C language function: <code> GLXFBConfig *  glXGetFBConfigs(Display *  dpy, int screen, int *  nelements); </code> <br>Part of CORE FUNC
      @param nelements a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native ByteBuffer dispatch_glXGetFBConfigs1(long dpy, int screen, Object nelements, int nelements_byte_offset, boolean nelements_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLXFBConfig *  glXGetFBConfigs(Display *  dpy, int screen, int *  nelements); </code> <br>Part of CORE FUNC   */
  public static PointerBuffer glXGetFBConfigs(long dpy, int screen, int[] nelements, int nelements_offset)  {

    if(nelements != null && nelements.length <= nelements_offset)
      throw new GLException("array offset argument \"nelements_offset\" (" + nelements_offset + ") equals or exceeds array length (" + nelements.length + ")");
    final long __addr_ = glxProcAddressTable._addressof_glXGetFBConfigs;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetFBConfigs\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_glXGetFBConfigs1(dpy, screen, nelements, Buffers.SIZEOF_INT * nelements_offset, false, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return PointerBuffer.wrap(_res);
  }

  /** Entry point to C language function: <code> Bool glXGetMscRateOML(Display *  dpy, XID drawable, int32_t *  numerator, int32_t *  denominator); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param numerator a direct or array-backed {@link java.nio.IntBuffer}
      @param denominator a direct or array-backed {@link java.nio.IntBuffer}   */
  public static boolean glXGetMscRateOML(long dpy, long drawable, IntBuffer numerator, IntBuffer denominator)  {

    final boolean numerator_is_direct = Buffers.isDirect(numerator);
    final boolean denominator_is_direct = Buffers.isDirect(denominator);
    final long __addr_ = glxProcAddressTable._addressof_glXGetMscRateOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetMscRateOML\" not available");
    }
        return dispatch_glXGetMscRateOML1(dpy, drawable, numerator_is_direct ? numerator : Buffers.getArray(numerator), numerator_is_direct ? Buffers.getDirectBufferByteOffset(numerator) : Buffers.getIndirectBufferByteOffset(numerator), numerator_is_direct, denominator_is_direct ? denominator : Buffers.getArray(denominator), denominator_is_direct ? Buffers.getDirectBufferByteOffset(denominator) : Buffers.getIndirectBufferByteOffset(denominator), denominator_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXGetMscRateOML(Display *  dpy, XID drawable, int32_t *  numerator, int32_t *  denominator); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param numerator a direct or array-backed {@link java.nio.IntBuffer}
      @param denominator a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_glXGetMscRateOML1(long dpy, long drawable, Object numerator, int numerator_byte_offset, boolean numerator_is_direct, Object denominator, int denominator_byte_offset, boolean denominator_is_direct, long procAddress);

  /** Entry point to C language function: <code> Bool glXGetMscRateOML(Display *  dpy, XID drawable, int32_t *  numerator, int32_t *  denominator); </code> <br>Part of <code>GLX_OML_sync_control</code>   */
  public static boolean glXGetMscRateOML(long dpy, long drawable, int[] numerator, int numerator_offset, int[] denominator, int denominator_offset)  {

    if(numerator != null && numerator.length <= numerator_offset)
      throw new GLException("array offset argument \"numerator_offset\" (" + numerator_offset + ") equals or exceeds array length (" + numerator.length + ")");
    if(denominator != null && denominator.length <= denominator_offset)
      throw new GLException("array offset argument \"denominator_offset\" (" + denominator_offset + ") equals or exceeds array length (" + denominator.length + ")");
    final long __addr_ = glxProcAddressTable._addressof_glXGetMscRateOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetMscRateOML\" not available");
    }
        return dispatch_glXGetMscRateOML1(dpy, drawable, numerator, Buffers.SIZEOF_INT * numerator_offset, false, denominator, Buffers.SIZEOF_INT * denominator_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> __GLXextFuncPtr glXGetProcAddress(const GLubyte *  procname); </code> <br>Part of <code>GLX_ARB_get_proc_address</code>   */
  public static long glXGetProcAddress(String procname)  {

    final long __addr_ = glxProcAddressTable._addressof_glXGetProcAddress;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetProcAddress\" not available");
    }
        return dispatch_glXGetProcAddress1(procname, __addr_);
  }

  /** Entry point to C language function: <code> __GLXextFuncPtr glXGetProcAddress(const GLubyte *  procname); </code> <br>Part of <code>GLX_ARB_get_proc_address</code>   */
  public static native long dispatch_glXGetProcAddress1(String procname, long procAddress);

  /** Entry point to C language function: <code> __GLXextFuncPtr glXGetProcAddressARB(const GLubyte *  procName); </code> <br>Part of <code>GLX_ARB_get_proc_address</code>   */
  public static long glXGetProcAddressARB(String procName)  {

    final long __addr_ = glxProcAddressTable._addressof_glXGetProcAddressARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetProcAddressARB\" not available");
    }
        return dispatch_glXGetProcAddressARB1(procName, __addr_);
  }

  /** Entry point to C language function: <code> __GLXextFuncPtr glXGetProcAddressARB(const GLubyte *  procName); </code> <br>Part of <code>GLX_ARB_get_proc_address</code>   */
  public static native long dispatch_glXGetProcAddressARB1(String procName, long procAddress);

  /** Entry point to C language function: <code> void glXGetSelectedEvent(Display *  dpy, XID drawable, unsigned long *  mask); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param mask a direct or array-backed {@link java.nio.LongBuffer}   */
  public static void glXGetSelectedEvent(long dpy, long drawable, LongBuffer mask)  {

    final boolean mask_is_direct = Buffers.isDirect(mask);
    final long __addr_ = glxProcAddressTable._addressof_glXGetSelectedEvent;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetSelectedEvent\" not available");
    }
        dispatch_glXGetSelectedEvent1(dpy, drawable, mask_is_direct ? mask : Buffers.getArray(mask), mask_is_direct ? Buffers.getDirectBufferByteOffset(mask) : Buffers.getIndirectBufferByteOffset(mask), mask_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void glXGetSelectedEvent(Display *  dpy, XID drawable, unsigned long *  mask); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param mask a direct or array-backed {@link java.nio.LongBuffer}   */
  private static native void dispatch_glXGetSelectedEvent1(long dpy, long drawable, Object mask, int mask_byte_offset, boolean mask_is_direct, long procAddress);

  /** Entry point to C language function: <code> void glXGetSelectedEvent(Display *  dpy, XID drawable, unsigned long *  mask); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXGetSelectedEvent(long dpy, long drawable, long[] mask, int mask_offset)  {

    if(mask != null && mask.length <= mask_offset)
      throw new GLException("array offset argument \"mask_offset\" (" + mask_offset + ") equals or exceeds array length (" + mask.length + ")");
    final long __addr_ = glxProcAddressTable._addressof_glXGetSelectedEvent;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetSelectedEvent\" not available");
    }
        dispatch_glXGetSelectedEvent1(dpy, drawable, mask, Buffers.SIZEOF_LONG * mask_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXGetSyncValuesOML(Display *  dpy, XID drawable, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param ust a direct or array-backed {@link java.nio.LongBuffer}
      @param msc a direct or array-backed {@link java.nio.LongBuffer}
      @param sbc a direct or array-backed {@link java.nio.LongBuffer}   */
  public static boolean glXGetSyncValuesOML(long dpy, long drawable, LongBuffer ust, LongBuffer msc, LongBuffer sbc)  {

    final boolean ust_is_direct = Buffers.isDirect(ust);
    final boolean msc_is_direct = Buffers.isDirect(msc);
    final boolean sbc_is_direct = Buffers.isDirect(sbc);
    final long __addr_ = glxProcAddressTable._addressof_glXGetSyncValuesOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetSyncValuesOML\" not available");
    }
        return dispatch_glXGetSyncValuesOML1(dpy, drawable, ust_is_direct ? ust : Buffers.getArray(ust), ust_is_direct ? Buffers.getDirectBufferByteOffset(ust) : Buffers.getIndirectBufferByteOffset(ust), ust_is_direct, msc_is_direct ? msc : Buffers.getArray(msc), msc_is_direct ? Buffers.getDirectBufferByteOffset(msc) : Buffers.getIndirectBufferByteOffset(msc), msc_is_direct, sbc_is_direct ? sbc : Buffers.getArray(sbc), sbc_is_direct ? Buffers.getDirectBufferByteOffset(sbc) : Buffers.getIndirectBufferByteOffset(sbc), sbc_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXGetSyncValuesOML(Display *  dpy, XID drawable, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param ust a direct or array-backed {@link java.nio.LongBuffer}
      @param msc a direct or array-backed {@link java.nio.LongBuffer}
      @param sbc a direct or array-backed {@link java.nio.LongBuffer}   */
  private static native boolean dispatch_glXGetSyncValuesOML1(long dpy, long drawable, Object ust, int ust_byte_offset, boolean ust_is_direct, Object msc, int msc_byte_offset, boolean msc_is_direct, Object sbc, int sbc_byte_offset, boolean sbc_is_direct, long procAddress);

  /** Entry point to C language function: <code> Bool glXGetSyncValuesOML(Display *  dpy, XID drawable, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>   */
  public static boolean glXGetSyncValuesOML(long dpy, long drawable, long[] ust, int ust_offset, long[] msc, int msc_offset, long[] sbc, int sbc_offset)  {

    if(ust != null && ust.length <= ust_offset)
      throw new GLException("array offset argument \"ust_offset\" (" + ust_offset + ") equals or exceeds array length (" + ust.length + ")");
    if(msc != null && msc.length <= msc_offset)
      throw new GLException("array offset argument \"msc_offset\" (" + msc_offset + ") equals or exceeds array length (" + msc.length + ")");
    if(sbc != null && sbc.length <= sbc_offset)
      throw new GLException("array offset argument \"sbc_offset\" (" + sbc_offset + ") equals or exceeds array length (" + sbc.length + ")");
    final long __addr_ = glxProcAddressTable._addressof_glXGetSyncValuesOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetSyncValuesOML\" not available");
    }
        return dispatch_glXGetSyncValuesOML1(dpy, drawable, ust, Buffers.SIZEOF_LONG * ust_offset, false, msc, Buffers.SIZEOF_LONG * msc_offset, false, sbc, Buffers.SIZEOF_LONG * sbc_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXIsDirect(Display *  dpy, GLXContext ctx); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static boolean glXIsDirect(long dpy, long ctx)  {

    final long __addr_ = glxProcAddressTable._addressof_glXIsDirect;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXIsDirect\" not available");
    }
        return dispatch_glXIsDirect1(dpy, ctx, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXIsDirect(Display *  dpy, GLXContext ctx); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native boolean dispatch_glXIsDirect1(long dpy, long ctx, long procAddress);

  /** Entry point to C language function: <code> Bool glXMakeContextCurrent(Display *  dpy, XID draw, XID read, GLXContext ctx); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static boolean glXMakeContextCurrent(long dpy, long draw, long read, long ctx)  {

    final long __addr_ = glxProcAddressTable._addressof_glXMakeContextCurrent;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXMakeContextCurrent\" not available");
    }
        return dispatch_glXMakeContextCurrent1(dpy, draw, read, ctx, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXMakeContextCurrent(Display *  dpy, XID draw, XID read, GLXContext ctx); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native boolean dispatch_glXMakeContextCurrent1(long dpy, long draw, long read, long ctx, long procAddress);

  /** Entry point to C language function: <code> Bool glXMakeCurrent(Display *  dpy, XID drawable, GLXContext ctx); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static boolean glXMakeCurrent(long dpy, long drawable, long ctx)  {

    final long __addr_ = glxProcAddressTable._addressof_glXMakeCurrent;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXMakeCurrent\" not available");
    }
        return dispatch_glXMakeCurrent1(dpy, drawable, ctx, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXMakeCurrent(Display *  dpy, XID drawable, GLXContext ctx); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native boolean dispatch_glXMakeCurrent1(long dpy, long drawable, long ctx, long procAddress);

  /** Entry point to C language function: <code> int glXQueryContext(Display *  dpy, GLXContext ctx, int attribute, int *  value); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public static int glXQueryContext(long dpy, long ctx, int attribute, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = glxProcAddressTable._addressof_glXQueryContext;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryContext\" not available");
    }
        return dispatch_glXQueryContext1(dpy, ctx, attribute, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> int glXQueryContext(Display *  dpy, GLXContext ctx, int attribute, int *  value); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native int dispatch_glXQueryContext1(long dpy, long ctx, int attribute, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> int glXQueryContext(Display *  dpy, GLXContext ctx, int attribute, int *  value); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static int glXQueryContext(long dpy, long ctx, int attribute, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = glxProcAddressTable._addressof_glXQueryContext;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryContext\" not available");
    }
        return dispatch_glXQueryContext1(dpy, ctx, attribute, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void glXQueryDrawable(Display *  dpy, XID draw, int attribute, unsigned int *  value); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glXQueryDrawable(long dpy, long draw, int attribute, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = glxProcAddressTable._addressof_glXQueryDrawable;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryDrawable\" not available");
    }
        dispatch_glXQueryDrawable1(dpy, draw, attribute, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void glXQueryDrawable(Display *  dpy, XID draw, int attribute, unsigned int *  value); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_glXQueryDrawable1(long dpy, long draw, int attribute, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void glXQueryDrawable(Display *  dpy, XID draw, int attribute, unsigned int *  value); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXQueryDrawable(long dpy, long draw, int attribute, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = glxProcAddressTable._addressof_glXQueryDrawable;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryDrawable\" not available");
    }
        dispatch_glXQueryDrawable1(dpy, draw, attribute, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryExtension(Display *  dpy, int *  errorb, int *  event); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param errorb a direct or array-backed {@link java.nio.IntBuffer}
      @param event a direct or array-backed {@link java.nio.IntBuffer}   */
  public static boolean glXQueryExtension(long dpy, IntBuffer errorb, IntBuffer event)  {

    final boolean errorb_is_direct = Buffers.isDirect(errorb);
    final boolean event_is_direct = Buffers.isDirect(event);
    final long __addr_ = glxProcAddressTable._addressof_glXQueryExtension;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryExtension\" not available");
    }
        return dispatch_glXQueryExtension1(dpy, errorb_is_direct ? errorb : Buffers.getArray(errorb), errorb_is_direct ? Buffers.getDirectBufferByteOffset(errorb) : Buffers.getIndirectBufferByteOffset(errorb), errorb_is_direct, event_is_direct ? event : Buffers.getArray(event), event_is_direct ? Buffers.getDirectBufferByteOffset(event) : Buffers.getIndirectBufferByteOffset(event), event_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryExtension(Display *  dpy, int *  errorb, int *  event); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param errorb a direct or array-backed {@link java.nio.IntBuffer}
      @param event a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_glXQueryExtension1(long dpy, Object errorb, int errorb_byte_offset, boolean errorb_is_direct, Object event, int event_byte_offset, boolean event_is_direct, long procAddress);

  /** Entry point to C language function: <code> Bool glXQueryExtension(Display *  dpy, int *  errorb, int *  event); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static boolean glXQueryExtension(long dpy, int[] errorb, int errorb_offset, int[] event, int event_offset)  {

    if(errorb != null && errorb.length <= errorb_offset)
      throw new GLException("array offset argument \"errorb_offset\" (" + errorb_offset + ") equals or exceeds array length (" + errorb.length + ")");
    if(event != null && event.length <= event_offset)
      throw new GLException("array offset argument \"event_offset\" (" + event_offset + ") equals or exceeds array length (" + event.length + ")");
    final long __addr_ = glxProcAddressTable._addressof_glXQueryExtension;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryExtension\" not available");
    }
        return dispatch_glXQueryExtension1(dpy, errorb, Buffers.SIZEOF_INT * errorb_offset, false, event, Buffers.SIZEOF_INT * event_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> const char *  glXQueryExtensionsString(Display *  dpy, int screen); </code> <br>Part of CORE FUNC   */
  public static String glXQueryExtensionsString(long dpy, int screen)  {

    final long __addr_ = glxProcAddressTable._addressof_glXQueryExtensionsString;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryExtensionsString\" not available");
    }
        return dispatch_glXQueryExtensionsString1(dpy, screen, __addr_);
  }

  /** Entry point to C language function: <code> const char *  glXQueryExtensionsString(Display *  dpy, int screen); </code> <br>Part of CORE FUNC   */
  public static native String dispatch_glXQueryExtensionsString1(long dpy, int screen, long procAddress);

  /** Entry point to C language function: <code> const char *  glXQueryServerString(Display *  dpy, int screen, int name); </code> <br>Part of CORE FUNC   */
  public static String glXQueryServerString(long dpy, int screen, int name)  {

    final long __addr_ = glxProcAddressTable._addressof_glXQueryServerString;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryServerString\" not available");
    }
        return dispatch_glXQueryServerString1(dpy, screen, name, __addr_);
  }

  /** Entry point to C language function: <code> const char *  glXQueryServerString(Display *  dpy, int screen, int name); </code> <br>Part of CORE FUNC   */
  public static native String dispatch_glXQueryServerString1(long dpy, int screen, int name, long procAddress);

  /** Entry point to C language function: <code> Bool glXQueryVersion(Display *  dpy, int *  maj, int *  min); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param maj a direct or array-backed {@link java.nio.IntBuffer}
      @param min a direct or array-backed {@link java.nio.IntBuffer}   */
  public static boolean glXQueryVersion(long dpy, IntBuffer maj, IntBuffer min)  {

    final boolean maj_is_direct = Buffers.isDirect(maj);
    final boolean min_is_direct = Buffers.isDirect(min);
    final long __addr_ = glxProcAddressTable._addressof_glXQueryVersion;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryVersion\" not available");
    }
        return dispatch_glXQueryVersion1(dpy, maj_is_direct ? maj : Buffers.getArray(maj), maj_is_direct ? Buffers.getDirectBufferByteOffset(maj) : Buffers.getIndirectBufferByteOffset(maj), maj_is_direct, min_is_direct ? min : Buffers.getArray(min), min_is_direct ? Buffers.getDirectBufferByteOffset(min) : Buffers.getIndirectBufferByteOffset(min), min_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryVersion(Display *  dpy, int *  maj, int *  min); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param maj a direct or array-backed {@link java.nio.IntBuffer}
      @param min a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_glXQueryVersion1(long dpy, Object maj, int maj_byte_offset, boolean maj_is_direct, Object min, int min_byte_offset, boolean min_is_direct, long procAddress);

  /** Entry point to C language function: <code> Bool glXQueryVersion(Display *  dpy, int *  maj, int *  min); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static boolean glXQueryVersion(long dpy, int[] maj, int maj_offset, int[] min, int min_offset)  {

    if(maj != null && maj.length <= maj_offset)
      throw new GLException("array offset argument \"maj_offset\" (" + maj_offset + ") equals or exceeds array length (" + maj.length + ")");
    if(min != null && min.length <= min_offset)
      throw new GLException("array offset argument \"min_offset\" (" + min_offset + ") equals or exceeds array length (" + min.length + ")");
    final long __addr_ = glxProcAddressTable._addressof_glXQueryVersion;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryVersion\" not available");
    }
        return dispatch_glXQueryVersion1(dpy, maj, Buffers.SIZEOF_INT * maj_offset, false, min, Buffers.SIZEOF_INT * min_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void glXReleaseTexImageEXT(Display *  dpy, XID drawable, int buffer); </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code>   */
  public static void glXReleaseTexImageEXT(long dpy, long drawable, int buffer)  {

    final long __addr_ = glxProcAddressTable._addressof_glXReleaseTexImageEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXReleaseTexImageEXT\" not available");
    }
        dispatch_glXReleaseTexImageEXT1(dpy, drawable, buffer, __addr_);
  }

  /** Entry point to C language function: <code> void glXReleaseTexImageEXT(Display *  dpy, XID drawable, int buffer); </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code>   */
  public static native void dispatch_glXReleaseTexImageEXT1(long dpy, long drawable, int buffer, long procAddress);

  /** Entry point to C language function: <code> void glXSelectEvent(Display *  dpy, XID drawable, unsigned long mask); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXSelectEvent(long dpy, long drawable, long mask)  {

    final long __addr_ = glxProcAddressTable._addressof_glXSelectEvent;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXSelectEvent\" not available");
    }
        dispatch_glXSelectEvent1(dpy, drawable, mask, __addr_);
  }

  /** Entry point to C language function: <code> void glXSelectEvent(Display *  dpy, XID drawable, unsigned long mask); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native void dispatch_glXSelectEvent1(long dpy, long drawable, long mask, long procAddress);

  /** Entry point to C language function: <code> void glXSwapBuffers(Display *  dpy, XID drawable); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXSwapBuffers(long dpy, long drawable)  {

    final long __addr_ = glxProcAddressTable._addressof_glXSwapBuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXSwapBuffers\" not available");
    }
        dispatch_glXSwapBuffers1(dpy, drawable, __addr_);
  }

  /** Entry point to C language function: <code> void glXSwapBuffers(Display *  dpy, XID drawable); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native void dispatch_glXSwapBuffers1(long dpy, long drawable, long procAddress);

  /** Entry point to C language function: <code> int64_t glXSwapBuffersMscOML(Display *  dpy, XID drawable, int64_t target_msc, int64_t divisor, int64_t remainder); </code> <br>Part of <code>GLX_OML_sync_control</code>   */
  public static long glXSwapBuffersMscOML(long dpy, long drawable, long target_msc, long divisor, long remainder)  {

    final long __addr_ = glxProcAddressTable._addressof_glXSwapBuffersMscOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXSwapBuffersMscOML\" not available");
    }
        return dispatch_glXSwapBuffersMscOML1(dpy, drawable, target_msc, divisor, remainder, __addr_);
  }

  /** Entry point to C language function: <code> int64_t glXSwapBuffersMscOML(Display *  dpy, XID drawable, int64_t target_msc, int64_t divisor, int64_t remainder); </code> <br>Part of <code>GLX_OML_sync_control</code>   */
  public static native long dispatch_glXSwapBuffersMscOML1(long dpy, long drawable, long target_msc, long divisor, long remainder, long procAddress);

  /** Entry point to C language function: <code> void glXUseXFont(XID font, int first, int count, int list); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXUseXFont(long font, int first, int count, int list)  {

    final long __addr_ = glxProcAddressTable._addressof_glXUseXFont;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXUseXFont\" not available");
    }
        dispatch_glXUseXFont1(font, first, count, list, __addr_);
  }

  /** Entry point to C language function: <code> void glXUseXFont(XID font, int first, int count, int list); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native void dispatch_glXUseXFont1(long font, int first, int count, int list, long procAddress);

  /** Entry point to C language function: <code> Bool glXWaitForMscOML(Display *  dpy, XID drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param ust a direct or array-backed {@link java.nio.LongBuffer}
      @param msc a direct or array-backed {@link java.nio.LongBuffer}
      @param sbc a direct or array-backed {@link java.nio.LongBuffer}   */
  public static boolean glXWaitForMscOML(long dpy, long drawable, long target_msc, long divisor, long remainder, LongBuffer ust, LongBuffer msc, LongBuffer sbc)  {

    final boolean ust_is_direct = Buffers.isDirect(ust);
    final boolean msc_is_direct = Buffers.isDirect(msc);
    final boolean sbc_is_direct = Buffers.isDirect(sbc);
    final long __addr_ = glxProcAddressTable._addressof_glXWaitForMscOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXWaitForMscOML\" not available");
    }
        return dispatch_glXWaitForMscOML1(dpy, drawable, target_msc, divisor, remainder, ust_is_direct ? ust : Buffers.getArray(ust), ust_is_direct ? Buffers.getDirectBufferByteOffset(ust) : Buffers.getIndirectBufferByteOffset(ust), ust_is_direct, msc_is_direct ? msc : Buffers.getArray(msc), msc_is_direct ? Buffers.getDirectBufferByteOffset(msc) : Buffers.getIndirectBufferByteOffset(msc), msc_is_direct, sbc_is_direct ? sbc : Buffers.getArray(sbc), sbc_is_direct ? Buffers.getDirectBufferByteOffset(sbc) : Buffers.getIndirectBufferByteOffset(sbc), sbc_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXWaitForMscOML(Display *  dpy, XID drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param ust a direct or array-backed {@link java.nio.LongBuffer}
      @param msc a direct or array-backed {@link java.nio.LongBuffer}
      @param sbc a direct or array-backed {@link java.nio.LongBuffer}   */
  private static native boolean dispatch_glXWaitForMscOML1(long dpy, long drawable, long target_msc, long divisor, long remainder, Object ust, int ust_byte_offset, boolean ust_is_direct, Object msc, int msc_byte_offset, boolean msc_is_direct, Object sbc, int sbc_byte_offset, boolean sbc_is_direct, long procAddress);

  /** Entry point to C language function: <code> Bool glXWaitForMscOML(Display *  dpy, XID drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>   */
  public static boolean glXWaitForMscOML(long dpy, long drawable, long target_msc, long divisor, long remainder, long[] ust, int ust_offset, long[] msc, int msc_offset, long[] sbc, int sbc_offset)  {

    if(ust != null && ust.length <= ust_offset)
      throw new GLException("array offset argument \"ust_offset\" (" + ust_offset + ") equals or exceeds array length (" + ust.length + ")");
    if(msc != null && msc.length <= msc_offset)
      throw new GLException("array offset argument \"msc_offset\" (" + msc_offset + ") equals or exceeds array length (" + msc.length + ")");
    if(sbc != null && sbc.length <= sbc_offset)
      throw new GLException("array offset argument \"sbc_offset\" (" + sbc_offset + ") equals or exceeds array length (" + sbc.length + ")");
    final long __addr_ = glxProcAddressTable._addressof_glXWaitForMscOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXWaitForMscOML\" not available");
    }
        return dispatch_glXWaitForMscOML1(dpy, drawable, target_msc, divisor, remainder, ust, Buffers.SIZEOF_LONG * ust_offset, false, msc, Buffers.SIZEOF_LONG * msc_offset, false, sbc, Buffers.SIZEOF_LONG * sbc_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXWaitForSbcOML(Display *  dpy, XID drawable, int64_t target_sbc, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param ust a direct or array-backed {@link java.nio.LongBuffer}
      @param msc a direct or array-backed {@link java.nio.LongBuffer}
      @param sbc a direct or array-backed {@link java.nio.LongBuffer}   */
  public static boolean glXWaitForSbcOML(long dpy, long drawable, long target_sbc, LongBuffer ust, LongBuffer msc, LongBuffer sbc)  {

    final boolean ust_is_direct = Buffers.isDirect(ust);
    final boolean msc_is_direct = Buffers.isDirect(msc);
    final boolean sbc_is_direct = Buffers.isDirect(sbc);
    final long __addr_ = glxProcAddressTable._addressof_glXWaitForSbcOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXWaitForSbcOML\" not available");
    }
        return dispatch_glXWaitForSbcOML1(dpy, drawable, target_sbc, ust_is_direct ? ust : Buffers.getArray(ust), ust_is_direct ? Buffers.getDirectBufferByteOffset(ust) : Buffers.getIndirectBufferByteOffset(ust), ust_is_direct, msc_is_direct ? msc : Buffers.getArray(msc), msc_is_direct ? Buffers.getDirectBufferByteOffset(msc) : Buffers.getIndirectBufferByteOffset(msc), msc_is_direct, sbc_is_direct ? sbc : Buffers.getArray(sbc), sbc_is_direct ? Buffers.getDirectBufferByteOffset(sbc) : Buffers.getIndirectBufferByteOffset(sbc), sbc_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXWaitForSbcOML(Display *  dpy, XID drawable, int64_t target_sbc, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param ust a direct or array-backed {@link java.nio.LongBuffer}
      @param msc a direct or array-backed {@link java.nio.LongBuffer}
      @param sbc a direct or array-backed {@link java.nio.LongBuffer}   */
  private static native boolean dispatch_glXWaitForSbcOML1(long dpy, long drawable, long target_sbc, Object ust, int ust_byte_offset, boolean ust_is_direct, Object msc, int msc_byte_offset, boolean msc_is_direct, Object sbc, int sbc_byte_offset, boolean sbc_is_direct, long procAddress);

  /** Entry point to C language function: <code> Bool glXWaitForSbcOML(Display *  dpy, XID drawable, int64_t target_sbc, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>   */
  public static boolean glXWaitForSbcOML(long dpy, long drawable, long target_sbc, long[] ust, int ust_offset, long[] msc, int msc_offset, long[] sbc, int sbc_offset)  {

    if(ust != null && ust.length <= ust_offset)
      throw new GLException("array offset argument \"ust_offset\" (" + ust_offset + ") equals or exceeds array length (" + ust.length + ")");
    if(msc != null && msc.length <= msc_offset)
      throw new GLException("array offset argument \"msc_offset\" (" + msc_offset + ") equals or exceeds array length (" + msc.length + ")");
    if(sbc != null && sbc.length <= sbc_offset)
      throw new GLException("array offset argument \"sbc_offset\" (" + sbc_offset + ") equals or exceeds array length (" + sbc.length + ")");
    final long __addr_ = glxProcAddressTable._addressof_glXWaitForSbcOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXWaitForSbcOML\" not available");
    }
        return dispatch_glXWaitForSbcOML1(dpy, drawable, target_sbc, ust, Buffers.SIZEOF_LONG * ust_offset, false, msc, Buffers.SIZEOF_LONG * msc_offset, false, sbc, Buffers.SIZEOF_LONG * sbc_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void glXWaitGL(void); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXWaitGL()  {

    final long __addr_ = glxProcAddressTable._addressof_glXWaitGL;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXWaitGL\" not available");
    }
        dispatch_glXWaitGL1(__addr_);
  }

  /** Entry point to C language function: <code> void glXWaitGL(void); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native void dispatch_glXWaitGL1(long procAddress);

  /** Entry point to C language function: <code> void glXWaitX(void); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXWaitX()  {

    final long __addr_ = glxProcAddressTable._addressof_glXWaitX;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXWaitX\" not available");
    }
        dispatch_glXWaitX1(__addr_);
  }

  /** Entry point to C language function: <code> void glXWaitX(void); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native void dispatch_glXWaitX1(long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
 private static GLXProcAddressTable glxProcAddressTable = new GLXProcAddressTable(new GLProcAddressResolver());
 public  static GLXProcAddressTable getGLXProcAddressTable() { return glxProcAddressTable; }
  
    /** Interface to C language function: <br> - Alias for: <br> <code> XVisualInfo *  glXGetVisualFromFBConfigSGIX, glXGetVisualFromFBConfig(Display *  dpy, GLXFBConfig config); </code>    */
    public static XVisualInfo glXGetVisualFromFBConfig(long dpy, long config)
    {
      final long __addr_ = glxProcAddressTable._addressof_glXGetVisualFromFBConfig;
      if (__addr_ == 0) {
          throw new GLException("Method \"glXGetVisualFromFBConfig\" not available");
      }
      java.nio.ByteBuffer _res;
      _res = dispatch_glXGetVisualFromFBConfig(dpy, config, __addr_);
      if (_res == null) return null;
      return XVisualInfo.create(_res);
    }
  
    /** Entry point to C language function: - Alias for: <br> <code> XVisualInfo *  glXGetVisualFromFBConfigSGIX, glXGetVisualFromFBConfig(Display *  dpy, GLXFBConfig config); </code>    */
    private static native java.nio.ByteBuffer dispatch_glXGetVisualFromFBConfig(long dpy, long config, long procAddr);
  
  
    /** Interface to C language function: <br> - Alias for: <br> <code> GLXFBConfig *  glXChooseFBConfigSGIX, glXChooseFBConfig(Display *  dpy, int screen, const int *  attribList, int *  nitems); </code>    */
    public static com.jogamp.common.nio.PointerBuffer glXChooseFBConfig(long dpy, int screen, int[] attribList, int attribList_offset, int[] nitems, int nitems_offset)
    {
      final long __addr_ = glxProcAddressTable._addressof_glXChooseFBConfig;
      if (__addr_ == 0) {
          throw new GLException("Method \"glXChooseFBConfig\" not available");
      }
      if(attribList != null && attribList.length <= attribList_offset)
        throw new GLException("array offset argument \"attribList_offset\" (" + attribList_offset + ") equals or exceeds array length (" + attribList.length + ")");
      if(nitems != null && nitems.length <= nitems_offset)
        throw new GLException("array offset argument \"nitems_offset\" (" + nitems_offset + ") equals or exceeds array length (" + nitems.length + ")");
      java.nio.ByteBuffer _res;
      _res = dispatch_glXChooseFBConfig(dpy, screen, attribList, Buffers.SIZEOF_INT * attribList_offset, nitems, Buffers.SIZEOF_INT * nitems_offset, __addr_);
  
      if (_res == null) return null;
      return PointerBuffer.wrap(_res);
    }
  
    /** Entry point to C language function: - Alias for: <br> <code> GLXFBConfig *  glXChooseFBConfigSGIX, glXChooseFBConfig(Display *  dpy, int screen, const int *  attribList, int *  nitems); </code>    */
    private static native java.nio.ByteBuffer dispatch_glXChooseFBConfig(long dpy, int screen, Object attribList, int attribList_byte_offset, Object nitems, int nitems_byte_offset, long procAddr);
  
    /** Interface to C language function: <br> - Alias for: <br> <code> XVisualInfo *  glXChooseVisual(Display *  dpy, int screen, int *  attribList); </code>    */
    public static XVisualInfo glXChooseVisual(long dpy, int screen, int[] attribList, int attribList_offset)
    {
      final long __addr_ = glxProcAddressTable._addressof_glXChooseVisual;
      if (__addr_ == 0) {
          throw new GLException("Method \"glXChooseVisual\" not available");
      }
      if(attribList != null && attribList.length <= attribList_offset)
        throw new GLException("array offset argument \"attribList_offset\" (" + attribList_offset + ") equals or exceeds array length (" + attribList.length + ")");
      java.nio.ByteBuffer _res;
      _res = dispatch_glXChooseVisual(dpy, screen, attribList, Buffers.SIZEOF_INT * attribList_offset, __addr_);
  
      if (_res == null) return null;
      return XVisualInfo.create(_res);
    }
  
    /** Entry point to C language function: - Alias for: <br> <code> XVisualInfo *  glXChooseVisual(Display *  dpy, int screen, int *  attribList); </code>    */
    private static native java.nio.ByteBuffer dispatch_glXChooseVisual(long dpy, int screen, Object attribList, int attribList_byte_offset, long procAddr);
  
  protected static long glXGetProcAddress(long glXGetProcAddressHandle, java.lang.String procname)
  {
    if (glXGetProcAddressHandle == 0) {
      throw new GLException("Passed null pointer for method \"glXGetProcAddress\"");
    }
    return dispatch_glXGetProcAddress1(procname, glXGetProcAddressHandle);
  }
  // ---- End CustomJavaCode .cfg declarations

} // end of class GLX
