/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Fri Aug 03 06:29:03 CEST 2012 ----! */

package jogamp.opengl.windows.wgl;

import java.util.*;
import javax.media.opengl.*;
import javax.media.opengl.fixedfunc.*;
import jogamp.opengl.*;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class WGLExtImpl implements WGLExt{
  /** Entry point to C language function: <code> LPVOID wglAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority); </code> <br>Part of <code>WGL_NV_vertex_array_range</code>   */
  public ByteBuffer wglAllocateMemoryNV(int size, float readfreq, float writefreq, float priority)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglAllocateMemoryNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglAllocateMemoryNV\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_wglAllocateMemoryNV1(size, readfreq, writefreq, priority, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> LPVOID wglAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority); </code> <br>Part of <code>WGL_NV_vertex_array_range</code>   */
  private native ByteBuffer dispatch_wglAllocateMemoryNV1(int size, float readfreq, float writefreq, float priority, long procAddress);

  /** Entry point to C language function: <code> BOOL wglBeginFrameTrackingI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>   */
  public boolean wglBeginFrameTrackingI3D()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglBeginFrameTrackingI3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglBeginFrameTrackingI3D\" not available");
    }
        return dispatch_wglBeginFrameTrackingI3D1(__addr_);
  }

  /** Entry point to C language function: <code> BOOL wglBeginFrameTrackingI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>   */
  public native boolean dispatch_wglBeginFrameTrackingI3D1(long procAddress);

  /** Entry point to C language function: <code> GLboolean wglBindDisplayColorTableEXT(GLushort id); </code> <br>Part of <code>WGL_EXT_display_color_table</code>   */
  public boolean wglBindDisplayColorTableEXT(short id)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglBindDisplayColorTableEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglBindDisplayColorTableEXT\" not available");
    }
        return dispatch_wglBindDisplayColorTableEXT1(id, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean wglBindDisplayColorTableEXT(GLushort id); </code> <br>Part of <code>WGL_EXT_display_color_table</code>   */
  public native boolean dispatch_wglBindDisplayColorTableEXT1(short id, long procAddress);

  /** Entry point to C language function: <code> BOOL wglBindSwapBarrierNV(GLuint group, GLuint barrier); </code> <br>Part of <code>WGL_NV_swap_group</code>   */
  public boolean wglBindSwapBarrierNV(int group, int barrier)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglBindSwapBarrierNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglBindSwapBarrierNV\" not available");
    }
        return dispatch_wglBindSwapBarrierNV1(group, barrier, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglBindSwapBarrierNV(GLuint group, GLuint barrier); </code> <br>Part of <code>WGL_NV_swap_group</code>   */
  public native boolean dispatch_wglBindSwapBarrierNV1(int group, int barrier, long procAddress);

  /** Entry point to C language function: <code> BOOL wglBindTexImageARB(HANDLE hPbuffer, int iBuffer); </code> <br>Part of <code>WGL_ARB_render_texture</code>   */
  public boolean wglBindTexImageARB(long hPbuffer, int iBuffer)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglBindTexImageARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglBindTexImageARB\" not available");
    }
        return dispatch_wglBindTexImageARB1(hPbuffer, iBuffer, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglBindTexImageARB(HANDLE hPbuffer, int iBuffer); </code> <br>Part of <code>WGL_ARB_render_texture</code>   */
  public native boolean dispatch_wglBindTexImageARB1(long hPbuffer, int iBuffer, long procAddress);

  /** Entry point to C language function: <code> BOOL wglChoosePixelFormatARB(HANDLE hdc, const int *  piAttribIList, const FLOAT *  pfAttribFList, UINT nMaxFormats, int *  piFormats, UINT *  nNumFormats); </code> <br>Part of <code>WGL_ARB_pixel_format</code>
      @param piAttribIList a direct or array-backed {@link java.nio.IntBuffer}
      @param pfAttribFList a direct or array-backed {@link java.nio.FloatBuffer}
      @param piFormats a direct or array-backed {@link java.nio.IntBuffer}
      @param nNumFormats a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean wglChoosePixelFormatARB(long hdc, IntBuffer piAttribIList, FloatBuffer pfAttribFList, int nMaxFormats, IntBuffer piFormats, IntBuffer nNumFormats)  {

    final boolean piAttribIList_is_direct = Buffers.isDirect(piAttribIList);
    final boolean pfAttribFList_is_direct = Buffers.isDirect(pfAttribFList);
    final boolean piFormats_is_direct = Buffers.isDirect(piFormats);
    final boolean nNumFormats_is_direct = Buffers.isDirect(nNumFormats);
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglChoosePixelFormatARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglChoosePixelFormatARB\" not available");
    }
        return dispatch_wglChoosePixelFormatARB1(hdc, piAttribIList_is_direct ? piAttribIList : Buffers.getArray(piAttribIList), piAttribIList_is_direct ? Buffers.getDirectBufferByteOffset(piAttribIList) : Buffers.getIndirectBufferByteOffset(piAttribIList), piAttribIList_is_direct, pfAttribFList_is_direct ? pfAttribFList : Buffers.getArray(pfAttribFList), pfAttribFList_is_direct ? Buffers.getDirectBufferByteOffset(pfAttribFList) : Buffers.getIndirectBufferByteOffset(pfAttribFList), pfAttribFList_is_direct, nMaxFormats, piFormats_is_direct ? piFormats : Buffers.getArray(piFormats), piFormats_is_direct ? Buffers.getDirectBufferByteOffset(piFormats) : Buffers.getIndirectBufferByteOffset(piFormats), piFormats_is_direct, nNumFormats_is_direct ? nNumFormats : Buffers.getArray(nNumFormats), nNumFormats_is_direct ? Buffers.getDirectBufferByteOffset(nNumFormats) : Buffers.getIndirectBufferByteOffset(nNumFormats), nNumFormats_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglChoosePixelFormatARB(HANDLE hdc, const int *  piAttribIList, const FLOAT *  pfAttribFList, UINT nMaxFormats, int *  piFormats, UINT *  nNumFormats); </code> <br>Part of <code>WGL_ARB_pixel_format</code>
      @param piAttribIList a direct or array-backed {@link java.nio.IntBuffer}
      @param pfAttribFList a direct or array-backed {@link java.nio.FloatBuffer}
      @param piFormats a direct or array-backed {@link java.nio.IntBuffer}
      @param nNumFormats a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglChoosePixelFormatARB1(long hdc, Object piAttribIList, int piAttribIList_byte_offset, boolean piAttribIList_is_direct, Object pfAttribFList, int pfAttribFList_byte_offset, boolean pfAttribFList_is_direct, int nMaxFormats, Object piFormats, int piFormats_byte_offset, boolean piFormats_is_direct, Object nNumFormats, int nNumFormats_byte_offset, boolean nNumFormats_is_direct, long procAddress);

  /** Entry point to C language function: <code> BOOL wglChoosePixelFormatARB(HANDLE hdc, const int *  piAttribIList, const FLOAT *  pfAttribFList, UINT nMaxFormats, int *  piFormats, UINT *  nNumFormats); </code> <br>Part of <code>WGL_ARB_pixel_format</code>   */
  public boolean wglChoosePixelFormatARB(long hdc, int[] piAttribIList, int piAttribIList_offset, float[] pfAttribFList, int pfAttribFList_offset, int nMaxFormats, int[] piFormats, int piFormats_offset, int[] nNumFormats, int nNumFormats_offset)  {

    if(piAttribIList != null && piAttribIList.length <= piAttribIList_offset)
      throw new GLException("array offset argument \"piAttribIList_offset\" (" + piAttribIList_offset + ") equals or exceeds array length (" + piAttribIList.length + ")");
    if(pfAttribFList != null && pfAttribFList.length <= pfAttribFList_offset)
      throw new GLException("array offset argument \"pfAttribFList_offset\" (" + pfAttribFList_offset + ") equals or exceeds array length (" + pfAttribFList.length + ")");
    if(piFormats != null && piFormats.length <= piFormats_offset)
      throw new GLException("array offset argument \"piFormats_offset\" (" + piFormats_offset + ") equals or exceeds array length (" + piFormats.length + ")");
    if(nNumFormats != null && nNumFormats.length <= nNumFormats_offset)
      throw new GLException("array offset argument \"nNumFormats_offset\" (" + nNumFormats_offset + ") equals or exceeds array length (" + nNumFormats.length + ")");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglChoosePixelFormatARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglChoosePixelFormatARB\" not available");
    }
        return dispatch_wglChoosePixelFormatARB1(hdc, piAttribIList, Buffers.SIZEOF_INT * piAttribIList_offset, false, pfAttribFList, Buffers.SIZEOF_FLOAT * pfAttribFList_offset, false, nMaxFormats, piFormats, Buffers.SIZEOF_INT * piFormats_offset, false, nNumFormats, Buffers.SIZEOF_INT * nNumFormats_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglChoosePixelFormatEXT(HANDLE hdc, const int *  piAttribIList, const FLOAT *  pfAttribFList, UINT nMaxFormats, int *  piFormats, UINT *  nNumFormats); </code> <br>Part of <code>WGL_EXT_pixel_format</code>
      @param piAttribIList a direct or array-backed {@link java.nio.IntBuffer}
      @param pfAttribFList a direct or array-backed {@link java.nio.FloatBuffer}
      @param piFormats a direct or array-backed {@link java.nio.IntBuffer}
      @param nNumFormats a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean wglChoosePixelFormatEXT(long hdc, IntBuffer piAttribIList, FloatBuffer pfAttribFList, int nMaxFormats, IntBuffer piFormats, IntBuffer nNumFormats)  {

    final boolean piAttribIList_is_direct = Buffers.isDirect(piAttribIList);
    final boolean pfAttribFList_is_direct = Buffers.isDirect(pfAttribFList);
    final boolean piFormats_is_direct = Buffers.isDirect(piFormats);
    final boolean nNumFormats_is_direct = Buffers.isDirect(nNumFormats);
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglChoosePixelFormatEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglChoosePixelFormatEXT\" not available");
    }
        return dispatch_wglChoosePixelFormatEXT1(hdc, piAttribIList_is_direct ? piAttribIList : Buffers.getArray(piAttribIList), piAttribIList_is_direct ? Buffers.getDirectBufferByteOffset(piAttribIList) : Buffers.getIndirectBufferByteOffset(piAttribIList), piAttribIList_is_direct, pfAttribFList_is_direct ? pfAttribFList : Buffers.getArray(pfAttribFList), pfAttribFList_is_direct ? Buffers.getDirectBufferByteOffset(pfAttribFList) : Buffers.getIndirectBufferByteOffset(pfAttribFList), pfAttribFList_is_direct, nMaxFormats, piFormats_is_direct ? piFormats : Buffers.getArray(piFormats), piFormats_is_direct ? Buffers.getDirectBufferByteOffset(piFormats) : Buffers.getIndirectBufferByteOffset(piFormats), piFormats_is_direct, nNumFormats_is_direct ? nNumFormats : Buffers.getArray(nNumFormats), nNumFormats_is_direct ? Buffers.getDirectBufferByteOffset(nNumFormats) : Buffers.getIndirectBufferByteOffset(nNumFormats), nNumFormats_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglChoosePixelFormatEXT(HANDLE hdc, const int *  piAttribIList, const FLOAT *  pfAttribFList, UINT nMaxFormats, int *  piFormats, UINT *  nNumFormats); </code> <br>Part of <code>WGL_EXT_pixel_format</code>
      @param piAttribIList a direct or array-backed {@link java.nio.IntBuffer}
      @param pfAttribFList a direct or array-backed {@link java.nio.FloatBuffer}
      @param piFormats a direct or array-backed {@link java.nio.IntBuffer}
      @param nNumFormats a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglChoosePixelFormatEXT1(long hdc, Object piAttribIList, int piAttribIList_byte_offset, boolean piAttribIList_is_direct, Object pfAttribFList, int pfAttribFList_byte_offset, boolean pfAttribFList_is_direct, int nMaxFormats, Object piFormats, int piFormats_byte_offset, boolean piFormats_is_direct, Object nNumFormats, int nNumFormats_byte_offset, boolean nNumFormats_is_direct, long procAddress);

  /** Entry point to C language function: <code> BOOL wglChoosePixelFormatEXT(HANDLE hdc, const int *  piAttribIList, const FLOAT *  pfAttribFList, UINT nMaxFormats, int *  piFormats, UINT *  nNumFormats); </code> <br>Part of <code>WGL_EXT_pixel_format</code>   */
  public boolean wglChoosePixelFormatEXT(long hdc, int[] piAttribIList, int piAttribIList_offset, float[] pfAttribFList, int pfAttribFList_offset, int nMaxFormats, int[] piFormats, int piFormats_offset, int[] nNumFormats, int nNumFormats_offset)  {

    if(piAttribIList != null && piAttribIList.length <= piAttribIList_offset)
      throw new GLException("array offset argument \"piAttribIList_offset\" (" + piAttribIList_offset + ") equals or exceeds array length (" + piAttribIList.length + ")");
    if(pfAttribFList != null && pfAttribFList.length <= pfAttribFList_offset)
      throw new GLException("array offset argument \"pfAttribFList_offset\" (" + pfAttribFList_offset + ") equals or exceeds array length (" + pfAttribFList.length + ")");
    if(piFormats != null && piFormats.length <= piFormats_offset)
      throw new GLException("array offset argument \"piFormats_offset\" (" + piFormats_offset + ") equals or exceeds array length (" + piFormats.length + ")");
    if(nNumFormats != null && nNumFormats.length <= nNumFormats_offset)
      throw new GLException("array offset argument \"nNumFormats_offset\" (" + nNumFormats_offset + ") equals or exceeds array length (" + nNumFormats.length + ")");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglChoosePixelFormatEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglChoosePixelFormatEXT\" not available");
    }
        return dispatch_wglChoosePixelFormatEXT1(hdc, piAttribIList, Buffers.SIZEOF_INT * piAttribIList_offset, false, pfAttribFList, Buffers.SIZEOF_FLOAT * pfAttribFList_offset, false, nMaxFormats, piFormats, Buffers.SIZEOF_INT * piFormats_offset, false, nNumFormats, Buffers.SIZEOF_INT * nNumFormats_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglCreateBufferRegionARB(HANDLE hDC, int iLayerPlane, UINT uType); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  public long wglCreateBufferRegionARB(long hDC, int iLayerPlane, int uType)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreateBufferRegionARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglCreateBufferRegionARB\" not available");
    }
        return dispatch_wglCreateBufferRegionARB1(hDC, iLayerPlane, uType, __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglCreateBufferRegionARB(HANDLE hDC, int iLayerPlane, UINT uType); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  public native long dispatch_wglCreateBufferRegionARB1(long hDC, int iLayerPlane, int uType, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglCreateContextAttribsARB(HANDLE hDC, HANDLE hshareContext, const int *  attribList); </code> <br>Part of <code>WGL_ARB_create_context</code>
      @param attribList a direct or array-backed {@link java.nio.IntBuffer}   */
  public long wglCreateContextAttribsARB(long hDC, long hshareContext, IntBuffer attribList)  {

    final boolean attribList_is_direct = Buffers.isDirect(attribList);
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreateContextAttribsARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglCreateContextAttribsARB\" not available");
    }
        return dispatch_wglCreateContextAttribsARB1(hDC, hshareContext, attribList_is_direct ? attribList : Buffers.getArray(attribList), attribList_is_direct ? Buffers.getDirectBufferByteOffset(attribList) : Buffers.getIndirectBufferByteOffset(attribList), attribList_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglCreateContextAttribsARB(HANDLE hDC, HANDLE hshareContext, const int *  attribList); </code> <br>Part of <code>WGL_ARB_create_context</code>
      @param attribList a direct or array-backed {@link java.nio.IntBuffer}   */
  private native long dispatch_wglCreateContextAttribsARB1(long hDC, long hshareContext, Object attribList, int attribList_byte_offset, boolean attribList_is_direct, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglCreateContextAttribsARB(HANDLE hDC, HANDLE hshareContext, const int *  attribList); </code> <br>Part of <code>WGL_ARB_create_context</code>   */
  public long wglCreateContextAttribsARB(long hDC, long hshareContext, int[] attribList, int attribList_offset)  {

    if(attribList != null && attribList.length <= attribList_offset)
      throw new GLException("array offset argument \"attribList_offset\" (" + attribList_offset + ") equals or exceeds array length (" + attribList.length + ")");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreateContextAttribsARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglCreateContextAttribsARB\" not available");
    }
        return dispatch_wglCreateContextAttribsARB1(hDC, hshareContext, attribList, Buffers.SIZEOF_INT * attribList_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean wglCreateDisplayColorTableEXT(GLushort id); </code> <br>Part of <code>WGL_EXT_display_color_table</code>   */
  public boolean wglCreateDisplayColorTableEXT(short id)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreateDisplayColorTableEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglCreateDisplayColorTableEXT\" not available");
    }
        return dispatch_wglCreateDisplayColorTableEXT1(id, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean wglCreateDisplayColorTableEXT(GLushort id); </code> <br>Part of <code>WGL_EXT_display_color_table</code>   */
  public native boolean dispatch_wglCreateDisplayColorTableEXT1(short id, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglCreatePbufferARB(HANDLE hDC, int iPixelFormat, int iWidth, int iHeight, const int *  piAttribList); </code> <br>Part of <code>WGL_ARB_pbuffer</code>
      @param piAttribList a direct or array-backed {@link java.nio.IntBuffer}   */
  public long wglCreatePbufferARB(long hDC, int iPixelFormat, int iWidth, int iHeight, IntBuffer piAttribList)  {

    final boolean piAttribList_is_direct = Buffers.isDirect(piAttribList);
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreatePbufferARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglCreatePbufferARB\" not available");
    }
        return dispatch_wglCreatePbufferARB1(hDC, iPixelFormat, iWidth, iHeight, piAttribList_is_direct ? piAttribList : Buffers.getArray(piAttribList), piAttribList_is_direct ? Buffers.getDirectBufferByteOffset(piAttribList) : Buffers.getIndirectBufferByteOffset(piAttribList), piAttribList_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglCreatePbufferARB(HANDLE hDC, int iPixelFormat, int iWidth, int iHeight, const int *  piAttribList); </code> <br>Part of <code>WGL_ARB_pbuffer</code>
      @param piAttribList a direct or array-backed {@link java.nio.IntBuffer}   */
  private native long dispatch_wglCreatePbufferARB1(long hDC, int iPixelFormat, int iWidth, int iHeight, Object piAttribList, int piAttribList_byte_offset, boolean piAttribList_is_direct, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglCreatePbufferARB(HANDLE hDC, int iPixelFormat, int iWidth, int iHeight, const int *  piAttribList); </code> <br>Part of <code>WGL_ARB_pbuffer</code>   */
  public long wglCreatePbufferARB(long hDC, int iPixelFormat, int iWidth, int iHeight, int[] piAttribList, int piAttribList_offset)  {

    if(piAttribList != null && piAttribList.length <= piAttribList_offset)
      throw new GLException("array offset argument \"piAttribList_offset\" (" + piAttribList_offset + ") equals or exceeds array length (" + piAttribList.length + ")");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreatePbufferARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglCreatePbufferARB\" not available");
    }
        return dispatch_wglCreatePbufferARB1(hDC, iPixelFormat, iWidth, iHeight, piAttribList, Buffers.SIZEOF_INT * piAttribList_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglCreatePbufferEXT(HANDLE hDC, int iPixelFormat, int iWidth, int iHeight, const int *  piAttribList); </code> <br>Part of <code>WGL_EXT_pbuffer</code>
      @param piAttribList a direct or array-backed {@link java.nio.IntBuffer}   */
  public long wglCreatePbufferEXT(long hDC, int iPixelFormat, int iWidth, int iHeight, IntBuffer piAttribList)  {

    final boolean piAttribList_is_direct = Buffers.isDirect(piAttribList);
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreatePbufferEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglCreatePbufferEXT\" not available");
    }
        return dispatch_wglCreatePbufferEXT1(hDC, iPixelFormat, iWidth, iHeight, piAttribList_is_direct ? piAttribList : Buffers.getArray(piAttribList), piAttribList_is_direct ? Buffers.getDirectBufferByteOffset(piAttribList) : Buffers.getIndirectBufferByteOffset(piAttribList), piAttribList_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglCreatePbufferEXT(HANDLE hDC, int iPixelFormat, int iWidth, int iHeight, const int *  piAttribList); </code> <br>Part of <code>WGL_EXT_pbuffer</code>
      @param piAttribList a direct or array-backed {@link java.nio.IntBuffer}   */
  private native long dispatch_wglCreatePbufferEXT1(long hDC, int iPixelFormat, int iWidth, int iHeight, Object piAttribList, int piAttribList_byte_offset, boolean piAttribList_is_direct, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglCreatePbufferEXT(HANDLE hDC, int iPixelFormat, int iWidth, int iHeight, const int *  piAttribList); </code> <br>Part of <code>WGL_EXT_pbuffer</code>   */
  public long wglCreatePbufferEXT(long hDC, int iPixelFormat, int iWidth, int iHeight, int[] piAttribList, int piAttribList_offset)  {

    if(piAttribList != null && piAttribList.length <= piAttribList_offset)
      throw new GLException("array offset argument \"piAttribList_offset\" (" + piAttribList_offset + ") equals or exceeds array length (" + piAttribList.length + ")");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreatePbufferEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglCreatePbufferEXT\" not available");
    }
        return dispatch_wglCreatePbufferEXT1(hDC, iPixelFormat, iWidth, iHeight, piAttribList, Buffers.SIZEOF_INT * piAttribList_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void wglDeleteBufferRegionARB(HANDLE hRegion); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  public void wglDeleteBufferRegionARB(long hRegion)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDeleteBufferRegionARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglDeleteBufferRegionARB\" not available");
    }
        dispatch_wglDeleteBufferRegionARB1(hRegion, __addr_);
  }

  /** Entry point to C language function: <code> void wglDeleteBufferRegionARB(HANDLE hRegion); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  public native void dispatch_wglDeleteBufferRegionARB1(long hRegion, long procAddress);

  /** Entry point to C language function: <code> void wglDestroyDisplayColorTableEXT(GLushort factor); </code> <br>Part of <code>WGL_EXT_display_color_table</code>   */
  public void wglDestroyDisplayColorTableEXT(short factor)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDestroyDisplayColorTableEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglDestroyDisplayColorTableEXT\" not available");
    }
        dispatch_wglDestroyDisplayColorTableEXT1(factor, __addr_);
  }

  /** Entry point to C language function: <code> void wglDestroyDisplayColorTableEXT(GLushort factor); </code> <br>Part of <code>WGL_EXT_display_color_table</code>   */
  public native void dispatch_wglDestroyDisplayColorTableEXT1(short factor, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDestroyPbufferARB(HANDLE hPbuffer); </code> <br>Part of <code>WGL_ARB_pbuffer</code>   */
  public boolean wglDestroyPbufferARB(long hPbuffer)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDestroyPbufferARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglDestroyPbufferARB\" not available");
    }
        return dispatch_wglDestroyPbufferARB1(hPbuffer, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDestroyPbufferARB(HANDLE hPbuffer); </code> <br>Part of <code>WGL_ARB_pbuffer</code>   */
  public native boolean dispatch_wglDestroyPbufferARB1(long hPbuffer, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDestroyPbufferEXT(HANDLE hPbuffer); </code> <br>Part of <code>WGL_EXT_pbuffer</code>   */
  public boolean wglDestroyPbufferEXT(long hPbuffer)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDestroyPbufferEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglDestroyPbufferEXT\" not available");
    }
        return dispatch_wglDestroyPbufferEXT1(hPbuffer, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDestroyPbufferEXT(HANDLE hPbuffer); </code> <br>Part of <code>WGL_EXT_pbuffer</code>   */
  public native boolean dispatch_wglDestroyPbufferEXT1(long hPbuffer, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDisableFrameLockI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>   */
  public boolean wglDisableFrameLockI3D()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDisableFrameLockI3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglDisableFrameLockI3D\" not available");
    }
        return dispatch_wglDisableFrameLockI3D1(__addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDisableFrameLockI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>   */
  public native boolean dispatch_wglDisableFrameLockI3D1(long procAddress);

  /** Entry point to C language function: <code> BOOL wglEnableFrameLockI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>   */
  public boolean wglEnableFrameLockI3D()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglEnableFrameLockI3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglEnableFrameLockI3D\" not available");
    }
        return dispatch_wglEnableFrameLockI3D1(__addr_);
  }

  /** Entry point to C language function: <code> BOOL wglEnableFrameLockI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>   */
  public native boolean dispatch_wglEnableFrameLockI3D1(long procAddress);

  /** Entry point to C language function: <code> BOOL wglEndFrameTrackingI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>   */
  public boolean wglEndFrameTrackingI3D()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglEndFrameTrackingI3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglEndFrameTrackingI3D\" not available");
    }
        return dispatch_wglEndFrameTrackingI3D1(__addr_);
  }

  /** Entry point to C language function: <code> BOOL wglEndFrameTrackingI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>   */
  public native boolean dispatch_wglEndFrameTrackingI3D1(long procAddress);

  /** Entry point to C language function: <code> void wglFreeMemoryNV(LPVOID hRegion); </code> <br>Part of <code>WGL_NV_vertex_array_range</code>
      @param hRegion a direct only {@link java.nio.Buffer}   */
  public void wglFreeMemoryNV(Buffer hRegion)  {

    if (!Buffers.isDirect(hRegion))
      throw new GLException("Argument \"hRegion\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglFreeMemoryNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglFreeMemoryNV\" not available");
    }
        dispatch_wglFreeMemoryNV0(hRegion, Buffers.getDirectBufferByteOffset(hRegion), __addr_);
  }

  /** Entry point to C language function: <code> void wglFreeMemoryNV(LPVOID hRegion); </code> <br>Part of <code>WGL_NV_vertex_array_range</code>
      @param hRegion a direct only {@link java.nio.Buffer}   */
  private native void dispatch_wglFreeMemoryNV0(Object hRegion, int hRegion_byte_offset, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglGetCurrentReadDCARB(void); </code> <br>Part of <code>WGL_ARB_make_current_read</code>   */
  public long wglGetCurrentReadDC()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetCurrentReadDC;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetCurrentReadDC\" not available");
    }
        return dispatch_wglGetCurrentReadDC1(__addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglGetCurrentReadDCARB(void); </code> <br>Part of <code>WGL_ARB_make_current_read</code>   */
  public native long dispatch_wglGetCurrentReadDC1(long procAddress);

  /** Entry point to C language function: <code> LPCSTR wglGetExtensionsStringARB(HANDLE hdc); </code> <br>Part of <code>WGL_ARB_extensions_string</code>   */
  public String wglGetExtensionsStringARB(long hdc)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetExtensionsStringARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetExtensionsStringARB\" not available");
    }
        return dispatch_wglGetExtensionsStringARB1(hdc, __addr_);
  }

  /** Entry point to C language function: <code> LPCSTR wglGetExtensionsStringARB(HANDLE hdc); </code> <br>Part of <code>WGL_ARB_extensions_string</code>   */
  public native String dispatch_wglGetExtensionsStringARB1(long hdc, long procAddress);

  /** Entry point to C language function: <code> LPCSTR wglGetExtensionsStringEXT(void); </code> <br>Part of <code>WGL_EXT_extensions_string</code>   */
  public String wglGetExtensionsStringEXT()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetExtensionsStringEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetExtensionsStringEXT\" not available");
    }
        return dispatch_wglGetExtensionsStringEXT1(__addr_);
  }

  /** Entry point to C language function: <code> LPCSTR wglGetExtensionsStringEXT(void); </code> <br>Part of <code>WGL_EXT_extensions_string</code>   */
  public native String dispatch_wglGetExtensionsStringEXT1(long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetFrameUsageI3D(float *  pUsage); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>
      @param pUsage a direct or array-backed {@link java.nio.FloatBuffer}   */
  public boolean wglGetFrameUsageI3D(FloatBuffer pUsage)  {

    final boolean pUsage_is_direct = Buffers.isDirect(pUsage);
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetFrameUsageI3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetFrameUsageI3D\" not available");
    }
        return dispatch_wglGetFrameUsageI3D1(pUsage_is_direct ? pUsage : Buffers.getArray(pUsage), pUsage_is_direct ? Buffers.getDirectBufferByteOffset(pUsage) : Buffers.getIndirectBufferByteOffset(pUsage), pUsage_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetFrameUsageI3D(float *  pUsage); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>
      @param pUsage a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native boolean dispatch_wglGetFrameUsageI3D1(Object pUsage, int pUsage_byte_offset, boolean pUsage_is_direct, long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetFrameUsageI3D(float *  pUsage); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>   */
  public boolean wglGetFrameUsageI3D(float[] pUsage, int pUsage_offset)  {

    if(pUsage != null && pUsage.length <= pUsage_offset)
      throw new GLException("array offset argument \"pUsage_offset\" (" + pUsage_offset + ") equals or exceeds array length (" + pUsage.length + ")");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetFrameUsageI3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetFrameUsageI3D\" not available");
    }
        return dispatch_wglGetFrameUsageI3D1(pUsage, Buffers.SIZEOF_FLOAT * pUsage_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglGetPbufferDCARB(HANDLE hPbuffer); </code> <br>Part of <code>WGL_ARB_pbuffer</code>   */
  public long wglGetPbufferDCARB(long hPbuffer)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPbufferDCARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetPbufferDCARB\" not available");
    }
        return dispatch_wglGetPbufferDCARB1(hPbuffer, __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglGetPbufferDCARB(HANDLE hPbuffer); </code> <br>Part of <code>WGL_ARB_pbuffer</code>   */
  public native long dispatch_wglGetPbufferDCARB1(long hPbuffer, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglGetPbufferDCEXT(HANDLE hPbuffer); </code> <br>Part of <code>WGL_EXT_pbuffer</code>   */
  public long wglGetPbufferDCEXT(long hPbuffer)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPbufferDCEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetPbufferDCEXT\" not available");
    }
        return dispatch_wglGetPbufferDCEXT1(hPbuffer, __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglGetPbufferDCEXT(HANDLE hPbuffer); </code> <br>Part of <code>WGL_EXT_pbuffer</code>   */
  public native long dispatch_wglGetPbufferDCEXT1(long hPbuffer, long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribfvARB(HANDLE hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *  piAttributes, FLOAT *  pfValues); </code> <br>Part of <code>WGL_ARB_pixel_format</code>
      @param piAttributes a direct or array-backed {@link java.nio.IntBuffer}
      @param pfValues a direct or array-backed {@link java.nio.FloatBuffer}   */
  public boolean wglGetPixelFormatAttribfvARB(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, IntBuffer piAttributes, FloatBuffer pfValues)  {

    final boolean piAttributes_is_direct = Buffers.isDirect(piAttributes);
    final boolean pfValues_is_direct = Buffers.isDirect(pfValues);
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPixelFormatAttribfvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetPixelFormatAttribfvARB\" not available");
    }
        return dispatch_wglGetPixelFormatAttribfvARB1(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes_is_direct ? piAttributes : Buffers.getArray(piAttributes), piAttributes_is_direct ? Buffers.getDirectBufferByteOffset(piAttributes) : Buffers.getIndirectBufferByteOffset(piAttributes), piAttributes_is_direct, pfValues_is_direct ? pfValues : Buffers.getArray(pfValues), pfValues_is_direct ? Buffers.getDirectBufferByteOffset(pfValues) : Buffers.getIndirectBufferByteOffset(pfValues), pfValues_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribfvARB(HANDLE hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *  piAttributes, FLOAT *  pfValues); </code> <br>Part of <code>WGL_ARB_pixel_format</code>
      @param piAttributes a direct or array-backed {@link java.nio.IntBuffer}
      @param pfValues a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native boolean dispatch_wglGetPixelFormatAttribfvARB1(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, Object piAttributes, int piAttributes_byte_offset, boolean piAttributes_is_direct, Object pfValues, int pfValues_byte_offset, boolean pfValues_is_direct, long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribfvARB(HANDLE hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *  piAttributes, FLOAT *  pfValues); </code> <br>Part of <code>WGL_ARB_pixel_format</code>   */
  public boolean wglGetPixelFormatAttribfvARB(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, int[] piAttributes, int piAttributes_offset, float[] pfValues, int pfValues_offset)  {

    if(piAttributes != null && piAttributes.length <= piAttributes_offset)
      throw new GLException("array offset argument \"piAttributes_offset\" (" + piAttributes_offset + ") equals or exceeds array length (" + piAttributes.length + ")");
    if(pfValues != null && pfValues.length <= pfValues_offset)
      throw new GLException("array offset argument \"pfValues_offset\" (" + pfValues_offset + ") equals or exceeds array length (" + pfValues.length + ")");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPixelFormatAttribfvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetPixelFormatAttribfvARB\" not available");
    }
        return dispatch_wglGetPixelFormatAttribfvARB1(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, Buffers.SIZEOF_INT * piAttributes_offset, false, pfValues, Buffers.SIZEOF_FLOAT * pfValues_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribfvEXT(HANDLE hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *  piAttributes, FLOAT *  pfValues); </code> <br>Part of <code>WGL_EXT_pixel_format</code>
      @param piAttributes a direct or array-backed {@link java.nio.IntBuffer}
      @param pfValues a direct or array-backed {@link java.nio.FloatBuffer}   */
  public boolean wglGetPixelFormatAttribfvEXT(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, IntBuffer piAttributes, FloatBuffer pfValues)  {

    final boolean piAttributes_is_direct = Buffers.isDirect(piAttributes);
    final boolean pfValues_is_direct = Buffers.isDirect(pfValues);
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPixelFormatAttribfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetPixelFormatAttribfvEXT\" not available");
    }
        return dispatch_wglGetPixelFormatAttribfvEXT1(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes_is_direct ? piAttributes : Buffers.getArray(piAttributes), piAttributes_is_direct ? Buffers.getDirectBufferByteOffset(piAttributes) : Buffers.getIndirectBufferByteOffset(piAttributes), piAttributes_is_direct, pfValues_is_direct ? pfValues : Buffers.getArray(pfValues), pfValues_is_direct ? Buffers.getDirectBufferByteOffset(pfValues) : Buffers.getIndirectBufferByteOffset(pfValues), pfValues_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribfvEXT(HANDLE hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *  piAttributes, FLOAT *  pfValues); </code> <br>Part of <code>WGL_EXT_pixel_format</code>
      @param piAttributes a direct or array-backed {@link java.nio.IntBuffer}
      @param pfValues a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native boolean dispatch_wglGetPixelFormatAttribfvEXT1(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, Object piAttributes, int piAttributes_byte_offset, boolean piAttributes_is_direct, Object pfValues, int pfValues_byte_offset, boolean pfValues_is_direct, long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribfvEXT(HANDLE hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *  piAttributes, FLOAT *  pfValues); </code> <br>Part of <code>WGL_EXT_pixel_format</code>   */
  public boolean wglGetPixelFormatAttribfvEXT(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, int[] piAttributes, int piAttributes_offset, float[] pfValues, int pfValues_offset)  {

    if(piAttributes != null && piAttributes.length <= piAttributes_offset)
      throw new GLException("array offset argument \"piAttributes_offset\" (" + piAttributes_offset + ") equals or exceeds array length (" + piAttributes.length + ")");
    if(pfValues != null && pfValues.length <= pfValues_offset)
      throw new GLException("array offset argument \"pfValues_offset\" (" + pfValues_offset + ") equals or exceeds array length (" + pfValues.length + ")");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPixelFormatAttribfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetPixelFormatAttribfvEXT\" not available");
    }
        return dispatch_wglGetPixelFormatAttribfvEXT1(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, Buffers.SIZEOF_INT * piAttributes_offset, false, pfValues, Buffers.SIZEOF_FLOAT * pfValues_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribivARB(HANDLE hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *  piAttributes, int *  piValues); </code> <br>Part of <code>WGL_ARB_pixel_format</code>
      @param piAttributes a direct or array-backed {@link java.nio.IntBuffer}
      @param piValues a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean wglGetPixelFormatAttribivARB(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, IntBuffer piAttributes, IntBuffer piValues)  {

    final boolean piAttributes_is_direct = Buffers.isDirect(piAttributes);
    final boolean piValues_is_direct = Buffers.isDirect(piValues);
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPixelFormatAttribivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetPixelFormatAttribivARB\" not available");
    }
        return dispatch_wglGetPixelFormatAttribivARB1(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes_is_direct ? piAttributes : Buffers.getArray(piAttributes), piAttributes_is_direct ? Buffers.getDirectBufferByteOffset(piAttributes) : Buffers.getIndirectBufferByteOffset(piAttributes), piAttributes_is_direct, piValues_is_direct ? piValues : Buffers.getArray(piValues), piValues_is_direct ? Buffers.getDirectBufferByteOffset(piValues) : Buffers.getIndirectBufferByteOffset(piValues), piValues_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribivARB(HANDLE hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *  piAttributes, int *  piValues); </code> <br>Part of <code>WGL_ARB_pixel_format</code>
      @param piAttributes a direct or array-backed {@link java.nio.IntBuffer}
      @param piValues a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglGetPixelFormatAttribivARB1(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, Object piAttributes, int piAttributes_byte_offset, boolean piAttributes_is_direct, Object piValues, int piValues_byte_offset, boolean piValues_is_direct, long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribivARB(HANDLE hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *  piAttributes, int *  piValues); </code> <br>Part of <code>WGL_ARB_pixel_format</code>   */
  public boolean wglGetPixelFormatAttribivARB(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, int[] piAttributes, int piAttributes_offset, int[] piValues, int piValues_offset)  {

    if(piAttributes != null && piAttributes.length <= piAttributes_offset)
      throw new GLException("array offset argument \"piAttributes_offset\" (" + piAttributes_offset + ") equals or exceeds array length (" + piAttributes.length + ")");
    if(piValues != null && piValues.length <= piValues_offset)
      throw new GLException("array offset argument \"piValues_offset\" (" + piValues_offset + ") equals or exceeds array length (" + piValues.length + ")");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPixelFormatAttribivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetPixelFormatAttribivARB\" not available");
    }
        return dispatch_wglGetPixelFormatAttribivARB1(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, Buffers.SIZEOF_INT * piAttributes_offset, false, piValues, Buffers.SIZEOF_INT * piValues_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribivEXT(HANDLE hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *  piAttributes, int *  piValues); </code> <br>Part of <code>WGL_EXT_pixel_format</code>
      @param piAttributes a direct or array-backed {@link java.nio.IntBuffer}
      @param piValues a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean wglGetPixelFormatAttribivEXT(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, IntBuffer piAttributes, IntBuffer piValues)  {

    final boolean piAttributes_is_direct = Buffers.isDirect(piAttributes);
    final boolean piValues_is_direct = Buffers.isDirect(piValues);
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPixelFormatAttribivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetPixelFormatAttribivEXT\" not available");
    }
        return dispatch_wglGetPixelFormatAttribivEXT1(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes_is_direct ? piAttributes : Buffers.getArray(piAttributes), piAttributes_is_direct ? Buffers.getDirectBufferByteOffset(piAttributes) : Buffers.getIndirectBufferByteOffset(piAttributes), piAttributes_is_direct, piValues_is_direct ? piValues : Buffers.getArray(piValues), piValues_is_direct ? Buffers.getDirectBufferByteOffset(piValues) : Buffers.getIndirectBufferByteOffset(piValues), piValues_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribivEXT(HANDLE hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *  piAttributes, int *  piValues); </code> <br>Part of <code>WGL_EXT_pixel_format</code>
      @param piAttributes a direct or array-backed {@link java.nio.IntBuffer}
      @param piValues a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglGetPixelFormatAttribivEXT1(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, Object piAttributes, int piAttributes_byte_offset, boolean piAttributes_is_direct, Object piValues, int piValues_byte_offset, boolean piValues_is_direct, long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribivEXT(HANDLE hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *  piAttributes, int *  piValues); </code> <br>Part of <code>WGL_EXT_pixel_format</code>   */
  public boolean wglGetPixelFormatAttribivEXT(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, int[] piAttributes, int piAttributes_offset, int[] piValues, int piValues_offset)  {

    if(piAttributes != null && piAttributes.length <= piAttributes_offset)
      throw new GLException("array offset argument \"piAttributes_offset\" (" + piAttributes_offset + ") equals or exceeds array length (" + piAttributes.length + ")");
    if(piValues != null && piValues.length <= piValues_offset)
      throw new GLException("array offset argument \"piValues_offset\" (" + piValues_offset + ") equals or exceeds array length (" + piValues.length + ")");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPixelFormatAttribivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetPixelFormatAttribivEXT\" not available");
    }
        return dispatch_wglGetPixelFormatAttribivEXT1(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, Buffers.SIZEOF_INT * piAttributes_offset, false, piValues, Buffers.SIZEOF_INT * piValues_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> int wglGetSwapIntervalEXT(void); </code> <br>Part of <code>WGL_EXT_swap_control</code>   */
  public int wglGetSwapIntervalEXT()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetSwapIntervalEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetSwapIntervalEXT\" not available");
    }
        return dispatch_wglGetSwapIntervalEXT1(__addr_);
  }

  /** Entry point to C language function: <code> int wglGetSwapIntervalEXT(void); </code> <br>Part of <code>WGL_EXT_swap_control</code>   */
  public native int dispatch_wglGetSwapIntervalEXT1(long procAddress);

  /** Entry point to C language function: <code> BOOL wglIsEnabledFrameLockI3D(BOOL *  marker_p); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>
      @param marker_p a direct or array-backed {@link java.nio.ByteBuffer}   */
  public boolean wglIsEnabledFrameLockI3D(ByteBuffer marker_p)  {

    final boolean marker_p_is_direct = Buffers.isDirect(marker_p);
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglIsEnabledFrameLockI3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglIsEnabledFrameLockI3D\" not available");
    }
        return dispatch_wglIsEnabledFrameLockI3D1(marker_p_is_direct ? marker_p : Buffers.getArray(marker_p), marker_p_is_direct ? Buffers.getDirectBufferByteOffset(marker_p) : Buffers.getIndirectBufferByteOffset(marker_p), marker_p_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglIsEnabledFrameLockI3D(BOOL *  marker_p); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>
      @param marker_p a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native boolean dispatch_wglIsEnabledFrameLockI3D1(Object marker_p, int marker_p_byte_offset, boolean marker_p_is_direct, long procAddress);

  /** Entry point to C language function: <code> BOOL wglIsEnabledFrameLockI3D(BOOL *  marker_p); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>   */
  public boolean wglIsEnabledFrameLockI3D(byte[] marker_p, int marker_p_offset)  {

    if(marker_p != null && marker_p.length <= marker_p_offset)
      throw new GLException("array offset argument \"marker_p_offset\" (" + marker_p_offset + ") equals or exceeds array length (" + marker_p.length + ")");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglIsEnabledFrameLockI3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglIsEnabledFrameLockI3D\" not available");
    }
        return dispatch_wglIsEnabledFrameLockI3D1(marker_p, marker_p_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglJoinSwapGroupNV(HANDLE hDC, GLuint group); </code> <br>Part of <code>WGL_NV_swap_group</code>   */
  public boolean wglJoinSwapGroupNV(long hDC, int group)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglJoinSwapGroupNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglJoinSwapGroupNV\" not available");
    }
        return dispatch_wglJoinSwapGroupNV1(hDC, group, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglJoinSwapGroupNV(HANDLE hDC, GLuint group); </code> <br>Part of <code>WGL_NV_swap_group</code>   */
  public native boolean dispatch_wglJoinSwapGroupNV1(long hDC, int group, long procAddress);

  /** Entry point to C language function: <code> GLboolean wglLoadDisplayColorTableEXT(const GLushort *  table, GLuint length); </code> <br>Part of <code>WGL_EXT_display_color_table</code>
      @param table a direct or array-backed {@link java.nio.ShortBuffer}   */
  public boolean wglLoadDisplayColorTableEXT(ShortBuffer table, int length)  {

    final boolean table_is_direct = Buffers.isDirect(table);
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglLoadDisplayColorTableEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglLoadDisplayColorTableEXT\" not available");
    }
        return dispatch_wglLoadDisplayColorTableEXT1(table_is_direct ? table : Buffers.getArray(table), table_is_direct ? Buffers.getDirectBufferByteOffset(table) : Buffers.getIndirectBufferByteOffset(table), table_is_direct, length, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean wglLoadDisplayColorTableEXT(const GLushort *  table, GLuint length); </code> <br>Part of <code>WGL_EXT_display_color_table</code>
      @param table a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native boolean dispatch_wglLoadDisplayColorTableEXT1(Object table, int table_byte_offset, boolean table_is_direct, int length, long procAddress);

  /** Entry point to C language function: <code> GLboolean wglLoadDisplayColorTableEXT(const GLushort *  table, GLuint length); </code> <br>Part of <code>WGL_EXT_display_color_table</code>   */
  public boolean wglLoadDisplayColorTableEXT(short[] table, int table_offset, int length)  {

    if(table != null && table.length <= table_offset)
      throw new GLException("array offset argument \"table_offset\" (" + table_offset + ") equals or exceeds array length (" + table.length + ")");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglLoadDisplayColorTableEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglLoadDisplayColorTableEXT\" not available");
    }
        return dispatch_wglLoadDisplayColorTableEXT1(table, Buffers.SIZEOF_SHORT * table_offset, false, length, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglMakeContextCurrentARB(HANDLE hDrawDC, HANDLE hReadDC, HANDLE hglrc); </code> <br>Part of <code>WGL_ARB_make_current_read</code>   */
  public boolean wglMakeContextCurrent(long hDrawDC, long hReadDC, long hglrc)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglMakeContextCurrent;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglMakeContextCurrent\" not available");
    }
        return dispatch_wglMakeContextCurrent1(hDrawDC, hReadDC, hglrc, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglMakeContextCurrentARB(HANDLE hDrawDC, HANDLE hReadDC, HANDLE hglrc); </code> <br>Part of <code>WGL_ARB_make_current_read</code>   */
  public native boolean dispatch_wglMakeContextCurrent1(long hDrawDC, long hReadDC, long hglrc, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryFrameCountNV(HANDLE hDC, GLuint *  count); </code> <br>Part of <code>WGL_NV_swap_group</code>
      @param count a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean wglQueryFrameCountNV(long hDC, IntBuffer count)  {

    final boolean count_is_direct = Buffers.isDirect(count);
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryFrameCountNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglQueryFrameCountNV\" not available");
    }
        return dispatch_wglQueryFrameCountNV1(hDC, count_is_direct ? count : Buffers.getArray(count), count_is_direct ? Buffers.getDirectBufferByteOffset(count) : Buffers.getIndirectBufferByteOffset(count), count_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryFrameCountNV(HANDLE hDC, GLuint *  count); </code> <br>Part of <code>WGL_NV_swap_group</code>
      @param count a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglQueryFrameCountNV1(long hDC, Object count, int count_byte_offset, boolean count_is_direct, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryFrameCountNV(HANDLE hDC, GLuint *  count); </code> <br>Part of <code>WGL_NV_swap_group</code>   */
  public boolean wglQueryFrameCountNV(long hDC, int[] count, int count_offset)  {

    if(count != null && count.length <= count_offset)
      throw new GLException("array offset argument \"count_offset\" (" + count_offset + ") equals or exceeds array length (" + count.length + ")");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryFrameCountNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglQueryFrameCountNV\" not available");
    }
        return dispatch_wglQueryFrameCountNV1(hDC, count, Buffers.SIZEOF_INT * count_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryFrameLockMasterI3D(BOOL *  marker_p); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>
      @param marker_p a direct or array-backed {@link java.nio.ByteBuffer}   */
  public boolean wglQueryFrameLockMasterI3D(ByteBuffer marker_p)  {

    final boolean marker_p_is_direct = Buffers.isDirect(marker_p);
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryFrameLockMasterI3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglQueryFrameLockMasterI3D\" not available");
    }
        return dispatch_wglQueryFrameLockMasterI3D1(marker_p_is_direct ? marker_p : Buffers.getArray(marker_p), marker_p_is_direct ? Buffers.getDirectBufferByteOffset(marker_p) : Buffers.getIndirectBufferByteOffset(marker_p), marker_p_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryFrameLockMasterI3D(BOOL *  marker_p); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>
      @param marker_p a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native boolean dispatch_wglQueryFrameLockMasterI3D1(Object marker_p, int marker_p_byte_offset, boolean marker_p_is_direct, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryFrameLockMasterI3D(BOOL *  marker_p); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>   */
  public boolean wglQueryFrameLockMasterI3D(byte[] marker_p, int marker_p_offset)  {

    if(marker_p != null && marker_p.length <= marker_p_offset)
      throw new GLException("array offset argument \"marker_p_offset\" (" + marker_p_offset + ") equals or exceeds array length (" + marker_p.length + ")");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryFrameLockMasterI3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglQueryFrameLockMasterI3D\" not available");
    }
        return dispatch_wglQueryFrameLockMasterI3D1(marker_p, marker_p_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryFrameTrackingI3D(DWORD *  pFrameCount, DWORD *  pMissedFrames, float *  pLastMissedUsage); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>
      @param pFrameCount a direct or array-backed {@link java.nio.IntBuffer}
      @param pMissedFrames a direct or array-backed {@link java.nio.IntBuffer}
      @param pLastMissedUsage a direct or array-backed {@link java.nio.FloatBuffer}   */
  public boolean wglQueryFrameTrackingI3D(IntBuffer pFrameCount, IntBuffer pMissedFrames, FloatBuffer pLastMissedUsage)  {

    final boolean pFrameCount_is_direct = Buffers.isDirect(pFrameCount);
    final boolean pMissedFrames_is_direct = Buffers.isDirect(pMissedFrames);
    final boolean pLastMissedUsage_is_direct = Buffers.isDirect(pLastMissedUsage);
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryFrameTrackingI3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglQueryFrameTrackingI3D\" not available");
    }
        return dispatch_wglQueryFrameTrackingI3D1(pFrameCount_is_direct ? pFrameCount : Buffers.getArray(pFrameCount), pFrameCount_is_direct ? Buffers.getDirectBufferByteOffset(pFrameCount) : Buffers.getIndirectBufferByteOffset(pFrameCount), pFrameCount_is_direct, pMissedFrames_is_direct ? pMissedFrames : Buffers.getArray(pMissedFrames), pMissedFrames_is_direct ? Buffers.getDirectBufferByteOffset(pMissedFrames) : Buffers.getIndirectBufferByteOffset(pMissedFrames), pMissedFrames_is_direct, pLastMissedUsage_is_direct ? pLastMissedUsage : Buffers.getArray(pLastMissedUsage), pLastMissedUsage_is_direct ? Buffers.getDirectBufferByteOffset(pLastMissedUsage) : Buffers.getIndirectBufferByteOffset(pLastMissedUsage), pLastMissedUsage_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryFrameTrackingI3D(DWORD *  pFrameCount, DWORD *  pMissedFrames, float *  pLastMissedUsage); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>
      @param pFrameCount a direct or array-backed {@link java.nio.IntBuffer}
      @param pMissedFrames a direct or array-backed {@link java.nio.IntBuffer}
      @param pLastMissedUsage a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native boolean dispatch_wglQueryFrameTrackingI3D1(Object pFrameCount, int pFrameCount_byte_offset, boolean pFrameCount_is_direct, Object pMissedFrames, int pMissedFrames_byte_offset, boolean pMissedFrames_is_direct, Object pLastMissedUsage, int pLastMissedUsage_byte_offset, boolean pLastMissedUsage_is_direct, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryFrameTrackingI3D(DWORD *  pFrameCount, DWORD *  pMissedFrames, float *  pLastMissedUsage); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>   */
  public boolean wglQueryFrameTrackingI3D(int[] pFrameCount, int pFrameCount_offset, int[] pMissedFrames, int pMissedFrames_offset, float[] pLastMissedUsage, int pLastMissedUsage_offset)  {

    if(pFrameCount != null && pFrameCount.length <= pFrameCount_offset)
      throw new GLException("array offset argument \"pFrameCount_offset\" (" + pFrameCount_offset + ") equals or exceeds array length (" + pFrameCount.length + ")");
    if(pMissedFrames != null && pMissedFrames.length <= pMissedFrames_offset)
      throw new GLException("array offset argument \"pMissedFrames_offset\" (" + pMissedFrames_offset + ") equals or exceeds array length (" + pMissedFrames.length + ")");
    if(pLastMissedUsage != null && pLastMissedUsage.length <= pLastMissedUsage_offset)
      throw new GLException("array offset argument \"pLastMissedUsage_offset\" (" + pLastMissedUsage_offset + ") equals or exceeds array length (" + pLastMissedUsage.length + ")");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryFrameTrackingI3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglQueryFrameTrackingI3D\" not available");
    }
        return dispatch_wglQueryFrameTrackingI3D1(pFrameCount, Buffers.SIZEOF_INT * pFrameCount_offset, false, pMissedFrames, Buffers.SIZEOF_INT * pMissedFrames_offset, false, pLastMissedUsage, Buffers.SIZEOF_FLOAT * pLastMissedUsage_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryMaxSwapGroupsNV(HANDLE hDC, GLuint *  maxGroups, GLuint *  maxBarriers); </code> <br>Part of <code>WGL_NV_swap_group</code>
      @param maxGroups a direct or array-backed {@link java.nio.IntBuffer}
      @param maxBarriers a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean wglQueryMaxSwapGroupsNV(long hDC, IntBuffer maxGroups, IntBuffer maxBarriers)  {

    final boolean maxGroups_is_direct = Buffers.isDirect(maxGroups);
    final boolean maxBarriers_is_direct = Buffers.isDirect(maxBarriers);
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryMaxSwapGroupsNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglQueryMaxSwapGroupsNV\" not available");
    }
        return dispatch_wglQueryMaxSwapGroupsNV1(hDC, maxGroups_is_direct ? maxGroups : Buffers.getArray(maxGroups), maxGroups_is_direct ? Buffers.getDirectBufferByteOffset(maxGroups) : Buffers.getIndirectBufferByteOffset(maxGroups), maxGroups_is_direct, maxBarriers_is_direct ? maxBarriers : Buffers.getArray(maxBarriers), maxBarriers_is_direct ? Buffers.getDirectBufferByteOffset(maxBarriers) : Buffers.getIndirectBufferByteOffset(maxBarriers), maxBarriers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryMaxSwapGroupsNV(HANDLE hDC, GLuint *  maxGroups, GLuint *  maxBarriers); </code> <br>Part of <code>WGL_NV_swap_group</code>
      @param maxGroups a direct or array-backed {@link java.nio.IntBuffer}
      @param maxBarriers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglQueryMaxSwapGroupsNV1(long hDC, Object maxGroups, int maxGroups_byte_offset, boolean maxGroups_is_direct, Object maxBarriers, int maxBarriers_byte_offset, boolean maxBarriers_is_direct, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryMaxSwapGroupsNV(HANDLE hDC, GLuint *  maxGroups, GLuint *  maxBarriers); </code> <br>Part of <code>WGL_NV_swap_group</code>   */
  public boolean wglQueryMaxSwapGroupsNV(long hDC, int[] maxGroups, int maxGroups_offset, int[] maxBarriers, int maxBarriers_offset)  {

    if(maxGroups != null && maxGroups.length <= maxGroups_offset)
      throw new GLException("array offset argument \"maxGroups_offset\" (" + maxGroups_offset + ") equals or exceeds array length (" + maxGroups.length + ")");
    if(maxBarriers != null && maxBarriers.length <= maxBarriers_offset)
      throw new GLException("array offset argument \"maxBarriers_offset\" (" + maxBarriers_offset + ") equals or exceeds array length (" + maxBarriers.length + ")");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryMaxSwapGroupsNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglQueryMaxSwapGroupsNV\" not available");
    }
        return dispatch_wglQueryMaxSwapGroupsNV1(hDC, maxGroups, Buffers.SIZEOF_INT * maxGroups_offset, false, maxBarriers, Buffers.SIZEOF_INT * maxBarriers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryPbufferARB(HANDLE hPbuffer, int iAttribute, int *  piValue); </code> <br>Part of <code>WGL_ARB_pbuffer</code>
      @param piValue a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean wglQueryPbufferARB(long hPbuffer, int iAttribute, IntBuffer piValue)  {

    final boolean piValue_is_direct = Buffers.isDirect(piValue);
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryPbufferARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglQueryPbufferARB\" not available");
    }
        return dispatch_wglQueryPbufferARB1(hPbuffer, iAttribute, piValue_is_direct ? piValue : Buffers.getArray(piValue), piValue_is_direct ? Buffers.getDirectBufferByteOffset(piValue) : Buffers.getIndirectBufferByteOffset(piValue), piValue_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryPbufferARB(HANDLE hPbuffer, int iAttribute, int *  piValue); </code> <br>Part of <code>WGL_ARB_pbuffer</code>
      @param piValue a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglQueryPbufferARB1(long hPbuffer, int iAttribute, Object piValue, int piValue_byte_offset, boolean piValue_is_direct, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryPbufferARB(HANDLE hPbuffer, int iAttribute, int *  piValue); </code> <br>Part of <code>WGL_ARB_pbuffer</code>   */
  public boolean wglQueryPbufferARB(long hPbuffer, int iAttribute, int[] piValue, int piValue_offset)  {

    if(piValue != null && piValue.length <= piValue_offset)
      throw new GLException("array offset argument \"piValue_offset\" (" + piValue_offset + ") equals or exceeds array length (" + piValue.length + ")");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryPbufferARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglQueryPbufferARB\" not available");
    }
        return dispatch_wglQueryPbufferARB1(hPbuffer, iAttribute, piValue, Buffers.SIZEOF_INT * piValue_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryPbufferEXT(HANDLE hPbuffer, int iAttribute, int *  piValue); </code> <br>Part of <code>WGL_EXT_pbuffer</code>
      @param piValue a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean wglQueryPbufferEXT(long hPbuffer, int iAttribute, IntBuffer piValue)  {

    final boolean piValue_is_direct = Buffers.isDirect(piValue);
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryPbufferEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglQueryPbufferEXT\" not available");
    }
        return dispatch_wglQueryPbufferEXT1(hPbuffer, iAttribute, piValue_is_direct ? piValue : Buffers.getArray(piValue), piValue_is_direct ? Buffers.getDirectBufferByteOffset(piValue) : Buffers.getIndirectBufferByteOffset(piValue), piValue_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryPbufferEXT(HANDLE hPbuffer, int iAttribute, int *  piValue); </code> <br>Part of <code>WGL_EXT_pbuffer</code>
      @param piValue a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglQueryPbufferEXT1(long hPbuffer, int iAttribute, Object piValue, int piValue_byte_offset, boolean piValue_is_direct, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryPbufferEXT(HANDLE hPbuffer, int iAttribute, int *  piValue); </code> <br>Part of <code>WGL_EXT_pbuffer</code>   */
  public boolean wglQueryPbufferEXT(long hPbuffer, int iAttribute, int[] piValue, int piValue_offset)  {

    if(piValue != null && piValue.length <= piValue_offset)
      throw new GLException("array offset argument \"piValue_offset\" (" + piValue_offset + ") equals or exceeds array length (" + piValue.length + ")");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryPbufferEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglQueryPbufferEXT\" not available");
    }
        return dispatch_wglQueryPbufferEXT1(hPbuffer, iAttribute, piValue, Buffers.SIZEOF_INT * piValue_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQuerySwapGroupNV(HANDLE hDC, GLuint *  group, GLuint *  barrier); </code> <br>Part of <code>WGL_NV_swap_group</code>
      @param group a direct or array-backed {@link java.nio.IntBuffer}
      @param barrier a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean wglQuerySwapGroupNV(long hDC, IntBuffer group, IntBuffer barrier)  {

    final boolean group_is_direct = Buffers.isDirect(group);
    final boolean barrier_is_direct = Buffers.isDirect(barrier);
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQuerySwapGroupNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglQuerySwapGroupNV\" not available");
    }
        return dispatch_wglQuerySwapGroupNV1(hDC, group_is_direct ? group : Buffers.getArray(group), group_is_direct ? Buffers.getDirectBufferByteOffset(group) : Buffers.getIndirectBufferByteOffset(group), group_is_direct, barrier_is_direct ? barrier : Buffers.getArray(barrier), barrier_is_direct ? Buffers.getDirectBufferByteOffset(barrier) : Buffers.getIndirectBufferByteOffset(barrier), barrier_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQuerySwapGroupNV(HANDLE hDC, GLuint *  group, GLuint *  barrier); </code> <br>Part of <code>WGL_NV_swap_group</code>
      @param group a direct or array-backed {@link java.nio.IntBuffer}
      @param barrier a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglQuerySwapGroupNV1(long hDC, Object group, int group_byte_offset, boolean group_is_direct, Object barrier, int barrier_byte_offset, boolean barrier_is_direct, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQuerySwapGroupNV(HANDLE hDC, GLuint *  group, GLuint *  barrier); </code> <br>Part of <code>WGL_NV_swap_group</code>   */
  public boolean wglQuerySwapGroupNV(long hDC, int[] group, int group_offset, int[] barrier, int barrier_offset)  {

    if(group != null && group.length <= group_offset)
      throw new GLException("array offset argument \"group_offset\" (" + group_offset + ") equals or exceeds array length (" + group.length + ")");
    if(barrier != null && barrier.length <= barrier_offset)
      throw new GLException("array offset argument \"barrier_offset\" (" + barrier_offset + ") equals or exceeds array length (" + barrier.length + ")");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQuerySwapGroupNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglQuerySwapGroupNV\" not available");
    }
        return dispatch_wglQuerySwapGroupNV1(hDC, group, Buffers.SIZEOF_INT * group_offset, false, barrier, Buffers.SIZEOF_INT * barrier_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> int wglReleasePbufferDCARB(HANDLE hPbuffer, HANDLE hDC); </code> <br>Part of <code>WGL_ARB_pbuffer</code>   */
  public int wglReleasePbufferDCARB(long hPbuffer, long hDC)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglReleasePbufferDCARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglReleasePbufferDCARB\" not available");
    }
        return dispatch_wglReleasePbufferDCARB1(hPbuffer, hDC, __addr_);
  }

  /** Entry point to C language function: <code> int wglReleasePbufferDCARB(HANDLE hPbuffer, HANDLE hDC); </code> <br>Part of <code>WGL_ARB_pbuffer</code>   */
  public native int dispatch_wglReleasePbufferDCARB1(long hPbuffer, long hDC, long procAddress);

  /** Entry point to C language function: <code> int wglReleasePbufferDCEXT(HANDLE hPbuffer, HANDLE hDC); </code> <br>Part of <code>WGL_EXT_pbuffer</code>   */
  public int wglReleasePbufferDCEXT(long hPbuffer, long hDC)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglReleasePbufferDCEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglReleasePbufferDCEXT\" not available");
    }
        return dispatch_wglReleasePbufferDCEXT1(hPbuffer, hDC, __addr_);
  }

  /** Entry point to C language function: <code> int wglReleasePbufferDCEXT(HANDLE hPbuffer, HANDLE hDC); </code> <br>Part of <code>WGL_EXT_pbuffer</code>   */
  public native int dispatch_wglReleasePbufferDCEXT1(long hPbuffer, long hDC, long procAddress);

  /** Entry point to C language function: <code> BOOL wglReleaseTexImageARB(HANDLE hPbuffer, int iBuffer); </code> <br>Part of <code>WGL_ARB_render_texture</code>   */
  public boolean wglReleaseTexImageARB(long hPbuffer, int iBuffer)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglReleaseTexImageARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglReleaseTexImageARB\" not available");
    }
        return dispatch_wglReleaseTexImageARB1(hPbuffer, iBuffer, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglReleaseTexImageARB(HANDLE hPbuffer, int iBuffer); </code> <br>Part of <code>WGL_ARB_render_texture</code>   */
  public native boolean dispatch_wglReleaseTexImageARB1(long hPbuffer, int iBuffer, long procAddress);

  /** Entry point to C language function: <code> BOOL wglResetFrameCountNV(HANDLE hDC); </code> <br>Part of <code>WGL_NV_swap_group</code>   */
  public boolean wglResetFrameCountNV(long hDC)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglResetFrameCountNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglResetFrameCountNV\" not available");
    }
        return dispatch_wglResetFrameCountNV1(hDC, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglResetFrameCountNV(HANDLE hDC); </code> <br>Part of <code>WGL_NV_swap_group</code>   */
  public native boolean dispatch_wglResetFrameCountNV1(long hDC, long procAddress);

  /** Entry point to C language function: <code> BOOL wglRestoreBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height, int xSrc, int ySrc); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  public boolean wglRestoreBufferRegionARB(long hRegion, int x, int y, int width, int height, int xSrc, int ySrc)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglRestoreBufferRegionARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglRestoreBufferRegionARB\" not available");
    }
        return dispatch_wglRestoreBufferRegionARB1(hRegion, x, y, width, height, xSrc, ySrc, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglRestoreBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height, int xSrc, int ySrc); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  public native boolean dispatch_wglRestoreBufferRegionARB1(long hRegion, int x, int y, int width, int height, int xSrc, int ySrc, long procAddress);

  /** Entry point to C language function: <code> BOOL wglSaveBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  public boolean wglSaveBufferRegionARB(long hRegion, int x, int y, int width, int height)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglSaveBufferRegionARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglSaveBufferRegionARB\" not available");
    }
        return dispatch_wglSaveBufferRegionARB1(hRegion, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglSaveBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  public native boolean dispatch_wglSaveBufferRegionARB1(long hRegion, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> BOOL wglSetPbufferAttribARB(HANDLE hPbuffer, const int *  piAttribList); </code> <br>Part of <code>WGL_ARB_render_texture</code>
      @param piAttribList a direct or array-backed {@link java.nio.IntBuffer}   */
  public boolean wglSetPbufferAttribARB(long hPbuffer, IntBuffer piAttribList)  {

    final boolean piAttribList_is_direct = Buffers.isDirect(piAttribList);
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglSetPbufferAttribARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglSetPbufferAttribARB\" not available");
    }
        return dispatch_wglSetPbufferAttribARB1(hPbuffer, piAttribList_is_direct ? piAttribList : Buffers.getArray(piAttribList), piAttribList_is_direct ? Buffers.getDirectBufferByteOffset(piAttribList) : Buffers.getIndirectBufferByteOffset(piAttribList), piAttribList_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglSetPbufferAttribARB(HANDLE hPbuffer, const int *  piAttribList); </code> <br>Part of <code>WGL_ARB_render_texture</code>
      @param piAttribList a direct or array-backed {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglSetPbufferAttribARB1(long hPbuffer, Object piAttribList, int piAttribList_byte_offset, boolean piAttribList_is_direct, long procAddress);

  /** Entry point to C language function: <code> BOOL wglSetPbufferAttribARB(HANDLE hPbuffer, const int *  piAttribList); </code> <br>Part of <code>WGL_ARB_render_texture</code>   */
  public boolean wglSetPbufferAttribARB(long hPbuffer, int[] piAttribList, int piAttribList_offset)  {

    if(piAttribList != null && piAttribList.length <= piAttribList_offset)
      throw new GLException("array offset argument \"piAttribList_offset\" (" + piAttribList_offset + ") equals or exceeds array length (" + piAttribList.length + ")");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglSetPbufferAttribARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglSetPbufferAttribARB\" not available");
    }
        return dispatch_wglSetPbufferAttribARB1(hPbuffer, piAttribList, Buffers.SIZEOF_INT * piAttribList_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglSwapIntervalEXT(int interval); </code> <br>Part of <code>WGL_EXT_swap_control</code>   */
  public boolean wglSwapIntervalEXT(int interval)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglSwapIntervalEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglSwapIntervalEXT\" not available");
    }
        return dispatch_wglSwapIntervalEXT1(interval, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglSwapIntervalEXT(int interval); </code> <br>Part of <code>WGL_EXT_swap_control</code>   */
  public native boolean dispatch_wglSwapIntervalEXT1(int interval, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
  public WGLExtImpl(WindowsWGLContext context) {
    this._context = context; 
  }
  public boolean isFunctionAvailable(String glFunctionName)
  {
    return _context.isFunctionAvailable(glFunctionName);
  }
  public boolean isExtensionAvailable(String glExtensionName)
  {
    return _context.isExtensionAvailable(glExtensionName);
  }
  private WindowsWGLContext _context;
  // ---- End CustomJavaCode .cfg declarations

} // end of class WGLExtImpl
