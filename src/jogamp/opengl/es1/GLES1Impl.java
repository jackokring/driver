/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Fri Aug 03 06:28:23 CEST 2012 ----! */

package jogamp.opengl.es1;

import java.util.*;
import javax.media.opengl.*;
import javax.media.opengl.fixedfunc.*;
import jogamp.opengl.*;
import javax.media.opengl.GLES1;
import javax.media.opengl.GLES2;
import javax.media.opengl.GL2;
import com.jogamp.common.nio.Buffers;
import com.jogamp.opengl.util.GLBuffers;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class GLES1Impl implements GLBase, GL, GL2ES1, GLES1{
  /** Entry point to C language function: <code> void {@native glActiveTexture}(GLenum texture); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>   */
  public void glActiveTexture(int texture)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glActiveTexture;
    if (__addr_ == 0) {
      throw new GLException("Method \"glActiveTexture\" not available");
    }
        dispatch_glActiveTexture1(texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glActiveTexture}(GLenum texture); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>   */
  public native void dispatch_glActiveTexture1(int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glAlphaFunc}(GLenum func, GLclampf ref); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glAlphaFunc(int func, float ref)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glAlphaFunc;
    if (__addr_ == 0) {
      throw new GLException("Method \"glAlphaFunc\" not available");
    }
        dispatch_glAlphaFunc1(func, ref, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glAlphaFunc}(GLenum func, GLclampf ref); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public native void dispatch_glAlphaFunc1(int func, float ref, long procAddress);

  /** Entry point to C language function: <code> void {@native glAlphaFuncx}(GLenum func, GLclampx ref); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glAlphaFuncx(int func, int ref)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glAlphaFuncx;
    if (__addr_ == 0) {
      throw new GLException("Method \"glAlphaFuncx\" not available");
    }
        dispatch_glAlphaFuncx1(func, ref, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glAlphaFuncx}(GLenum func, GLclampx ref); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glAlphaFuncx1(int func, int ref, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindBuffer}(GLenum target, GLuint buffer); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>   */
  public void glBindBuffer(int target, int buffer)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindBuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindBuffer\" not available");
    }
        dispatch_glBindBuffer1(target, buffer, __addr_);
    bufferStateTracker.setBoundBufferObject(target, buffer);
  }

  /** Entry point to C language function: <code> void {@native glBindBuffer}(GLenum target, GLuint buffer); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>   */
  private native void dispatch_glBindBuffer1(int target, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindFramebufferOES}(GLenum target, GLuint framebuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glBindFramebuffer(int target, int framebuffer)  {

    if( 0 == framebuffer ) {
    if( GL_FRAMEBUFFER == target || 0x8CA9 /* GL_DRAW_FRAMEBUFFER */ == target ) {
    framebuffer = _context.getDefaultDrawFramebuffer();
    } else if( 0x8CA8 /* GL_READ_FRAMEBUFFER */ == target ) {
    framebuffer = _context.getDefaultReadFramebuffer();
    }
    }
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindFramebuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindFramebuffer\" not available");
    }
        dispatch_glBindFramebuffer1(target, framebuffer, __addr_);
    _context.setBoundFramebuffer(target, framebuffer);
  }

  /** Entry point to C language function: <code> void {@native glBindFramebufferOES}(GLenum target, GLuint framebuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  private native void dispatch_glBindFramebuffer1(int target, int framebuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindRenderbufferOES}(GLenum target, GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glBindRenderbuffer(int target, int renderbuffer)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindRenderbuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindRenderbuffer\" not available");
    }
        dispatch_glBindRenderbuffer1(target, renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindRenderbufferOES}(GLenum target, GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  public native void dispatch_glBindRenderbuffer1(int target, int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindTexture}(GLenum target, GLuint texture); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  public void glBindTexture(int target, int texture)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindTexture;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindTexture\" not available");
    }
        dispatch_glBindTexture1(target, texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindTexture}(GLenum target, GLuint texture); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glBindTexture1(int target, int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindVertexArrayOES}(GLuint array); </code> <br>Part of <code>GL_OES_vertex_array_object</code>   */
  public void glBindVertexArrayOES(int array)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindVertexArrayOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindVertexArrayOES\" not available");
    }
        dispatch_glBindVertexArrayOES1(array, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindVertexArrayOES}(GLuint array); </code> <br>Part of <code>GL_OES_vertex_array_object</code>   */
  public native void dispatch_glBindVertexArrayOES1(int array, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquationOES}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_2</code>; <code>GL_OES_blend_subtract</code>   */
  public void glBlendEquation(int mode)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendEquation;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlendEquation\" not available");
    }
        dispatch_glBlendEquation1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquationOES}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_2</code>; <code>GL_OES_blend_subtract</code>   */
  public native void dispatch_glBlendEquation1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparateOES}(GLenum modeRGB, GLenum modeAlpha); </code> <br>Part of <code>GL_VERSION_2_0</code>; <code>GL_OES_blend_equation_separate</code>   */
  public void glBlendEquationSeparate(int modeRGB, int modeAlpha)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendEquationSeparate;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlendEquationSeparate\" not available");
    }
        dispatch_glBlendEquationSeparate1(modeRGB, modeAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparateOES}(GLenum modeRGB, GLenum modeAlpha); </code> <br>Part of <code>GL_VERSION_2_0</code>; <code>GL_OES_blend_equation_separate</code>   */
  public native void dispatch_glBlendEquationSeparate1(int modeRGB, int modeAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFunc}(GLenum sfactor, GLenum dfactor); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glBlendFunc(int sfactor, int dfactor)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendFunc;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlendFunc\" not available");
    }
        dispatch_glBlendFunc1(sfactor, dfactor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFunc}(GLenum sfactor, GLenum dfactor); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glBlendFunc1(int sfactor, int dfactor, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparateOES}(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha); </code> <br>Part of <code>GL_VERSION_1_4</code>; <code>GL_OES_blend_func_separate</code>   */
  public void glBlendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendFuncSeparate;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlendFuncSeparate\" not available");
    }
        dispatch_glBlendFuncSeparate1(srcRGB, dstRGB, srcAlpha, dstAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparateOES}(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha); </code> <br>Part of <code>GL_VERSION_1_4</code>; <code>GL_OES_blend_func_separate</code>   */
  public native void dispatch_glBlendFuncSeparate1(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBufferData}(GLenum target, GLsizeiptr size, const GLvoid *  data, GLenum usage); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glBufferData(int target, long size, Buffer data, int usage)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBufferData;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBufferData\" not available");
    }
        dispatch_glBufferData1(target, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, usage, __addr_);
    bufferSizeTracker.setBufferSize(bufferStateTracker, target, this, size);
  }

  /** Entry point to C language function: <code> void {@native glBufferData}(GLenum target, GLsizeiptr size, const GLvoid *  data, GLenum usage); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glBufferData1(int target, long size, Object data, int data_byte_offset, boolean data_is_direct, int usage, long procAddress);

  /** Entry point to C language function: <code> void {@native glBufferSubData}(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glBufferSubData(int target, long offset, long size, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBufferSubData;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBufferSubData\" not available");
    }
        dispatch_glBufferSubData1(target, offset, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBufferSubData}(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glBufferSubData1(int target, long offset, long size, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLenum {@native glCheckFramebufferStatusOES}(GLenum target); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  public int glCheckFramebufferStatus(int target)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCheckFramebufferStatus;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCheckFramebufferStatus\" not available");
    }
        return dispatch_glCheckFramebufferStatus1(target, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glCheckFramebufferStatusOES}(GLenum target); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  public native int dispatch_glCheckFramebufferStatus1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glClear}(GLbitfield mask); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glClear(int mask)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClear;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClear\" not available");
    }
        dispatch_glClear1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClear}(GLbitfield mask); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glClear1(int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearColor}(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glClearColor(float red, float green, float blue, float alpha)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearColor;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClearColor\" not available");
    }
        dispatch_glClearColor1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearColor}(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public native void dispatch_glClearColor1(float red, float green, float blue, float alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearColorx}(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glClearColorx(int red, int green, int blue, int alpha)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearColorx;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClearColorx\" not available");
    }
        dispatch_glClearColorx1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearColorx}(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glClearColorx1(int red, int green, int blue, int alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearDepthf}(GLclampf depth); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glClearDepthf(float depth)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearDepthf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClearDepthf\" not available");
    }
        dispatch_glClearDepthf1(depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearDepthf}(GLclampf depth); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_VERSION_ES_CM</code>   */
  public native void dispatch_glClearDepthf1(float depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearDepthx}(GLclampx depth); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glClearDepthx(int depth)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearDepthx;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClearDepthx\" not available");
    }
        dispatch_glClearDepthx1(depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearDepthx}(GLclampx depth); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glClearDepthx1(int depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearStencil}(GLint s); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glClearStencil(int s)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearStencil;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClearStencil\" not available");
    }
        dispatch_glClearStencil1(s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearStencil}(GLint s); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glClearStencil1(int s, long procAddress);

  /** Entry point to C language function: <code> void {@native glClientActiveTexture}(GLenum texture); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public void glClientActiveTexture(int texture)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClientActiveTexture;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClientActiveTexture\" not available");
    }
        dispatch_glClientActiveTexture1(texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClientActiveTexture}(GLenum texture); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3_DEPRECATED</code>   */
  public native void dispatch_glClientActiveTexture1(int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glClipPlanef}(GLenum plane, const GLfloat *  equation); </code> <br>Part of <code>GL_VERSION_ES_CM</code>
      @param equation a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glClipPlanef(int plane, FloatBuffer equation)  {

    final boolean equation_is_direct = Buffers.isDirect(equation);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClipPlanef;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClipPlanef\" not available");
    }
        dispatch_glClipPlanef1(plane, equation_is_direct ? equation : Buffers.getArray(equation), equation_is_direct ? Buffers.getDirectBufferByteOffset(equation) : Buffers.getIndirectBufferByteOffset(equation), equation_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClipPlanef}(GLenum plane, const GLfloat *  equation); </code> <br>Part of <code>GL_VERSION_ES_CM</code>
      @param equation a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glClipPlanef1(int plane, Object equation, int equation_byte_offset, boolean equation_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClipPlanef}(GLenum plane, const GLfloat *  equation); </code> <br>Part of <code>GL_VERSION_ES_CM</code>   */
  public void glClipPlanef(int plane, float[] equation, int equation_offset)  {

    if(equation != null && equation.length <= equation_offset)
      throw new GLException("array offset argument \"equation_offset\" (" + equation_offset + ") equals or exceeds array length (" + equation.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClipPlanef;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClipPlanef\" not available");
    }
        dispatch_glClipPlanef1(plane, equation, Buffers.SIZEOF_FLOAT * equation_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClipPlanefIMG}(GLenum plane, const GLfloat *  equation); </code> <br>Part of <code>GL_IMG_user_clip_plane</code>
      @param equation a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glClipPlanefIMG(int plane, FloatBuffer equation)  {

    final boolean equation_is_direct = Buffers.isDirect(equation);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClipPlanefIMG;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClipPlanefIMG\" not available");
    }
        dispatch_glClipPlanefIMG1(plane, equation_is_direct ? equation : Buffers.getArray(equation), equation_is_direct ? Buffers.getDirectBufferByteOffset(equation) : Buffers.getIndirectBufferByteOffset(equation), equation_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClipPlanefIMG}(GLenum plane, const GLfloat *  equation); </code> <br>Part of <code>GL_IMG_user_clip_plane</code>
      @param equation a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glClipPlanefIMG1(int plane, Object equation, int equation_byte_offset, boolean equation_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClipPlanefIMG}(GLenum plane, const GLfloat *  equation); </code> <br>Part of <code>GL_IMG_user_clip_plane</code>   */
  public void glClipPlanefIMG(int plane, float[] equation, int equation_offset)  {

    if(equation != null && equation.length <= equation_offset)
      throw new GLException("array offset argument \"equation_offset\" (" + equation_offset + ") equals or exceeds array length (" + equation.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClipPlanefIMG;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClipPlanefIMG\" not available");
    }
        dispatch_glClipPlanefIMG1(plane, equation, Buffers.SIZEOF_FLOAT * equation_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClipPlanex}(GLenum plane, const GLfixed *  equation); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param equation a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glClipPlanex(int plane, IntBuffer equation)  {

    final boolean equation_is_direct = Buffers.isDirect(equation);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClipPlanex;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClipPlanex\" not available");
    }
        dispatch_glClipPlanex1(plane, equation_is_direct ? equation : Buffers.getArray(equation), equation_is_direct ? Buffers.getDirectBufferByteOffset(equation) : Buffers.getIndirectBufferByteOffset(equation), equation_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClipPlanex}(GLenum plane, const GLfixed *  equation); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param equation a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glClipPlanex1(int plane, Object equation, int equation_byte_offset, boolean equation_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClipPlanex}(GLenum plane, const GLfixed *  equation); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glClipPlanex(int plane, int[] equation, int equation_offset)  {

    if(equation != null && equation.length <= equation_offset)
      throw new GLException("array offset argument \"equation_offset\" (" + equation_offset + ") equals or exceeds array length (" + equation.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClipPlanex;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClipPlanex\" not available");
    }
        dispatch_glClipPlanex1(plane, equation, Buffers.SIZEOF_INT * equation_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClipPlanexIMG}(GLenum plane, const GLfixed *  equation); </code> <br>Part of <code>GL_IMG_user_clip_plane</code>
      @param equation a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glClipPlanexIMG(int plane, IntBuffer equation)  {

    final boolean equation_is_direct = Buffers.isDirect(equation);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClipPlanexIMG;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClipPlanexIMG\" not available");
    }
        dispatch_glClipPlanexIMG1(plane, equation_is_direct ? equation : Buffers.getArray(equation), equation_is_direct ? Buffers.getDirectBufferByteOffset(equation) : Buffers.getIndirectBufferByteOffset(equation), equation_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClipPlanexIMG}(GLenum plane, const GLfixed *  equation); </code> <br>Part of <code>GL_IMG_user_clip_plane</code>
      @param equation a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glClipPlanexIMG1(int plane, Object equation, int equation_byte_offset, boolean equation_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClipPlanexIMG}(GLenum plane, const GLfixed *  equation); </code> <br>Part of <code>GL_IMG_user_clip_plane</code>   */
  public void glClipPlanexIMG(int plane, int[] equation, int equation_offset)  {

    if(equation != null && equation.length <= equation_offset)
      throw new GLException("array offset argument \"equation_offset\" (" + equation_offset + ") equals or exceeds array length (" + equation.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClipPlanexIMG;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClipPlanexIMG\" not available");
    }
        dispatch_glClipPlanexIMG1(plane, equation, Buffers.SIZEOF_INT * equation_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4f}(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glColor4f(float red, float green, float blue, float alpha)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4f\" not available");
    }
        dispatch_glColor4f1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4f}(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public native void dispatch_glColor4f1(float red, float green, float blue, float alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4ub}(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glColor4ub(byte red, byte green, byte blue, byte alpha)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4ub;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4ub\" not available");
    }
        dispatch_glColor4ub1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4ub}(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glColor4ub1(byte red, byte green, byte blue, byte alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4x}(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glColor4x(int red, int green, int blue, int alpha)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glColor4x;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColor4x\" not available");
    }
        dispatch_glColor4x1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4x}(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glColor4x1(int red, int green, int blue, int alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorMask}(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glColorMask(boolean red, boolean green, boolean blue, boolean alpha)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorMask;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorMask\" not available");
    }
        dispatch_glColorMask1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorMask}(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glColorMask1(boolean red, boolean green, boolean blue, boolean alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glColorPointer(int size, int type, int stride, Buffer pointer)  {

    checkArrayVBODisabled(true);
    Buffers.rangeCheck(pointer, 1);
    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorPointer\" not available");
    }
        dispatch_glColorPointer1(size, type, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glColorPointer1(int size, int type, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  public void glColorPointer(int size, int type, int stride, long pointer_buffer_offset)  {

    checkArrayVBOEnabled(true);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorPointer\" not available");
    }
        dispatch_glColorPointer1(size, type, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  private native void dispatch_glColorPointer1(int size, int type, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, Buffer data)  {

    checkUnpackPBODisabled(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexImage2D\" not available");
    }
        dispatch_glCompressedTexImage2D1(target, level, internalformat, width, height, border, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>   */
  public void glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexImage2D\" not available");
    }
        dispatch_glCompressedTexImage2D1(target, level, internalformat, width, height, border, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>   */
  private native void dispatch_glCompressedTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Buffer data)  {

    checkUnpackPBODisabled(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexSubImage2D\" not available");
    }
        dispatch_glCompressedTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>   */
  public void glCompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexSubImage2D\" not available");
    }
        dispatch_glCompressedTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>   */
  private native void dispatch_glCompressedTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  public void glCopyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyTexImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyTexImage2D\" not available");
    }
        dispatch_glCopyTexImage2D1(target, level, internalformat, x, y, width, height, border, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glCopyTexImage2D1(int target, int level, int internalformat, int x, int y, int width, int height, int border, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  public void glCopyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyTexSubImage2D\" not available");
    }
        dispatch_glCopyTexSubImage2D1(target, level, xoffset, yoffset, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glCopyTexSubImage2D1(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glCullFace}(GLenum mode); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glCullFace(int mode)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCullFace;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCullFace\" not available");
    }
        dispatch_glCullFace1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCullFace}(GLenum mode); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glCullFace1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glCurrentPaletteMatrixOES}(GLuint matrixpaletteindex); </code> <br>Part of <code>GL_ARB_matrix_palette</code>; <code>GL_OES_matrix_palette</code>   */
  public void glCurrentPaletteMatrix(int matrixpaletteindex)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCurrentPaletteMatrix;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCurrentPaletteMatrix\" not available");
    }
        dispatch_glCurrentPaletteMatrix1(matrixpaletteindex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCurrentPaletteMatrixOES}(GLuint matrixpaletteindex); </code> <br>Part of <code>GL_ARB_matrix_palette</code>; <code>GL_OES_matrix_palette</code>   */
  public native void dispatch_glCurrentPaletteMatrix1(int matrixpaletteindex, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteBuffers}(GLsizei n, const GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteBuffers(int n, IntBuffer buffers)  {

    Buffers.rangeCheck(buffers, n);
    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteBuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteBuffers\" not available");
    }
        dispatch_glDeleteBuffers1(n, buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteBuffers}(GLsizei n, const GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteBuffers1(int n, Object buffers, int buffers_byte_offset, boolean buffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteBuffers}(GLsizei n, const GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>   */
  public void glDeleteBuffers(int n, int[] buffers, int buffers_offset)  {

    Buffers.rangeCheck(buffers, buffers_offset, n);
    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteBuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteBuffers\" not available");
    }
        dispatch_glDeleteBuffers1(n, buffers, Buffers.SIZEOF_INT * buffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteFencesNV}(GLsizei n, const GLuint *  renderbuffers); </code> <br>Part of <code>GL_NV_fence</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteFencesNV(int n, IntBuffer renderbuffers)  {

    Buffers.rangeCheck(renderbuffers, n);
    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteFencesNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteFencesNV\" not available");
    }
        dispatch_glDeleteFencesNV1(n, renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteFencesNV}(GLsizei n, const GLuint *  renderbuffers); </code> <br>Part of <code>GL_NV_fence</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteFencesNV1(int n, Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteFencesNV}(GLsizei n, const GLuint *  renderbuffers); </code> <br>Part of <code>GL_NV_fence</code>   */
  public void glDeleteFencesNV(int n, int[] renderbuffers, int renderbuffers_offset)  {

    Buffers.rangeCheck(renderbuffers, renderbuffers_offset, n);
    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteFencesNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteFencesNV\" not available");
    }
        dispatch_glDeleteFencesNV1(n, renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteFramebuffersOES}(GLsizei n, const GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteFramebuffers(int n, IntBuffer framebuffers)  {

    final boolean framebuffers_is_direct = Buffers.isDirect(framebuffers);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteFramebuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteFramebuffers\" not available");
    }
        dispatch_glDeleteFramebuffers1(n, framebuffers_is_direct ? framebuffers : Buffers.getArray(framebuffers), framebuffers_is_direct ? Buffers.getDirectBufferByteOffset(framebuffers) : Buffers.getIndirectBufferByteOffset(framebuffers), framebuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteFramebuffersOES}(GLsizei n, const GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteFramebuffers1(int n, Object framebuffers, int framebuffers_byte_offset, boolean framebuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteFramebuffersOES}(GLsizei n, const GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glDeleteFramebuffers(int n, int[] framebuffers, int framebuffers_offset)  {

    if(framebuffers != null && framebuffers.length <= framebuffers_offset)
      throw new GLException("array offset argument \"framebuffers_offset\" (" + framebuffers_offset + ") equals or exceeds array length (" + framebuffers.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteFramebuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteFramebuffers\" not available");
    }
        dispatch_glDeleteFramebuffers1(n, framebuffers, Buffers.SIZEOF_INT * framebuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteRenderbuffersOES}(GLsizei n, const GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteRenderbuffers(int n, IntBuffer renderbuffers)  {

    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteRenderbuffers\" not available");
    }
        dispatch_glDeleteRenderbuffers1(n, renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteRenderbuffersOES}(GLsizei n, const GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteRenderbuffers1(int n, Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteRenderbuffersOES}(GLsizei n, const GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glDeleteRenderbuffers(int n, int[] renderbuffers, int renderbuffers_offset)  {

    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteRenderbuffers\" not available");
    }
        dispatch_glDeleteRenderbuffers1(n, renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteTextures}(GLsizei n, const GLuint *  textures); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteTextures(int n, IntBuffer textures)  {

    Buffers.rangeCheck(textures, n);
    final boolean textures_is_direct = Buffers.isDirect(textures);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteTextures;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteTextures\" not available");
    }
        dispatch_glDeleteTextures1(n, textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteTextures}(GLsizei n, const GLuint *  textures); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteTextures1(int n, Object textures, int textures_byte_offset, boolean textures_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteTextures}(GLsizei n, const GLuint *  textures); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  public void glDeleteTextures(int n, int[] textures, int textures_offset)  {

    Buffers.rangeCheck(textures, textures_offset, n);
    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteTextures;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteTextures\" not available");
    }
        dispatch_glDeleteTextures1(n, textures, Buffers.SIZEOF_INT * textures_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteVertexArraysOES}(GLsizei n, const GLuint *  arrays); </code> <br>Part of <code>GL_OES_vertex_array_object</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteVertexArraysOES(int n, IntBuffer arrays)  {

    final boolean arrays_is_direct = Buffers.isDirect(arrays);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteVertexArraysOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteVertexArraysOES\" not available");
    }
        dispatch_glDeleteVertexArraysOES1(n, arrays_is_direct ? arrays : Buffers.getArray(arrays), arrays_is_direct ? Buffers.getDirectBufferByteOffset(arrays) : Buffers.getIndirectBufferByteOffset(arrays), arrays_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteVertexArraysOES}(GLsizei n, const GLuint *  arrays); </code> <br>Part of <code>GL_OES_vertex_array_object</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteVertexArraysOES1(int n, Object arrays, int arrays_byte_offset, boolean arrays_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteVertexArraysOES}(GLsizei n, const GLuint *  arrays); </code> <br>Part of <code>GL_OES_vertex_array_object</code>   */
  public void glDeleteVertexArraysOES(int n, int[] arrays, int arrays_offset)  {

    if(arrays != null && arrays.length <= arrays_offset)
      throw new GLException("array offset argument \"arrays_offset\" (" + arrays_offset + ") equals or exceeds array length (" + arrays.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteVertexArraysOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteVertexArraysOES\" not available");
    }
        dispatch_glDeleteVertexArraysOES1(n, arrays, Buffers.SIZEOF_INT * arrays_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthFunc}(GLenum func); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glDepthFunc(int func)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDepthFunc;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDepthFunc\" not available");
    }
        dispatch_glDepthFunc1(func, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthFunc}(GLenum func); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glDepthFunc1(int func, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthMask}(GLboolean flag); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glDepthMask(boolean flag)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDepthMask;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDepthMask\" not available");
    }
        dispatch_glDepthMask1(flag, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthMask}(GLboolean flag); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glDepthMask1(boolean flag, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthRangef}(GLclampf zNear, GLclampf zFar); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glDepthRangef(float zNear, float zFar)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDepthRangef;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDepthRangef\" not available");
    }
        dispatch_glDepthRangef1(zNear, zFar, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthRangef}(GLclampf zNear, GLclampf zFar); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_VERSION_ES_CM</code>   */
  public native void dispatch_glDepthRangef1(float zNear, float zFar, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthRangex}(GLclampx zNear, GLclampx zFar); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glDepthRangex(int zNear, int zFar)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDepthRangex;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDepthRangex\" not available");
    }
        dispatch_glDepthRangex1(zNear, zFar, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthRangex}(GLclampx zNear, GLclampx zFar); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glDepthRangex1(int zNear, int zFar, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisable}(GLenum cap); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glDisable(int cap)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDisable;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDisable\" not available");
    }
        dispatch_glDisable1(cap, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisable}(GLenum cap); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glDisable1(int cap, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableClientState}(GLenum array); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  public void glDisableClientState(int array)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDisableClientState;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDisableClientState\" not available");
    }
        dispatch_glDisableClientState1(array, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableClientState}(GLenum array); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glDisableClientState1(int array, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableDriverControlQCOM}(GLuint driverControl); </code> <br>Part of <code>GL_QCOM_driver_control</code>   */
  public void glDisableDriverControlQCOM(int driverControl)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDisableDriverControlQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDisableDriverControlQCOM\" not available");
    }
        dispatch_glDisableDriverControlQCOM1(driverControl, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableDriverControlQCOM}(GLuint driverControl); </code> <br>Part of <code>GL_QCOM_driver_control</code>   */
  public native void dispatch_glDisableDriverControlQCOM1(int driverControl, long procAddress);

  /** Entry point to C language function: <code> void {@native glDiscardFramebufferEXT}(GLenum target, GLsizei numAttachments, const GLenum *  attachments); </code> <br>Part of <code>GL_EXT_discard_framebuffer</code>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDiscardFramebufferEXT(int target, int numAttachments, IntBuffer attachments)  {

    final boolean attachments_is_direct = Buffers.isDirect(attachments);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDiscardFramebufferEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDiscardFramebufferEXT\" not available");
    }
        dispatch_glDiscardFramebufferEXT1(target, numAttachments, attachments_is_direct ? attachments : Buffers.getArray(attachments), attachments_is_direct ? Buffers.getDirectBufferByteOffset(attachments) : Buffers.getIndirectBufferByteOffset(attachments), attachments_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDiscardFramebufferEXT}(GLenum target, GLsizei numAttachments, const GLenum *  attachments); </code> <br>Part of <code>GL_EXT_discard_framebuffer</code>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDiscardFramebufferEXT1(int target, int numAttachments, Object attachments, int attachments_byte_offset, boolean attachments_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDiscardFramebufferEXT}(GLenum target, GLsizei numAttachments, const GLenum *  attachments); </code> <br>Part of <code>GL_EXT_discard_framebuffer</code>   */
  public void glDiscardFramebufferEXT(int target, int numAttachments, int[] attachments, int attachments_offset)  {

    if(attachments != null && attachments.length <= attachments_offset)
      throw new GLException("array offset argument \"attachments_offset\" (" + attachments_offset + ") equals or exceeds array length (" + attachments.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDiscardFramebufferEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDiscardFramebufferEXT\" not available");
    }
        dispatch_glDiscardFramebufferEXT1(target, numAttachments, attachments, Buffers.SIZEOF_INT * attachments_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArrays}(GLenum mode, GLint first, GLsizei count); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  public void glDrawArrays(int mode, int first, int count)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawArrays;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawArrays\" not available");
    }
        dispatch_glDrawArrays1(mode, first, count, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArrays}(GLenum mode, GLint first, GLsizei count); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glDrawArrays1(int mode, int first, int count, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElements(int mode, int count, int type, Buffer indices)  {

    checkElementVBODisabled(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawElements;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawElements\" not available");
    }
        dispatch_glDrawElements1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElements1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  public void glDrawElements(int mode, int count, int type, long indices_buffer_offset)  {

    checkElementVBOEnabled(true);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawElements;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawElements\" not available");
    }
        dispatch_glDrawElements1(mode, count, type, indices_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  private native void dispatch_glDrawElements1(int mode, int count, int type, long indices_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTexfOES}(GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height); </code> <br>Part of <code>GL_OES_draw_texture</code>   */
  public void glDrawTexfOES(float x, float y, float z, float width, float height)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawTexfOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawTexfOES\" not available");
    }
        dispatch_glDrawTexfOES1(x, y, z, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTexfOES}(GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height); </code> <br>Part of <code>GL_OES_draw_texture</code>   */
  public native void dispatch_glDrawTexfOES1(float x, float y, float z, float width, float height, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTexfvOES}(const GLfloat *  coords); </code> <br>Part of <code>GL_OES_draw_texture</code>
      @param coords a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glDrawTexfvOES(FloatBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawTexfvOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawTexfvOES\" not available");
    }
        dispatch_glDrawTexfvOES1(coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTexfvOES}(const GLfloat *  coords); </code> <br>Part of <code>GL_OES_draw_texture</code>
      @param coords a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glDrawTexfvOES1(Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTexfvOES}(const GLfloat *  coords); </code> <br>Part of <code>GL_OES_draw_texture</code>   */
  public void glDrawTexfvOES(float[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawTexfvOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawTexfvOES\" not available");
    }
        dispatch_glDrawTexfvOES1(coords, Buffers.SIZEOF_FLOAT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTexiOES}(GLint x, GLint y, GLint z, GLint width, GLint height); </code> <br>Part of <code>GL_OES_draw_texture</code>   */
  public void glDrawTexiOES(int x, int y, int z, int width, int height)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawTexiOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawTexiOES\" not available");
    }
        dispatch_glDrawTexiOES1(x, y, z, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTexiOES}(GLint x, GLint y, GLint z, GLint width, GLint height); </code> <br>Part of <code>GL_OES_draw_texture</code>   */
  public native void dispatch_glDrawTexiOES1(int x, int y, int z, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTexivOES}(const GLint *  coords); </code> <br>Part of <code>GL_OES_draw_texture</code>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDrawTexivOES(IntBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawTexivOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawTexivOES\" not available");
    }
        dispatch_glDrawTexivOES1(coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTexivOES}(const GLint *  coords); </code> <br>Part of <code>GL_OES_draw_texture</code>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDrawTexivOES1(Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTexivOES}(const GLint *  coords); </code> <br>Part of <code>GL_OES_draw_texture</code>   */
  public void glDrawTexivOES(int[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawTexivOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawTexivOES\" not available");
    }
        dispatch_glDrawTexivOES1(coords, Buffers.SIZEOF_INT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTexsOES}(GLshort x, GLshort y, GLshort z, GLshort width, GLshort height); </code> <br>Part of <code>GL_OES_draw_texture</code>   */
  public void glDrawTexsOES(short x, short y, short z, short width, short height)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawTexsOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawTexsOES\" not available");
    }
        dispatch_glDrawTexsOES1(x, y, z, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTexsOES}(GLshort x, GLshort y, GLshort z, GLshort width, GLshort height); </code> <br>Part of <code>GL_OES_draw_texture</code>   */
  public native void dispatch_glDrawTexsOES1(short x, short y, short z, short width, short height, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTexsvOES}(const GLshort *  coords); </code> <br>Part of <code>GL_OES_draw_texture</code>
      @param coords a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glDrawTexsvOES(ShortBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawTexsvOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawTexsvOES\" not available");
    }
        dispatch_glDrawTexsvOES1(coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTexsvOES}(const GLshort *  coords); </code> <br>Part of <code>GL_OES_draw_texture</code>
      @param coords a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glDrawTexsvOES1(Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTexsvOES}(const GLshort *  coords); </code> <br>Part of <code>GL_OES_draw_texture</code>   */
  public void glDrawTexsvOES(short[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawTexsvOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawTexsvOES\" not available");
    }
        dispatch_glDrawTexsvOES1(coords, Buffers.SIZEOF_SHORT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTexxOES}(GLfixed x, GLfixed y, GLfixed z, GLfixed width, GLfixed height); </code> <br>Part of <code>GL_OES_draw_texture</code>   */
  public void glDrawTexxOES(int x, int y, int z, int width, int height)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawTexxOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawTexxOES\" not available");
    }
        dispatch_glDrawTexxOES1(x, y, z, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTexxOES}(GLfixed x, GLfixed y, GLfixed z, GLfixed width, GLfixed height); </code> <br>Part of <code>GL_OES_draw_texture</code>   */
  public native void dispatch_glDrawTexxOES1(int x, int y, int z, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTexxvOES}(const GLfixed *  coords); </code> <br>Part of <code>GL_OES_draw_texture</code>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDrawTexxvOES(IntBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawTexxvOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawTexxvOES\" not available");
    }
        dispatch_glDrawTexxvOES1(coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTexxvOES}(const GLfixed *  coords); </code> <br>Part of <code>GL_OES_draw_texture</code>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDrawTexxvOES1(Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTexxvOES}(const GLfixed *  coords); </code> <br>Part of <code>GL_OES_draw_texture</code>   */
  public void glDrawTexxvOES(int[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawTexxvOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawTexxvOES\" not available");
    }
        dispatch_glDrawTexxvOES1(coords, Buffers.SIZEOF_INT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEGLImageTargetRenderbufferStorageOES}(GLenum target, GLeglImageOES image); </code> <br>Part of <code>GL_OES_EGL_image</code>   */
  public void glEGLImageTargetRenderbufferStorageOES(int target, long image)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glEGLImageTargetRenderbufferStorageOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEGLImageTargetRenderbufferStorageOES\" not available");
    }
        dispatch_glEGLImageTargetRenderbufferStorageOES1(target, image, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEGLImageTargetRenderbufferStorageOES}(GLenum target, GLeglImageOES image); </code> <br>Part of <code>GL_OES_EGL_image</code>   */
  public native void dispatch_glEGLImageTargetRenderbufferStorageOES1(int target, long image, long procAddress);

  /** Entry point to C language function: <code> void {@native glEGLImageTargetTexture2DOES}(GLenum target, GLeglImageOES image); </code> <br>Part of <code>GL_OES_EGL_image</code>   */
  public void glEGLImageTargetTexture2DOES(int target, long image)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glEGLImageTargetTexture2DOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEGLImageTargetTexture2DOES\" not available");
    }
        dispatch_glEGLImageTargetTexture2DOES1(target, image, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEGLImageTargetTexture2DOES}(GLenum target, GLeglImageOES image); </code> <br>Part of <code>GL_OES_EGL_image</code>   */
  public native void dispatch_glEGLImageTargetTexture2DOES1(int target, long image, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnable}(GLenum cap); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glEnable(int cap)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glEnable;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEnable\" not available");
    }
        dispatch_glEnable1(cap, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnable}(GLenum cap); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glEnable1(int cap, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableClientState}(GLenum array); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  public void glEnableClientState(int array)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glEnableClientState;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEnableClientState\" not available");
    }
        dispatch_glEnableClientState1(array, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableClientState}(GLenum array); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glEnableClientState1(int array, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableDriverControlQCOM}(GLuint driverControl); </code> <br>Part of <code>GL_QCOM_driver_control</code>   */
  public void glEnableDriverControlQCOM(int driverControl)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glEnableDriverControlQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEnableDriverControlQCOM\" not available");
    }
        dispatch_glEnableDriverControlQCOM1(driverControl, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableDriverControlQCOM}(GLuint driverControl); </code> <br>Part of <code>GL_QCOM_driver_control</code>   */
  public native void dispatch_glEnableDriverControlQCOM1(int driverControl, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndTilingQCOM}(GLbitfield preserveMask); </code> <br>Part of <code>GL_QCOM_tiled_rendering</code>   */
  public void glEndTilingQCOM(int preserveMask)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glEndTilingQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEndTilingQCOM\" not available");
    }
        dispatch_glEndTilingQCOM1(preserveMask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndTilingQCOM}(GLbitfield preserveMask); </code> <br>Part of <code>GL_QCOM_tiled_rendering</code>   */
  public native void dispatch_glEndTilingQCOM1(int preserveMask, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetBufferPointervQCOM}(GLenum target, GLvoid *  *  params); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param params a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glExtGetBufferPointervQCOM(int target, PointerBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetBufferPointervQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetBufferPointervQCOM\" not available");
    }
        dispatch_glExtGetBufferPointervQCOM1(target, params_is_direct ? ( params != null ? params.getBuffer() : null ) : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetBufferPointervQCOM}(GLenum target, GLvoid *  *  params); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param params a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private native void dispatch_glExtGetBufferPointervQCOM1(int target, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetBuffersQCOM}(GLuint *  buffers, GLint maxBuffers, GLint *  numBuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numBuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetBuffersQCOM(IntBuffer buffers, int maxBuffers, IntBuffer numBuffers)  {

    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final boolean numBuffers_is_direct = Buffers.isDirect(numBuffers);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetBuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetBuffersQCOM\" not available");
    }
        dispatch_glExtGetBuffersQCOM1(buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, maxBuffers, numBuffers_is_direct ? numBuffers : Buffers.getArray(numBuffers), numBuffers_is_direct ? Buffers.getDirectBufferByteOffset(numBuffers) : Buffers.getIndirectBufferByteOffset(numBuffers), numBuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetBuffersQCOM}(GLuint *  buffers, GLint maxBuffers, GLint *  numBuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numBuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetBuffersQCOM1(Object buffers, int buffers_byte_offset, boolean buffers_is_direct, int maxBuffers, Object numBuffers, int numBuffers_byte_offset, boolean numBuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetBuffersQCOM}(GLuint *  buffers, GLint maxBuffers, GLint *  numBuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>   */
  public void glExtGetBuffersQCOM(int[] buffers, int buffers_offset, int maxBuffers, int[] numBuffers, int numBuffers_offset)  {

    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    if(numBuffers != null && numBuffers.length <= numBuffers_offset)
      throw new GLException("array offset argument \"numBuffers_offset\" (" + numBuffers_offset + ") equals or exceeds array length (" + numBuffers.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetBuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetBuffersQCOM\" not available");
    }
        dispatch_glExtGetBuffersQCOM1(buffers, Buffers.SIZEOF_INT * buffers_offset, false, maxBuffers, numBuffers, Buffers.SIZEOF_INT * numBuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetFramebuffersQCOM}(GLuint *  framebuffers, GLint maxFramebuffers, GLint *  numFramebuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numFramebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetFramebuffersQCOM(IntBuffer framebuffers, int maxFramebuffers, IntBuffer numFramebuffers)  {

    final boolean framebuffers_is_direct = Buffers.isDirect(framebuffers);
    final boolean numFramebuffers_is_direct = Buffers.isDirect(numFramebuffers);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetFramebuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetFramebuffersQCOM\" not available");
    }
        dispatch_glExtGetFramebuffersQCOM1(framebuffers_is_direct ? framebuffers : Buffers.getArray(framebuffers), framebuffers_is_direct ? Buffers.getDirectBufferByteOffset(framebuffers) : Buffers.getIndirectBufferByteOffset(framebuffers), framebuffers_is_direct, maxFramebuffers, numFramebuffers_is_direct ? numFramebuffers : Buffers.getArray(numFramebuffers), numFramebuffers_is_direct ? Buffers.getDirectBufferByteOffset(numFramebuffers) : Buffers.getIndirectBufferByteOffset(numFramebuffers), numFramebuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetFramebuffersQCOM}(GLuint *  framebuffers, GLint maxFramebuffers, GLint *  numFramebuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numFramebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetFramebuffersQCOM1(Object framebuffers, int framebuffers_byte_offset, boolean framebuffers_is_direct, int maxFramebuffers, Object numFramebuffers, int numFramebuffers_byte_offset, boolean numFramebuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetFramebuffersQCOM}(GLuint *  framebuffers, GLint maxFramebuffers, GLint *  numFramebuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>   */
  public void glExtGetFramebuffersQCOM(int[] framebuffers, int framebuffers_offset, int maxFramebuffers, int[] numFramebuffers, int numFramebuffers_offset)  {

    if(framebuffers != null && framebuffers.length <= framebuffers_offset)
      throw new GLException("array offset argument \"framebuffers_offset\" (" + framebuffers_offset + ") equals or exceeds array length (" + framebuffers.length + ")");
    if(numFramebuffers != null && numFramebuffers.length <= numFramebuffers_offset)
      throw new GLException("array offset argument \"numFramebuffers_offset\" (" + numFramebuffers_offset + ") equals or exceeds array length (" + numFramebuffers.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetFramebuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetFramebuffersQCOM\" not available");
    }
        dispatch_glExtGetFramebuffersQCOM1(framebuffers, Buffers.SIZEOF_INT * framebuffers_offset, false, maxFramebuffers, numFramebuffers, Buffers.SIZEOF_INT * numFramebuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetProgramBinarySourceQCOM}(GLuint program, GLenum shadertype, GLchar *  source, GLint *  length); </code> <br>Part of <code>GL_QCOM_extended_get2</code>
      @param source a direct or array-backed {@link java.nio.ByteBuffer}
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetProgramBinarySourceQCOM(int program, int shadertype, ByteBuffer source, IntBuffer length)  {

    final boolean source_is_direct = Buffers.isDirect(source);
    final boolean length_is_direct = Buffers.isDirect(length);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetProgramBinarySourceQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetProgramBinarySourceQCOM\" not available");
    }
        dispatch_glExtGetProgramBinarySourceQCOM1(program, shadertype, source_is_direct ? source : Buffers.getArray(source), source_is_direct ? Buffers.getDirectBufferByteOffset(source) : Buffers.getIndirectBufferByteOffset(source), source_is_direct, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetProgramBinarySourceQCOM}(GLuint program, GLenum shadertype, GLchar *  source, GLint *  length); </code> <br>Part of <code>GL_QCOM_extended_get2</code>
      @param source a direct or array-backed {@link java.nio.ByteBuffer}
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetProgramBinarySourceQCOM1(int program, int shadertype, Object source, int source_byte_offset, boolean source_is_direct, Object length, int length_byte_offset, boolean length_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetProgramBinarySourceQCOM}(GLuint program, GLenum shadertype, GLchar *  source, GLint *  length); </code> <br>Part of <code>GL_QCOM_extended_get2</code>   */
  public void glExtGetProgramBinarySourceQCOM(int program, int shadertype, byte[] source, int source_offset, int[] length, int length_offset)  {

    if(source != null && source.length <= source_offset)
      throw new GLException("array offset argument \"source_offset\" (" + source_offset + ") equals or exceeds array length (" + source.length + ")");
    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetProgramBinarySourceQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetProgramBinarySourceQCOM\" not available");
    }
        dispatch_glExtGetProgramBinarySourceQCOM1(program, shadertype, source, source_offset, false, length, Buffers.SIZEOF_INT * length_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetProgramsQCOM}(GLuint *  programs, GLint maxPrograms, GLint *  numPrograms); </code> <br>Part of <code>GL_QCOM_extended_get2</code>
      @param programs a direct or array-backed {@link java.nio.IntBuffer}
      @param numPrograms a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetProgramsQCOM(IntBuffer programs, int maxPrograms, IntBuffer numPrograms)  {

    final boolean programs_is_direct = Buffers.isDirect(programs);
    final boolean numPrograms_is_direct = Buffers.isDirect(numPrograms);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetProgramsQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetProgramsQCOM\" not available");
    }
        dispatch_glExtGetProgramsQCOM1(programs_is_direct ? programs : Buffers.getArray(programs), programs_is_direct ? Buffers.getDirectBufferByteOffset(programs) : Buffers.getIndirectBufferByteOffset(programs), programs_is_direct, maxPrograms, numPrograms_is_direct ? numPrograms : Buffers.getArray(numPrograms), numPrograms_is_direct ? Buffers.getDirectBufferByteOffset(numPrograms) : Buffers.getIndirectBufferByteOffset(numPrograms), numPrograms_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetProgramsQCOM}(GLuint *  programs, GLint maxPrograms, GLint *  numPrograms); </code> <br>Part of <code>GL_QCOM_extended_get2</code>
      @param programs a direct or array-backed {@link java.nio.IntBuffer}
      @param numPrograms a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetProgramsQCOM1(Object programs, int programs_byte_offset, boolean programs_is_direct, int maxPrograms, Object numPrograms, int numPrograms_byte_offset, boolean numPrograms_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetProgramsQCOM}(GLuint *  programs, GLint maxPrograms, GLint *  numPrograms); </code> <br>Part of <code>GL_QCOM_extended_get2</code>   */
  public void glExtGetProgramsQCOM(int[] programs, int programs_offset, int maxPrograms, int[] numPrograms, int numPrograms_offset)  {

    if(programs != null && programs.length <= programs_offset)
      throw new GLException("array offset argument \"programs_offset\" (" + programs_offset + ") equals or exceeds array length (" + programs.length + ")");
    if(numPrograms != null && numPrograms.length <= numPrograms_offset)
      throw new GLException("array offset argument \"numPrograms_offset\" (" + numPrograms_offset + ") equals or exceeds array length (" + numPrograms.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetProgramsQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetProgramsQCOM\" not available");
    }
        dispatch_glExtGetProgramsQCOM1(programs, Buffers.SIZEOF_INT * programs_offset, false, maxPrograms, numPrograms, Buffers.SIZEOF_INT * numPrograms_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetRenderbuffersQCOM}(GLuint *  renderbuffers, GLint maxRenderbuffers, GLint *  numRenderbuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numRenderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetRenderbuffersQCOM(IntBuffer renderbuffers, int maxRenderbuffers, IntBuffer numRenderbuffers)  {

    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    final boolean numRenderbuffers_is_direct = Buffers.isDirect(numRenderbuffers);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetRenderbuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetRenderbuffersQCOM\" not available");
    }
        dispatch_glExtGetRenderbuffersQCOM1(renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct, maxRenderbuffers, numRenderbuffers_is_direct ? numRenderbuffers : Buffers.getArray(numRenderbuffers), numRenderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(numRenderbuffers) : Buffers.getIndirectBufferByteOffset(numRenderbuffers), numRenderbuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetRenderbuffersQCOM}(GLuint *  renderbuffers, GLint maxRenderbuffers, GLint *  numRenderbuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numRenderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetRenderbuffersQCOM1(Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct, int maxRenderbuffers, Object numRenderbuffers, int numRenderbuffers_byte_offset, boolean numRenderbuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetRenderbuffersQCOM}(GLuint *  renderbuffers, GLint maxRenderbuffers, GLint *  numRenderbuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>   */
  public void glExtGetRenderbuffersQCOM(int[] renderbuffers, int renderbuffers_offset, int maxRenderbuffers, int[] numRenderbuffers, int numRenderbuffers_offset)  {

    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    if(numRenderbuffers != null && numRenderbuffers.length <= numRenderbuffers_offset)
      throw new GLException("array offset argument \"numRenderbuffers_offset\" (" + numRenderbuffers_offset + ") equals or exceeds array length (" + numRenderbuffers.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetRenderbuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetRenderbuffersQCOM\" not available");
    }
        dispatch_glExtGetRenderbuffersQCOM1(renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false, maxRenderbuffers, numRenderbuffers, Buffers.SIZEOF_INT * numRenderbuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetShadersQCOM}(GLuint *  shaders, GLint maxShaders, GLint *  numShaders); </code> <br>Part of <code>GL_QCOM_extended_get2</code>
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}
      @param numShaders a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetShadersQCOM(IntBuffer shaders, int maxShaders, IntBuffer numShaders)  {

    final boolean shaders_is_direct = Buffers.isDirect(shaders);
    final boolean numShaders_is_direct = Buffers.isDirect(numShaders);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetShadersQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetShadersQCOM\" not available");
    }
        dispatch_glExtGetShadersQCOM1(shaders_is_direct ? shaders : Buffers.getArray(shaders), shaders_is_direct ? Buffers.getDirectBufferByteOffset(shaders) : Buffers.getIndirectBufferByteOffset(shaders), shaders_is_direct, maxShaders, numShaders_is_direct ? numShaders : Buffers.getArray(numShaders), numShaders_is_direct ? Buffers.getDirectBufferByteOffset(numShaders) : Buffers.getIndirectBufferByteOffset(numShaders), numShaders_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetShadersQCOM}(GLuint *  shaders, GLint maxShaders, GLint *  numShaders); </code> <br>Part of <code>GL_QCOM_extended_get2</code>
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}
      @param numShaders a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetShadersQCOM1(Object shaders, int shaders_byte_offset, boolean shaders_is_direct, int maxShaders, Object numShaders, int numShaders_byte_offset, boolean numShaders_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetShadersQCOM}(GLuint *  shaders, GLint maxShaders, GLint *  numShaders); </code> <br>Part of <code>GL_QCOM_extended_get2</code>   */
  public void glExtGetShadersQCOM(int[] shaders, int shaders_offset, int maxShaders, int[] numShaders, int numShaders_offset)  {

    if(shaders != null && shaders.length <= shaders_offset)
      throw new GLException("array offset argument \"shaders_offset\" (" + shaders_offset + ") equals or exceeds array length (" + shaders.length + ")");
    if(numShaders != null && numShaders.length <= numShaders_offset)
      throw new GLException("array offset argument \"numShaders_offset\" (" + numShaders_offset + ") equals or exceeds array length (" + numShaders.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetShadersQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetShadersQCOM\" not available");
    }
        dispatch_glExtGetShadersQCOM1(shaders, Buffers.SIZEOF_INT * shaders_offset, false, maxShaders, numShaders, Buffers.SIZEOF_INT * numShaders_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetTexLevelParameterivQCOM}(GLuint texture, GLenum face, GLint level, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetTexLevelParameterivQCOM(int texture, int face, int level, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetTexLevelParameterivQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetTexLevelParameterivQCOM\" not available");
    }
        dispatch_glExtGetTexLevelParameterivQCOM1(texture, face, level, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetTexLevelParameterivQCOM}(GLuint texture, GLenum face, GLint level, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetTexLevelParameterivQCOM1(int texture, int face, int level, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetTexLevelParameterivQCOM}(GLuint texture, GLenum face, GLint level, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_QCOM_extended_get</code>   */
  public void glExtGetTexLevelParameterivQCOM(int texture, int face, int level, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetTexLevelParameterivQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetTexLevelParameterivQCOM\" not available");
    }
        dispatch_glExtGetTexLevelParameterivQCOM1(texture, face, level, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetTexSubImageQCOM}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLvoid *  texels); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param texels a direct or array-backed {@link java.nio.Buffer}   */
  public void glExtGetTexSubImageQCOM(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Buffer texels)  {

    final boolean texels_is_direct = Buffers.isDirect(texels);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetTexSubImageQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetTexSubImageQCOM\" not available");
    }
        dispatch_glExtGetTexSubImageQCOM1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, texels_is_direct ? texels : Buffers.getArray(texels), texels_is_direct ? Buffers.getDirectBufferByteOffset(texels) : Buffers.getIndirectBufferByteOffset(texels), texels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetTexSubImageQCOM}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLvoid *  texels); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param texels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glExtGetTexSubImageQCOM1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Object texels, int texels_byte_offset, boolean texels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetTexturesQCOM}(GLuint *  textures, GLint maxTextures, GLint *  numTextures); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}
      @param numTextures a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetTexturesQCOM(IntBuffer textures, int maxTextures, IntBuffer numTextures)  {

    final boolean textures_is_direct = Buffers.isDirect(textures);
    final boolean numTextures_is_direct = Buffers.isDirect(numTextures);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetTexturesQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetTexturesQCOM\" not available");
    }
        dispatch_glExtGetTexturesQCOM1(textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, maxTextures, numTextures_is_direct ? numTextures : Buffers.getArray(numTextures), numTextures_is_direct ? Buffers.getDirectBufferByteOffset(numTextures) : Buffers.getIndirectBufferByteOffset(numTextures), numTextures_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetTexturesQCOM}(GLuint *  textures, GLint maxTextures, GLint *  numTextures); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}
      @param numTextures a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetTexturesQCOM1(Object textures, int textures_byte_offset, boolean textures_is_direct, int maxTextures, Object numTextures, int numTextures_byte_offset, boolean numTextures_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetTexturesQCOM}(GLuint *  textures, GLint maxTextures, GLint *  numTextures); </code> <br>Part of <code>GL_QCOM_extended_get</code>   */
  public void glExtGetTexturesQCOM(int[] textures, int textures_offset, int maxTextures, int[] numTextures, int numTextures_offset)  {

    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    if(numTextures != null && numTextures.length <= numTextures_offset)
      throw new GLException("array offset argument \"numTextures_offset\" (" + numTextures_offset + ") equals or exceeds array length (" + numTextures.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetTexturesQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetTexturesQCOM\" not available");
    }
        dispatch_glExtGetTexturesQCOM1(textures, Buffers.SIZEOF_INT * textures_offset, false, maxTextures, numTextures, Buffers.SIZEOF_INT * numTextures_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glExtIsProgramBinaryQCOM}(GLuint program); </code> <br>Part of <code>GL_QCOM_extended_get2</code>   */
  public boolean glExtIsProgramBinaryQCOM(int program)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtIsProgramBinaryQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtIsProgramBinaryQCOM\" not available");
    }
        return dispatch_glExtIsProgramBinaryQCOM1(program, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glExtIsProgramBinaryQCOM}(GLuint program); </code> <br>Part of <code>GL_QCOM_extended_get2</code>   */
  public native boolean dispatch_glExtIsProgramBinaryQCOM1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtTexObjectStateOverrideiQCOM}(GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_QCOM_extended_get</code>   */
  public void glExtTexObjectStateOverrideiQCOM(int target, int pname, int param)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtTexObjectStateOverrideiQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtTexObjectStateOverrideiQCOM\" not available");
    }
        dispatch_glExtTexObjectStateOverrideiQCOM1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtTexObjectStateOverrideiQCOM}(GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_QCOM_extended_get</code>   */
  public native void dispatch_glExtTexObjectStateOverrideiQCOM1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glFinish}(void); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glFinish()  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFinish;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFinish\" not available");
    }
        dispatch_glFinish1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glFinish}(void); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glFinish1(long procAddress);

  /** Entry point to C language function: <code> void {@native glFinishFenceNV}(GLuint mode); </code> <br>Part of <code>GL_NV_fence</code>   */
  public void glFinishFenceNV(int mode)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFinishFenceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFinishFenceNV\" not available");
    }
        dispatch_glFinishFenceNV1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFinishFenceNV}(GLuint mode); </code> <br>Part of <code>GL_NV_fence</code>   */
  public native void dispatch_glFinishFenceNV1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glFlush}(void); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glFlush()  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFlush;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFlush\" not available");
    }
        dispatch_glFlush1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glFlush}(void); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glFlush1(long procAddress);

  /** Entry point to C language function: <code> void {@native glFogf}(GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glFogf(int pname, float param)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogf\" not available");
    }
        dispatch_glFogf1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogf}(GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public native void dispatch_glFogf1(int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogfv}(GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glFogfv(int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogfv\" not available");
    }
        dispatch_glFogfv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogfv}(GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glFogfv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogfv}(GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glFogfv(int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogfv\" not available");
    }
        dispatch_glFogfv1(pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogx}(GLenum pname, GLfixed param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glFogx(int pname, int param)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogx;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogx\" not available");
    }
        dispatch_glFogx1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogx}(GLenum pname, GLfixed param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glFogx1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogxv}(GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glFogxv(int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogxv\" not available");
    }
        dispatch_glFogxv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogxv}(GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glFogxv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogxv}(GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glFogxv(int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFogxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFogxv\" not available");
    }
        dispatch_glFogxv1(pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferRenderbufferOES}(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glFramebufferRenderbuffer(int target, int attachment, int renderbuffertarget, int renderbuffer)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferRenderbuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferRenderbuffer\" not available");
    }
        dispatch_glFramebufferRenderbuffer1(target, attachment, renderbuffertarget, renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferRenderbufferOES}(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  public native void dispatch_glFramebufferRenderbuffer1(int target, int attachment, int renderbuffertarget, int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2DMultisampleEXT}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples); </code> <br>Part of <code>GL_EXT_multisampled_render_to_texture</code>   */
  public void glFramebufferTexture2DMultisampleEXT(int target, int attachment, int textarget, int texture, int level, int samples)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferTexture2DMultisampleEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferTexture2DMultisampleEXT\" not available");
    }
        dispatch_glFramebufferTexture2DMultisampleEXT1(target, attachment, textarget, texture, level, samples, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2DMultisampleEXT}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples); </code> <br>Part of <code>GL_EXT_multisampled_render_to_texture</code>   */
  public native void dispatch_glFramebufferTexture2DMultisampleEXT1(int target, int attachment, int textarget, int texture, int level, int samples, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2DMultisampleIMG}(GLenum, GLenum, GLenum, GLuint, GLint, GLsizei); </code> <br>Part of <code>GL_IMG_multisampled_render_to_texture</code>   */
  public void glFramebufferTexture2DMultisampleIMG(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferTexture2DMultisampleIMG;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferTexture2DMultisampleIMG\" not available");
    }
        dispatch_glFramebufferTexture2DMultisampleIMG1(arg0, arg1, arg2, arg3, arg4, arg5, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2DMultisampleIMG}(GLenum, GLenum, GLenum, GLuint, GLint, GLsizei); </code> <br>Part of <code>GL_IMG_multisampled_render_to_texture</code>   */
  public native void dispatch_glFramebufferTexture2DMultisampleIMG1(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2DOES}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glFramebufferTexture2D(int target, int attachment, int textarget, int texture, int level)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferTexture2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferTexture2D\" not available");
    }
        dispatch_glFramebufferTexture2D1(target, attachment, textarget, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2DOES}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  public native void dispatch_glFramebufferTexture2D1(int target, int attachment, int textarget, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glFrontFace}(GLenum mode); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glFrontFace(int mode)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFrontFace;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFrontFace\" not available");
    }
        dispatch_glFrontFace1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFrontFace}(GLenum mode); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glFrontFace1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glFrustumf}(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar); </code> <br>Part of <code>GL_VERSION_ES_CM</code>   */
  public void glFrustumf(float left, float right, float bottom, float top, float zNear, float zFar)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFrustumf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFrustumf\" not available");
    }
        dispatch_glFrustumf1(left, right, bottom, top, zNear, zFar, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFrustumf}(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar); </code> <br>Part of <code>GL_VERSION_ES_CM</code>   */
  public native void dispatch_glFrustumf1(float left, float right, float bottom, float top, float zNear, float zFar, long procAddress);

  /** Entry point to C language function: <code> void {@native glFrustumx}(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glFrustumx(int left, int right, int bottom, int top, int zNear, int zFar)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFrustumx;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFrustumx\" not available");
    }
        dispatch_glFrustumx1(left, right, bottom, top, zNear, zFar, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFrustumx}(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glFrustumx1(int left, int right, int bottom, int top, int zNear, int zFar, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenBuffers}(GLsizei n, GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenBuffers(int n, IntBuffer buffers)  {

    Buffers.rangeCheck(buffers, n);
    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenBuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenBuffers\" not available");
    }
        dispatch_glGenBuffers1(n, buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenBuffers}(GLsizei n, GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenBuffers1(int n, Object buffers, int buffers_byte_offset, boolean buffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenBuffers}(GLsizei n, GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>   */
  public void glGenBuffers(int n, int[] buffers, int buffers_offset)  {

    Buffers.rangeCheck(buffers, buffers_offset, n);
    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenBuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenBuffers\" not available");
    }
        dispatch_glGenBuffers1(n, buffers, Buffers.SIZEOF_INT * buffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenFencesNV}(GLsizei n, GLuint *  renderbuffers); </code> <br>Part of <code>GL_NV_fence</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenFencesNV(int n, IntBuffer renderbuffers)  {

    Buffers.rangeCheck(renderbuffers, n);
    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenFencesNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenFencesNV\" not available");
    }
        dispatch_glGenFencesNV1(n, renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenFencesNV}(GLsizei n, GLuint *  renderbuffers); </code> <br>Part of <code>GL_NV_fence</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenFencesNV1(int n, Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenFencesNV}(GLsizei n, GLuint *  renderbuffers); </code> <br>Part of <code>GL_NV_fence</code>   */
  public void glGenFencesNV(int n, int[] renderbuffers, int renderbuffers_offset)  {

    Buffers.rangeCheck(renderbuffers, renderbuffers_offset, n);
    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenFencesNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenFencesNV\" not available");
    }
        dispatch_glGenFencesNV1(n, renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenFramebuffersOES}(GLsizei n, GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenFramebuffers(int n, IntBuffer framebuffers)  {

    final boolean framebuffers_is_direct = Buffers.isDirect(framebuffers);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenFramebuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenFramebuffers\" not available");
    }
        dispatch_glGenFramebuffers1(n, framebuffers_is_direct ? framebuffers : Buffers.getArray(framebuffers), framebuffers_is_direct ? Buffers.getDirectBufferByteOffset(framebuffers) : Buffers.getIndirectBufferByteOffset(framebuffers), framebuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenFramebuffersOES}(GLsizei n, GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenFramebuffers1(int n, Object framebuffers, int framebuffers_byte_offset, boolean framebuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenFramebuffersOES}(GLsizei n, GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glGenFramebuffers(int n, int[] framebuffers, int framebuffers_offset)  {

    if(framebuffers != null && framebuffers.length <= framebuffers_offset)
      throw new GLException("array offset argument \"framebuffers_offset\" (" + framebuffers_offset + ") equals or exceeds array length (" + framebuffers.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenFramebuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenFramebuffers\" not available");
    }
        dispatch_glGenFramebuffers1(n, framebuffers, Buffers.SIZEOF_INT * framebuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenRenderbuffersOES}(GLsizei n, GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenRenderbuffers(int n, IntBuffer renderbuffers)  {

    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenRenderbuffers\" not available");
    }
        dispatch_glGenRenderbuffers1(n, renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenRenderbuffersOES}(GLsizei n, GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenRenderbuffers1(int n, Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenRenderbuffersOES}(GLsizei n, GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glGenRenderbuffers(int n, int[] renderbuffers, int renderbuffers_offset)  {

    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenRenderbuffers\" not available");
    }
        dispatch_glGenRenderbuffers1(n, renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTextures}(GLsizei n, GLuint *  textures); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenTextures(int n, IntBuffer textures)  {

    Buffers.rangeCheck(textures, n);
    final boolean textures_is_direct = Buffers.isDirect(textures);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenTextures;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenTextures\" not available");
    }
        dispatch_glGenTextures1(n, textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTextures}(GLsizei n, GLuint *  textures); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenTextures1(int n, Object textures, int textures_byte_offset, boolean textures_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenTextures}(GLsizei n, GLuint *  textures); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  public void glGenTextures(int n, int[] textures, int textures_offset)  {

    Buffers.rangeCheck(textures, textures_offset, n);
    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenTextures;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenTextures\" not available");
    }
        dispatch_glGenTextures1(n, textures, Buffers.SIZEOF_INT * textures_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenVertexArraysOES}(GLsizei n, GLuint *  arrays); </code> <br>Part of <code>GL_OES_vertex_array_object</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenVertexArraysOES(int n, IntBuffer arrays)  {

    final boolean arrays_is_direct = Buffers.isDirect(arrays);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenVertexArraysOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenVertexArraysOES\" not available");
    }
        dispatch_glGenVertexArraysOES1(n, arrays_is_direct ? arrays : Buffers.getArray(arrays), arrays_is_direct ? Buffers.getDirectBufferByteOffset(arrays) : Buffers.getIndirectBufferByteOffset(arrays), arrays_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenVertexArraysOES}(GLsizei n, GLuint *  arrays); </code> <br>Part of <code>GL_OES_vertex_array_object</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenVertexArraysOES1(int n, Object arrays, int arrays_byte_offset, boolean arrays_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenVertexArraysOES}(GLsizei n, GLuint *  arrays); </code> <br>Part of <code>GL_OES_vertex_array_object</code>   */
  public void glGenVertexArraysOES(int n, int[] arrays, int arrays_offset)  {

    if(arrays != null && arrays.length <= arrays_offset)
      throw new GLException("array offset argument \"arrays_offset\" (" + arrays_offset + ") equals or exceeds array length (" + arrays.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenVertexArraysOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenVertexArraysOES\" not available");
    }
        dispatch_glGenVertexArraysOES1(n, arrays, Buffers.SIZEOF_INT * arrays_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenerateMipmapOES}(GLenum target); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glGenerateMipmap(int target)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenerateMipmap;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenerateMipmap\" not available");
    }
        dispatch_glGenerateMipmap1(target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenerateMipmapOES}(GLenum target); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  public native void dispatch_glGenerateMipmap1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBooleanv}(GLenum pname, GLboolean *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetBooleanv(int pname, ByteBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBooleanv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetBooleanv\" not available");
    }
        dispatch_glGetBooleanv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBooleanv}(GLenum pname, GLboolean *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetBooleanv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBooleanv}(GLenum pname, GLboolean *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glGetBooleanv(int pname, byte[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBooleanv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetBooleanv\" not available");
    }
        dispatch_glGetBooleanv1(pname, params, params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetBufferParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetBufferParameteriv\" not available");
    }
        dispatch_glGetBufferParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetBufferParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBufferParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>   */
  public void glGetBufferParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetBufferParameteriv\" not available");
    }
        dispatch_glGetBufferParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetClipPlanef}(GLenum pname, const GLfloat *  eqn); </code> <br>Part of <code>GL_VERSION_ES_CM</code>
      @param eqn a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetClipPlanef(int pname, FloatBuffer eqn)  {

    final boolean eqn_is_direct = Buffers.isDirect(eqn);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetClipPlanef;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetClipPlanef\" not available");
    }
        dispatch_glGetClipPlanef1(pname, eqn_is_direct ? eqn : Buffers.getArray(eqn), eqn_is_direct ? Buffers.getDirectBufferByteOffset(eqn) : Buffers.getIndirectBufferByteOffset(eqn), eqn_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetClipPlanef}(GLenum pname, const GLfloat *  eqn); </code> <br>Part of <code>GL_VERSION_ES_CM</code>
      @param eqn a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetClipPlanef1(int pname, Object eqn, int eqn_byte_offset, boolean eqn_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetClipPlanef}(GLenum pname, const GLfloat *  eqn); </code> <br>Part of <code>GL_VERSION_ES_CM</code>   */
  public void glGetClipPlanef(int pname, float[] eqn, int eqn_offset)  {

    if(eqn != null && eqn.length <= eqn_offset)
      throw new GLException("array offset argument \"eqn_offset\" (" + eqn_offset + ") equals or exceeds array length (" + eqn.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetClipPlanef;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetClipPlanef\" not available");
    }
        dispatch_glGetClipPlanef1(pname, eqn, Buffers.SIZEOF_FLOAT * eqn_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetClipPlanex}(GLenum pname, GLfixed *  eqn); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param eqn a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetClipPlanex(int pname, IntBuffer eqn)  {

    final boolean eqn_is_direct = Buffers.isDirect(eqn);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetClipPlanex;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetClipPlanex\" not available");
    }
        dispatch_glGetClipPlanex1(pname, eqn_is_direct ? eqn : Buffers.getArray(eqn), eqn_is_direct ? Buffers.getDirectBufferByteOffset(eqn) : Buffers.getIndirectBufferByteOffset(eqn), eqn_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetClipPlanex}(GLenum pname, GLfixed *  eqn); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param eqn a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetClipPlanex1(int pname, Object eqn, int eqn_byte_offset, boolean eqn_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetClipPlanex}(GLenum pname, GLfixed *  eqn); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glGetClipPlanex(int pname, int[] eqn, int eqn_offset)  {

    if(eqn != null && eqn.length <= eqn_offset)
      throw new GLException("array offset argument \"eqn_offset\" (" + eqn_offset + ") equals or exceeds array length (" + eqn.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetClipPlanex;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetClipPlanex\" not available");
    }
        dispatch_glGetClipPlanex1(pname, eqn, Buffers.SIZEOF_INT * eqn_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDriverControlStringQCOM}(GLuint driverControl, GLsizei bufSize, GLsizei *  length, GLchar *  driverControlString); </code> <br>Part of <code>GL_QCOM_driver_control</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param driverControlString a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetDriverControlStringQCOM(int driverControl, int bufSize, IntBuffer length, ByteBuffer driverControlString)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean driverControlString_is_direct = Buffers.isDirect(driverControlString);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDriverControlStringQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetDriverControlStringQCOM\" not available");
    }
        dispatch_glGetDriverControlStringQCOM1(driverControl, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, driverControlString_is_direct ? driverControlString : Buffers.getArray(driverControlString), driverControlString_is_direct ? Buffers.getDirectBufferByteOffset(driverControlString) : Buffers.getIndirectBufferByteOffset(driverControlString), driverControlString_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDriverControlStringQCOM}(GLuint driverControl, GLsizei bufSize, GLsizei *  length, GLchar *  driverControlString); </code> <br>Part of <code>GL_QCOM_driver_control</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param driverControlString a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetDriverControlStringQCOM1(int driverControl, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object driverControlString, int driverControlString_byte_offset, boolean driverControlString_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetDriverControlStringQCOM}(GLuint driverControl, GLsizei bufSize, GLsizei *  length, GLchar *  driverControlString); </code> <br>Part of <code>GL_QCOM_driver_control</code>   */
  public void glGetDriverControlStringQCOM(int driverControl, int bufSize, int[] length, int length_offset, byte[] driverControlString, int driverControlString_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(driverControlString != null && driverControlString.length <= driverControlString_offset)
      throw new GLException("array offset argument \"driverControlString_offset\" (" + driverControlString_offset + ") equals or exceeds array length (" + driverControlString.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDriverControlStringQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetDriverControlStringQCOM\" not available");
    }
        dispatch_glGetDriverControlStringQCOM1(driverControl, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, driverControlString, driverControlString_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDriverControlsQCOM}(GLint *  num, GLsizei size, GLuint *  driverControls); </code> <br>Part of <code>GL_QCOM_driver_control</code>
      @param num a direct or array-backed {@link java.nio.IntBuffer}
      @param driverControls a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetDriverControlsQCOM(IntBuffer num, int size, IntBuffer driverControls)  {

    final boolean num_is_direct = Buffers.isDirect(num);
    final boolean driverControls_is_direct = Buffers.isDirect(driverControls);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDriverControlsQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetDriverControlsQCOM\" not available");
    }
        dispatch_glGetDriverControlsQCOM1(num_is_direct ? num : Buffers.getArray(num), num_is_direct ? Buffers.getDirectBufferByteOffset(num) : Buffers.getIndirectBufferByteOffset(num), num_is_direct, size, driverControls_is_direct ? driverControls : Buffers.getArray(driverControls), driverControls_is_direct ? Buffers.getDirectBufferByteOffset(driverControls) : Buffers.getIndirectBufferByteOffset(driverControls), driverControls_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDriverControlsQCOM}(GLint *  num, GLsizei size, GLuint *  driverControls); </code> <br>Part of <code>GL_QCOM_driver_control</code>
      @param num a direct or array-backed {@link java.nio.IntBuffer}
      @param driverControls a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetDriverControlsQCOM1(Object num, int num_byte_offset, boolean num_is_direct, int size, Object driverControls, int driverControls_byte_offset, boolean driverControls_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetDriverControlsQCOM}(GLint *  num, GLsizei size, GLuint *  driverControls); </code> <br>Part of <code>GL_QCOM_driver_control</code>   */
  public void glGetDriverControlsQCOM(int[] num, int num_offset, int size, int[] driverControls, int driverControls_offset)  {

    if(num != null && num.length <= num_offset)
      throw new GLException("array offset argument \"num_offset\" (" + num_offset + ") equals or exceeds array length (" + num.length + ")");
    if(driverControls != null && driverControls.length <= driverControls_offset)
      throw new GLException("array offset argument \"driverControls_offset\" (" + driverControls_offset + ") equals or exceeds array length (" + driverControls.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDriverControlsQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetDriverControlsQCOM\" not available");
    }
        dispatch_glGetDriverControlsQCOM1(num, Buffers.SIZEOF_INT * num_offset, false, size, driverControls, Buffers.SIZEOF_INT * driverControls_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetError}(void); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public int glGetError()  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetError;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetError\" not available");
    }
        return dispatch_glGetError1(__addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetError}(void); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native int dispatch_glGetError1(long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFenceivNV}(GLuint target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_fence</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetFenceivNV(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFenceivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFenceivNV\" not available");
    }
        dispatch_glGetFenceivNV1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFenceivNV}(GLuint target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_fence</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetFenceivNV1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFenceivNV}(GLuint target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_fence</code>   */
  public void glGetFenceivNV(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFenceivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFenceivNV\" not available");
    }
        dispatch_glGetFenceivNV1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFixedv}(GLenum pname, GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetFixedv(int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFixedv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFixedv\" not available");
    }
        dispatch_glGetFixedv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFixedv}(GLenum pname, GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetFixedv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFixedv}(GLenum pname, GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glGetFixedv(int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFixedv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFixedv\" not available");
    }
        dispatch_glGetFixedv1(pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFloatv}(GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetFloatv(int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFloatv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFloatv\" not available");
    }
        dispatch_glGetFloatv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFloatv}(GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetFloatv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFloatv}(GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glGetFloatv(int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFloatv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFloatv\" not available");
    }
        dispatch_glGetFloatv1(pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFramebufferAttachmentParameterivOES}(GLenum target, GLenum attachment, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetFramebufferAttachmentParameteriv(int target, int attachment, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFramebufferAttachmentParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFramebufferAttachmentParameteriv\" not available");
    }
        dispatch_glGetFramebufferAttachmentParameteriv1(target, attachment, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFramebufferAttachmentParameterivOES}(GLenum target, GLenum attachment, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetFramebufferAttachmentParameteriv1(int target, int attachment, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFramebufferAttachmentParameterivOES}(GLenum target, GLenum attachment, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glGetFramebufferAttachmentParameteriv(int target, int attachment, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFramebufferAttachmentParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFramebufferAttachmentParameteriv\" not available");
    }
        dispatch_glGetFramebufferAttachmentParameteriv1(target, attachment, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetGraphicsResetStatusEXT}(void); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>   */
  public int glGetGraphicsResetStatus()  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetGraphicsResetStatus;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetGraphicsResetStatus\" not available");
    }
        return dispatch_glGetGraphicsResetStatus1(__addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetGraphicsResetStatusEXT}(void); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>   */
  public native int dispatch_glGetGraphicsResetStatus1(long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegerv}(GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetIntegerv(int pname, IntBuffer params)  {

    if ( glStateTracker.getInt(pname, params, params_offset) ) { return; }
    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetIntegerv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetIntegerv\" not available");
    }
        dispatch_glGetIntegerv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegerv}(GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetIntegerv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegerv}(GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glGetIntegerv(int pname, int[] params, int params_offset)  {

    if ( glStateTracker.getInt(pname, params, params_offset) ) { return; }
    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetIntegerv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetIntegerv\" not available");
    }
        dispatch_glGetIntegerv1(pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLightfv}(GLenum light, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetLightfv(int light, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetLightfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetLightfv\" not available");
    }
        dispatch_glGetLightfv1(light, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLightfv}(GLenum light, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetLightfv1(int light, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetLightfv}(GLenum light, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glGetLightfv(int light, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetLightfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetLightfv\" not available");
    }
        dispatch_glGetLightfv1(light, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLightxv}(GLenum light, GLenum pname, GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetLightxv(int light, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetLightxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetLightxv\" not available");
    }
        dispatch_glGetLightxv1(light, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLightxv}(GLenum light, GLenum pname, GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetLightxv1(int light, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetLightxv}(GLenum light, GLenum pname, GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glGetLightxv(int light, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetLightxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetLightxv\" not available");
    }
        dispatch_glGetLightxv1(light, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMaterialfv}(GLenum face, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMaterialfv(int face, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMaterialfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMaterialfv\" not available");
    }
        dispatch_glGetMaterialfv1(face, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMaterialfv}(GLenum face, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMaterialfv1(int face, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMaterialfv}(GLenum face, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glGetMaterialfv(int face, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMaterialfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMaterialfv\" not available");
    }
        dispatch_glGetMaterialfv1(face, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMaterialxv}(GLenum face, GLenum pname, GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMaterialxv(int face, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMaterialxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMaterialxv\" not available");
    }
        dispatch_glGetMaterialxv1(face, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMaterialxv}(GLenum face, GLenum pname, GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMaterialxv1(int face, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMaterialxv}(GLenum face, GLenum pname, GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glGetMaterialxv(int face, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetMaterialxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetMaterialxv\" not available");
    }
        dispatch_glGetMaterialxv1(face, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetRenderbufferParameterivOES}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetRenderbufferParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetRenderbufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetRenderbufferParameteriv\" not available");
    }
        dispatch_glGetRenderbufferParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetRenderbufferParameterivOES}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetRenderbufferParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetRenderbufferParameterivOES}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glGetRenderbufferParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetRenderbufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetRenderbufferParameteriv\" not available");
    }
        dispatch_glGetRenderbufferParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> const GLubyte *  {@native glGetString}(GLenum name); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public String glGetString(int name)  {

    if(_context.isExtensionCacheInitialized()) {
    if(GL.GL_EXTENSIONS==name) {
    return _context.getGLExtensionsString();
    } /* else if(GL.GL_VERSION==name) {
    return _context.getGLVersion();
    } */
    }
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetString;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetString\" not available");
    }
        return dispatch_glGetString1(name, __addr_);
  }

  /** Entry point to C language function: <code> const GLubyte *  {@native glGetString}(GLenum name); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  private native String dispatch_glGetString1(int name, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexEnvfv}(GLenum tenv, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTexEnvfv(int tenv, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexEnvfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexEnvfv\" not available");
    }
        dispatch_glGetTexEnvfv1(tenv, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexEnvfv}(GLenum tenv, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTexEnvfv1(int tenv, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexEnvfv}(GLenum tenv, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glGetTexEnvfv(int tenv, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexEnvfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexEnvfv\" not available");
    }
        dispatch_glGetTexEnvfv1(tenv, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexEnviv}(GLenum tenv, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexEnviv(int tenv, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexEnviv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexEnviv\" not available");
    }
        dispatch_glGetTexEnviv1(tenv, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexEnviv}(GLenum tenv, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexEnviv1(int tenv, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexEnviv}(GLenum tenv, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glGetTexEnviv(int tenv, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexEnviv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexEnviv\" not available");
    }
        dispatch_glGetTexEnviv1(tenv, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexEnvxv}(GLenum tenv, GLenum pname, GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexEnvxv(int tenv, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexEnvxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexEnvxv\" not available");
    }
        dispatch_glGetTexEnvxv1(tenv, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexEnvxv}(GLenum tenv, GLenum pname, GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexEnvxv1(int tenv, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexEnvxv}(GLenum tenv, GLenum pname, GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glGetTexEnvxv(int tenv, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexEnvxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexEnvxv\" not available");
    }
        dispatch_glGetTexEnvxv1(tenv, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGenfvOES}(GLenum coord, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>; <code>GL_OES_texture_cube_map</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTexGenfv(int coord, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexGenfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexGenfv\" not available");
    }
        dispatch_glGetTexGenfv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGenfvOES}(GLenum coord, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>; <code>GL_OES_texture_cube_map</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTexGenfv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexGenfvOES}(GLenum coord, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>; <code>GL_OES_texture_cube_map</code>   */
  public void glGetTexGenfv(int coord, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexGenfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexGenfv\" not available");
    }
        dispatch_glGetTexGenfv1(coord, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGenivOES}(GLenum coord, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>; <code>GL_OES_texture_cube_map</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexGeniv(int coord, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexGeniv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexGeniv\" not available");
    }
        dispatch_glGetTexGeniv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGenivOES}(GLenum coord, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>; <code>GL_OES_texture_cube_map</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexGeniv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexGenivOES}(GLenum coord, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>; <code>GL_OES_texture_cube_map</code>   */
  public void glGetTexGeniv(int coord, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexGeniv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexGeniv\" not available");
    }
        dispatch_glGetTexGeniv1(coord, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGenxvOES}(GLenum coord, GLenum pname, GLfixed *  params); </code> <br>Part of <code>GL_OES_texture_cube_map</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexGenxv(int coord, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexGenxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexGenxv\" not available");
    }
        dispatch_glGetTexGenxv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGenxvOES}(GLenum coord, GLenum pname, GLfixed *  params); </code> <br>Part of <code>GL_OES_texture_cube_map</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexGenxv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexGenxvOES}(GLenum coord, GLenum pname, GLfixed *  params); </code> <br>Part of <code>GL_OES_texture_cube_map</code>   */
  public void glGetTexGenxv(int coord, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexGenxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexGenxv\" not available");
    }
        dispatch_glGetTexGenxv1(coord, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTexParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexParameterfv\" not available");
    }
        dispatch_glGetTexParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTexParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glGetTexParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexParameterfv\" not available");
    }
        dispatch_glGetTexParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexParameteriv\" not available");
    }
        dispatch_glGetTexParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glGetTexParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexParameteriv\" not available");
    }
        dispatch_glGetTexParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterxv}(GLenum target, GLenum pname, GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexParameterxv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexParameterxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexParameterxv\" not available");
    }
        dispatch_glGetTexParameterxv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterxv}(GLenum target, GLenum pname, GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexParameterxv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameterxv}(GLenum target, GLenum pname, GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glGetTexParameterxv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexParameterxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexParameterxv\" not available");
    }
        dispatch_glGetTexParameterxv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformfvEXT}(GLuint program, GLint location, GLsizei bufSize, float *  params); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetnUniformfv(int program, int location, int bufSize, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnUniformfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnUniformfv\" not available");
    }
        dispatch_glGetnUniformfv1(program, location, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformfvEXT}(GLuint program, GLint location, GLsizei bufSize, float *  params); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetnUniformfv1(int program, int location, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformfvEXT}(GLuint program, GLint location, GLsizei bufSize, float *  params); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>   */
  public void glGetnUniformfv(int program, int location, int bufSize, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnUniformfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnUniformfv\" not available");
    }
        dispatch_glGetnUniformfv1(program, location, bufSize, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformivEXT}(GLuint program, GLint location, GLsizei bufSize, GLint *  params); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetnUniformiv(int program, int location, int bufSize, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnUniformiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnUniformiv\" not available");
    }
        dispatch_glGetnUniformiv1(program, location, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformivEXT}(GLuint program, GLint location, GLsizei bufSize, GLint *  params); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetnUniformiv1(int program, int location, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformivEXT}(GLuint program, GLint location, GLsizei bufSize, GLint *  params); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>   */
  public void glGetnUniformiv(int program, int location, int bufSize, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnUniformiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnUniformiv\" not available");
    }
        dispatch_glGetnUniformiv1(program, location, bufSize, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glHint}(GLenum target, GLenum mode); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glHint(int target, int mode)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glHint;
    if (__addr_ == 0) {
      throw new GLException("Method \"glHint\" not available");
    }
        dispatch_glHint1(target, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glHint}(GLenum target, GLenum mode); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glHint1(int target, int mode, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsBuffer}(GLuint buffer); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>   */
  public boolean glIsBuffer(int buffer)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsBuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsBuffer\" not available");
    }
        return dispatch_glIsBuffer1(buffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsBuffer}(GLuint buffer); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>   */
  public native boolean dispatch_glIsBuffer1(int buffer, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabled}(GLenum cap); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public boolean glIsEnabled(int cap)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsEnabled;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsEnabled\" not available");
    }
        return dispatch_glIsEnabled1(cap, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabled}(GLenum cap); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native boolean dispatch_glIsEnabled1(int cap, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsFenceNV}(GLuint renderbuffer); </code> <br>Part of <code>GL_NV_fence</code>   */
  public boolean glIsFenceNV(int renderbuffer)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsFenceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsFenceNV\" not available");
    }
        return dispatch_glIsFenceNV1(renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsFenceNV}(GLuint renderbuffer); </code> <br>Part of <code>GL_NV_fence</code>   */
  public native boolean dispatch_glIsFenceNV1(int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsFramebufferOES}(GLuint framebuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  public boolean glIsFramebuffer(int framebuffer)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsFramebuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsFramebuffer\" not available");
    }
        return dispatch_glIsFramebuffer1(framebuffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsFramebufferOES}(GLuint framebuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  public native boolean dispatch_glIsFramebuffer1(int framebuffer, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsRenderbufferOES}(GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  public boolean glIsRenderbuffer(int renderbuffer)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsRenderbuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsRenderbuffer\" not available");
    }
        return dispatch_glIsRenderbuffer1(renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsRenderbufferOES}(GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  public native boolean dispatch_glIsRenderbuffer1(int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsTexture}(GLuint texture); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  public boolean glIsTexture(int texture)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsTexture;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsTexture\" not available");
    }
        return dispatch_glIsTexture1(texture, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsTexture}(GLuint texture); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  public native boolean dispatch_glIsTexture1(int texture, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsVertexArrayOES}(GLuint array); </code> <br>Part of <code>GL_OES_vertex_array_object</code>   */
  public boolean glIsVertexArrayOES(int array)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsVertexArrayOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsVertexArrayOES\" not available");
    }
        return dispatch_glIsVertexArrayOES1(array, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsVertexArrayOES}(GLuint array); </code> <br>Part of <code>GL_OES_vertex_array_object</code>   */
  public native boolean dispatch_glIsVertexArrayOES1(int array, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightModelf}(GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glLightModelf(int pname, float param)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLightModelf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLightModelf\" not available");
    }
        dispatch_glLightModelf1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightModelf}(GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public native void dispatch_glLightModelf1(int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightModelfv}(GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glLightModelfv(int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLightModelfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLightModelfv\" not available");
    }
        dispatch_glLightModelfv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightModelfv}(GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glLightModelfv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightModelfv}(GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glLightModelfv(int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLightModelfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLightModelfv\" not available");
    }
        dispatch_glLightModelfv1(pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightModelx}(GLenum pname, GLfixed param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glLightModelx(int pname, int param)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLightModelx;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLightModelx\" not available");
    }
        dispatch_glLightModelx1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightModelx}(GLenum pname, GLfixed param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glLightModelx1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightModelxv}(GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glLightModelxv(int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLightModelxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLightModelxv\" not available");
    }
        dispatch_glLightModelxv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightModelxv}(GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glLightModelxv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightModelxv}(GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glLightModelxv(int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLightModelxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLightModelxv\" not available");
    }
        dispatch_glLightModelxv1(pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightf}(GLenum light, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glLightf(int light, int pname, float param)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLightf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLightf\" not available");
    }
        dispatch_glLightf1(light, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightf}(GLenum light, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public native void dispatch_glLightf1(int light, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightfv}(GLenum light, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glLightfv(int light, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLightfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLightfv\" not available");
    }
        dispatch_glLightfv1(light, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightfv}(GLenum light, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glLightfv1(int light, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightfv}(GLenum light, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glLightfv(int light, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLightfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLightfv\" not available");
    }
        dispatch_glLightfv1(light, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightx}(GLenum light, GLenum pname, GLfixed param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glLightx(int light, int pname, int param)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLightx;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLightx\" not available");
    }
        dispatch_glLightx1(light, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightx}(GLenum light, GLenum pname, GLfixed param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glLightx1(int light, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightxv}(GLenum light, GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glLightxv(int light, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLightxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLightxv\" not available");
    }
        dispatch_glLightxv1(light, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightxv}(GLenum light, GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glLightxv1(int light, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightxv}(GLenum light, GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glLightxv(int light, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLightxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLightxv\" not available");
    }
        dispatch_glLightxv1(light, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLineWidth}(GLfloat width); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glLineWidth(float width)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLineWidth;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLineWidth\" not available");
    }
        dispatch_glLineWidth1(width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLineWidth}(GLfloat width); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public native void dispatch_glLineWidth1(float width, long procAddress);

  /** Entry point to C language function: <code> void {@native glLineWidthx}(GLfixed width); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glLineWidthx(int width)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLineWidthx;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLineWidthx\" not available");
    }
        dispatch_glLineWidthx1(width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLineWidthx}(GLfixed width); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glLineWidthx1(int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadIdentity}(void); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glLoadIdentity()  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLoadIdentity;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLoadIdentity\" not available");
    }
        dispatch_glLoadIdentity1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadIdentity}(void); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glLoadIdentity1(long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadMatrixf}(const GLfloat *  m); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glLoadMatrixf(FloatBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLoadMatrixf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLoadMatrixf\" not available");
    }
        dispatch_glLoadMatrixf1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadMatrixf}(const GLfloat *  m); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glLoadMatrixf1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadMatrixf}(const GLfloat *  m); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glLoadMatrixf(float[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLoadMatrixf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLoadMatrixf\" not available");
    }
        dispatch_glLoadMatrixf1(m, Buffers.SIZEOF_FLOAT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadMatrixx}(const GLfixed *  m); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param m a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glLoadMatrixx(IntBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLoadMatrixx;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLoadMatrixx\" not available");
    }
        dispatch_glLoadMatrixx1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadMatrixx}(const GLfixed *  m); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param m a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glLoadMatrixx1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadMatrixx}(const GLfixed *  m); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glLoadMatrixx(int[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLoadMatrixx;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLoadMatrixx\" not available");
    }
        dispatch_glLoadMatrixx1(m, Buffers.SIZEOF_INT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadPaletteFromModelViewMatrixOES}(void); </code> <br>Part of <code>GL_OES_matrix_palette</code>   */
  public void glLoadPaletteFromModelViewMatrixOES()  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLoadPaletteFromModelViewMatrixOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLoadPaletteFromModelViewMatrixOES\" not available");
    }
        dispatch_glLoadPaletteFromModelViewMatrixOES1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadPaletteFromModelViewMatrixOES}(void); </code> <br>Part of <code>GL_OES_matrix_palette</code>   */
  public native void dispatch_glLoadPaletteFromModelViewMatrixOES1(long procAddress);

  /** Entry point to C language function: <code> void {@native glLogicOp}(GLenum opcode); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glLogicOp(int opcode)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLogicOp;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLogicOp\" not available");
    }
        dispatch_glLogicOp1(opcode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLogicOp}(GLenum opcode); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glLogicOp1(int opcode, long procAddress);

  /** Entry point to C language function: <code> void {@native glMaterialf}(GLenum face, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glMaterialf(int face, int pname, float param)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glMaterialf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMaterialf\" not available");
    }
        dispatch_glMaterialf1(face, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMaterialf}(GLenum face, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public native void dispatch_glMaterialf1(int face, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glMaterialfv}(GLenum face, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMaterialfv(int face, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glMaterialfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMaterialfv\" not available");
    }
        dispatch_glMaterialfv1(face, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMaterialfv}(GLenum face, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMaterialfv1(int face, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMaterialfv}(GLenum face, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glMaterialfv(int face, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glMaterialfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMaterialfv\" not available");
    }
        dispatch_glMaterialfv1(face, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMaterialx}(GLenum face, GLenum pname, GLfixed param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glMaterialx(int face, int pname, int param)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glMaterialx;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMaterialx\" not available");
    }
        dispatch_glMaterialx1(face, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMaterialx}(GLenum face, GLenum pname, GLfixed param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glMaterialx1(int face, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glMaterialxv}(GLenum face, GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMaterialxv(int face, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glMaterialxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMaterialxv\" not available");
    }
        dispatch_glMaterialxv1(face, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMaterialxv}(GLenum face, GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMaterialxv1(int face, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMaterialxv}(GLenum face, GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glMaterialxv(int face, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glMaterialxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMaterialxv\" not available");
    }
        dispatch_glMaterialxv1(face, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixIndexPointerOES}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_ARB_matrix_palette</code>; <code>GL_OES_matrix_palette</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glMatrixIndexPointer(int size, int type, int stride, Buffer pointer)  {

    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixIndexPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixIndexPointer\" not available");
    }
        dispatch_glMatrixIndexPointer1(size, type, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixIndexPointerOES}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_ARB_matrix_palette</code>; <code>GL_OES_matrix_palette</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMatrixIndexPointer1(int size, int type, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixMode}(GLenum mode); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glMatrixMode(int mode)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glMatrixMode;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMatrixMode\" not available");
    }
        dispatch_glMatrixMode1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixMode}(GLenum mode); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glMatrixMode1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultMatrixf}(const GLfloat *  m); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMultMatrixf(FloatBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultMatrixf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultMatrixf\" not available");
    }
        dispatch_glMultMatrixf1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultMatrixf}(const GLfloat *  m); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMultMatrixf1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultMatrixf}(const GLfloat *  m); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glMultMatrixf(float[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultMatrixf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultMatrixf\" not available");
    }
        dispatch_glMultMatrixf1(m, Buffers.SIZEOF_FLOAT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultMatrixx}(const GLfixed *  m); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param m a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultMatrixx(IntBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultMatrixx;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultMatrixx\" not available");
    }
        dispatch_glMultMatrixx1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultMatrixx}(const GLfixed *  m); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param m a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultMatrixx1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultMatrixx}(const GLfixed *  m); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glMultMatrixx(int[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultMatrixx;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultMatrixx\" not available");
    }
        dispatch_glMultMatrixx1(m, Buffers.SIZEOF_INT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4f}(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glMultiTexCoord4f(int target, float s, float t, float r, float q)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord4f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord4f\" not available");
    }
        dispatch_glMultiTexCoord4f1(target, s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4f}(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q); </code> <br>Part of <code>GL_VERSION_1_3_DEPRECATED</code>, <code>GL_VERSION_ES_CM</code>   */
  public native void dispatch_glMultiTexCoord4f1(int target, float s, float t, float r, float q, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4x}(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glMultiTexCoord4x(int target, int s, int t, int r, int q)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glMultiTexCoord4x;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMultiTexCoord4x\" not available");
    }
        dispatch_glMultiTexCoord4x1(target, s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4x}(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glMultiTexCoord4x1(int target, int s, int t, int r, int q, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3f}(GLfloat nx, GLfloat ny, GLfloat nz); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glNormal3f(float nx, float ny, float nz)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormal3f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormal3f\" not available");
    }
        dispatch_glNormal3f1(nx, ny, nz, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3f}(GLfloat nx, GLfloat ny, GLfloat nz); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public native void dispatch_glNormal3f1(float nx, float ny, float nz, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3x}(GLfixed nx, GLfixed ny, GLfixed nz); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glNormal3x(int nx, int ny, int nz)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormal3x;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormal3x\" not available");
    }
        dispatch_glNormal3x1(nx, ny, nz, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3x}(GLfixed nx, GLfixed ny, GLfixed nz); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glNormal3x1(int nx, int ny, int nz, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormalPointer}(GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glNormalPointer(int type, int stride, Buffer pointer)  {

    checkArrayVBODisabled(true);
    Buffers.rangeCheck(pointer, 1);
    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormalPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormalPointer\" not available");
    }
        dispatch_glNormalPointer1(type, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormalPointer}(GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glNormalPointer1(int type, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormalPointer}(GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  public void glNormalPointer(int type, int stride, long pointer_buffer_offset)  {

    checkArrayVBOEnabled(true);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glNormalPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glNormalPointer\" not available");
    }
        dispatch_glNormalPointer1(type, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormalPointer}(GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  private native void dispatch_glNormalPointer1(int type, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glOrthof}(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar); </code> <br>Part of <code>GL_VERSION_ES_CM</code>   */
  public void glOrthof(float left, float right, float bottom, float top, float zNear, float zFar)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glOrthof;
    if (__addr_ == 0) {
      throw new GLException("Method \"glOrthof\" not available");
    }
        dispatch_glOrthof1(left, right, bottom, top, zNear, zFar, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glOrthof}(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar); </code> <br>Part of <code>GL_VERSION_ES_CM</code>   */
  public native void dispatch_glOrthof1(float left, float right, float bottom, float top, float zNear, float zFar, long procAddress);

  /** Entry point to C language function: <code> void {@native glOrthox}(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glOrthox(int left, int right, int bottom, int top, int zNear, int zFar)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glOrthox;
    if (__addr_ == 0) {
      throw new GLException("Method \"glOrthox\" not available");
    }
        dispatch_glOrthox1(left, right, bottom, top, zNear, zFar, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glOrthox}(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glOrthox1(int left, int right, int bottom, int top, int zNear, int zFar, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelStorei}(GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glPixelStorei(int pname, int param)  {

    if (pname != GL_PACK_ALIGNMENT && pname != GL_UNPACK_ALIGNMENT) {
    throw new GLException("Unsupported pixel store parameter name 0x" + Integer.toHexString(pname));
    }
    glStateTracker.setInt(pname, param);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelStorei;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPixelStorei\" not available");
    }
        dispatch_glPixelStorei1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelStorei}(GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  private native void dispatch_glPixelStorei1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointParameterf}(GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glPointParameterf(int pname, float param)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPointParameterf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPointParameterf\" not available");
    }
        dispatch_glPointParameterf1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointParameterf}(GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_VERSION_ES_CM</code>   */
  public native void dispatch_glPointParameterf1(int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointParameterfv}(GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glPointParameterfv(int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPointParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPointParameterfv\" not available");
    }
        dispatch_glPointParameterfv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointParameterfv}(GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glPointParameterfv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointParameterfv}(GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glPointParameterfv(int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPointParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPointParameterfv\" not available");
    }
        dispatch_glPointParameterfv1(pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointParameterx}(GLenum pname, GLfixed param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glPointParameterx(int pname, int param)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPointParameterx;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPointParameterx\" not available");
    }
        dispatch_glPointParameterx1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointParameterx}(GLenum pname, GLfixed param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glPointParameterx1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointParameterxv}(GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glPointParameterxv(int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPointParameterxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPointParameterxv\" not available");
    }
        dispatch_glPointParameterxv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointParameterxv}(GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glPointParameterxv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointParameterxv}(GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glPointParameterxv(int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPointParameterxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPointParameterxv\" not available");
    }
        dispatch_glPointParameterxv1(pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointSize}(GLfloat size); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glPointSize(float size)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPointSize;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPointSize\" not available");
    }
        dispatch_glPointSize1(size, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointSize}(GLfloat size); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public native void dispatch_glPointSize1(float size, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointSizePointerOES}(GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_OES_point_size_array</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glPointSizePointerOES(int type, int stride, Buffer pointer)  {

    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPointSizePointerOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPointSizePointerOES\" not available");
    }
        dispatch_glPointSizePointerOES1(type, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointSizePointerOES}(GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_OES_point_size_array</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glPointSizePointerOES1(int type, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointSizex}(GLfixed size); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glPointSizex(int size)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPointSizex;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPointSizex\" not available");
    }
        dispatch_glPointSizex1(size, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointSizex}(GLfixed size); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glPointSizex1(int size, long procAddress);

  /** Entry point to C language function: <code> void {@native glPolygonOffset}(GLfloat factor, GLfloat units); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glPolygonOffset(float factor, float units)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPolygonOffset;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPolygonOffset\" not available");
    }
        dispatch_glPolygonOffset1(factor, units, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPolygonOffset}(GLfloat factor, GLfloat units); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public native void dispatch_glPolygonOffset1(float factor, float units, long procAddress);

  /** Entry point to C language function: <code> void {@native glPolygonOffsetx}(GLfixed factor, GLfixed units); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glPolygonOffsetx(int factor, int units)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPolygonOffsetx;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPolygonOffsetx\" not available");
    }
        dispatch_glPolygonOffsetx1(factor, units, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPolygonOffsetx}(GLfixed factor, GLfixed units); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glPolygonOffsetx1(int factor, int units, long procAddress);

  /** Entry point to C language function: <code> void {@native glPopMatrix}(void); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glPopMatrix()  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPopMatrix;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPopMatrix\" not available");
    }
        dispatch_glPopMatrix1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPopMatrix}(void); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glPopMatrix1(long procAddress);

  /** Entry point to C language function: <code> void {@native glPushMatrix}(void); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glPushMatrix()  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPushMatrix;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPushMatrix\" not available");
    }
        dispatch_glPushMatrix1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPushMatrix}(void); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glPushMatrix1(long procAddress);

  /** Entry point to C language function: <code> GLbitfield {@native glQueryMatrixxOES}(GLfixed *  mantissa, GLint *  exponent); </code> <br>Part of <code>GL_OES_query_matrix</code>
      @param mantissa a direct or array-backed {@link java.nio.IntBuffer}
      @param exponent a direct or array-backed {@link java.nio.IntBuffer}   */
  public int glQueryMatrixxOES(IntBuffer mantissa, IntBuffer exponent)  {

    final boolean mantissa_is_direct = Buffers.isDirect(mantissa);
    final boolean exponent_is_direct = Buffers.isDirect(exponent);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glQueryMatrixxOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glQueryMatrixxOES\" not available");
    }
        return dispatch_glQueryMatrixxOES1(mantissa_is_direct ? mantissa : Buffers.getArray(mantissa), mantissa_is_direct ? Buffers.getDirectBufferByteOffset(mantissa) : Buffers.getIndirectBufferByteOffset(mantissa), mantissa_is_direct, exponent_is_direct ? exponent : Buffers.getArray(exponent), exponent_is_direct ? Buffers.getDirectBufferByteOffset(exponent) : Buffers.getIndirectBufferByteOffset(exponent), exponent_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLbitfield {@native glQueryMatrixxOES}(GLfixed *  mantissa, GLint *  exponent); </code> <br>Part of <code>GL_OES_query_matrix</code>
      @param mantissa a direct or array-backed {@link java.nio.IntBuffer}
      @param exponent a direct or array-backed {@link java.nio.IntBuffer}   */
  private native int dispatch_glQueryMatrixxOES1(Object mantissa, int mantissa_byte_offset, boolean mantissa_is_direct, Object exponent, int exponent_byte_offset, boolean exponent_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLbitfield {@native glQueryMatrixxOES}(GLfixed *  mantissa, GLint *  exponent); </code> <br>Part of <code>GL_OES_query_matrix</code>   */
  public int glQueryMatrixxOES(int[] mantissa, int mantissa_offset, int[] exponent, int exponent_offset)  {

    if(mantissa != null && mantissa.length <= mantissa_offset)
      throw new GLException("array offset argument \"mantissa_offset\" (" + mantissa_offset + ") equals or exceeds array length (" + mantissa.length + ")");
    if(exponent != null && exponent.length <= exponent_offset)
      throw new GLException("array offset argument \"exponent_offset\" (" + exponent_offset + ") equals or exceeds array length (" + exponent.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glQueryMatrixxOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glQueryMatrixxOES\" not available");
    }
        return dispatch_glQueryMatrixxOES1(mantissa, Buffers.SIZEOF_INT * mantissa_offset, false, exponent, Buffers.SIZEOF_INT * exponent_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glReadPixels(int x, int y, int width, int height, int format, int type, Buffer pixels)  {

    checkPackPBODisabled(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width            , height            , 1    , true));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glReadPixels;
    if (__addr_ == 0) {
      throw new GLException("Method \"glReadPixels\" not available");
    }
        dispatch_glReadPixels1(x, y, width, height, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glReadPixels1(int x, int y, int width, int height, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glReadPixels(int x, int y, int width, int height, int format, int type, long pixels_buffer_offset)  {

    checkPackPBOEnabled(true);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glReadPixels;
    if (__addr_ == 0) {
      throw new GLException("Method \"glReadPixels\" not available");
    }
        dispatch_glReadPixels1(x, y, width, height, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  private native void dispatch_glReadPixels1(int x, int y, int width, int height, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glReadnPixelsEXT}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *  data); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glReadnPixels(int x, int y, int width, int height, int format, int type, int bufSize, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glReadnPixels;
    if (__addr_ == 0) {
      throw new GLException("Method \"glReadnPixels\" not available");
    }
        dispatch_glReadnPixels1(x, y, width, height, format, type, bufSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadnPixelsEXT}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *  data); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glReadnPixels1(int x, int y, int width, int height, int format, int type, int bufSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleAPPLE}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_APPLE_framebuffer_multisample</code>   */
  public void glRenderbufferStorageMultisampleAPPLE(int target, int samples, int internalformat, int width, int height)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glRenderbufferStorageMultisampleAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRenderbufferStorageMultisampleAPPLE\" not available");
    }
        dispatch_glRenderbufferStorageMultisampleAPPLE1(target, samples, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleAPPLE}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_APPLE_framebuffer_multisample</code>   */
  public native void dispatch_glRenderbufferStorageMultisampleAPPLE1(int target, int samples, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleIMG}(GLenum, GLsizei, GLenum, GLsizei, GLsizei); </code> <br>Part of <code>GL_IMG_multisampled_render_to_texture</code>   */
  public void glRenderbufferStorageMultisampleIMG(int arg0, int arg1, int arg2, int arg3, int arg4)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glRenderbufferStorageMultisampleIMG;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRenderbufferStorageMultisampleIMG\" not available");
    }
        dispatch_glRenderbufferStorageMultisampleIMG1(arg0, arg1, arg2, arg3, arg4, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleIMG}(GLenum, GLsizei, GLenum, GLsizei, GLsizei); </code> <br>Part of <code>GL_IMG_multisampled_render_to_texture</code>   */
  public native void dispatch_glRenderbufferStorageMultisampleIMG1(int arg0, int arg1, int arg2, int arg3, int arg4, long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageOES}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glRenderbufferStorage(int target, int internalformat, int width, int height)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glRenderbufferStorage;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRenderbufferStorage\" not available");
    }
        dispatch_glRenderbufferStorage1(target, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageOES}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_framebuffer_object</code>   */
  public native void dispatch_glRenderbufferStorage1(int target, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glResolveMultisampleFramebufferAPPLE}(void); </code> <br>Part of <code>GL_APPLE_framebuffer_multisample</code>   */
  public void glResolveMultisampleFramebufferAPPLE()  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glResolveMultisampleFramebufferAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glResolveMultisampleFramebufferAPPLE\" not available");
    }
        dispatch_glResolveMultisampleFramebufferAPPLE1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glResolveMultisampleFramebufferAPPLE}(void); </code> <br>Part of <code>GL_APPLE_framebuffer_multisample</code>   */
  public native void dispatch_glResolveMultisampleFramebufferAPPLE1(long procAddress);

  /** Entry point to C language function: <code> void {@native glRotatef}(GLfloat angle, GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glRotatef(float angle, float x, float y, float z)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glRotatef;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRotatef\" not available");
    }
        dispatch_glRotatef1(angle, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRotatef}(GLfloat angle, GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public native void dispatch_glRotatef1(float angle, float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glRotatex}(GLfixed angle, GLfixed x, GLfixed y, GLfixed z); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glRotatex(int angle, int x, int y, int z)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glRotatex;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRotatex\" not available");
    }
        dispatch_glRotatex1(angle, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRotatex}(GLfixed angle, GLfixed x, GLfixed y, GLfixed z); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glRotatex1(int angle, int x, int y, int z, long procAddress);

  /** Entry point to C language function: <code> void {@native glSampleCoverage}(GLclampf value, GLboolean invert); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>   */
  public void glSampleCoverage(float value, boolean invert)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glSampleCoverage;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSampleCoverage\" not available");
    }
        dispatch_glSampleCoverage1(value, invert, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSampleCoverage}(GLclampf value, GLboolean invert); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>   */
  public native void dispatch_glSampleCoverage1(float value, boolean invert, long procAddress);

  /** Entry point to C language function: <code> void {@native glSampleCoveragex}(GLclampx value, GLboolean invert); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glSampleCoveragex(int value, boolean invert)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glSampleCoveragex;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSampleCoveragex\" not available");
    }
        dispatch_glSampleCoveragex1(value, invert, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSampleCoveragex}(GLclampx value, GLboolean invert); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glSampleCoveragex1(int value, boolean invert, long procAddress);

  /** Entry point to C language function: <code> void {@native glScalef}(GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glScalef(float x, float y, float z)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glScalef;
    if (__addr_ == 0) {
      throw new GLException("Method \"glScalef\" not available");
    }
        dispatch_glScalef1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScalef}(GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public native void dispatch_glScalef1(float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glScalex}(GLfixed x, GLfixed y, GLfixed z); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glScalex(int x, int y, int z)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glScalex;
    if (__addr_ == 0) {
      throw new GLException("Method \"glScalex\" not available");
    }
        dispatch_glScalex1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScalex}(GLfixed x, GLfixed y, GLfixed z); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glScalex1(int x, int y, int z, long procAddress);

  /** Entry point to C language function: <code> void {@native glScissor}(GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glScissor(int x, int y, int width, int height)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glScissor;
    if (__addr_ == 0) {
      throw new GLException("Method \"glScissor\" not available");
    }
        dispatch_glScissor1(x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScissor}(GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glScissor1(int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glSetFenceNV}(GLuint modeRGB, GLenum modeAlpha); </code> <br>Part of <code>GL_NV_fence</code>   */
  public void glSetFenceNV(int modeRGB, int modeAlpha)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glSetFenceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSetFenceNV\" not available");
    }
        dispatch_glSetFenceNV1(modeRGB, modeAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSetFenceNV}(GLuint modeRGB, GLenum modeAlpha); </code> <br>Part of <code>GL_NV_fence</code>   */
  public native void dispatch_glSetFenceNV1(int modeRGB, int modeAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glShadeModel}(GLenum mode); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glShadeModel(int mode)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glShadeModel;
    if (__addr_ == 0) {
      throw new GLException("Method \"glShadeModel\" not available");
    }
        dispatch_glShadeModel1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShadeModel}(GLenum mode); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glShadeModel1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glStartTilingQCOM}(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask); </code> <br>Part of <code>GL_QCOM_tiled_rendering</code>   */
  public void glStartTilingQCOM(int x, int y, int width, int height, int preserveMask)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glStartTilingQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glStartTilingQCOM\" not available");
    }
        dispatch_glStartTilingQCOM1(x, y, width, height, preserveMask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStartTilingQCOM}(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask); </code> <br>Part of <code>GL_QCOM_tiled_rendering</code>   */
  public native void dispatch_glStartTilingQCOM1(int x, int y, int width, int height, int preserveMask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilFunc}(GLenum func, GLint ref, GLuint mask); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glStencilFunc(int func, int ref, int mask)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glStencilFunc;
    if (__addr_ == 0) {
      throw new GLException("Method \"glStencilFunc\" not available");
    }
        dispatch_glStencilFunc1(func, ref, mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilFunc}(GLenum func, GLint ref, GLuint mask); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glStencilFunc1(int func, int ref, int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilMask}(GLuint mask); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glStencilMask(int mask)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glStencilMask;
    if (__addr_ == 0) {
      throw new GLException("Method \"glStencilMask\" not available");
    }
        dispatch_glStencilMask1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilMask}(GLuint mask); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glStencilMask1(int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilOp}(GLenum fail, GLenum zfail, GLenum zpass); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glStencilOp(int fail, int zfail, int zpass)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glStencilOp;
    if (__addr_ == 0) {
      throw new GLException("Method \"glStencilOp\" not available");
    }
        dispatch_glStencilOp1(fail, zfail, zpass, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilOp}(GLenum fail, GLenum zfail, GLenum zpass); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glStencilOp1(int fail, int zfail, int zpass, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glTestFenceNV}(GLuint renderbuffer); </code> <br>Part of <code>GL_NV_fence</code>   */
  public boolean glTestFenceNV(int renderbuffer)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTestFenceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTestFenceNV\" not available");
    }
        return dispatch_glTestFenceNV1(renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glTestFenceNV}(GLuint renderbuffer); </code> <br>Part of <code>GL_NV_fence</code>   */
  public native boolean dispatch_glTestFenceNV1(int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexCoordPointer(int size, int type, int stride, Buffer pointer)  {

    checkArrayVBODisabled(true);
    Buffers.rangeCheck(pointer, 1);
    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoordPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoordPointer\" not available");
    }
        dispatch_glTexCoordPointer1(size, type, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexCoordPointer1(int size, int type, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  public void glTexCoordPointer(int size, int type, int stride, long pointer_buffer_offset)  {

    checkArrayVBOEnabled(true);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexCoordPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexCoordPointer\" not available");
    }
        dispatch_glTexCoordPointer1(size, type, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  private native void dispatch_glTexCoordPointer1(int size, int type, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnvf}(GLenum target, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glTexEnvf(int target, int pname, float param)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexEnvf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexEnvf\" not available");
    }
        dispatch_glTexEnvf1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnvf}(GLenum target, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public native void dispatch_glTexEnvf1(int target, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnvfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTexEnvfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexEnvfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexEnvfv\" not available");
    }
        dispatch_glTexEnvfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnvfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTexEnvfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnvfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glTexEnvfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexEnvfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexEnvfv\" not available");
    }
        dispatch_glTexEnvfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnvi}(GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glTexEnvi(int target, int pname, int param)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexEnvi;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexEnvi\" not available");
    }
        dispatch_glTexEnvi1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnvi}(GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexEnvi1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnviv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexEnviv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexEnviv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexEnviv\" not available");
    }
        dispatch_glTexEnviv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnviv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexEnviv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnviv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glTexEnviv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexEnviv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexEnviv\" not available");
    }
        dispatch_glTexEnviv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnvx}(GLenum target, GLenum pname, GLfixed param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glTexEnvx(int target, int pname, int param)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexEnvx;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexEnvx\" not available");
    }
        dispatch_glTexEnvx1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnvx}(GLenum target, GLenum pname, GLfixed param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glTexEnvx1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnvxv}(GLenum target, GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexEnvxv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexEnvxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexEnvxv\" not available");
    }
        dispatch_glTexEnvxv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnvxv}(GLenum target, GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexEnvxv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnvxv}(GLenum target, GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glTexEnvxv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexEnvxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexEnvxv\" not available");
    }
        dispatch_glTexEnvxv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGenfOES}(GLenum coord, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>; <code>GL_OES_texture_cube_map</code>   */
  public void glTexGenf(int coord, int pname, float param)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexGenf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexGenf\" not available");
    }
        dispatch_glTexGenf1(coord, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGenfOES}(GLenum coord, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>; <code>GL_OES_texture_cube_map</code>   */
  public native void dispatch_glTexGenf1(int coord, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGenfvOES}(GLenum coord, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>; <code>GL_OES_texture_cube_map</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTexGenfv(int coord, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexGenfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexGenfv\" not available");
    }
        dispatch_glTexGenfv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGenfvOES}(GLenum coord, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>; <code>GL_OES_texture_cube_map</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTexGenfv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGenfvOES}(GLenum coord, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>; <code>GL_OES_texture_cube_map</code>   */
  public void glTexGenfv(int coord, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexGenfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexGenfv\" not available");
    }
        dispatch_glTexGenfv1(coord, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGeniOES}(GLenum coord, GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>; <code>GL_OES_texture_cube_map</code>   */
  public void glTexGeni(int coord, int pname, int param)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexGeni;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexGeni\" not available");
    }
        dispatch_glTexGeni1(coord, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGeniOES}(GLenum coord, GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>; <code>GL_OES_texture_cube_map</code>   */
  public native void dispatch_glTexGeni1(int coord, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGenivOES}(GLenum coord, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>; <code>GL_OES_texture_cube_map</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexGeniv(int coord, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexGeniv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexGeniv\" not available");
    }
        dispatch_glTexGeniv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGenivOES}(GLenum coord, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>; <code>GL_OES_texture_cube_map</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexGeniv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGenivOES}(GLenum coord, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>; <code>GL_OES_texture_cube_map</code>   */
  public void glTexGeniv(int coord, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexGeniv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexGeniv\" not available");
    }
        dispatch_glTexGeniv1(coord, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGenxOES}(GLenum coord, GLenum pname, GLfixed param); </code> <br>Part of <code>GL_OES_texture_cube_map</code>   */
  public void glTexGenx(int coord, int pname, int param)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexGenx;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexGenx\" not available");
    }
        dispatch_glTexGenx1(coord, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGenxOES}(GLenum coord, GLenum pname, GLfixed param); </code> <br>Part of <code>GL_OES_texture_cube_map</code>   */
  public native void dispatch_glTexGenx1(int coord, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGenxvOES}(GLenum coord, GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_OES_texture_cube_map</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexGenxv(int coord, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexGenxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexGenxv\" not available");
    }
        dispatch_glTexGenxv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGenxvOES}(GLenum coord, GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_OES_texture_cube_map</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexGenxv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGenxvOES}(GLenum coord, GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_OES_texture_cube_map</code>   */
  public void glTexGenxv(int coord, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexGenxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexGenxv\" not available");
    }
        dispatch_glTexGenxv1(coord, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexImage2D(int target, int level, int internalformat, int width, int height, int border, int format, int type, Buffer pixels)  {

    checkUnpackPBODisabled(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width            , height            , 1    , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexImage2D\" not available");
    }
        dispatch_glTexImage2D1(target, level, internalformat, width, height, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glTexImage2D(int target, int level, int internalformat, int width, int height, int border, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexImage2D\" not available");
    }
        dispatch_glTexImage2D1(target, level, internalformat, width, height, border, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  private native void dispatch_glTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterf}(GLenum target, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glTexParameterf(int target, int pname, float param)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameterf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameterf\" not available");
    }
        dispatch_glTexParameterf1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterf}(GLenum target, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public native void dispatch_glTexParameterf1(int target, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTexParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameterfv\" not available");
    }
        dispatch_glTexParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTexParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glTexParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameterfv\" not available");
    }
        dispatch_glTexParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameteri}(GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glTexParameteri(int target, int pname, int param)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameteri;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameteri\" not available");
    }
        dispatch_glTexParameteri1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameteri}(GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glTexParameteri1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameteriv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameteriv\" not available");
    }
        dispatch_glTexParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameteriv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameteriv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glTexParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameteriv\" not available");
    }
        dispatch_glTexParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterx}(GLenum target, GLenum pname, GLfixed param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glTexParameterx(int target, int pname, int param)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameterx;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameterx\" not available");
    }
        dispatch_glTexParameterx1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterx}(GLenum target, GLenum pname, GLfixed param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glTexParameterx1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterxv}(GLenum target, GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexParameterxv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameterxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameterxv\" not available");
    }
        dispatch_glTexParameterxv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterxv}(GLenum target, GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexParameterxv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterxv}(GLenum target, GLenum pname, const GLfixed *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glTexParameterxv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameterxv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameterxv\" not available");
    }
        dispatch_glTexParameterxv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage1DEXT}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width); </code> <br>Part of <code>GL_ARB_texture_storage</code>; <code>GL_EXT_texture_storage</code>   */
  public void glTexStorage1D(int target, int levels, int internalformat, int width)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexStorage1D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexStorage1D\" not available");
    }
        dispatch_glTexStorage1D1(target, levels, internalformat, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage1DEXT}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width); </code> <br>Part of <code>GL_ARB_texture_storage</code>; <code>GL_EXT_texture_storage</code>   */
  public native void dispatch_glTexStorage1D1(int target, int levels, int internalformat, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexStorage2DEXT}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ARB_texture_storage</code>; <code>GL_EXT_texture_storage</code>   */
  public void glTexStorage2D(int target, int levels, int internalformat, int width, int height)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexStorage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexStorage2D\" not available");
    }
        dispatch_glTexStorage2D1(target, levels, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage2DEXT}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ARB_texture_storage</code>; <code>GL_EXT_texture_storage</code>   */
  public native void dispatch_glTexStorage2D1(int target, int levels, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexStorage3DEXT}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); </code> <br>Part of <code>GL_ARB_texture_storage</code>; <code>GL_EXT_texture_storage</code>   */
  public void glTexStorage3D(int target, int levels, int internalformat, int width, int height, int depth)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexStorage3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexStorage3D\" not available");
    }
        dispatch_glTexStorage3D1(target, levels, internalformat, width, height, depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage3DEXT}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); </code> <br>Part of <code>GL_ARB_texture_storage</code>; <code>GL_EXT_texture_storage</code>   */
  public native void dispatch_glTexStorage3D1(int target, int levels, int internalformat, int width, int height, int depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Buffer pixels)  {

    checkUnpackPBODisabled(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width            , height            , 1    , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexSubImage2D\" not available");
    }
        dispatch_glTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  public void glTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexSubImage2D\" not available");
    }
        dispatch_glTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  private native void dispatch_glTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage1DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width); </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>   */
  public void glTextureStorage1DEXT(int texture, int target, int levels, int internalformat, int width)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureStorage1DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureStorage1DEXT\" not available");
    }
        dispatch_glTextureStorage1DEXT1(texture, target, levels, internalformat, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage1DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width); </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>   */
  public native void dispatch_glTextureStorage1DEXT1(int texture, int target, int levels, int internalformat, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage2DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>   */
  public void glTextureStorage2DEXT(int texture, int target, int levels, int internalformat, int width, int height)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureStorage2DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureStorage2DEXT\" not available");
    }
        dispatch_glTextureStorage2DEXT1(texture, target, levels, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage2DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>   */
  public native void dispatch_glTextureStorage2DEXT1(int texture, int target, int levels, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage3DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>   */
  public void glTextureStorage3DEXT(int texture, int target, int levels, int internalformat, int width, int height, int depth)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureStorage3DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureStorage3DEXT\" not available");
    }
        dispatch_glTextureStorage3DEXT1(texture, target, levels, internalformat, width, height, depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage3DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>   */
  public native void dispatch_glTextureStorage3DEXT1(int texture, int target, int levels, int internalformat, int width, int height, int depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glTranslatef}(GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glTranslatef(float x, float y, float z)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTranslatef;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTranslatef\" not available");
    }
        dispatch_glTranslatef1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTranslatef}(GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public native void dispatch_glTranslatef1(float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glTranslatex}(GLfixed x, GLfixed y, GLfixed z); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public void glTranslatex(int x, int y, int z)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTranslatex;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTranslatex\" not available");
    }
        dispatch_glTranslatex1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTranslatex}(GLfixed x, GLfixed y, GLfixed z); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>   */
  public native void dispatch_glTranslatex1(int x, int y, int z, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glUnmapBufferOES}(GLenum target); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_OES_mapbuffer</code>   */
  public boolean glUnmapBuffer(int target)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUnmapBuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUnmapBuffer\" not available");
    }
        return dispatch_glUnmapBuffer1(target, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glUnmapBufferOES}(GLenum target); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_OES_mapbuffer</code>   */
  public native boolean dispatch_glUnmapBuffer1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glVertexPointer(int size, int type, int stride, Buffer pointer)  {

    checkArrayVBODisabled(true);
    Buffers.rangeCheck(pointer, 1);
    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexPointer\" not available");
    }
        dispatch_glVertexPointer1(size, type, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glVertexPointer1(int size, int type, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  public void glVertexPointer(int size, int type, int stride, long pointer_buffer_offset)  {

    checkArrayVBOEnabled(true);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexPointer\" not available");
    }
        dispatch_glVertexPointer1(size, type, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_ES_CL_CM</code>   */
  private native void dispatch_glVertexPointer1(int size, int type, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glViewport}(GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public void glViewport(int x, int y, int width, int height)  {

    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glViewport;
    if (__addr_ == 0) {
      throw new GLException("Method \"glViewport\" not available");
    }
        dispatch_glViewport1(x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glViewport}(GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>   */
  public native void dispatch_glViewport1(int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glWeightPointerOES}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_ARB_vertex_blend</code>; <code>GL_OES_matrix_palette</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glWeightPointer(int size, int type, int stride, Buffer pointer)  {

    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glWeightPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glWeightPointer\" not available");
    }
        dispatch_glWeightPointer1(size, type, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightPointerOES}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_ARB_vertex_blend</code>; <code>GL_OES_matrix_palette</code>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glWeightPointer1(int size, int type, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
 private static final int params_offset = 0; // just a helper for JavaPrologue ..
  public void glOrtho(double left, double right, double bottom, double top, double near_val, double far_val) {
    glOrthof((float) left, (float) right, (float) bottom, (float) top, (float) near_val, (float) far_val); }
  public void glFrustum(double left, double right, double bottom, double top, double zNear, double zFar) {
    glFrustumf((float) left, (float) right, (float) bottom, (float) top, (float) zNear, (float) zFar); }
  public void glClearDepth(double depth) {
   glClearDepthf((float)depth); }
  public void glDepthRange(double zNear, double zFar) {
   glDepthRangef((float)zNear, (float)zFar); }
      @Override
      public GLProfile getGLProfile() {
          return this.glProfile;
      }
      private final GLProfile glProfile;
  
      @Override
      public final int glGetBoundBuffer(int target) {
          return bufferStateTracker.getBoundBufferObject(target, this);
      }
  
      @Override
      public final long glGetBufferSize(int buffer) {
          return bufferSizeTracker.getDirectStateBufferSize(buffer, this);
      }
  
      @Override
      public final boolean glIsVBOArrayEnabled() {
          return checkArrayVBOEnabled(false);
      }
  
      @Override
      public final boolean glIsVBOElementArrayEnabled() {
          return checkElementVBOEnabled(false);
      }
  
      @Override
      public final boolean isGL() {
          return true;
      }
        
      @Override
      public final GL getGL() throws GLException {
          return this;
      }
  
      @Override
      public final boolean isFunctionAvailable(String glFunctionName) {
        return _context.isFunctionAvailable(glFunctionName);
      }
  
      @Override
      public final boolean isExtensionAvailable(String glExtensionName) {
        return _context.isExtensionAvailable(glExtensionName);
      }
  
      @Override
      public final Object getExtension(String extensionName) {
        // At this point we don't expose any extensions using this mechanism
        return null;
      }
  
      @Override
      public final GLContext getContext() {
        return _context;
      }
  
      private final GLContextImpl _context;
  
      /**
       * @see javax.media.opengl.GLContext#setSwapInterval(int)
       */
      @Override
      public final void setSwapInterval(int interval) {
        _context.setSwapInterval(interval);
      }
  
      /**
       * @see javax.media.opengl.GLContext#getSwapInterval()
       */
      @Override
      public final int getSwapInterval() {
        return _context.getSwapInterval();
      }
  
      @Override
      public final Object getPlatformGLExtensions() {
        return _context.getPlatformGLExtensions();
      }
  
      @Override
      public final int getBoundFramebuffer(int target) {
        return _context.getBoundFramebuffer(target);
      }
  
      @Override
      public final int getDefaultDrawFramebuffer() {
        return _context.getDefaultDrawFramebuffer();
      }
  
      @Override
      public final int getDefaultReadFramebuffer() {
        return _context.getDefaultReadFramebuffer();
      }
  
  public GLES1Impl(GLProfile glp, GLContextImpl context) {
    this._context = context; 
    if(null != context) {
        this.bufferSizeTracker  = context.getBufferSizeTracker();
        this.bufferStateTracker = context.getBufferStateTracker();
        this.glStateTracker     = context.getGLStateTracker();
    } else {
        this.bufferSizeTracker  = null;
        this.bufferStateTracker = null;
        this.glStateTracker     = null;
    }
    this.glProfile = glp;
  }
  
  @Override
  public final boolean isGL4bc() {
      return false;
  }
  
  @Override
  public final boolean isGL4() {
      return false;
  }
  
  @Override
  public final boolean isGL3bc() {
      return false;
  }
  
  @Override
  public final boolean isGL3() {
      return false;
  }
  
  @Override
  public final boolean isGL2() {
      return false;
  }
  
  @Override
  public final boolean isGLES1() {
      return true;
  }
  
  @Override
  public final boolean isGLES2() {
      return false;
  }
  
  @Override
  public final boolean isGLES() {
      return true;
  }
  
  @Override
  public final boolean isGL2ES1() {
      return true;
  }
  
  @Override
  public final boolean isGL2ES2() {
      return false;
  }
  
  @Override
  public final boolean isGLES2Compatible() {
      return false;
  }
  
  @Override
  public final boolean isGL2GL3() {
      return false;
  }
  
  @Override
  public final boolean hasGLSL() {
      return false;
  }
  
  @Override
  public boolean isNPOTTextureAvailable() {
    return false;
  }
  
  @Override
  public final GL4bc getGL4bc() throws GLException {
      throw new GLException("Not a GL4bc implementation");
  }
  
  @Override
  public final GL4 getGL4() throws GLException {
      throw new GLException("Not a GL4 implementation");
  }
  
  @Override
  public final GL3bc getGL3bc() throws GLException {
      throw new GLException("Not a GL3bc implementation");
  }
  
  @Override
  public final GL3 getGL3() throws GLException {
      throw new GLException("Not a GL3 implementation");
  }
  
  @Override
  public final GL2 getGL2() throws GLException {
      throw new GLException("Not a GL2 implementation");
  }
  
  @Override
  public final GLES1 getGLES1() throws GLException {
      return this;
  }
  
  @Override
  public final GLES2 getGLES2() throws GLException {
      throw new GLException("Not a GLES2 implementation");
  }
  
  @Override
  public final GL2ES1 getGL2ES1() throws GLException {
      return this;
  }
  
  @Override
  public final GL2ES2 getGL2ES2() throws GLException {
      throw new GLException("Not a GL2ES2 implementation");
  }
  
  @Override
  public final GL2GL3 getGL2GL3() throws GLException {
      throw new GLException("Not a GL2GL3 implementation");
  }
  
  //
  // Helpers for ensuring the correct amount of texture data
  //
  
  private final GLBufferSizeTracker  bufferSizeTracker;
  private final GLBufferStateTracker bufferStateTracker;
  private final GLStateTracker       glStateTracker;
  
  private boolean bufferObjectExtensionsInitialized = false;
  private boolean haveOESFramebufferObject;
  
  private final void initBufferObjectExtensionChecks() {
    if (bufferObjectExtensionsInitialized)
      return;
    bufferObjectExtensionsInitialized = true;
    haveOESFramebufferObject  = isExtensionAvailable("GL_OES_framebuffer_object");
  }
  
  private final boolean checkBufferObject(boolean avail,
                                          boolean enabled,
                                          int state,
                                          String kind, boolean throwException) {
    if (!avail) {
      if (!enabled)
        return true;
      if(throwException) {
          throw new GLException("Required extensions not available to call this function");
      }
      return false;
    }
    int buffer = bufferStateTracker.getBoundBufferObject(state, this);
    if (enabled) {
      if (buffer == 0) {
        if(throwException) {
            throw new GLException(kind + " must be enabled to call this method");
        }
        return false;
      }
    } else {
      if (buffer != 0) {
        if(throwException) {
            throw new GLException(kind + " must be disabled to call this method");
        }
        return false;
      }
    }
    return true;
  }  
  
  private final boolean checkArrayVBODisabled(boolean throwException) { 
    initBufferObjectExtensionChecks();
    return checkBufferObject(true,
                      false,
                      GL.GL_ARRAY_BUFFER,
                      "array vertex_buffer_object", throwException);
  }
  
  private final boolean checkArrayVBOEnabled(boolean throwException) { 
    initBufferObjectExtensionChecks();
    return checkBufferObject(true,
                      true,
                      GL.GL_ARRAY_BUFFER,
                      "array vertex_buffer_object", throwException);
  }
  
  private final boolean checkElementVBODisabled(boolean throwException) { 
    initBufferObjectExtensionChecks();
    return checkBufferObject(true,
                      false,
                      GL.GL_ELEMENT_ARRAY_BUFFER,
                      "element vertex_buffer_object", throwException);
  }
  
  private final boolean checkElementVBOEnabled(boolean throwException) { 
    initBufferObjectExtensionChecks();
    return checkBufferObject(true,
                      true,
                      GL.GL_ELEMENT_ARRAY_BUFFER,
                      "element vertex_buffer_object", throwException);
  }
  
  private final boolean checkUnpackPBODisabled(boolean throwException) { 
      // PBO n/a for ES 1.1 or ES 2.0
      return true;
  }
  
  private final boolean checkUnpackPBOEnabled(boolean throwException) { 
      // PBO n/a for ES 1.1 or ES 2.0
      return false;
  }
  
  private final boolean checkPackPBODisabled(boolean throwException) { 
      // PBO n/a for ES 1.1 or ES 2.0
      return true;
  }
  
  private final boolean checkPackPBOEnabled(boolean throwException) { 
      // PBO n/a for ES 1.1 or ES 2.0
      return false;
  }
  
  private final HashMap<MemoryObject, MemoryObject> arbMemCache = new HashMap<MemoryObject, MemoryObject>();
  
  /** Entry point to C language function: <br> <code> LPVOID glMapBuffer(GLenum target, GLenum access); </code>    */
  public final java.nio.ByteBuffer glMapBuffer(int target, int access) {
    final long __addr_ = ((GLES1ProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapBuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMapBuffer\" not available");
    }
    final long sz = bufferSizeTracker.getBufferSize(bufferStateTracker, target, this);
    if (0 == sz) {
      return null;
    }
    final long addr = dispatch_glMapBuffer(target, access, __addr_);
    if (0 == addr) {
      return null;
    }
    ByteBuffer buffer;
    MemoryObject memObj0 = new MemoryObject(addr, sz); // object and key
    MemoryObject memObj1 = MemoryObject.getOrAddSafe(arbMemCache, memObj0);
    if(memObj0 == memObj1) {
      // just added ..
      if(null != memObj0.getBuffer()) {
          throw new InternalError();
      }
      buffer = newDirectByteBuffer(addr, sz);
      Buffers.nativeOrder(buffer);
      memObj0.setBuffer(buffer);
    } else {
      // already mapped
      buffer = memObj1.getBuffer();
      if(null == buffer) {
          throw new InternalError();
      }
    }
    buffer.position(0);
    return buffer;
  }
  
  /** Encapsulates function pointer for OpenGL function <br>: <code> LPVOID glMapBuffer(GLenum target, GLenum access); </code>    */
  native private long dispatch_glMapBuffer(int target, int access, long glProcAddress);
  
  native private ByteBuffer newDirectByteBuffer(long addr, long capacity);
  
  @Override
  public final void glVertexPointer(GLArrayData array) {
    if(array.getComponentCount()==0) return;
    if(array.isVBO()) {
        glVertexPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getVBOOffset());
    } else {
        glVertexPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getBuffer());
    }
  }
  @Override
  public final void glColorPointer(GLArrayData array) {
    if(array.getComponentCount()==0) return;
    if(array.isVBO()) {
        glColorPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getVBOOffset());
    } else {
        glColorPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getBuffer());
    }
  
  }
  @Override
  public final void glNormalPointer(GLArrayData array) {
    if(array.getComponentCount()==0) return;
    if(array.getComponentCount()!=3) {
      throw new GLException("Only 3 components per normal allowed");
    }
    if(array.isVBO()) {
        glNormalPointer(array.getComponentType(), array.getStride(), array.getVBOOffset());
    } else {
        glNormalPointer(array.getComponentType(), array.getStride(), array.getBuffer());
    }
  }
  @Override
  public final void glTexCoordPointer(GLArrayData array) {
    if(array.getComponentCount()==0) return;
    if(array.isVBO()) {
        glTexCoordPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getVBOOffset());
    } else {
        glTexCoordPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getBuffer());
    }
  }
  
  
      private int[] imageSizeTemp = new int[1];
  
      private final int imageSizeInBytes(int format, int type, int width, int height, int depth, boolean pack) {
          return GLBuffers.sizeof(this, imageSizeTemp, format, type, width, height, depth, pack) ;                                    
      }
  
  // ---- End CustomJavaCode .cfg declarations

} // end of class GLES1Impl
