/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Fri Aug 03 06:28:27 CEST 2012 ----! */

package jogamp.opengl.es2;

import java.util.*;
import javax.media.opengl.*;
import javax.media.opengl.fixedfunc.*;
import jogamp.opengl.*;
import javax.media.opengl.GLES1;
import javax.media.opengl.GLES2;
import javax.media.opengl.GL2;
import javax.media.opengl.GLArrayData;
import javax.media.opengl.GLUniformData;
import com.jogamp.common.nio.Buffers;
import com.jogamp.opengl.util.GLBuffers;
import java.io.PrintStream;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class GLES2Impl implements GLBase, GL, GL2ES2, GLES2{
  /** Entry point to C language function: <code> void {@native glActiveTexture}(GLenum texture); </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glActiveTexture(int texture)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glActiveTexture;
    if (__addr_ == 0) {
      throw new GLException("Method \"glActiveTexture\" not available");
    }
        dispatch_glActiveTexture1(texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glActiveTexture}(GLenum texture); </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glActiveTexture1(int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glAlphaFuncQCOM}(GLenum func, GLclampf ref); </code> <br>Part of <code>GL_QCOM_alpha_test</code>   */
  public void glAlphaFuncQCOM(int func, float ref)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glAlphaFuncQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glAlphaFuncQCOM\" not available");
    }
        dispatch_glAlphaFuncQCOM1(func, ref, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glAlphaFuncQCOM}(GLenum func, GLclampf ref); </code> <br>Part of <code>GL_QCOM_alpha_test</code>   */
  public native void dispatch_glAlphaFuncQCOM1(int func, float ref, long procAddress);

  /** Entry point to C language function: <code> void {@native glAttachShader}(GLuint program, GLuint shader); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glAttachShader(int program, int shader)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glAttachShader;
    if (__addr_ == 0) {
      throw new GLException("Method \"glAttachShader\" not available");
    }
        dispatch_glAttachShader1(program, shader, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glAttachShader}(GLuint program, GLuint shader); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glAttachShader1(int program, int shader, long procAddress);

  /** Entry point to C language function: <code> void {@native glBeginPerfMonitorAMD}(GLuint monitor); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glBeginPerfMonitorAMD(int monitor)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBeginPerfMonitorAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBeginPerfMonitorAMD\" not available");
    }
        dispatch_glBeginPerfMonitorAMD1(monitor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginPerfMonitorAMD}(GLuint monitor); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public native void dispatch_glBeginPerfMonitorAMD1(int monitor, long procAddress);

  /** Entry point to C language function: <code> void {@native glBeginQueryEXT}(GLenum target, GLuint id); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>   */
  public void glBeginQuery(int target, int id)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBeginQuery;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBeginQuery\" not available");
    }
        dispatch_glBeginQuery1(target, id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginQueryEXT}(GLenum target, GLuint id); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>   */
  public native void dispatch_glBeginQuery1(int target, int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindAttribLocation}(GLuint program, GLuint index, const GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glBindAttribLocation(int program, int index, String name)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindAttribLocation;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindAttribLocation\" not available");
    }
        dispatch_glBindAttribLocation1(program, index, name, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindAttribLocation}(GLuint program, GLuint index, const GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glBindAttribLocation1(int program, int index, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindBuffer}(GLenum target, GLuint buffer); </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glBindBuffer(int target, int buffer)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindBuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindBuffer\" not available");
    }
        dispatch_glBindBuffer1(target, buffer, __addr_);
    bufferStateTracker.setBoundBufferObject(target, buffer);
  }

  /** Entry point to C language function: <code> void {@native glBindBuffer}(GLenum target, GLuint buffer); </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glBindBuffer1(int target, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindFramebuffer}(GLenum target, GLuint framebuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glBindFramebuffer(int target, int framebuffer)  {

    if( 0 == framebuffer ) {
    if( GL_FRAMEBUFFER == target || 0x8CA9 /* GL_DRAW_FRAMEBUFFER */ == target ) {
    framebuffer = _context.getDefaultDrawFramebuffer();
    } else if( 0x8CA8 /* GL_READ_FRAMEBUFFER */ == target ) {
    framebuffer = _context.getDefaultReadFramebuffer();
    }
    }
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindFramebuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindFramebuffer\" not available");
    }
        dispatch_glBindFramebuffer1(target, framebuffer, __addr_);
    _context.setBoundFramebuffer(target, framebuffer);
  }

  /** Entry point to C language function: <code> void {@native glBindFramebuffer}(GLenum target, GLuint framebuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glBindFramebuffer1(int target, int framebuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindRenderbuffer}(GLenum target, GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glBindRenderbuffer(int target, int renderbuffer)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindRenderbuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindRenderbuffer\" not available");
    }
        dispatch_glBindRenderbuffer1(target, renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindRenderbuffer}(GLenum target, GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glBindRenderbuffer1(int target, int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindTexture}(GLenum target, GLuint texture); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glBindTexture(int target, int texture)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindTexture;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindTexture\" not available");
    }
        dispatch_glBindTexture1(target, texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindTexture}(GLenum target, GLuint texture); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glBindTexture1(int target, int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindVertexArrayOES}(GLuint array); </code> <br>Part of <code>GL_OES_vertex_array_object</code>   */
  public void glBindVertexArrayOES(int array)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindVertexArrayOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBindVertexArrayOES\" not available");
    }
        dispatch_glBindVertexArrayOES1(array, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindVertexArrayOES}(GLuint array); </code> <br>Part of <code>GL_OES_vertex_array_object</code>   */
  public native void dispatch_glBindVertexArrayOES1(int array, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendColor}(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha); </code> <br>Part of <code>GL_VERSION_1_2</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glBlendColor(float red, float green, float blue, float alpha)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendColor;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlendColor\" not available");
    }
        dispatch_glBlendColor1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendColor}(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha); </code> <br>Part of <code>GL_VERSION_1_2</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glBlendColor1(float red, float green, float blue, float alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquation}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_2</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glBlendEquation(int mode)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendEquation;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlendEquation\" not available");
    }
        dispatch_glBlendEquation1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquation}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_2</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glBlendEquation1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparate}(GLenum modeRGB, GLenum modeAlpha); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glBlendEquationSeparate(int modeRGB, int modeAlpha)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendEquationSeparate;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlendEquationSeparate\" not available");
    }
        dispatch_glBlendEquationSeparate1(modeRGB, modeAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparate}(GLenum modeRGB, GLenum modeAlpha); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glBlendEquationSeparate1(int modeRGB, int modeAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFunc}(GLenum sfactor, GLenum dfactor); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glBlendFunc(int sfactor, int dfactor)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendFunc;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlendFunc\" not available");
    }
        dispatch_glBlendFunc1(sfactor, dfactor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFunc}(GLenum sfactor, GLenum dfactor); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glBlendFunc1(int sfactor, int dfactor, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparate}(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha); </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glBlendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendFuncSeparate;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlendFuncSeparate\" not available");
    }
        dispatch_glBlendFuncSeparate1(srcRGB, dstRGB, srcAlpha, dstAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparate}(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha); </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glBlendFuncSeparate1(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlitFramebufferANGLE}(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); </code> <br>Part of <code>GL_ANGLE_framebuffer_blit</code>   */
  public void glBlitFramebufferANGLE(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlitFramebufferANGLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBlitFramebufferANGLE\" not available");
    }
        dispatch_glBlitFramebufferANGLE1(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlitFramebufferANGLE}(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); </code> <br>Part of <code>GL_ANGLE_framebuffer_blit</code>   */
  public native void dispatch_glBlitFramebufferANGLE1(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter, long procAddress);

  /** Entry point to C language function: <code> void {@native glBufferData}(GLenum target, GLsizeiptr size, const GLvoid *  data, GLenum usage); </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glBufferData(int target, long size, Buffer data, int usage)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBufferData;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBufferData\" not available");
    }
        dispatch_glBufferData1(target, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, usage, __addr_);
    bufferSizeTracker.setBufferSize(bufferStateTracker, target, this, size);
  }

  /** Entry point to C language function: <code> void {@native glBufferData}(GLenum target, GLsizeiptr size, const GLvoid *  data, GLenum usage); </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glBufferData1(int target, long size, Object data, int data_byte_offset, boolean data_is_direct, int usage, long procAddress);

  /** Entry point to C language function: <code> void {@native glBufferSubData}(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glBufferSubData(int target, long offset, long size, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBufferSubData;
    if (__addr_ == 0) {
      throw new GLException("Method \"glBufferSubData\" not available");
    }
        dispatch_glBufferSubData1(target, offset, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBufferSubData}(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glBufferSubData1(int target, long offset, long size, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLenum {@native glCheckFramebufferStatus}(GLenum target); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  public int glCheckFramebufferStatus(int target)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCheckFramebufferStatus;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCheckFramebufferStatus\" not available");
    }
        return dispatch_glCheckFramebufferStatus1(target, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glCheckFramebufferStatus}(GLenum target); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native int dispatch_glCheckFramebufferStatus1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glClear}(GLbitfield mask); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glClear(int mask)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClear;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClear\" not available");
    }
        dispatch_glClear1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClear}(GLbitfield mask); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glClear1(int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearColor}(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glClearColor(float red, float green, float blue, float alpha)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearColor;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClearColor\" not available");
    }
        dispatch_glClearColor1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearColor}(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glClearColor1(float red, float green, float blue, float alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearDepthf}(GLclampf depth); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glClearDepthf(float depth)  {

    if ( !_context.isGLES2Compatible() ) {
    glClearDepth( (double)depth );
    return;
    }
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearDepthf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClearDepthf\" not available");
    }
        dispatch_glClearDepthf1(depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearDepthf}(GLclampf depth); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glClearDepthf1(float depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearStencil}(GLint s); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glClearStencil(int s)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearStencil;
    if (__addr_ == 0) {
      throw new GLException("Method \"glClearStencil\" not available");
    }
        dispatch_glClearStencil1(s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearStencil}(GLint s); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glClearStencil1(int s, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorMask}(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glColorMask(boolean red, boolean green, boolean blue, boolean alpha)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorMask;
    if (__addr_ == 0) {
      throw new GLException("Method \"glColorMask\" not available");
    }
        dispatch_glColorMask1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorMask}(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glColorMask1(boolean red, boolean green, boolean blue, boolean alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompileShader}(GLuint shader); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glCompileShader(int shader)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompileShader;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompileShader\" not available");
    }
        dispatch_glCompileShader1(shader, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompileShader}(GLuint shader); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glCompileShader1(int shader, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, Buffer data)  {

    checkUnpackPBODisabled(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexImage2D\" not available");
    }
        dispatch_glCompressedTexImage2D1(target, level, internalformat, width, height, border, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexImage2D\" not available");
    }
        dispatch_glCompressedTexImage2D1(target, level, internalformat, width, height, border, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glCompressedTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage3DOES}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>; <code>GL_OES_texture_3D</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, Buffer data)  {

    checkUnpackPBODisabled(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexImage3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexImage3D\" not available");
    }
        dispatch_glCompressedTexImage3D1(target, level, internalformat, width, height, depth, border, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage3DOES}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>; <code>GL_OES_texture_3D</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexImage3D1(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage3DOES}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>; <code>GL_OES_texture_3D</code>   */
  public void glCompressedTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexImage3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexImage3D\" not available");
    }
        dispatch_glCompressedTexImage3D1(target, level, internalformat, width, height, depth, border, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage3DOES}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>; <code>GL_OES_texture_3D</code>   */
  private native void dispatch_glCompressedTexImage3D1(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Buffer data)  {

    checkUnpackPBODisabled(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexSubImage2D\" not available");
    }
        dispatch_glCompressedTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glCompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexSubImage2D\" not available");
    }
        dispatch_glCompressedTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glCompressedTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage3DOES}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>; <code>GL_OES_texture_3D</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, Buffer data)  {

    checkUnpackPBODisabled(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexSubImage3D\" not available");
    }
        dispatch_glCompressedTexSubImage3D1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage3DOES}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>; <code>GL_OES_texture_3D</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage3DOES}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>; <code>GL_OES_texture_3D</code>   */
  public void glCompressedTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCompressedTexSubImage3D\" not available");
    }
        dispatch_glCompressedTexSubImage3D1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage3DOES}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_1_3</code>; <code>GL_OES_texture_3D</code>   */
  private native void dispatch_glCompressedTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glCopyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyTexImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyTexImage2D\" not available");
    }
        dispatch_glCopyTexImage2D1(target, level, internalformat, x, y, width, height, border, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glCopyTexImage2D1(int target, int level, int internalformat, int x, int y, int width, int height, int border, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glCopyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyTexSubImage2D\" not available");
    }
        dispatch_glCopyTexSubImage2D1(target, level, xoffset, yoffset, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glCopyTexSubImage2D1(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage3DOES}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_1_2</code>; <code>GL_OES_texture_3D</code>   */
  public void glCopyTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCopyTexSubImage3D\" not available");
    }
        dispatch_glCopyTexSubImage3D1(target, level, xoffset, yoffset, zoffset, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage3DOES}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_1_2</code>; <code>GL_OES_texture_3D</code>   */
  public native void dispatch_glCopyTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glCoverageMaskNV}(GLboolean mask); </code> <br>Part of <code>GL_NV_coverage_sample</code>   */
  public void glCoverageMaskNV(boolean mask)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCoverageMaskNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCoverageMaskNV\" not available");
    }
        dispatch_glCoverageMaskNV1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCoverageMaskNV}(GLboolean mask); </code> <br>Part of <code>GL_NV_coverage_sample</code>   */
  public native void dispatch_glCoverageMaskNV1(boolean mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glCoverageOperationNV}(GLenum operation); </code> <br>Part of <code>GL_NV_coverage_sample</code>   */
  public void glCoverageOperationNV(int operation)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCoverageOperationNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCoverageOperationNV\" not available");
    }
        dispatch_glCoverageOperationNV1(operation, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCoverageOperationNV}(GLenum operation); </code> <br>Part of <code>GL_NV_coverage_sample</code>   */
  public native void dispatch_glCoverageOperationNV1(int operation, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glCreateProgram}(void); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public int glCreateProgram()  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCreateProgram;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCreateProgram\" not available");
    }
        return dispatch_glCreateProgram1(__addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glCreateProgram}(void); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native int dispatch_glCreateProgram1(long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glCreateShader}(GLenum type); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public int glCreateShader(int type)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCreateShader;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCreateShader\" not available");
    }
        return dispatch_glCreateShader1(type, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glCreateShader}(GLenum type); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native int dispatch_glCreateShader1(int type, long procAddress);

  /** Entry point to C language function: <code> void {@native glCullFace}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glCullFace(int mode)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCullFace;
    if (__addr_ == 0) {
      throw new GLException("Method \"glCullFace\" not available");
    }
        dispatch_glCullFace1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCullFace}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glCullFace1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteBuffers}(GLsizei n, const GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteBuffers(int n, IntBuffer buffers)  {

    Buffers.rangeCheck(buffers, n);
    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteBuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteBuffers\" not available");
    }
        dispatch_glDeleteBuffers1(n, buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteBuffers}(GLsizei n, const GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteBuffers1(int n, Object buffers, int buffers_byte_offset, boolean buffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteBuffers}(GLsizei n, const GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glDeleteBuffers(int n, int[] buffers, int buffers_offset)  {

    Buffers.rangeCheck(buffers, buffers_offset, n);
    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteBuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteBuffers\" not available");
    }
        dispatch_glDeleteBuffers1(n, buffers, Buffers.SIZEOF_INT * buffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteFencesNV}(GLsizei n, const GLuint *  arrays); </code> <br>Part of <code>GL_NV_fence</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteFencesNV(int n, IntBuffer arrays)  {

    Buffers.rangeCheck(arrays, n);
    final boolean arrays_is_direct = Buffers.isDirect(arrays);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteFencesNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteFencesNV\" not available");
    }
        dispatch_glDeleteFencesNV1(n, arrays_is_direct ? arrays : Buffers.getArray(arrays), arrays_is_direct ? Buffers.getDirectBufferByteOffset(arrays) : Buffers.getIndirectBufferByteOffset(arrays), arrays_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteFencesNV}(GLsizei n, const GLuint *  arrays); </code> <br>Part of <code>GL_NV_fence</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteFencesNV1(int n, Object arrays, int arrays_byte_offset, boolean arrays_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteFencesNV}(GLsizei n, const GLuint *  arrays); </code> <br>Part of <code>GL_NV_fence</code>   */
  public void glDeleteFencesNV(int n, int[] arrays, int arrays_offset)  {

    Buffers.rangeCheck(arrays, arrays_offset, n);
    if(arrays != null && arrays.length <= arrays_offset)
      throw new GLException("array offset argument \"arrays_offset\" (" + arrays_offset + ") equals or exceeds array length (" + arrays.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteFencesNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteFencesNV\" not available");
    }
        dispatch_glDeleteFencesNV1(n, arrays, Buffers.SIZEOF_INT * arrays_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteFramebuffers}(GLsizei n, const GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteFramebuffers(int n, IntBuffer framebuffers)  {

    final boolean framebuffers_is_direct = Buffers.isDirect(framebuffers);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteFramebuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteFramebuffers\" not available");
    }
        dispatch_glDeleteFramebuffers1(n, framebuffers_is_direct ? framebuffers : Buffers.getArray(framebuffers), framebuffers_is_direct ? Buffers.getDirectBufferByteOffset(framebuffers) : Buffers.getIndirectBufferByteOffset(framebuffers), framebuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteFramebuffers}(GLsizei n, const GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteFramebuffers1(int n, Object framebuffers, int framebuffers_byte_offset, boolean framebuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteFramebuffers}(GLsizei n, const GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glDeleteFramebuffers(int n, int[] framebuffers, int framebuffers_offset)  {

    if(framebuffers != null && framebuffers.length <= framebuffers_offset)
      throw new GLException("array offset argument \"framebuffers_offset\" (" + framebuffers_offset + ") equals or exceeds array length (" + framebuffers.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteFramebuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteFramebuffers\" not available");
    }
        dispatch_glDeleteFramebuffers1(n, framebuffers, Buffers.SIZEOF_INT * framebuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeletePerfMonitorsAMD}(GLsizei n, GLuint *  monitors); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param monitors a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeletePerfMonitorsAMD(int n, IntBuffer monitors)  {

    final boolean monitors_is_direct = Buffers.isDirect(monitors);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeletePerfMonitorsAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeletePerfMonitorsAMD\" not available");
    }
        dispatch_glDeletePerfMonitorsAMD1(n, monitors_is_direct ? monitors : Buffers.getArray(monitors), monitors_is_direct ? Buffers.getDirectBufferByteOffset(monitors) : Buffers.getIndirectBufferByteOffset(monitors), monitors_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeletePerfMonitorsAMD}(GLsizei n, GLuint *  monitors); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param monitors a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeletePerfMonitorsAMD1(int n, Object monitors, int monitors_byte_offset, boolean monitors_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeletePerfMonitorsAMD}(GLsizei n, GLuint *  monitors); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glDeletePerfMonitorsAMD(int n, int[] monitors, int monitors_offset)  {

    if(monitors != null && monitors.length <= monitors_offset)
      throw new GLException("array offset argument \"monitors_offset\" (" + monitors_offset + ") equals or exceeds array length (" + monitors.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeletePerfMonitorsAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeletePerfMonitorsAMD\" not available");
    }
        dispatch_glDeletePerfMonitorsAMD1(n, monitors, Buffers.SIZEOF_INT * monitors_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteProgram}(GLuint program); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glDeleteProgram(int program)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteProgram;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteProgram\" not available");
    }
        dispatch_glDeleteProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteProgram}(GLuint program); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glDeleteProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteQueriesEXT}(GLsizei n, const GLuint *  ids); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteQueries(int n, IntBuffer ids)  {

    Buffers.rangeCheck(ids, n);
    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteQueries;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteQueries\" not available");
    }
        dispatch_glDeleteQueries1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteQueriesEXT}(GLsizei n, const GLuint *  ids); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteQueries1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteQueriesEXT}(GLsizei n, const GLuint *  ids); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>   */
  public void glDeleteQueries(int n, int[] ids, int ids_offset)  {

    Buffers.rangeCheck(ids, ids_offset, n);
    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteQueries;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteQueries\" not available");
    }
        dispatch_glDeleteQueries1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteRenderbuffers}(GLsizei n, const GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteRenderbuffers(int n, IntBuffer renderbuffers)  {

    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteRenderbuffers\" not available");
    }
        dispatch_glDeleteRenderbuffers1(n, renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteRenderbuffers}(GLsizei n, const GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteRenderbuffers1(int n, Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteRenderbuffers}(GLsizei n, const GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glDeleteRenderbuffers(int n, int[] renderbuffers, int renderbuffers_offset)  {

    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteRenderbuffers\" not available");
    }
        dispatch_glDeleteRenderbuffers1(n, renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteShader}(GLuint shader); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glDeleteShader(int shader)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteShader;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteShader\" not available");
    }
        dispatch_glDeleteShader1(shader, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteShader}(GLuint shader); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glDeleteShader1(int shader, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteTextures}(GLsizei n, const GLuint *  textures); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteTextures(int n, IntBuffer textures)  {

    Buffers.rangeCheck(textures, n);
    final boolean textures_is_direct = Buffers.isDirect(textures);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteTextures;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteTextures\" not available");
    }
        dispatch_glDeleteTextures1(n, textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteTextures}(GLsizei n, const GLuint *  textures); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteTextures1(int n, Object textures, int textures_byte_offset, boolean textures_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteTextures}(GLsizei n, const GLuint *  textures); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glDeleteTextures(int n, int[] textures, int textures_offset)  {

    Buffers.rangeCheck(textures, textures_offset, n);
    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteTextures;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteTextures\" not available");
    }
        dispatch_glDeleteTextures1(n, textures, Buffers.SIZEOF_INT * textures_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteVertexArraysOES}(GLsizei n, const GLuint *  arrays); </code> <br>Part of <code>GL_OES_vertex_array_object</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteVertexArraysOES(int n, IntBuffer arrays)  {

    final boolean arrays_is_direct = Buffers.isDirect(arrays);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteVertexArraysOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteVertexArraysOES\" not available");
    }
        dispatch_glDeleteVertexArraysOES1(n, arrays_is_direct ? arrays : Buffers.getArray(arrays), arrays_is_direct ? Buffers.getDirectBufferByteOffset(arrays) : Buffers.getIndirectBufferByteOffset(arrays), arrays_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteVertexArraysOES}(GLsizei n, const GLuint *  arrays); </code> <br>Part of <code>GL_OES_vertex_array_object</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteVertexArraysOES1(int n, Object arrays, int arrays_byte_offset, boolean arrays_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteVertexArraysOES}(GLsizei n, const GLuint *  arrays); </code> <br>Part of <code>GL_OES_vertex_array_object</code>   */
  public void glDeleteVertexArraysOES(int n, int[] arrays, int arrays_offset)  {

    if(arrays != null && arrays.length <= arrays_offset)
      throw new GLException("array offset argument \"arrays_offset\" (" + arrays_offset + ") equals or exceeds array length (" + arrays.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteVertexArraysOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDeleteVertexArraysOES\" not available");
    }
        dispatch_glDeleteVertexArraysOES1(n, arrays, Buffers.SIZEOF_INT * arrays_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthFunc}(GLenum func); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glDepthFunc(int func)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDepthFunc;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDepthFunc\" not available");
    }
        dispatch_glDepthFunc1(func, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthFunc}(GLenum func); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glDepthFunc1(int func, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthMask}(GLboolean flag); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glDepthMask(boolean flag)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDepthMask;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDepthMask\" not available");
    }
        dispatch_glDepthMask1(flag, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthMask}(GLboolean flag); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glDepthMask1(boolean flag, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthRangef}(GLclampf zNear, GLclampf zFar); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glDepthRangef(float zNear, float zFar)  {

    if ( !_context.isGLES2Compatible() ) {
    glDepthRange( (double)zNear, (double)zFar );
    return;
    }
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDepthRangef;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDepthRangef\" not available");
    }
        dispatch_glDepthRangef1(zNear, zFar, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthRangef}(GLclampf zNear, GLclampf zFar); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glDepthRangef1(float zNear, float zFar, long procAddress);

  /** Entry point to C language function: <code> void {@native glDetachShader}(GLuint program, GLuint shader); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glDetachShader(int program, int shader)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDetachShader;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDetachShader\" not available");
    }
        dispatch_glDetachShader1(program, shader, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDetachShader}(GLuint program, GLuint shader); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glDetachShader1(int program, int shader, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisable}(GLenum cap); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glDisable(int cap)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDisable;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDisable\" not available");
    }
        dispatch_glDisable1(cap, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisable}(GLenum cap); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glDisable1(int cap, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableDriverControlQCOM}(GLuint driverControl); </code> <br>Part of <code>GL_QCOM_driver_control</code>   */
  public void glDisableDriverControlQCOM(int driverControl)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDisableDriverControlQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDisableDriverControlQCOM\" not available");
    }
        dispatch_glDisableDriverControlQCOM1(driverControl, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableDriverControlQCOM}(GLuint driverControl); </code> <br>Part of <code>GL_QCOM_driver_control</code>   */
  public native void dispatch_glDisableDriverControlQCOM1(int driverControl, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableVertexAttribArray}(GLuint index); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glDisableVertexAttribArray(int index)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDisableVertexAttribArray;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDisableVertexAttribArray\" not available");
    }
        dispatch_glDisableVertexAttribArray1(index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableVertexAttribArray}(GLuint index); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glDisableVertexAttribArray1(int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glDiscardFramebufferEXT}(GLenum target, GLsizei numAttachments, const GLenum *  attachments); </code> <br>Part of <code>GL_EXT_discard_framebuffer</code>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDiscardFramebufferEXT(int target, int numAttachments, IntBuffer attachments)  {

    final boolean attachments_is_direct = Buffers.isDirect(attachments);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDiscardFramebufferEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDiscardFramebufferEXT\" not available");
    }
        dispatch_glDiscardFramebufferEXT1(target, numAttachments, attachments_is_direct ? attachments : Buffers.getArray(attachments), attachments_is_direct ? Buffers.getDirectBufferByteOffset(attachments) : Buffers.getIndirectBufferByteOffset(attachments), attachments_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDiscardFramebufferEXT}(GLenum target, GLsizei numAttachments, const GLenum *  attachments); </code> <br>Part of <code>GL_EXT_discard_framebuffer</code>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDiscardFramebufferEXT1(int target, int numAttachments, Object attachments, int attachments_byte_offset, boolean attachments_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDiscardFramebufferEXT}(GLenum target, GLsizei numAttachments, const GLenum *  attachments); </code> <br>Part of <code>GL_EXT_discard_framebuffer</code>   */
  public void glDiscardFramebufferEXT(int target, int numAttachments, int[] attachments, int attachments_offset)  {

    if(attachments != null && attachments.length <= attachments_offset)
      throw new GLException("array offset argument \"attachments_offset\" (" + attachments_offset + ") equals or exceeds array length (" + attachments.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDiscardFramebufferEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDiscardFramebufferEXT\" not available");
    }
        dispatch_glDiscardFramebufferEXT1(target, numAttachments, attachments, Buffers.SIZEOF_INT * attachments_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArrays}(GLenum mode, GLint first, GLsizei count); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glDrawArrays(int mode, int first, int count)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawArrays;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawArrays\" not available");
    }
        dispatch_glDrawArrays1(mode, first, count, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArrays}(GLenum mode, GLint first, GLsizei count); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glDrawArrays1(int mode, int first, int count, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawBuffersNV}(GLsizei n, const GLenum *  bufs); </code> <br>Part of <code>GL_VERSION_2_0</code>; <code>GL_NV_draw_buffers</code>
      @param bufs a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDrawBuffers(int n, IntBuffer bufs)  {

    final boolean bufs_is_direct = Buffers.isDirect(bufs);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawBuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawBuffers\" not available");
    }
        dispatch_glDrawBuffers1(n, bufs_is_direct ? bufs : Buffers.getArray(bufs), bufs_is_direct ? Buffers.getDirectBufferByteOffset(bufs) : Buffers.getIndirectBufferByteOffset(bufs), bufs_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawBuffersNV}(GLsizei n, const GLenum *  bufs); </code> <br>Part of <code>GL_VERSION_2_0</code>; <code>GL_NV_draw_buffers</code>
      @param bufs a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDrawBuffers1(int n, Object bufs, int bufs_byte_offset, boolean bufs_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawBuffersNV}(GLsizei n, const GLenum *  bufs); </code> <br>Part of <code>GL_VERSION_2_0</code>; <code>GL_NV_draw_buffers</code>   */
  public void glDrawBuffers(int n, int[] bufs, int bufs_offset)  {

    if(bufs != null && bufs.length <= bufs_offset)
      throw new GLException("array offset argument \"bufs_offset\" (" + bufs_offset + ") equals or exceeds array length (" + bufs.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawBuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawBuffers\" not available");
    }
        dispatch_glDrawBuffers1(n, bufs, Buffers.SIZEOF_INT * bufs_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElements(int mode, int count, int type, Buffer indices)  {

    checkElementVBODisabled(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawElements;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawElements\" not available");
    }
        dispatch_glDrawElements1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElements1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glDrawElements(int mode, int count, int type, long indices_buffer_offset)  {

    checkElementVBOEnabled(true);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawElements;
    if (__addr_ == 0) {
      throw new GLException("Method \"glDrawElements\" not available");
    }
        dispatch_glDrawElements1(mode, count, type, indices_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glDrawElements1(int mode, int count, int type, long indices_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glEGLImageTargetRenderbufferStorageOES}(GLenum target, GLeglImageOES image); </code> <br>Part of <code>GL_OES_EGL_image</code>   */
  public void glEGLImageTargetRenderbufferStorageOES(int target, long image)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glEGLImageTargetRenderbufferStorageOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEGLImageTargetRenderbufferStorageOES\" not available");
    }
        dispatch_glEGLImageTargetRenderbufferStorageOES1(target, image, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEGLImageTargetRenderbufferStorageOES}(GLenum target, GLeglImageOES image); </code> <br>Part of <code>GL_OES_EGL_image</code>   */
  public native void dispatch_glEGLImageTargetRenderbufferStorageOES1(int target, long image, long procAddress);

  /** Entry point to C language function: <code> void {@native glEGLImageTargetTexture2DOES}(GLenum target, GLeglImageOES image); </code> <br>Part of <code>GL_OES_EGL_image</code>   */
  public void glEGLImageTargetTexture2DOES(int target, long image)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glEGLImageTargetTexture2DOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEGLImageTargetTexture2DOES\" not available");
    }
        dispatch_glEGLImageTargetTexture2DOES1(target, image, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEGLImageTargetTexture2DOES}(GLenum target, GLeglImageOES image); </code> <br>Part of <code>GL_OES_EGL_image</code>   */
  public native void dispatch_glEGLImageTargetTexture2DOES1(int target, long image, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnable}(GLenum cap); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glEnable(int cap)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glEnable;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEnable\" not available");
    }
        dispatch_glEnable1(cap, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnable}(GLenum cap); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glEnable1(int cap, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableDriverControlQCOM}(GLuint driverControl); </code> <br>Part of <code>GL_QCOM_driver_control</code>   */
  public void glEnableDriverControlQCOM(int driverControl)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glEnableDriverControlQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEnableDriverControlQCOM\" not available");
    }
        dispatch_glEnableDriverControlQCOM1(driverControl, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableDriverControlQCOM}(GLuint driverControl); </code> <br>Part of <code>GL_QCOM_driver_control</code>   */
  public native void dispatch_glEnableDriverControlQCOM1(int driverControl, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableVertexAttribArray}(GLuint index); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glEnableVertexAttribArray(int index)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glEnableVertexAttribArray;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEnableVertexAttribArray\" not available");
    }
        dispatch_glEnableVertexAttribArray1(index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableVertexAttribArray}(GLuint index); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glEnableVertexAttribArray1(int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndPerfMonitorAMD}(GLuint monitor); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glEndPerfMonitorAMD(int monitor)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glEndPerfMonitorAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEndPerfMonitorAMD\" not available");
    }
        dispatch_glEndPerfMonitorAMD1(monitor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndPerfMonitorAMD}(GLuint monitor); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public native void dispatch_glEndPerfMonitorAMD1(int monitor, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndQueryEXT}(GLenum target); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>   */
  public void glEndQuery(int target)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glEndQuery;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEndQuery\" not available");
    }
        dispatch_glEndQuery1(target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndQueryEXT}(GLenum target); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>   */
  public native void dispatch_glEndQuery1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndTilingQCOM}(GLbitfield preserveMask); </code> <br>Part of <code>GL_QCOM_tiled_rendering</code>   */
  public void glEndTilingQCOM(int preserveMask)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glEndTilingQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glEndTilingQCOM\" not available");
    }
        dispatch_glEndTilingQCOM1(preserveMask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndTilingQCOM}(GLbitfield preserveMask); </code> <br>Part of <code>GL_QCOM_tiled_rendering</code>   */
  public native void dispatch_glEndTilingQCOM1(int preserveMask, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetBufferPointervQCOM}(GLenum target, GLvoid *  *  params); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param params a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glExtGetBufferPointervQCOM(int target, PointerBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetBufferPointervQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetBufferPointervQCOM\" not available");
    }
        dispatch_glExtGetBufferPointervQCOM1(target, params_is_direct ? ( params != null ? params.getBuffer() : null ) : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetBufferPointervQCOM}(GLenum target, GLvoid *  *  params); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param params a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private native void dispatch_glExtGetBufferPointervQCOM1(int target, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetBuffersQCOM}(GLuint *  buffers, GLint maxBuffers, GLint *  numBuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numBuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetBuffersQCOM(IntBuffer buffers, int maxBuffers, IntBuffer numBuffers)  {

    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final boolean numBuffers_is_direct = Buffers.isDirect(numBuffers);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetBuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetBuffersQCOM\" not available");
    }
        dispatch_glExtGetBuffersQCOM1(buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, maxBuffers, numBuffers_is_direct ? numBuffers : Buffers.getArray(numBuffers), numBuffers_is_direct ? Buffers.getDirectBufferByteOffset(numBuffers) : Buffers.getIndirectBufferByteOffset(numBuffers), numBuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetBuffersQCOM}(GLuint *  buffers, GLint maxBuffers, GLint *  numBuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numBuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetBuffersQCOM1(Object buffers, int buffers_byte_offset, boolean buffers_is_direct, int maxBuffers, Object numBuffers, int numBuffers_byte_offset, boolean numBuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetBuffersQCOM}(GLuint *  buffers, GLint maxBuffers, GLint *  numBuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>   */
  public void glExtGetBuffersQCOM(int[] buffers, int buffers_offset, int maxBuffers, int[] numBuffers, int numBuffers_offset)  {

    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    if(numBuffers != null && numBuffers.length <= numBuffers_offset)
      throw new GLException("array offset argument \"numBuffers_offset\" (" + numBuffers_offset + ") equals or exceeds array length (" + numBuffers.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetBuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetBuffersQCOM\" not available");
    }
        dispatch_glExtGetBuffersQCOM1(buffers, Buffers.SIZEOF_INT * buffers_offset, false, maxBuffers, numBuffers, Buffers.SIZEOF_INT * numBuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetFramebuffersQCOM}(GLuint *  framebuffers, GLint maxFramebuffers, GLint *  numFramebuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numFramebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetFramebuffersQCOM(IntBuffer framebuffers, int maxFramebuffers, IntBuffer numFramebuffers)  {

    final boolean framebuffers_is_direct = Buffers.isDirect(framebuffers);
    final boolean numFramebuffers_is_direct = Buffers.isDirect(numFramebuffers);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetFramebuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetFramebuffersQCOM\" not available");
    }
        dispatch_glExtGetFramebuffersQCOM1(framebuffers_is_direct ? framebuffers : Buffers.getArray(framebuffers), framebuffers_is_direct ? Buffers.getDirectBufferByteOffset(framebuffers) : Buffers.getIndirectBufferByteOffset(framebuffers), framebuffers_is_direct, maxFramebuffers, numFramebuffers_is_direct ? numFramebuffers : Buffers.getArray(numFramebuffers), numFramebuffers_is_direct ? Buffers.getDirectBufferByteOffset(numFramebuffers) : Buffers.getIndirectBufferByteOffset(numFramebuffers), numFramebuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetFramebuffersQCOM}(GLuint *  framebuffers, GLint maxFramebuffers, GLint *  numFramebuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numFramebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetFramebuffersQCOM1(Object framebuffers, int framebuffers_byte_offset, boolean framebuffers_is_direct, int maxFramebuffers, Object numFramebuffers, int numFramebuffers_byte_offset, boolean numFramebuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetFramebuffersQCOM}(GLuint *  framebuffers, GLint maxFramebuffers, GLint *  numFramebuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>   */
  public void glExtGetFramebuffersQCOM(int[] framebuffers, int framebuffers_offset, int maxFramebuffers, int[] numFramebuffers, int numFramebuffers_offset)  {

    if(framebuffers != null && framebuffers.length <= framebuffers_offset)
      throw new GLException("array offset argument \"framebuffers_offset\" (" + framebuffers_offset + ") equals or exceeds array length (" + framebuffers.length + ")");
    if(numFramebuffers != null && numFramebuffers.length <= numFramebuffers_offset)
      throw new GLException("array offset argument \"numFramebuffers_offset\" (" + numFramebuffers_offset + ") equals or exceeds array length (" + numFramebuffers.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetFramebuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetFramebuffersQCOM\" not available");
    }
        dispatch_glExtGetFramebuffersQCOM1(framebuffers, Buffers.SIZEOF_INT * framebuffers_offset, false, maxFramebuffers, numFramebuffers, Buffers.SIZEOF_INT * numFramebuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetProgramBinarySourceQCOM}(GLuint program, GLenum shadertype, GLchar *  source, GLint *  length); </code> <br>Part of <code>GL_QCOM_extended_get2</code>
      @param source a direct or array-backed {@link java.nio.ByteBuffer}
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetProgramBinarySourceQCOM(int program, int shadertype, ByteBuffer source, IntBuffer length)  {

    final boolean source_is_direct = Buffers.isDirect(source);
    final boolean length_is_direct = Buffers.isDirect(length);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetProgramBinarySourceQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetProgramBinarySourceQCOM\" not available");
    }
        dispatch_glExtGetProgramBinarySourceQCOM1(program, shadertype, source_is_direct ? source : Buffers.getArray(source), source_is_direct ? Buffers.getDirectBufferByteOffset(source) : Buffers.getIndirectBufferByteOffset(source), source_is_direct, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetProgramBinarySourceQCOM}(GLuint program, GLenum shadertype, GLchar *  source, GLint *  length); </code> <br>Part of <code>GL_QCOM_extended_get2</code>
      @param source a direct or array-backed {@link java.nio.ByteBuffer}
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetProgramBinarySourceQCOM1(int program, int shadertype, Object source, int source_byte_offset, boolean source_is_direct, Object length, int length_byte_offset, boolean length_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetProgramBinarySourceQCOM}(GLuint program, GLenum shadertype, GLchar *  source, GLint *  length); </code> <br>Part of <code>GL_QCOM_extended_get2</code>   */
  public void glExtGetProgramBinarySourceQCOM(int program, int shadertype, byte[] source, int source_offset, int[] length, int length_offset)  {

    if(source != null && source.length <= source_offset)
      throw new GLException("array offset argument \"source_offset\" (" + source_offset + ") equals or exceeds array length (" + source.length + ")");
    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetProgramBinarySourceQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetProgramBinarySourceQCOM\" not available");
    }
        dispatch_glExtGetProgramBinarySourceQCOM1(program, shadertype, source, source_offset, false, length, Buffers.SIZEOF_INT * length_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetProgramsQCOM}(GLuint *  programs, GLint maxPrograms, GLint *  numPrograms); </code> <br>Part of <code>GL_QCOM_extended_get2</code>
      @param programs a direct or array-backed {@link java.nio.IntBuffer}
      @param numPrograms a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetProgramsQCOM(IntBuffer programs, int maxPrograms, IntBuffer numPrograms)  {

    final boolean programs_is_direct = Buffers.isDirect(programs);
    final boolean numPrograms_is_direct = Buffers.isDirect(numPrograms);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetProgramsQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetProgramsQCOM\" not available");
    }
        dispatch_glExtGetProgramsQCOM1(programs_is_direct ? programs : Buffers.getArray(programs), programs_is_direct ? Buffers.getDirectBufferByteOffset(programs) : Buffers.getIndirectBufferByteOffset(programs), programs_is_direct, maxPrograms, numPrograms_is_direct ? numPrograms : Buffers.getArray(numPrograms), numPrograms_is_direct ? Buffers.getDirectBufferByteOffset(numPrograms) : Buffers.getIndirectBufferByteOffset(numPrograms), numPrograms_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetProgramsQCOM}(GLuint *  programs, GLint maxPrograms, GLint *  numPrograms); </code> <br>Part of <code>GL_QCOM_extended_get2</code>
      @param programs a direct or array-backed {@link java.nio.IntBuffer}
      @param numPrograms a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetProgramsQCOM1(Object programs, int programs_byte_offset, boolean programs_is_direct, int maxPrograms, Object numPrograms, int numPrograms_byte_offset, boolean numPrograms_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetProgramsQCOM}(GLuint *  programs, GLint maxPrograms, GLint *  numPrograms); </code> <br>Part of <code>GL_QCOM_extended_get2</code>   */
  public void glExtGetProgramsQCOM(int[] programs, int programs_offset, int maxPrograms, int[] numPrograms, int numPrograms_offset)  {

    if(programs != null && programs.length <= programs_offset)
      throw new GLException("array offset argument \"programs_offset\" (" + programs_offset + ") equals or exceeds array length (" + programs.length + ")");
    if(numPrograms != null && numPrograms.length <= numPrograms_offset)
      throw new GLException("array offset argument \"numPrograms_offset\" (" + numPrograms_offset + ") equals or exceeds array length (" + numPrograms.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetProgramsQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetProgramsQCOM\" not available");
    }
        dispatch_glExtGetProgramsQCOM1(programs, Buffers.SIZEOF_INT * programs_offset, false, maxPrograms, numPrograms, Buffers.SIZEOF_INT * numPrograms_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetRenderbuffersQCOM}(GLuint *  renderbuffers, GLint maxRenderbuffers, GLint *  numRenderbuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numRenderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetRenderbuffersQCOM(IntBuffer renderbuffers, int maxRenderbuffers, IntBuffer numRenderbuffers)  {

    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    final boolean numRenderbuffers_is_direct = Buffers.isDirect(numRenderbuffers);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetRenderbuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetRenderbuffersQCOM\" not available");
    }
        dispatch_glExtGetRenderbuffersQCOM1(renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct, maxRenderbuffers, numRenderbuffers_is_direct ? numRenderbuffers : Buffers.getArray(numRenderbuffers), numRenderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(numRenderbuffers) : Buffers.getIndirectBufferByteOffset(numRenderbuffers), numRenderbuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetRenderbuffersQCOM}(GLuint *  renderbuffers, GLint maxRenderbuffers, GLint *  numRenderbuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numRenderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetRenderbuffersQCOM1(Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct, int maxRenderbuffers, Object numRenderbuffers, int numRenderbuffers_byte_offset, boolean numRenderbuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetRenderbuffersQCOM}(GLuint *  renderbuffers, GLint maxRenderbuffers, GLint *  numRenderbuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>   */
  public void glExtGetRenderbuffersQCOM(int[] renderbuffers, int renderbuffers_offset, int maxRenderbuffers, int[] numRenderbuffers, int numRenderbuffers_offset)  {

    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    if(numRenderbuffers != null && numRenderbuffers.length <= numRenderbuffers_offset)
      throw new GLException("array offset argument \"numRenderbuffers_offset\" (" + numRenderbuffers_offset + ") equals or exceeds array length (" + numRenderbuffers.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetRenderbuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetRenderbuffersQCOM\" not available");
    }
        dispatch_glExtGetRenderbuffersQCOM1(renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false, maxRenderbuffers, numRenderbuffers, Buffers.SIZEOF_INT * numRenderbuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetShadersQCOM}(GLuint *  shaders, GLint maxShaders, GLint *  numShaders); </code> <br>Part of <code>GL_QCOM_extended_get2</code>
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}
      @param numShaders a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetShadersQCOM(IntBuffer shaders, int maxShaders, IntBuffer numShaders)  {

    final boolean shaders_is_direct = Buffers.isDirect(shaders);
    final boolean numShaders_is_direct = Buffers.isDirect(numShaders);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetShadersQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetShadersQCOM\" not available");
    }
        dispatch_glExtGetShadersQCOM1(shaders_is_direct ? shaders : Buffers.getArray(shaders), shaders_is_direct ? Buffers.getDirectBufferByteOffset(shaders) : Buffers.getIndirectBufferByteOffset(shaders), shaders_is_direct, maxShaders, numShaders_is_direct ? numShaders : Buffers.getArray(numShaders), numShaders_is_direct ? Buffers.getDirectBufferByteOffset(numShaders) : Buffers.getIndirectBufferByteOffset(numShaders), numShaders_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetShadersQCOM}(GLuint *  shaders, GLint maxShaders, GLint *  numShaders); </code> <br>Part of <code>GL_QCOM_extended_get2</code>
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}
      @param numShaders a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetShadersQCOM1(Object shaders, int shaders_byte_offset, boolean shaders_is_direct, int maxShaders, Object numShaders, int numShaders_byte_offset, boolean numShaders_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetShadersQCOM}(GLuint *  shaders, GLint maxShaders, GLint *  numShaders); </code> <br>Part of <code>GL_QCOM_extended_get2</code>   */
  public void glExtGetShadersQCOM(int[] shaders, int shaders_offset, int maxShaders, int[] numShaders, int numShaders_offset)  {

    if(shaders != null && shaders.length <= shaders_offset)
      throw new GLException("array offset argument \"shaders_offset\" (" + shaders_offset + ") equals or exceeds array length (" + shaders.length + ")");
    if(numShaders != null && numShaders.length <= numShaders_offset)
      throw new GLException("array offset argument \"numShaders_offset\" (" + numShaders_offset + ") equals or exceeds array length (" + numShaders.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetShadersQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetShadersQCOM\" not available");
    }
        dispatch_glExtGetShadersQCOM1(shaders, Buffers.SIZEOF_INT * shaders_offset, false, maxShaders, numShaders, Buffers.SIZEOF_INT * numShaders_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetTexLevelParameterivQCOM}(GLuint texture, GLenum face, GLint level, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetTexLevelParameterivQCOM(int texture, int face, int level, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetTexLevelParameterivQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetTexLevelParameterivQCOM\" not available");
    }
        dispatch_glExtGetTexLevelParameterivQCOM1(texture, face, level, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetTexLevelParameterivQCOM}(GLuint texture, GLenum face, GLint level, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetTexLevelParameterivQCOM1(int texture, int face, int level, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetTexLevelParameterivQCOM}(GLuint texture, GLenum face, GLint level, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_QCOM_extended_get</code>   */
  public void glExtGetTexLevelParameterivQCOM(int texture, int face, int level, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetTexLevelParameterivQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetTexLevelParameterivQCOM\" not available");
    }
        dispatch_glExtGetTexLevelParameterivQCOM1(texture, face, level, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetTexSubImageQCOM}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLvoid *  texels); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param texels a direct or array-backed {@link java.nio.Buffer}   */
  public void glExtGetTexSubImageQCOM(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Buffer texels)  {

    final boolean texels_is_direct = Buffers.isDirect(texels);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetTexSubImageQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetTexSubImageQCOM\" not available");
    }
        dispatch_glExtGetTexSubImageQCOM1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, texels_is_direct ? texels : Buffers.getArray(texels), texels_is_direct ? Buffers.getDirectBufferByteOffset(texels) : Buffers.getIndirectBufferByteOffset(texels), texels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetTexSubImageQCOM}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLvoid *  texels); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param texels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glExtGetTexSubImageQCOM1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Object texels, int texels_byte_offset, boolean texels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetTexturesQCOM}(GLuint *  textures, GLint maxTextures, GLint *  numTextures); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}
      @param numTextures a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetTexturesQCOM(IntBuffer textures, int maxTextures, IntBuffer numTextures)  {

    final boolean textures_is_direct = Buffers.isDirect(textures);
    final boolean numTextures_is_direct = Buffers.isDirect(numTextures);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetTexturesQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetTexturesQCOM\" not available");
    }
        dispatch_glExtGetTexturesQCOM1(textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, maxTextures, numTextures_is_direct ? numTextures : Buffers.getArray(numTextures), numTextures_is_direct ? Buffers.getDirectBufferByteOffset(numTextures) : Buffers.getIndirectBufferByteOffset(numTextures), numTextures_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetTexturesQCOM}(GLuint *  textures, GLint maxTextures, GLint *  numTextures); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}
      @param numTextures a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetTexturesQCOM1(Object textures, int textures_byte_offset, boolean textures_is_direct, int maxTextures, Object numTextures, int numTextures_byte_offset, boolean numTextures_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetTexturesQCOM}(GLuint *  textures, GLint maxTextures, GLint *  numTextures); </code> <br>Part of <code>GL_QCOM_extended_get</code>   */
  public void glExtGetTexturesQCOM(int[] textures, int textures_offset, int maxTextures, int[] numTextures, int numTextures_offset)  {

    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    if(numTextures != null && numTextures.length <= numTextures_offset)
      throw new GLException("array offset argument \"numTextures_offset\" (" + numTextures_offset + ") equals or exceeds array length (" + numTextures.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetTexturesQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtGetTexturesQCOM\" not available");
    }
        dispatch_glExtGetTexturesQCOM1(textures, Buffers.SIZEOF_INT * textures_offset, false, maxTextures, numTextures, Buffers.SIZEOF_INT * numTextures_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glExtIsProgramBinaryQCOM}(GLuint program); </code> <br>Part of <code>GL_QCOM_extended_get2</code>   */
  public boolean glExtIsProgramBinaryQCOM(int program)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtIsProgramBinaryQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtIsProgramBinaryQCOM\" not available");
    }
        return dispatch_glExtIsProgramBinaryQCOM1(program, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glExtIsProgramBinaryQCOM}(GLuint program); </code> <br>Part of <code>GL_QCOM_extended_get2</code>   */
  public native boolean dispatch_glExtIsProgramBinaryQCOM1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtTexObjectStateOverrideiQCOM}(GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_QCOM_extended_get</code>   */
  public void glExtTexObjectStateOverrideiQCOM(int target, int pname, int param)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtTexObjectStateOverrideiQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glExtTexObjectStateOverrideiQCOM\" not available");
    }
        dispatch_glExtTexObjectStateOverrideiQCOM1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtTexObjectStateOverrideiQCOM}(GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_QCOM_extended_get</code>   */
  public native void dispatch_glExtTexObjectStateOverrideiQCOM1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glFinish}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glFinish()  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFinish;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFinish\" not available");
    }
        dispatch_glFinish1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glFinish}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glFinish1(long procAddress);

  /** Entry point to C language function: <code> void {@native glFinishFenceNV}(GLuint array); </code> <br>Part of <code>GL_NV_fence</code>   */
  public void glFinishFenceNV(int array)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFinishFenceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFinishFenceNV\" not available");
    }
        dispatch_glFinishFenceNV1(array, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFinishFenceNV}(GLuint array); </code> <br>Part of <code>GL_NV_fence</code>   */
  public native void dispatch_glFinishFenceNV1(int array, long procAddress);

  /** Entry point to C language function: <code> void {@native glFlush}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glFlush()  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFlush;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFlush\" not available");
    }
        dispatch_glFlush1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glFlush}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glFlush1(long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferRenderbuffer}(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glFramebufferRenderbuffer(int target, int attachment, int renderbuffertarget, int renderbuffer)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferRenderbuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferRenderbuffer\" not available");
    }
        dispatch_glFramebufferRenderbuffer1(target, attachment, renderbuffertarget, renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferRenderbuffer}(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glFramebufferRenderbuffer1(int target, int attachment, int renderbuffertarget, int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glFramebufferTexture2D(int target, int attachment, int textarget, int texture, int level)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferTexture2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferTexture2D\" not available");
    }
        dispatch_glFramebufferTexture2D1(target, attachment, textarget, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glFramebufferTexture2D1(int target, int attachment, int textarget, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2DMultisampleEXT}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei zoffset); </code> <br>Part of <code>GL_EXT_multisampled_render_to_texture</code>   */
  public void glFramebufferTexture2DMultisampleEXT(int target, int attachment, int textarget, int texture, int level, int zoffset)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferTexture2DMultisampleEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferTexture2DMultisampleEXT\" not available");
    }
        dispatch_glFramebufferTexture2DMultisampleEXT1(target, attachment, textarget, texture, level, zoffset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2DMultisampleEXT}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei zoffset); </code> <br>Part of <code>GL_EXT_multisampled_render_to_texture</code>   */
  public native void dispatch_glFramebufferTexture2DMultisampleEXT1(int target, int attachment, int textarget, int texture, int level, int zoffset, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2DMultisampleIMG}(GLenum, GLenum, GLenum, GLuint, GLint, GLsizei); </code> <br>Part of <code>GL_IMG_multisampled_render_to_texture</code>   */
  public void glFramebufferTexture2DMultisampleIMG(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferTexture2DMultisampleIMG;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferTexture2DMultisampleIMG\" not available");
    }
        dispatch_glFramebufferTexture2DMultisampleIMG1(arg0, arg1, arg2, arg3, arg4, arg5, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2DMultisampleIMG}(GLenum, GLenum, GLenum, GLuint, GLint, GLsizei); </code> <br>Part of <code>GL_IMG_multisampled_render_to_texture</code>   */
  public native void dispatch_glFramebufferTexture2DMultisampleIMG1(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture3DOES}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_texture_3D</code>   */
  public void glFramebufferTexture3D(int target, int attachment, int textarget, int texture, int level, int zoffset)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferTexture3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFramebufferTexture3D\" not available");
    }
        dispatch_glFramebufferTexture3D1(target, attachment, textarget, texture, level, zoffset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture3DOES}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>; <code>GL_OES_texture_3D</code>   */
  public native void dispatch_glFramebufferTexture3D1(int target, int attachment, int textarget, int texture, int level, int zoffset, long procAddress);

  /** Entry point to C language function: <code> void {@native glFrontFace}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glFrontFace(int mode)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFrontFace;
    if (__addr_ == 0) {
      throw new GLException("Method \"glFrontFace\" not available");
    }
        dispatch_glFrontFace1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFrontFace}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glFrontFace1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenBuffers}(GLsizei n, GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenBuffers(int n, IntBuffer buffers)  {

    Buffers.rangeCheck(buffers, n);
    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenBuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenBuffers\" not available");
    }
        dispatch_glGenBuffers1(n, buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenBuffers}(GLsizei n, GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenBuffers1(int n, Object buffers, int buffers_byte_offset, boolean buffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenBuffers}(GLsizei n, GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGenBuffers(int n, int[] buffers, int buffers_offset)  {

    Buffers.rangeCheck(buffers, buffers_offset, n);
    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenBuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenBuffers\" not available");
    }
        dispatch_glGenBuffers1(n, buffers, Buffers.SIZEOF_INT * buffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenFencesNV}(GLsizei n, GLuint *  arrays); </code> <br>Part of <code>GL_NV_fence</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenFencesNV(int n, IntBuffer arrays)  {

    Buffers.rangeCheck(arrays, n);
    final boolean arrays_is_direct = Buffers.isDirect(arrays);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenFencesNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenFencesNV\" not available");
    }
        dispatch_glGenFencesNV1(n, arrays_is_direct ? arrays : Buffers.getArray(arrays), arrays_is_direct ? Buffers.getDirectBufferByteOffset(arrays) : Buffers.getIndirectBufferByteOffset(arrays), arrays_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenFencesNV}(GLsizei n, GLuint *  arrays); </code> <br>Part of <code>GL_NV_fence</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenFencesNV1(int n, Object arrays, int arrays_byte_offset, boolean arrays_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenFencesNV}(GLsizei n, GLuint *  arrays); </code> <br>Part of <code>GL_NV_fence</code>   */
  public void glGenFencesNV(int n, int[] arrays, int arrays_offset)  {

    Buffers.rangeCheck(arrays, arrays_offset, n);
    if(arrays != null && arrays.length <= arrays_offset)
      throw new GLException("array offset argument \"arrays_offset\" (" + arrays_offset + ") equals or exceeds array length (" + arrays.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenFencesNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenFencesNV\" not available");
    }
        dispatch_glGenFencesNV1(n, arrays, Buffers.SIZEOF_INT * arrays_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenFramebuffers}(GLsizei n, GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenFramebuffers(int n, IntBuffer framebuffers)  {

    final boolean framebuffers_is_direct = Buffers.isDirect(framebuffers);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenFramebuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenFramebuffers\" not available");
    }
        dispatch_glGenFramebuffers1(n, framebuffers_is_direct ? framebuffers : Buffers.getArray(framebuffers), framebuffers_is_direct ? Buffers.getDirectBufferByteOffset(framebuffers) : Buffers.getIndirectBufferByteOffset(framebuffers), framebuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenFramebuffers}(GLsizei n, GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenFramebuffers1(int n, Object framebuffers, int framebuffers_byte_offset, boolean framebuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenFramebuffers}(GLsizei n, GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGenFramebuffers(int n, int[] framebuffers, int framebuffers_offset)  {

    if(framebuffers != null && framebuffers.length <= framebuffers_offset)
      throw new GLException("array offset argument \"framebuffers_offset\" (" + framebuffers_offset + ") equals or exceeds array length (" + framebuffers.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenFramebuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenFramebuffers\" not available");
    }
        dispatch_glGenFramebuffers1(n, framebuffers, Buffers.SIZEOF_INT * framebuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenPerfMonitorsAMD}(GLsizei n, GLuint *  monitors); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param monitors a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenPerfMonitorsAMD(int n, IntBuffer monitors)  {

    final boolean monitors_is_direct = Buffers.isDirect(monitors);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenPerfMonitorsAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenPerfMonitorsAMD\" not available");
    }
        dispatch_glGenPerfMonitorsAMD1(n, monitors_is_direct ? monitors : Buffers.getArray(monitors), monitors_is_direct ? Buffers.getDirectBufferByteOffset(monitors) : Buffers.getIndirectBufferByteOffset(monitors), monitors_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenPerfMonitorsAMD}(GLsizei n, GLuint *  monitors); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param monitors a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenPerfMonitorsAMD1(int n, Object monitors, int monitors_byte_offset, boolean monitors_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenPerfMonitorsAMD}(GLsizei n, GLuint *  monitors); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glGenPerfMonitorsAMD(int n, int[] monitors, int monitors_offset)  {

    if(monitors != null && monitors.length <= monitors_offset)
      throw new GLException("array offset argument \"monitors_offset\" (" + monitors_offset + ") equals or exceeds array length (" + monitors.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenPerfMonitorsAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenPerfMonitorsAMD\" not available");
    }
        dispatch_glGenPerfMonitorsAMD1(n, monitors, Buffers.SIZEOF_INT * monitors_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenQueriesEXT}(GLsizei n, GLuint *  ids); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenQueries(int n, IntBuffer ids)  {

    Buffers.rangeCheck(ids, n);
    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenQueries;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenQueries\" not available");
    }
        dispatch_glGenQueries1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenQueriesEXT}(GLsizei n, GLuint *  ids); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenQueries1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenQueriesEXT}(GLsizei n, GLuint *  ids); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>   */
  public void glGenQueries(int n, int[] ids, int ids_offset)  {

    Buffers.rangeCheck(ids, ids_offset, n);
    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenQueries;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenQueries\" not available");
    }
        dispatch_glGenQueries1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenRenderbuffers}(GLsizei n, GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenRenderbuffers(int n, IntBuffer renderbuffers)  {

    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenRenderbuffers\" not available");
    }
        dispatch_glGenRenderbuffers1(n, renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenRenderbuffers}(GLsizei n, GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenRenderbuffers1(int n, Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenRenderbuffers}(GLsizei n, GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGenRenderbuffers(int n, int[] renderbuffers, int renderbuffers_offset)  {

    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenRenderbuffers\" not available");
    }
        dispatch_glGenRenderbuffers1(n, renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTextures}(GLsizei n, GLuint *  textures); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenTextures(int n, IntBuffer textures)  {

    Buffers.rangeCheck(textures, n);
    final boolean textures_is_direct = Buffers.isDirect(textures);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenTextures;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenTextures\" not available");
    }
        dispatch_glGenTextures1(n, textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTextures}(GLsizei n, GLuint *  textures); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenTextures1(int n, Object textures, int textures_byte_offset, boolean textures_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenTextures}(GLsizei n, GLuint *  textures); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGenTextures(int n, int[] textures, int textures_offset)  {

    Buffers.rangeCheck(textures, textures_offset, n);
    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenTextures;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenTextures\" not available");
    }
        dispatch_glGenTextures1(n, textures, Buffers.SIZEOF_INT * textures_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenVertexArraysOES}(GLsizei n, GLuint *  arrays); </code> <br>Part of <code>GL_OES_vertex_array_object</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenVertexArraysOES(int n, IntBuffer arrays)  {

    final boolean arrays_is_direct = Buffers.isDirect(arrays);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenVertexArraysOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenVertexArraysOES\" not available");
    }
        dispatch_glGenVertexArraysOES1(n, arrays_is_direct ? arrays : Buffers.getArray(arrays), arrays_is_direct ? Buffers.getDirectBufferByteOffset(arrays) : Buffers.getIndirectBufferByteOffset(arrays), arrays_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenVertexArraysOES}(GLsizei n, GLuint *  arrays); </code> <br>Part of <code>GL_OES_vertex_array_object</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenVertexArraysOES1(int n, Object arrays, int arrays_byte_offset, boolean arrays_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenVertexArraysOES}(GLsizei n, GLuint *  arrays); </code> <br>Part of <code>GL_OES_vertex_array_object</code>   */
  public void glGenVertexArraysOES(int n, int[] arrays, int arrays_offset)  {

    if(arrays != null && arrays.length <= arrays_offset)
      throw new GLException("array offset argument \"arrays_offset\" (" + arrays_offset + ") equals or exceeds array length (" + arrays.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenVertexArraysOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenVertexArraysOES\" not available");
    }
        dispatch_glGenVertexArraysOES1(n, arrays, Buffers.SIZEOF_INT * arrays_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenerateMipmap}(GLenum target); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGenerateMipmap(int target)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenerateMipmap;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGenerateMipmap\" not available");
    }
        dispatch_glGenerateMipmap1(target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenerateMipmap}(GLenum target); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glGenerateMipmap1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveAttrib}(GLuint program, GLuint index, GLsizei bufsize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetActiveAttrib(int program, int index, int bufsize, IntBuffer length, IntBuffer size, IntBuffer type, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean size_is_direct = Buffers.isDirect(size);
    final boolean type_is_direct = Buffers.isDirect(type);
    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveAttrib;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveAttrib\" not available");
    }
        dispatch_glGetActiveAttrib1(program, index, bufsize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, size_is_direct ? size : Buffers.getArray(size), size_is_direct ? Buffers.getDirectBufferByteOffset(size) : Buffers.getIndirectBufferByteOffset(size), size_is_direct, type_is_direct ? type : Buffers.getArray(type), type_is_direct ? Buffers.getDirectBufferByteOffset(type) : Buffers.getIndirectBufferByteOffset(type), type_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveAttrib}(GLuint program, GLuint index, GLsizei bufsize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetActiveAttrib1(int program, int index, int bufsize, Object length, int length_byte_offset, boolean length_is_direct, Object size, int size_byte_offset, boolean size_is_direct, Object type, int type_byte_offset, boolean type_is_direct, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveAttrib}(GLuint program, GLuint index, GLsizei bufsize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetActiveAttrib(int program, int index, int bufsize, int[] length, int length_offset, int[] size, int size_offset, int[] type, int type_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(size != null && size.length <= size_offset)
      throw new GLException("array offset argument \"size_offset\" (" + size_offset + ") equals or exceeds array length (" + size.length + ")");
    if(type != null && type.length <= type_offset)
      throw new GLException("array offset argument \"type_offset\" (" + type_offset + ") equals or exceeds array length (" + type.length + ")");
    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveAttrib;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveAttrib\" not available");
    }
        dispatch_glGetActiveAttrib1(program, index, bufsize, length, Buffers.SIZEOF_INT * length_offset, false, size, Buffers.SIZEOF_INT * size_offset, false, type, Buffers.SIZEOF_INT * type_offset, false, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniform}(GLuint program, GLuint index, GLsizei bufsize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetActiveUniform(int program, int index, int bufsize, IntBuffer length, IntBuffer size, IntBuffer type, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean size_is_direct = Buffers.isDirect(size);
    final boolean type_is_direct = Buffers.isDirect(type);
    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveUniform;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveUniform\" not available");
    }
        dispatch_glGetActiveUniform1(program, index, bufsize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, size_is_direct ? size : Buffers.getArray(size), size_is_direct ? Buffers.getDirectBufferByteOffset(size) : Buffers.getIndirectBufferByteOffset(size), size_is_direct, type_is_direct ? type : Buffers.getArray(type), type_is_direct ? Buffers.getDirectBufferByteOffset(type) : Buffers.getIndirectBufferByteOffset(type), type_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniform}(GLuint program, GLuint index, GLsizei bufsize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetActiveUniform1(int program, int index, int bufsize, Object length, int length_byte_offset, boolean length_is_direct, Object size, int size_byte_offset, boolean size_is_direct, Object type, int type_byte_offset, boolean type_is_direct, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniform}(GLuint program, GLuint index, GLsizei bufsize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetActiveUniform(int program, int index, int bufsize, int[] length, int length_offset, int[] size, int size_offset, int[] type, int type_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(size != null && size.length <= size_offset)
      throw new GLException("array offset argument \"size_offset\" (" + size_offset + ") equals or exceeds array length (" + size.length + ")");
    if(type != null && type.length <= type_offset)
      throw new GLException("array offset argument \"type_offset\" (" + type_offset + ") equals or exceeds array length (" + type.length + ")");
    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveUniform;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetActiveUniform\" not available");
    }
        dispatch_glGetActiveUniform1(program, index, bufsize, length, Buffers.SIZEOF_INT * length_offset, false, size, Buffers.SIZEOF_INT * size_offset, false, type, Buffers.SIZEOF_INT * type_offset, false, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetAttachedShaders}(GLuint program, GLsizei maxcount, GLsizei *  count, GLuint *  shaders); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param count a direct or array-backed {@link java.nio.IntBuffer}
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetAttachedShaders(int program, int maxcount, IntBuffer count, IntBuffer shaders)  {

    final boolean count_is_direct = Buffers.isDirect(count);
    final boolean shaders_is_direct = Buffers.isDirect(shaders);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetAttachedShaders;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetAttachedShaders\" not available");
    }
        dispatch_glGetAttachedShaders1(program, maxcount, count_is_direct ? count : Buffers.getArray(count), count_is_direct ? Buffers.getDirectBufferByteOffset(count) : Buffers.getIndirectBufferByteOffset(count), count_is_direct, shaders_is_direct ? shaders : Buffers.getArray(shaders), shaders_is_direct ? Buffers.getDirectBufferByteOffset(shaders) : Buffers.getIndirectBufferByteOffset(shaders), shaders_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetAttachedShaders}(GLuint program, GLsizei maxcount, GLsizei *  count, GLuint *  shaders); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param count a direct or array-backed {@link java.nio.IntBuffer}
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetAttachedShaders1(int program, int maxcount, Object count, int count_byte_offset, boolean count_is_direct, Object shaders, int shaders_byte_offset, boolean shaders_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetAttachedShaders}(GLuint program, GLsizei maxcount, GLsizei *  count, GLuint *  shaders); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetAttachedShaders(int program, int maxcount, int[] count, int count_offset, int[] shaders, int shaders_offset)  {

    if(count != null && count.length <= count_offset)
      throw new GLException("array offset argument \"count_offset\" (" + count_offset + ") equals or exceeds array length (" + count.length + ")");
    if(shaders != null && shaders.length <= shaders_offset)
      throw new GLException("array offset argument \"shaders_offset\" (" + shaders_offset + ") equals or exceeds array length (" + shaders.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetAttachedShaders;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetAttachedShaders\" not available");
    }
        dispatch_glGetAttachedShaders1(program, maxcount, count, Buffers.SIZEOF_INT * count_offset, false, shaders, Buffers.SIZEOF_INT * shaders_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> int {@native glGetAttribLocation}(GLuint program, const GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public int glGetAttribLocation(int program, String name)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetAttribLocation;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetAttribLocation\" not available");
    }
        return dispatch_glGetAttribLocation1(program, name, __addr_);
  }

  /** Entry point to C language function: <code> int {@native glGetAttribLocation}(GLuint program, const GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native int dispatch_glGetAttribLocation1(int program, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBooleanv}(GLenum pname, GLboolean *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetBooleanv(int pname, ByteBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBooleanv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetBooleanv\" not available");
    }
        dispatch_glGetBooleanv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBooleanv}(GLenum pname, GLboolean *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetBooleanv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBooleanv}(GLenum pname, GLboolean *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetBooleanv(int pname, byte[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBooleanv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetBooleanv\" not available");
    }
        dispatch_glGetBooleanv1(pname, params, params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetBufferParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetBufferParameteriv\" not available");
    }
        dispatch_glGetBufferParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetBufferParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBufferParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetBufferParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetBufferParameteriv\" not available");
    }
        dispatch_glGetBufferParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferPointervOES}(GLenum target, GLenum pname, GLvoid *  *  params); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_OES_mapbuffer</code>
      @param params a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glGetBufferPointerv(int target, int pname, PointerBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBufferPointerv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetBufferPointerv\" not available");
    }
        dispatch_glGetBufferPointerv1(target, pname, params_is_direct ? ( params != null ? params.getBuffer() : null ) : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferPointervOES}(GLenum target, GLenum pname, GLvoid *  *  params); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_OES_mapbuffer</code>
      @param params a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private native void dispatch_glGetBufferPointerv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetDriverControlStringQCOM}(GLuint driverControl, GLsizei bufSize, GLsizei *  length, GLchar *  driverControlString); </code> <br>Part of <code>GL_QCOM_driver_control</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param driverControlString a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetDriverControlStringQCOM(int driverControl, int bufSize, IntBuffer length, ByteBuffer driverControlString)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean driverControlString_is_direct = Buffers.isDirect(driverControlString);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDriverControlStringQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetDriverControlStringQCOM\" not available");
    }
        dispatch_glGetDriverControlStringQCOM1(driverControl, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, driverControlString_is_direct ? driverControlString : Buffers.getArray(driverControlString), driverControlString_is_direct ? Buffers.getDirectBufferByteOffset(driverControlString) : Buffers.getIndirectBufferByteOffset(driverControlString), driverControlString_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDriverControlStringQCOM}(GLuint driverControl, GLsizei bufSize, GLsizei *  length, GLchar *  driverControlString); </code> <br>Part of <code>GL_QCOM_driver_control</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param driverControlString a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetDriverControlStringQCOM1(int driverControl, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object driverControlString, int driverControlString_byte_offset, boolean driverControlString_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetDriverControlStringQCOM}(GLuint driverControl, GLsizei bufSize, GLsizei *  length, GLchar *  driverControlString); </code> <br>Part of <code>GL_QCOM_driver_control</code>   */
  public void glGetDriverControlStringQCOM(int driverControl, int bufSize, int[] length, int length_offset, byte[] driverControlString, int driverControlString_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(driverControlString != null && driverControlString.length <= driverControlString_offset)
      throw new GLException("array offset argument \"driverControlString_offset\" (" + driverControlString_offset + ") equals or exceeds array length (" + driverControlString.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDriverControlStringQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetDriverControlStringQCOM\" not available");
    }
        dispatch_glGetDriverControlStringQCOM1(driverControl, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, driverControlString, driverControlString_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDriverControlsQCOM}(GLint *  num, GLsizei size, GLuint *  driverControls); </code> <br>Part of <code>GL_QCOM_driver_control</code>
      @param num a direct or array-backed {@link java.nio.IntBuffer}
      @param driverControls a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetDriverControlsQCOM(IntBuffer num, int size, IntBuffer driverControls)  {

    final boolean num_is_direct = Buffers.isDirect(num);
    final boolean driverControls_is_direct = Buffers.isDirect(driverControls);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDriverControlsQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetDriverControlsQCOM\" not available");
    }
        dispatch_glGetDriverControlsQCOM1(num_is_direct ? num : Buffers.getArray(num), num_is_direct ? Buffers.getDirectBufferByteOffset(num) : Buffers.getIndirectBufferByteOffset(num), num_is_direct, size, driverControls_is_direct ? driverControls : Buffers.getArray(driverControls), driverControls_is_direct ? Buffers.getDirectBufferByteOffset(driverControls) : Buffers.getIndirectBufferByteOffset(driverControls), driverControls_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDriverControlsQCOM}(GLint *  num, GLsizei size, GLuint *  driverControls); </code> <br>Part of <code>GL_QCOM_driver_control</code>
      @param num a direct or array-backed {@link java.nio.IntBuffer}
      @param driverControls a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetDriverControlsQCOM1(Object num, int num_byte_offset, boolean num_is_direct, int size, Object driverControls, int driverControls_byte_offset, boolean driverControls_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetDriverControlsQCOM}(GLint *  num, GLsizei size, GLuint *  driverControls); </code> <br>Part of <code>GL_QCOM_driver_control</code>   */
  public void glGetDriverControlsQCOM(int[] num, int num_offset, int size, int[] driverControls, int driverControls_offset)  {

    if(num != null && num.length <= num_offset)
      throw new GLException("array offset argument \"num_offset\" (" + num_offset + ") equals or exceeds array length (" + num.length + ")");
    if(driverControls != null && driverControls.length <= driverControls_offset)
      throw new GLException("array offset argument \"driverControls_offset\" (" + driverControls_offset + ") equals or exceeds array length (" + driverControls.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDriverControlsQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetDriverControlsQCOM\" not available");
    }
        dispatch_glGetDriverControlsQCOM1(num, Buffers.SIZEOF_INT * num_offset, false, size, driverControls, Buffers.SIZEOF_INT * driverControls_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetError}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public int glGetError()  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetError;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetError\" not available");
    }
        return dispatch_glGetError1(__addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetError}(void); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native int dispatch_glGetError1(long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFenceivNV}(GLuint target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_fence</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetFenceivNV(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFenceivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFenceivNV\" not available");
    }
        dispatch_glGetFenceivNV1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFenceivNV}(GLuint target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_fence</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetFenceivNV1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFenceivNV}(GLuint target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_NV_fence</code>   */
  public void glGetFenceivNV(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFenceivNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFenceivNV\" not available");
    }
        dispatch_glGetFenceivNV1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFloatv}(GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetFloatv(int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFloatv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFloatv\" not available");
    }
        dispatch_glGetFloatv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFloatv}(GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetFloatv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFloatv}(GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetFloatv(int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFloatv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFloatv\" not available");
    }
        dispatch_glGetFloatv1(pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFramebufferAttachmentParameteriv}(GLenum target, GLenum attachment, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetFramebufferAttachmentParameteriv(int target, int attachment, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFramebufferAttachmentParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFramebufferAttachmentParameteriv\" not available");
    }
        dispatch_glGetFramebufferAttachmentParameteriv1(target, attachment, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFramebufferAttachmentParameteriv}(GLenum target, GLenum attachment, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetFramebufferAttachmentParameteriv1(int target, int attachment, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFramebufferAttachmentParameteriv}(GLenum target, GLenum attachment, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetFramebufferAttachmentParameteriv(int target, int attachment, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFramebufferAttachmentParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetFramebufferAttachmentParameteriv\" not available");
    }
        dispatch_glGetFramebufferAttachmentParameteriv1(target, attachment, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetGraphicsResetStatusEXT}(void); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>   */
  public int glGetGraphicsResetStatus()  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetGraphicsResetStatus;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetGraphicsResetStatus\" not available");
    }
        return dispatch_glGetGraphicsResetStatus1(__addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetGraphicsResetStatusEXT}(void); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>   */
  public native int dispatch_glGetGraphicsResetStatus1(long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegerv}(GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetIntegerv(int pname, IntBuffer params)  {

    if ( glStateTracker.getInt(pname, params, params_offset) ) { return; }
    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetIntegerv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetIntegerv\" not available");
    }
        dispatch_glGetIntegerv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegerv}(GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetIntegerv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegerv}(GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetIntegerv(int pname, int[] params, int params_offset)  {

    if ( glStateTracker.getInt(pname, params, params_offset) ) { return; }
    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetIntegerv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetIntegerv\" not available");
    }
        dispatch_glGetIntegerv1(pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectLabelEXT}(GLenum type, GLuint object, GLsizei bufSize, GLsizei *  length, GLchar *  label); </code> <br>Part of <code>GL_EXT_debug_label</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetObjectLabelEXT(int type, int object, int bufSize, IntBuffer length, ByteBuffer label)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean label_is_direct = Buffers.isDirect(label);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetObjectLabelEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetObjectLabelEXT\" not available");
    }
        dispatch_glGetObjectLabelEXT1(type, object, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, label_is_direct ? label : Buffers.getArray(label), label_is_direct ? Buffers.getDirectBufferByteOffset(label) : Buffers.getIndirectBufferByteOffset(label), label_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectLabelEXT}(GLenum type, GLuint object, GLsizei bufSize, GLsizei *  length, GLchar *  label); </code> <br>Part of <code>GL_EXT_debug_label</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetObjectLabelEXT1(int type, int object, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object label, int label_byte_offset, boolean label_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetObjectLabelEXT}(GLenum type, GLuint object, GLsizei bufSize, GLsizei *  length, GLchar *  label); </code> <br>Part of <code>GL_EXT_debug_label</code>   */
  public void glGetObjectLabelEXT(int type, int object, int bufSize, int[] length, int length_offset, byte[] label, int label_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(label != null && label.length <= label_offset)
      throw new GLException("array offset argument \"label_offset\" (" + label_offset + ") equals or exceeds array length (" + label.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetObjectLabelEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetObjectLabelEXT\" not available");
    }
        dispatch_glGetObjectLabelEXT1(type, object, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, label, label_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterDataAMD}(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *  data, GLint *  bytesWritten); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}
      @param bytesWritten a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetPerfMonitorCounterDataAMD(int monitor, int pname, int dataSize, IntBuffer data, IntBuffer bytesWritten)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final boolean bytesWritten_is_direct = Buffers.isDirect(bytesWritten);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorCounterDataAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPerfMonitorCounterDataAMD\" not available");
    }
        dispatch_glGetPerfMonitorCounterDataAMD1(monitor, pname, dataSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, bytesWritten_is_direct ? bytesWritten : Buffers.getArray(bytesWritten), bytesWritten_is_direct ? Buffers.getDirectBufferByteOffset(bytesWritten) : Buffers.getIndirectBufferByteOffset(bytesWritten), bytesWritten_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterDataAMD}(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *  data, GLint *  bytesWritten); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}
      @param bytesWritten a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetPerfMonitorCounterDataAMD1(int monitor, int pname, int dataSize, Object data, int data_byte_offset, boolean data_is_direct, Object bytesWritten, int bytesWritten_byte_offset, boolean bytesWritten_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterDataAMD}(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *  data, GLint *  bytesWritten); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glGetPerfMonitorCounterDataAMD(int monitor, int pname, int dataSize, int[] data, int data_offset, int[] bytesWritten, int bytesWritten_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    if(bytesWritten != null && bytesWritten.length <= bytesWritten_offset)
      throw new GLException("array offset argument \"bytesWritten_offset\" (" + bytesWritten_offset + ") equals or exceeds array length (" + bytesWritten.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorCounterDataAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPerfMonitorCounterDataAMD\" not available");
    }
        dispatch_glGetPerfMonitorCounterDataAMD1(monitor, pname, dataSize, data, Buffers.SIZEOF_INT * data_offset, false, bytesWritten, Buffers.SIZEOF_INT * bytesWritten_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterInfoAMD}(GLuint group, GLuint counter, GLenum pname, GLvoid *  data); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetPerfMonitorCounterInfoAMD(int group, int counter, int pname, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorCounterInfoAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPerfMonitorCounterInfoAMD\" not available");
    }
        dispatch_glGetPerfMonitorCounterInfoAMD1(group, counter, pname, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterInfoAMD}(GLuint group, GLuint counter, GLenum pname, GLvoid *  data); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetPerfMonitorCounterInfoAMD1(int group, int counter, int pname, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterStringAMD}(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *  length, GLchar *  counterString); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param counterString a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetPerfMonitorCounterStringAMD(int group, int counter, int bufSize, IntBuffer length, ByteBuffer counterString)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean counterString_is_direct = Buffers.isDirect(counterString);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorCounterStringAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPerfMonitorCounterStringAMD\" not available");
    }
        dispatch_glGetPerfMonitorCounterStringAMD1(group, counter, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, counterString_is_direct ? counterString : Buffers.getArray(counterString), counterString_is_direct ? Buffers.getDirectBufferByteOffset(counterString) : Buffers.getIndirectBufferByteOffset(counterString), counterString_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterStringAMD}(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *  length, GLchar *  counterString); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param counterString a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetPerfMonitorCounterStringAMD1(int group, int counter, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object counterString, int counterString_byte_offset, boolean counterString_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterStringAMD}(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *  length, GLchar *  counterString); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glGetPerfMonitorCounterStringAMD(int group, int counter, int bufSize, int[] length, int length_offset, byte[] counterString, int counterString_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(counterString != null && counterString.length <= counterString_offset)
      throw new GLException("array offset argument \"counterString_offset\" (" + counterString_offset + ") equals or exceeds array length (" + counterString.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorCounterStringAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPerfMonitorCounterStringAMD\" not available");
    }
        dispatch_glGetPerfMonitorCounterStringAMD1(group, counter, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, counterString, counterString_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCountersAMD}(GLuint group, GLint *  numCounters, GLint *  maxActiveCounters, GLsizei counterSize, GLuint *  counters); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param numCounters a direct or array-backed {@link java.nio.IntBuffer}
      @param maxActiveCounters a direct or array-backed {@link java.nio.IntBuffer}
      @param counters a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetPerfMonitorCountersAMD(int group, IntBuffer numCounters, IntBuffer maxActiveCounters, int counterSize, IntBuffer counters)  {

    final boolean numCounters_is_direct = Buffers.isDirect(numCounters);
    final boolean maxActiveCounters_is_direct = Buffers.isDirect(maxActiveCounters);
    final boolean counters_is_direct = Buffers.isDirect(counters);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorCountersAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPerfMonitorCountersAMD\" not available");
    }
        dispatch_glGetPerfMonitorCountersAMD1(group, numCounters_is_direct ? numCounters : Buffers.getArray(numCounters), numCounters_is_direct ? Buffers.getDirectBufferByteOffset(numCounters) : Buffers.getIndirectBufferByteOffset(numCounters), numCounters_is_direct, maxActiveCounters_is_direct ? maxActiveCounters : Buffers.getArray(maxActiveCounters), maxActiveCounters_is_direct ? Buffers.getDirectBufferByteOffset(maxActiveCounters) : Buffers.getIndirectBufferByteOffset(maxActiveCounters), maxActiveCounters_is_direct, counterSize, counters_is_direct ? counters : Buffers.getArray(counters), counters_is_direct ? Buffers.getDirectBufferByteOffset(counters) : Buffers.getIndirectBufferByteOffset(counters), counters_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCountersAMD}(GLuint group, GLint *  numCounters, GLint *  maxActiveCounters, GLsizei counterSize, GLuint *  counters); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param numCounters a direct or array-backed {@link java.nio.IntBuffer}
      @param maxActiveCounters a direct or array-backed {@link java.nio.IntBuffer}
      @param counters a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetPerfMonitorCountersAMD1(int group, Object numCounters, int numCounters_byte_offset, boolean numCounters_is_direct, Object maxActiveCounters, int maxActiveCounters_byte_offset, boolean maxActiveCounters_is_direct, int counterSize, Object counters, int counters_byte_offset, boolean counters_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCountersAMD}(GLuint group, GLint *  numCounters, GLint *  maxActiveCounters, GLsizei counterSize, GLuint *  counters); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glGetPerfMonitorCountersAMD(int group, int[] numCounters, int numCounters_offset, int[] maxActiveCounters, int maxActiveCounters_offset, int counterSize, int[] counters, int counters_offset)  {

    if(numCounters != null && numCounters.length <= numCounters_offset)
      throw new GLException("array offset argument \"numCounters_offset\" (" + numCounters_offset + ") equals or exceeds array length (" + numCounters.length + ")");
    if(maxActiveCounters != null && maxActiveCounters.length <= maxActiveCounters_offset)
      throw new GLException("array offset argument \"maxActiveCounters_offset\" (" + maxActiveCounters_offset + ") equals or exceeds array length (" + maxActiveCounters.length + ")");
    if(counters != null && counters.length <= counters_offset)
      throw new GLException("array offset argument \"counters_offset\" (" + counters_offset + ") equals or exceeds array length (" + counters.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorCountersAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPerfMonitorCountersAMD\" not available");
    }
        dispatch_glGetPerfMonitorCountersAMD1(group, numCounters, Buffers.SIZEOF_INT * numCounters_offset, false, maxActiveCounters, Buffers.SIZEOF_INT * maxActiveCounters_offset, false, counterSize, counters, Buffers.SIZEOF_INT * counters_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupStringAMD}(GLuint group, GLsizei bufSize, GLsizei *  length, GLchar *  groupString); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param groupString a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetPerfMonitorGroupStringAMD(int group, int bufSize, IntBuffer length, ByteBuffer groupString)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean groupString_is_direct = Buffers.isDirect(groupString);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorGroupStringAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPerfMonitorGroupStringAMD\" not available");
    }
        dispatch_glGetPerfMonitorGroupStringAMD1(group, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, groupString_is_direct ? groupString : Buffers.getArray(groupString), groupString_is_direct ? Buffers.getDirectBufferByteOffset(groupString) : Buffers.getIndirectBufferByteOffset(groupString), groupString_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupStringAMD}(GLuint group, GLsizei bufSize, GLsizei *  length, GLchar *  groupString); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param groupString a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetPerfMonitorGroupStringAMD1(int group, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object groupString, int groupString_byte_offset, boolean groupString_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupStringAMD}(GLuint group, GLsizei bufSize, GLsizei *  length, GLchar *  groupString); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glGetPerfMonitorGroupStringAMD(int group, int bufSize, int[] length, int length_offset, byte[] groupString, int groupString_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(groupString != null && groupString.length <= groupString_offset)
      throw new GLException("array offset argument \"groupString_offset\" (" + groupString_offset + ") equals or exceeds array length (" + groupString.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorGroupStringAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPerfMonitorGroupStringAMD\" not available");
    }
        dispatch_glGetPerfMonitorGroupStringAMD1(group, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, groupString, groupString_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupsAMD}(GLint *  numGroups, GLsizei groupsSize, GLuint *  groups); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param numGroups a direct or array-backed {@link java.nio.IntBuffer}
      @param groups a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetPerfMonitorGroupsAMD(IntBuffer numGroups, int groupsSize, IntBuffer groups)  {

    final boolean numGroups_is_direct = Buffers.isDirect(numGroups);
    final boolean groups_is_direct = Buffers.isDirect(groups);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorGroupsAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPerfMonitorGroupsAMD\" not available");
    }
        dispatch_glGetPerfMonitorGroupsAMD1(numGroups_is_direct ? numGroups : Buffers.getArray(numGroups), numGroups_is_direct ? Buffers.getDirectBufferByteOffset(numGroups) : Buffers.getIndirectBufferByteOffset(numGroups), numGroups_is_direct, groupsSize, groups_is_direct ? groups : Buffers.getArray(groups), groups_is_direct ? Buffers.getDirectBufferByteOffset(groups) : Buffers.getIndirectBufferByteOffset(groups), groups_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupsAMD}(GLint *  numGroups, GLsizei groupsSize, GLuint *  groups); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param numGroups a direct or array-backed {@link java.nio.IntBuffer}
      @param groups a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetPerfMonitorGroupsAMD1(Object numGroups, int numGroups_byte_offset, boolean numGroups_is_direct, int groupsSize, Object groups, int groups_byte_offset, boolean groups_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupsAMD}(GLint *  numGroups, GLsizei groupsSize, GLuint *  groups); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glGetPerfMonitorGroupsAMD(int[] numGroups, int numGroups_offset, int groupsSize, int[] groups, int groups_offset)  {

    if(numGroups != null && numGroups.length <= numGroups_offset)
      throw new GLException("array offset argument \"numGroups_offset\" (" + numGroups_offset + ") equals or exceeds array length (" + numGroups.length + ")");
    if(groups != null && groups.length <= groups_offset)
      throw new GLException("array offset argument \"groups_offset\" (" + groups_offset + ") equals or exceeds array length (" + groups.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorGroupsAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetPerfMonitorGroupsAMD\" not available");
    }
        dispatch_glGetPerfMonitorGroupsAMD1(numGroups, Buffers.SIZEOF_INT * numGroups_offset, false, groupsSize, groups, Buffers.SIZEOF_INT * groups_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramBinaryOES}(GLuint program, GLsizei bufSize, GLsizei *  length, GLenum *  binaryFormat, GLvoid *  binary); </code> <br>Part of <code>GL_ARB_get_program_binary</code>; <code>GL_OES_get_program_binary</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param binaryFormat a direct or array-backed {@link java.nio.IntBuffer}
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetProgramBinary(int program, int bufSize, IntBuffer length, IntBuffer binaryFormat, Buffer binary)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean binaryFormat_is_direct = Buffers.isDirect(binaryFormat);
    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramBinary;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramBinary\" not available");
    }
        dispatch_glGetProgramBinary1(program, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, binaryFormat_is_direct ? binaryFormat : Buffers.getArray(binaryFormat), binaryFormat_is_direct ? Buffers.getDirectBufferByteOffset(binaryFormat) : Buffers.getIndirectBufferByteOffset(binaryFormat), binaryFormat_is_direct, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramBinaryOES}(GLuint program, GLsizei bufSize, GLsizei *  length, GLenum *  binaryFormat, GLvoid *  binary); </code> <br>Part of <code>GL_ARB_get_program_binary</code>; <code>GL_OES_get_program_binary</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param binaryFormat a direct or array-backed {@link java.nio.IntBuffer}
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetProgramBinary1(int program, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object binaryFormat, int binaryFormat_byte_offset, boolean binaryFormat_is_direct, Object binary, int binary_byte_offset, boolean binary_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramBinaryOES}(GLuint program, GLsizei bufSize, GLsizei *  length, GLenum *  binaryFormat, GLvoid *  binary); </code> <br>Part of <code>GL_ARB_get_program_binary</code>; <code>GL_OES_get_program_binary</code>
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetProgramBinary(int program, int bufSize, int[] length, int length_offset, int[] binaryFormat, int binaryFormat_offset, Buffer binary)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(binaryFormat != null && binaryFormat.length <= binaryFormat_offset)
      throw new GLException("array offset argument \"binaryFormat_offset\" (" + binaryFormat_offset + ") equals or exceeds array length (" + binaryFormat.length + ")");
    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramBinary;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramBinary\" not available");
    }
        dispatch_glGetProgramBinary1(program, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, binaryFormat, Buffers.SIZEOF_INT * binaryFormat_offset, false, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramInfoLog}(GLuint program, GLsizei bufsize, GLsizei *  length, GLchar *  infolog); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infolog a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetProgramInfoLog(int program, int bufsize, IntBuffer length, ByteBuffer infolog)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean infolog_is_direct = Buffers.isDirect(infolog);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramInfoLog;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramInfoLog\" not available");
    }
        dispatch_glGetProgramInfoLog1(program, bufsize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, infolog_is_direct ? infolog : Buffers.getArray(infolog), infolog_is_direct ? Buffers.getDirectBufferByteOffset(infolog) : Buffers.getIndirectBufferByteOffset(infolog), infolog_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramInfoLog}(GLuint program, GLsizei bufsize, GLsizei *  length, GLchar *  infolog); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infolog a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetProgramInfoLog1(int program, int bufsize, Object length, int length_byte_offset, boolean length_is_direct, Object infolog, int infolog_byte_offset, boolean infolog_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramInfoLog}(GLuint program, GLsizei bufsize, GLsizei *  length, GLchar *  infolog); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetProgramInfoLog(int program, int bufsize, int[] length, int length_offset, byte[] infolog, int infolog_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(infolog != null && infolog.length <= infolog_offset)
      throw new GLException("array offset argument \"infolog_offset\" (" + infolog_offset + ") equals or exceeds array length (" + infolog.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramInfoLog;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramInfoLog\" not available");
    }
        dispatch_glGetProgramInfoLog1(program, bufsize, length, Buffers.SIZEOF_INT * length_offset, false, infolog, infolog_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramiv}(GLuint program, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramiv(int program, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramiv\" not available");
    }
        dispatch_glGetProgramiv1(program, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramiv}(GLuint program, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramiv1(int program, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramiv}(GLuint program, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetProgramiv(int program, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetProgramiv\" not available");
    }
        dispatch_glGetProgramiv1(program, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectuivEXT}(GLuint id, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetQueryObjectuiv(int id, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryObjectuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetQueryObjectuiv\" not available");
    }
        dispatch_glGetQueryObjectuiv1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectuivEXT}(GLuint id, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetQueryObjectuiv1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjectuivEXT}(GLuint id, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>   */
  public void glGetQueryObjectuiv(int id, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryObjectuiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetQueryObjectuiv\" not available");
    }
        dispatch_glGetQueryObjectuiv1(id, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryivEXT}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetQueryiv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetQueryiv\" not available");
    }
        dispatch_glGetQueryiv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryivEXT}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetQueryiv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryivEXT}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>   */
  public void glGetQueryiv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetQueryiv\" not available");
    }
        dispatch_glGetQueryiv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetRenderbufferParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetRenderbufferParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetRenderbufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetRenderbufferParameteriv\" not available");
    }
        dispatch_glGetRenderbufferParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetRenderbufferParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetRenderbufferParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetRenderbufferParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetRenderbufferParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetRenderbufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetRenderbufferParameteriv\" not available");
    }
        dispatch_glGetRenderbufferParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderInfoLog}(GLuint shader, GLsizei bufsize, GLsizei *  length, GLchar *  infolog); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infolog a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetShaderInfoLog(int shader, int bufsize, IntBuffer length, ByteBuffer infolog)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean infolog_is_direct = Buffers.isDirect(infolog);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderInfoLog;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetShaderInfoLog\" not available");
    }
        dispatch_glGetShaderInfoLog1(shader, bufsize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, infolog_is_direct ? infolog : Buffers.getArray(infolog), infolog_is_direct ? Buffers.getDirectBufferByteOffset(infolog) : Buffers.getIndirectBufferByteOffset(infolog), infolog_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderInfoLog}(GLuint shader, GLsizei bufsize, GLsizei *  length, GLchar *  infolog); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infolog a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetShaderInfoLog1(int shader, int bufsize, Object length, int length_byte_offset, boolean length_is_direct, Object infolog, int infolog_byte_offset, boolean infolog_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetShaderInfoLog}(GLuint shader, GLsizei bufsize, GLsizei *  length, GLchar *  infolog); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetShaderInfoLog(int shader, int bufsize, int[] length, int length_offset, byte[] infolog, int infolog_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(infolog != null && infolog.length <= infolog_offset)
      throw new GLException("array offset argument \"infolog_offset\" (" + infolog_offset + ") equals or exceeds array length (" + infolog.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderInfoLog;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetShaderInfoLog\" not available");
    }
        dispatch_glGetShaderInfoLog1(shader, bufsize, length, Buffers.SIZEOF_INT * length_offset, false, infolog, infolog_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderPrecisionFormat}(GLenum shadertype, GLenum precisiontype, GLint *  range, GLint *  precision); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>
      @param range a direct or array-backed {@link java.nio.IntBuffer}
      @param precision a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetShaderPrecisionFormat(int shadertype, int precisiontype, IntBuffer range, IntBuffer precision)  {

    if ( !_context.isGLES2Compatible() ) {
    throw new GLException("Method \"glGetShaderPrecisionFormat\" not available");
    }
    final boolean range_is_direct = Buffers.isDirect(range);
    final boolean precision_is_direct = Buffers.isDirect(precision);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderPrecisionFormat;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetShaderPrecisionFormat\" not available");
    }
        dispatch_glGetShaderPrecisionFormat1(shadertype, precisiontype, range_is_direct ? range : Buffers.getArray(range), range_is_direct ? Buffers.getDirectBufferByteOffset(range) : Buffers.getIndirectBufferByteOffset(range), range_is_direct, precision_is_direct ? precision : Buffers.getArray(precision), precision_is_direct ? Buffers.getDirectBufferByteOffset(precision) : Buffers.getIndirectBufferByteOffset(precision), precision_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderPrecisionFormat}(GLenum shadertype, GLenum precisiontype, GLint *  range, GLint *  precision); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>
      @param range a direct or array-backed {@link java.nio.IntBuffer}
      @param precision a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetShaderPrecisionFormat1(int shadertype, int precisiontype, Object range, int range_byte_offset, boolean range_is_direct, Object precision, int precision_byte_offset, boolean precision_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetShaderPrecisionFormat}(GLenum shadertype, GLenum precisiontype, GLint *  range, GLint *  precision); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetShaderPrecisionFormat(int shadertype, int precisiontype, int[] range, int range_offset, int[] precision, int precision_offset)  {

    if ( !_context.isGLES2Compatible() ) {
    throw new GLException("Method \"glGetShaderPrecisionFormat\" not available");
    }
    if(range != null && range.length <= range_offset)
      throw new GLException("array offset argument \"range_offset\" (" + range_offset + ") equals or exceeds array length (" + range.length + ")");
    if(precision != null && precision.length <= precision_offset)
      throw new GLException("array offset argument \"precision_offset\" (" + precision_offset + ") equals or exceeds array length (" + precision.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderPrecisionFormat;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetShaderPrecisionFormat\" not available");
    }
        dispatch_glGetShaderPrecisionFormat1(shadertype, precisiontype, range, Buffers.SIZEOF_INT * range_offset, false, precision, Buffers.SIZEOF_INT * precision_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderSource}(GLuint shader, GLsizei bufsize, GLsizei *  length, GLchar *  source); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param source a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetShaderSource(int shader, int bufsize, IntBuffer length, ByteBuffer source)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean source_is_direct = Buffers.isDirect(source);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderSource;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetShaderSource\" not available");
    }
        dispatch_glGetShaderSource1(shader, bufsize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, source_is_direct ? source : Buffers.getArray(source), source_is_direct ? Buffers.getDirectBufferByteOffset(source) : Buffers.getIndirectBufferByteOffset(source), source_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderSource}(GLuint shader, GLsizei bufsize, GLsizei *  length, GLchar *  source); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param source a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetShaderSource1(int shader, int bufsize, Object length, int length_byte_offset, boolean length_is_direct, Object source, int source_byte_offset, boolean source_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetShaderSource}(GLuint shader, GLsizei bufsize, GLsizei *  length, GLchar *  source); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetShaderSource(int shader, int bufsize, int[] length, int length_offset, byte[] source, int source_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(source != null && source.length <= source_offset)
      throw new GLException("array offset argument \"source_offset\" (" + source_offset + ") equals or exceeds array length (" + source.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderSource;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetShaderSource\" not available");
    }
        dispatch_glGetShaderSource1(shader, bufsize, length, Buffers.SIZEOF_INT * length_offset, false, source, source_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderiv}(GLuint shader, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetShaderiv(int shader, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetShaderiv\" not available");
    }
        dispatch_glGetShaderiv1(shader, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderiv}(GLuint shader, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetShaderiv1(int shader, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetShaderiv}(GLuint shader, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetShaderiv(int shader, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetShaderiv\" not available");
    }
        dispatch_glGetShaderiv1(shader, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> const GLubyte *  {@native glGetString}(GLenum name); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public String glGetString(int name)  {

    if(_context.isExtensionCacheInitialized()) {
    if(GL.GL_EXTENSIONS==name) {
    return _context.getGLExtensionsString();
    } /* else if(GL.GL_VERSION==name) {
    return _context.getGLVersion();
    } */
    }
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetString;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetString\" not available");
    }
        return dispatch_glGetString1(name, __addr_);
  }

  /** Entry point to C language function: <code> const GLubyte *  {@native glGetString}(GLenum name); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native String dispatch_glGetString1(int name, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTexParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexParameterfv\" not available");
    }
        dispatch_glGetTexParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTexParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetTexParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexParameterfv\" not available");
    }
        dispatch_glGetTexParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexParameteriv\" not available");
    }
        dispatch_glGetTexParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetTexParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetTexParameteriv\" not available");
    }
        dispatch_glGetTexParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> int {@native glGetUniformLocation}(GLuint program, const GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public int glGetUniformLocation(int program, String name)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformLocation;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformLocation\" not available");
    }
        return dispatch_glGetUniformLocation1(program, name, __addr_);
  }

  /** Entry point to C language function: <code> int {@native glGetUniformLocation}(GLuint program, const GLchar *  name); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native int dispatch_glGetUniformLocation1(int program, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformfv}(GLuint program, GLint location, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetUniformfv(int program, int location, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformfv\" not available");
    }
        dispatch_glGetUniformfv1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformfv}(GLuint program, GLint location, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetUniformfv1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformfv}(GLuint program, GLint location, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetUniformfv(int program, int location, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformfv\" not available");
    }
        dispatch_glGetUniformfv1(program, location, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformiv}(GLuint program, GLint location, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetUniformiv(int program, int location, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformiv\" not available");
    }
        dispatch_glGetUniformiv1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformiv}(GLuint program, GLint location, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetUniformiv1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformiv}(GLuint program, GLint location, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetUniformiv(int program, int location, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetUniformiv\" not available");
    }
        dispatch_glGetUniformiv1(program, location, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribfv}(GLuint index, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetVertexAttribfv(int index, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribfv\" not available");
    }
        dispatch_glGetVertexAttribfv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribfv}(GLuint index, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetVertexAttribfv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribfv}(GLuint index, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetVertexAttribfv(int index, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribfv\" not available");
    }
        dispatch_glGetVertexAttribfv1(index, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribiv}(GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVertexAttribiv(int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribiv\" not available");
    }
        dispatch_glGetVertexAttribiv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribiv}(GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVertexAttribiv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribiv}(GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetVertexAttribiv(int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetVertexAttribiv\" not available");
    }
        dispatch_glGetVertexAttribiv1(index, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformfvEXT}(GLuint program, GLint location, GLsizei bufSize, float *  params); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetnUniformfv(int program, int location, int bufSize, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnUniformfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnUniformfv\" not available");
    }
        dispatch_glGetnUniformfv1(program, location, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformfvEXT}(GLuint program, GLint location, GLsizei bufSize, float *  params); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetnUniformfv1(int program, int location, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformfvEXT}(GLuint program, GLint location, GLsizei bufSize, float *  params); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>   */
  public void glGetnUniformfv(int program, int location, int bufSize, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnUniformfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnUniformfv\" not available");
    }
        dispatch_glGetnUniformfv1(program, location, bufSize, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformivEXT}(GLuint program, GLint location, GLsizei bufSize, GLint *  params); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetnUniformiv(int program, int location, int bufSize, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnUniformiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnUniformiv\" not available");
    }
        dispatch_glGetnUniformiv1(program, location, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformivEXT}(GLuint program, GLint location, GLsizei bufSize, GLint *  params); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetnUniformiv1(int program, int location, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformivEXT}(GLuint program, GLint location, GLsizei bufSize, GLint *  params); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>   */
  public void glGetnUniformiv(int program, int location, int bufSize, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnUniformiv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glGetnUniformiv\" not available");
    }
        dispatch_glGetnUniformiv1(program, location, bufSize, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glHint}(GLenum target, GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glHint(int target, int mode)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glHint;
    if (__addr_ == 0) {
      throw new GLException("Method \"glHint\" not available");
    }
        dispatch_glHint1(target, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glHint}(GLenum target, GLenum mode); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glHint1(int target, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glInsertEventMarkerEXT}(GLsizei length, const GLchar *  marker); </code> <br>Part of <code>GL_EXT_debug_marker</code>
      @param marker a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glInsertEventMarkerEXT(int length, ByteBuffer marker)  {

    final boolean marker_is_direct = Buffers.isDirect(marker);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glInsertEventMarkerEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glInsertEventMarkerEXT\" not available");
    }
        dispatch_glInsertEventMarkerEXT1(length, marker_is_direct ? marker : Buffers.getArray(marker), marker_is_direct ? Buffers.getDirectBufferByteOffset(marker) : Buffers.getIndirectBufferByteOffset(marker), marker_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInsertEventMarkerEXT}(GLsizei length, const GLchar *  marker); </code> <br>Part of <code>GL_EXT_debug_marker</code>
      @param marker a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glInsertEventMarkerEXT1(int length, Object marker, int marker_byte_offset, boolean marker_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glInsertEventMarkerEXT}(GLsizei length, const GLchar *  marker); </code> <br>Part of <code>GL_EXT_debug_marker</code>   */
  public void glInsertEventMarkerEXT(int length, byte[] marker, int marker_offset)  {

    if(marker != null && marker.length <= marker_offset)
      throw new GLException("array offset argument \"marker_offset\" (" + marker_offset + ") equals or exceeds array length (" + marker.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glInsertEventMarkerEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glInsertEventMarkerEXT\" not available");
    }
        dispatch_glInsertEventMarkerEXT1(length, marker, marker_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsBuffer}(GLuint buffer); </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>   */
  public boolean glIsBuffer(int buffer)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsBuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsBuffer\" not available");
    }
        return dispatch_glIsBuffer1(buffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsBuffer}(GLuint buffer); </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native boolean dispatch_glIsBuffer1(int buffer, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabled}(GLenum cap); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public boolean glIsEnabled(int cap)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsEnabled;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsEnabled\" not available");
    }
        return dispatch_glIsEnabled1(cap, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabled}(GLenum cap); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native boolean dispatch_glIsEnabled1(int cap, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsFenceNV}(GLuint target); </code> <br>Part of <code>GL_NV_fence</code>   */
  public boolean glIsFenceNV(int target)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsFenceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsFenceNV\" not available");
    }
        return dispatch_glIsFenceNV1(target, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsFenceNV}(GLuint target); </code> <br>Part of <code>GL_NV_fence</code>   */
  public native boolean dispatch_glIsFenceNV1(int target, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsFramebuffer}(GLuint framebuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  public boolean glIsFramebuffer(int framebuffer)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsFramebuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsFramebuffer\" not available");
    }
        return dispatch_glIsFramebuffer1(framebuffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsFramebuffer}(GLuint framebuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native boolean dispatch_glIsFramebuffer1(int framebuffer, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsProgram}(GLuint program); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public boolean glIsProgram(int program)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsProgram;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsProgram\" not available");
    }
        return dispatch_glIsProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsProgram}(GLuint program); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native boolean dispatch_glIsProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsQueryEXT}(GLuint id); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>   */
  public boolean glIsQuery(int id)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsQuery;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsQuery\" not available");
    }
        return dispatch_glIsQuery1(id, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsQueryEXT}(GLuint id); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>   */
  public native boolean dispatch_glIsQuery1(int id, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsRenderbuffer}(GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  public boolean glIsRenderbuffer(int renderbuffer)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsRenderbuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsRenderbuffer\" not available");
    }
        return dispatch_glIsRenderbuffer1(renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsRenderbuffer}(GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native boolean dispatch_glIsRenderbuffer1(int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsShader}(GLuint shader); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public boolean glIsShader(int shader)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsShader;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsShader\" not available");
    }
        return dispatch_glIsShader1(shader, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsShader}(GLuint shader); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native boolean dispatch_glIsShader1(int shader, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsTexture}(GLuint texture); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  public boolean glIsTexture(int texture)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsTexture;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsTexture\" not available");
    }
        return dispatch_glIsTexture1(texture, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsTexture}(GLuint texture); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native boolean dispatch_glIsTexture1(int texture, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsVertexArrayOES}(GLuint array); </code> <br>Part of <code>GL_OES_vertex_array_object</code>   */
  public boolean glIsVertexArrayOES(int array)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsVertexArrayOES;
    if (__addr_ == 0) {
      throw new GLException("Method \"glIsVertexArrayOES\" not available");
    }
        return dispatch_glIsVertexArrayOES1(array, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsVertexArrayOES}(GLuint array); </code> <br>Part of <code>GL_OES_vertex_array_object</code>   */
  public native boolean dispatch_glIsVertexArrayOES1(int array, long procAddress);

  /** Entry point to C language function: <code> void {@native glLabelObjectEXT}(GLenum type, GLuint object, GLsizei length, const GLchar *  label); </code> <br>Part of <code>GL_EXT_debug_label</code>
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glLabelObjectEXT(int type, int object, int length, ByteBuffer label)  {

    final boolean label_is_direct = Buffers.isDirect(label);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLabelObjectEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLabelObjectEXT\" not available");
    }
        dispatch_glLabelObjectEXT1(type, object, length, label_is_direct ? label : Buffers.getArray(label), label_is_direct ? Buffers.getDirectBufferByteOffset(label) : Buffers.getIndirectBufferByteOffset(label), label_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLabelObjectEXT}(GLenum type, GLuint object, GLsizei length, const GLchar *  label); </code> <br>Part of <code>GL_EXT_debug_label</code>
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glLabelObjectEXT1(int type, int object, int length, Object label, int label_byte_offset, boolean label_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLabelObjectEXT}(GLenum type, GLuint object, GLsizei length, const GLchar *  label); </code> <br>Part of <code>GL_EXT_debug_label</code>   */
  public void glLabelObjectEXT(int type, int object, int length, byte[] label, int label_offset)  {

    if(label != null && label.length <= label_offset)
      throw new GLException("array offset argument \"label_offset\" (" + label_offset + ") equals or exceeds array length (" + label.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLabelObjectEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLabelObjectEXT\" not available");
    }
        dispatch_glLabelObjectEXT1(type, object, length, label, label_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLineWidth}(GLfloat width); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glLineWidth(float width)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLineWidth;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLineWidth\" not available");
    }
        dispatch_glLineWidth1(width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLineWidth}(GLfloat width); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glLineWidth1(float width, long procAddress);

  /** Entry point to C language function: <code> void {@native glLinkProgram}(GLuint program); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glLinkProgram(int program)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLinkProgram;
    if (__addr_ == 0) {
      throw new GLException("Method \"glLinkProgram\" not available");
    }
        dispatch_glLinkProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLinkProgram}(GLuint program); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glLinkProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelStorei}(GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glPixelStorei(int pname, int param)  {

    if (pname != GL_PACK_ALIGNMENT && pname != GL_UNPACK_ALIGNMENT) {
    throw new GLException("Unsupported pixel store parameter name 0x" + Integer.toHexString(pname));
    }
    glStateTracker.setInt(pname, param);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelStorei;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPixelStorei\" not available");
    }
        dispatch_glPixelStorei1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelStorei}(GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glPixelStorei1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPolygonOffset}(GLfloat factor, GLfloat units); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glPolygonOffset(float factor, float units)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPolygonOffset;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPolygonOffset\" not available");
    }
        dispatch_glPolygonOffset1(factor, units, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPolygonOffset}(GLfloat factor, GLfloat units); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glPolygonOffset1(float factor, float units, long procAddress);

  /** Entry point to C language function: <code> void {@native glPopGroupMarkerEXT}(void); </code> <br>Part of <code>GL_EXT_debug_marker</code>   */
  public void glPopGroupMarkerEXT()  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPopGroupMarkerEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPopGroupMarkerEXT\" not available");
    }
        dispatch_glPopGroupMarkerEXT1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPopGroupMarkerEXT}(void); </code> <br>Part of <code>GL_EXT_debug_marker</code>   */
  public native void dispatch_glPopGroupMarkerEXT1(long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramBinaryOES}(GLuint program, GLenum binaryFormat, const GLvoid *  binary, GLint length); </code> <br>Part of <code>GL_ARB_get_program_binary</code>; <code>GL_OES_get_program_binary</code>
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glProgramBinary(int program, int binaryFormat, Buffer binary, int length)  {

    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramBinary;
    if (__addr_ == 0) {
      throw new GLException("Method \"glProgramBinary\" not available");
    }
        dispatch_glProgramBinary1(program, binaryFormat, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramBinaryOES}(GLuint program, GLenum binaryFormat, const GLvoid *  binary, GLint length); </code> <br>Part of <code>GL_ARB_get_program_binary</code>; <code>GL_OES_get_program_binary</code>
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glProgramBinary1(int program, int binaryFormat, Object binary, int binary_byte_offset, boolean binary_is_direct, int length, long procAddress);

  /** Entry point to C language function: <code> void {@native glPushGroupMarkerEXT}(GLsizei length, const GLchar *  marker); </code> <br>Part of <code>GL_EXT_debug_marker</code>
      @param marker a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glPushGroupMarkerEXT(int length, ByteBuffer marker)  {

    final boolean marker_is_direct = Buffers.isDirect(marker);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPushGroupMarkerEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPushGroupMarkerEXT\" not available");
    }
        dispatch_glPushGroupMarkerEXT1(length, marker_is_direct ? marker : Buffers.getArray(marker), marker_is_direct ? Buffers.getDirectBufferByteOffset(marker) : Buffers.getIndirectBufferByteOffset(marker), marker_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPushGroupMarkerEXT}(GLsizei length, const GLchar *  marker); </code> <br>Part of <code>GL_EXT_debug_marker</code>
      @param marker a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glPushGroupMarkerEXT1(int length, Object marker, int marker_byte_offset, boolean marker_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPushGroupMarkerEXT}(GLsizei length, const GLchar *  marker); </code> <br>Part of <code>GL_EXT_debug_marker</code>   */
  public void glPushGroupMarkerEXT(int length, byte[] marker, int marker_offset)  {

    if(marker != null && marker.length <= marker_offset)
      throw new GLException("array offset argument \"marker_offset\" (" + marker_offset + ") equals or exceeds array length (" + marker.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPushGroupMarkerEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glPushGroupMarkerEXT\" not available");
    }
        dispatch_glPushGroupMarkerEXT1(length, marker, marker_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadBufferNV}(GLenum mode); </code> <br>Part of <code>GL_NV_read_buffer</code>   */
  public void glReadBufferNV(int mode)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glReadBufferNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glReadBufferNV\" not available");
    }
        dispatch_glReadBufferNV1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadBufferNV}(GLenum mode); </code> <br>Part of <code>GL_NV_read_buffer</code>   */
  public native void dispatch_glReadBufferNV1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glReadPixels(int x, int y, int width, int height, int format, int type, Buffer pixels)  {

    checkPackPBODisabled(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width            , height            , 1    , true));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glReadPixels;
    if (__addr_ == 0) {
      throw new GLException("Method \"glReadPixels\" not available");
    }
        dispatch_glReadPixels1(x, y, width, height, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glReadPixels1(int x, int y, int width, int height, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glReadPixels(int x, int y, int width, int height, int format, int type, long pixels_buffer_offset)  {

    checkPackPBOEnabled(true);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glReadPixels;
    if (__addr_ == 0) {
      throw new GLException("Method \"glReadPixels\" not available");
    }
        dispatch_glReadPixels1(x, y, width, height, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glReadPixels1(int x, int y, int width, int height, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glReadnPixelsEXT}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *  data); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glReadnPixels(int x, int y, int width, int height, int format, int type, int bufSize, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glReadnPixels;
    if (__addr_ == 0) {
      throw new GLException("Method \"glReadnPixels\" not available");
    }
        dispatch_glReadnPixels1(x, y, width, height, format, type, bufSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadnPixelsEXT}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *  data); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glReadnPixels1(int x, int y, int width, int height, int format, int type, int bufSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glReleaseShaderCompiler}(void); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glReleaseShaderCompiler()  {

    if ( !_context.isGLES2Compatible() ) {
    return;
    }
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glReleaseShaderCompiler;
    if (__addr_ == 0) {
      throw new GLException("Method \"glReleaseShaderCompiler\" not available");
    }
        dispatch_glReleaseShaderCompiler1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glReleaseShaderCompiler}(void); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glReleaseShaderCompiler1(long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorage}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glRenderbufferStorage(int target, int internalformat, int width, int height)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glRenderbufferStorage;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRenderbufferStorage\" not available");
    }
        dispatch_glRenderbufferStorage1(target, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorage}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glRenderbufferStorage1(int target, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleANGLE}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ANGLE_framebuffer_multisample</code>   */
  public void glRenderbufferStorageMultisampleANGLE(int target, int samples, int internalformat, int width, int height)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glRenderbufferStorageMultisampleANGLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRenderbufferStorageMultisampleANGLE\" not available");
    }
        dispatch_glRenderbufferStorageMultisampleANGLE1(target, samples, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleANGLE}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ANGLE_framebuffer_multisample</code>   */
  public native void dispatch_glRenderbufferStorageMultisampleANGLE1(int target, int samples, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleAPPLE}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_APPLE_framebuffer_multisample</code>   */
  public void glRenderbufferStorageMultisampleAPPLE(int target, int samples, int internalformat, int width, int height)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glRenderbufferStorageMultisampleAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRenderbufferStorageMultisampleAPPLE\" not available");
    }
        dispatch_glRenderbufferStorageMultisampleAPPLE1(target, samples, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleAPPLE}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_APPLE_framebuffer_multisample</code>   */
  public native void dispatch_glRenderbufferStorageMultisampleAPPLE1(int target, int samples, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleIMG}(GLenum, GLsizei, GLenum, GLsizei, GLsizei); </code> <br>Part of <code>GL_IMG_multisampled_render_to_texture</code>   */
  public void glRenderbufferStorageMultisampleIMG(int arg0, int arg1, int arg2, int arg3, int arg4)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glRenderbufferStorageMultisampleIMG;
    if (__addr_ == 0) {
      throw new GLException("Method \"glRenderbufferStorageMultisampleIMG\" not available");
    }
        dispatch_glRenderbufferStorageMultisampleIMG1(arg0, arg1, arg2, arg3, arg4, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleIMG}(GLenum, GLsizei, GLenum, GLsizei, GLsizei); </code> <br>Part of <code>GL_IMG_multisampled_render_to_texture</code>   */
  public native void dispatch_glRenderbufferStorageMultisampleIMG1(int arg0, int arg1, int arg2, int arg3, int arg4, long procAddress);

  /** Entry point to C language function: <code> void {@native glResolveMultisampleFramebufferAPPLE}(void); </code> <br>Part of <code>GL_APPLE_framebuffer_multisample</code>   */
  public void glResolveMultisampleFramebufferAPPLE()  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glResolveMultisampleFramebufferAPPLE;
    if (__addr_ == 0) {
      throw new GLException("Method \"glResolveMultisampleFramebufferAPPLE\" not available");
    }
        dispatch_glResolveMultisampleFramebufferAPPLE1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glResolveMultisampleFramebufferAPPLE}(void); </code> <br>Part of <code>GL_APPLE_framebuffer_multisample</code>   */
  public native void dispatch_glResolveMultisampleFramebufferAPPLE1(long procAddress);

  /** Entry point to C language function: <code> void {@native glSampleCoverage}(GLclampf value, GLboolean invert); </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glSampleCoverage(float value, boolean invert)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glSampleCoverage;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSampleCoverage\" not available");
    }
        dispatch_glSampleCoverage1(value, invert, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSampleCoverage}(GLclampf value, GLboolean invert); </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glSampleCoverage1(float value, boolean invert, long procAddress);

  /** Entry point to C language function: <code> void {@native glScissor}(GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glScissor(int x, int y, int width, int height)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glScissor;
    if (__addr_ == 0) {
      throw new GLException("Method \"glScissor\" not available");
    }
        dispatch_glScissor1(x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScissor}(GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glScissor1(int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glSelectPerfMonitorCountersAMD}(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *  countersList); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param countersList a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glSelectPerfMonitorCountersAMD(int monitor, boolean enable, int group, int numCounters, IntBuffer countersList)  {

    final boolean countersList_is_direct = Buffers.isDirect(countersList);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glSelectPerfMonitorCountersAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSelectPerfMonitorCountersAMD\" not available");
    }
        dispatch_glSelectPerfMonitorCountersAMD1(monitor, enable, group, numCounters, countersList_is_direct ? countersList : Buffers.getArray(countersList), countersList_is_direct ? Buffers.getDirectBufferByteOffset(countersList) : Buffers.getIndirectBufferByteOffset(countersList), countersList_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSelectPerfMonitorCountersAMD}(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *  countersList); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param countersList a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glSelectPerfMonitorCountersAMD1(int monitor, boolean enable, int group, int numCounters, Object countersList, int countersList_byte_offset, boolean countersList_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSelectPerfMonitorCountersAMD}(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *  countersList); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glSelectPerfMonitorCountersAMD(int monitor, boolean enable, int group, int numCounters, int[] countersList, int countersList_offset)  {

    if(countersList != null && countersList.length <= countersList_offset)
      throw new GLException("array offset argument \"countersList_offset\" (" + countersList_offset + ") equals or exceeds array length (" + countersList.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glSelectPerfMonitorCountersAMD;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSelectPerfMonitorCountersAMD\" not available");
    }
        dispatch_glSelectPerfMonitorCountersAMD1(monitor, enable, group, numCounters, countersList, Buffers.SIZEOF_INT * countersList_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSetFenceNV}(GLuint target, GLenum id); </code> <br>Part of <code>GL_NV_fence</code>   */
  public void glSetFenceNV(int target, int id)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glSetFenceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glSetFenceNV\" not available");
    }
        dispatch_glSetFenceNV1(target, id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSetFenceNV}(GLuint target, GLenum id); </code> <br>Part of <code>GL_NV_fence</code>   */
  public native void dispatch_glSetFenceNV1(int target, int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderBinary}(GLsizei n, const GLuint *  shaders, GLenum binaryformat, const GLvoid *  binary, GLsizei length); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glShaderBinary(int n, IntBuffer shaders, int binaryformat, Buffer binary, int length)  {

    if ( !_context.isGLES2Compatible() ) {
    throw new GLException("Method \"glShaderBinary\" not available");
    }
    final boolean shaders_is_direct = Buffers.isDirect(shaders);
    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glShaderBinary;
    if (__addr_ == 0) {
      throw new GLException("Method \"glShaderBinary\" not available");
    }
        dispatch_glShaderBinary1(n, shaders_is_direct ? shaders : Buffers.getArray(shaders), shaders_is_direct ? Buffers.getDirectBufferByteOffset(shaders) : Buffers.getIndirectBufferByteOffset(shaders), shaders_is_direct, binaryformat, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderBinary}(GLsizei n, const GLuint *  shaders, GLenum binaryformat, const GLvoid *  binary, GLsizei length); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glShaderBinary1(int n, Object shaders, int shaders_byte_offset, boolean shaders_is_direct, int binaryformat, Object binary, int binary_byte_offset, boolean binary_is_direct, int length, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderBinary}(GLsizei n, const GLuint *  shaders, GLenum binaryformat, const GLvoid *  binary, GLsizei length); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glShaderBinary(int n, int[] shaders, int shaders_offset, int binaryformat, Buffer binary, int length)  {

    if ( !_context.isGLES2Compatible() ) {
    throw new GLException("Method \"glShaderBinary\" not available");
    }
    if(shaders != null && shaders.length <= shaders_offset)
      throw new GLException("array offset argument \"shaders_offset\" (" + shaders_offset + ") equals or exceeds array length (" + shaders.length + ")");
    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glShaderBinary;
    if (__addr_ == 0) {
      throw new GLException("Method \"glShaderBinary\" not available");
    }
        dispatch_glShaderBinary1(n, shaders, Buffers.SIZEOF_INT * shaders_offset, false, binaryformat, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderSource}(GLuint shader, GLsizei count, const GLchar *  *  string, const GLint *  length); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glShaderSource(int shader, int count, String[] string, IntBuffer length)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glShaderSource;
    if (__addr_ == 0) {
      throw new GLException("Method \"glShaderSource\" not available");
    }
        dispatch_glShaderSource1(shader, count, string, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderSource}(GLuint shader, GLsizei count, const GLchar *  *  string, const GLint *  length); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glShaderSource1(int shader, int count, String[] string, Object length, int length_byte_offset, boolean length_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderSource}(GLuint shader, GLsizei count, const GLchar *  *  string, const GLint *  length); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glShaderSource(int shader, int count, String[] string, int[] length, int length_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glShaderSource;
    if (__addr_ == 0) {
      throw new GLException("Method \"glShaderSource\" not available");
    }
        dispatch_glShaderSource1(shader, count, string, length, Buffers.SIZEOF_INT * length_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStartTilingQCOM}(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask); </code> <br>Part of <code>GL_QCOM_tiled_rendering</code>   */
  public void glStartTilingQCOM(int x, int y, int width, int height, int preserveMask)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glStartTilingQCOM;
    if (__addr_ == 0) {
      throw new GLException("Method \"glStartTilingQCOM\" not available");
    }
        dispatch_glStartTilingQCOM1(x, y, width, height, preserveMask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStartTilingQCOM}(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask); </code> <br>Part of <code>GL_QCOM_tiled_rendering</code>   */
  public native void dispatch_glStartTilingQCOM1(int x, int y, int width, int height, int preserveMask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilFunc}(GLenum func, GLint ref, GLuint mask); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glStencilFunc(int func, int ref, int mask)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glStencilFunc;
    if (__addr_ == 0) {
      throw new GLException("Method \"glStencilFunc\" not available");
    }
        dispatch_glStencilFunc1(func, ref, mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilFunc}(GLenum func, GLint ref, GLuint mask); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glStencilFunc1(int func, int ref, int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilFuncSeparate}(GLenum face, GLenum func, GLint ref, GLuint mask); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glStencilFuncSeparate(int face, int func, int ref, int mask)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glStencilFuncSeparate;
    if (__addr_ == 0) {
      throw new GLException("Method \"glStencilFuncSeparate\" not available");
    }
        dispatch_glStencilFuncSeparate1(face, func, ref, mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilFuncSeparate}(GLenum face, GLenum func, GLint ref, GLuint mask); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glStencilFuncSeparate1(int face, int func, int ref, int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilMask}(GLuint mask); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glStencilMask(int mask)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glStencilMask;
    if (__addr_ == 0) {
      throw new GLException("Method \"glStencilMask\" not available");
    }
        dispatch_glStencilMask1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilMask}(GLuint mask); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glStencilMask1(int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilMaskSeparate}(GLenum face, GLuint mask); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glStencilMaskSeparate(int face, int mask)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glStencilMaskSeparate;
    if (__addr_ == 0) {
      throw new GLException("Method \"glStencilMaskSeparate\" not available");
    }
        dispatch_glStencilMaskSeparate1(face, mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilMaskSeparate}(GLenum face, GLuint mask); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glStencilMaskSeparate1(int face, int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilOp}(GLenum fail, GLenum zfail, GLenum zpass); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glStencilOp(int fail, int zfail, int zpass)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glStencilOp;
    if (__addr_ == 0) {
      throw new GLException("Method \"glStencilOp\" not available");
    }
        dispatch_glStencilOp1(fail, zfail, zpass, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilOp}(GLenum fail, GLenum zfail, GLenum zpass); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glStencilOp1(int fail, int zfail, int zpass, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilOpSeparate}(GLenum face, GLenum fail, GLenum zfail, GLenum zpass); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glStencilOpSeparate(int face, int fail, int zfail, int zpass)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glStencilOpSeparate;
    if (__addr_ == 0) {
      throw new GLException("Method \"glStencilOpSeparate\" not available");
    }
        dispatch_glStencilOpSeparate1(face, fail, zfail, zpass, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilOpSeparate}(GLenum face, GLenum fail, GLenum zfail, GLenum zpass); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glStencilOpSeparate1(int face, int fail, int zfail, int zpass, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glTestFenceNV}(GLuint target); </code> <br>Part of <code>GL_NV_fence</code>   */
  public boolean glTestFenceNV(int target)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTestFenceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTestFenceNV\" not available");
    }
        return dispatch_glTestFenceNV1(target, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glTestFenceNV}(GLuint target); </code> <br>Part of <code>GL_NV_fence</code>   */
  public native boolean dispatch_glTestFenceNV1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexImage2D(int target, int level, int internalformat, int width, int height, int border, int format, int type, Buffer pixels)  {

    checkUnpackPBODisabled(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width            , height            , 1    , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexImage2D\" not available");
    }
        dispatch_glTexImage2D1(target, level, internalformat, width, height, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glTexImage2D(int target, int level, int internalformat, int width, int height, int border, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexImage2D\" not available");
    }
        dispatch_glTexImage2D1(target, level, internalformat, width, height, border, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage3DOES}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>; <code>GL_OES_texture_3D</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, Buffer pixels)  {

    checkUnpackPBODisabled(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width            , height            , depth  , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexImage3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexImage3D\" not available");
    }
        dispatch_glTexImage3D1(target, level, internalformat, width, height, depth, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage3DOES}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>; <code>GL_OES_texture_3D</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexImage3D1(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage3DOES}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>; <code>GL_OES_texture_3D</code>   */
  public void glTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexImage3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexImage3D\" not available");
    }
        dispatch_glTexImage3D1(target, level, internalformat, width, height, depth, border, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage3DOES}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>; <code>GL_OES_texture_3D</code>   */
  private native void dispatch_glTexImage3D1(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterf}(GLenum target, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glTexParameterf(int target, int pname, float param)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameterf;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameterf\" not available");
    }
        dispatch_glTexParameterf1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterf}(GLenum target, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glTexParameterf1(int target, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTexParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameterfv\" not available");
    }
        dispatch_glTexParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTexParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glTexParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameterfv\" not available");
    }
        dispatch_glTexParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameteri}(GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glTexParameteri(int target, int pname, int param)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameteri;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameteri\" not available");
    }
        dispatch_glTexParameteri1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameteri}(GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glTexParameteri1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameteriv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameteriv\" not available");
    }
        dispatch_glTexParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameteriv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameteriv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glTexParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexParameteriv\" not available");
    }
        dispatch_glTexParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage1DEXT}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width); </code> <br>Part of <code>GL_ARB_texture_storage</code>; <code>GL_EXT_texture_storage</code>   */
  public void glTexStorage1D(int target, int levels, int internalformat, int width)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexStorage1D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexStorage1D\" not available");
    }
        dispatch_glTexStorage1D1(target, levels, internalformat, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage1DEXT}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width); </code> <br>Part of <code>GL_ARB_texture_storage</code>; <code>GL_EXT_texture_storage</code>   */
  public native void dispatch_glTexStorage1D1(int target, int levels, int internalformat, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexStorage2DEXT}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ARB_texture_storage</code>; <code>GL_EXT_texture_storage</code>   */
  public void glTexStorage2D(int target, int levels, int internalformat, int width, int height)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexStorage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexStorage2D\" not available");
    }
        dispatch_glTexStorage2D1(target, levels, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage2DEXT}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ARB_texture_storage</code>; <code>GL_EXT_texture_storage</code>   */
  public native void dispatch_glTexStorage2D1(int target, int levels, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexStorage3DEXT}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); </code> <br>Part of <code>GL_ARB_texture_storage</code>; <code>GL_EXT_texture_storage</code>   */
  public void glTexStorage3D(int target, int levels, int internalformat, int width, int height, int depth)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexStorage3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexStorage3D\" not available");
    }
        dispatch_glTexStorage3D1(target, levels, internalformat, width, height, depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage3DEXT}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); </code> <br>Part of <code>GL_ARB_texture_storage</code>; <code>GL_EXT_texture_storage</code>   */
  public native void dispatch_glTexStorage3D1(int target, int levels, int internalformat, int width, int height, int depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Buffer pixels)  {

    checkUnpackPBODisabled(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width            , height            , 1    , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexSubImage2D\" not available");
    }
        dispatch_glTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexSubImage2D\" not available");
    }
        dispatch_glTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage3DOES}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>; <code>GL_OES_texture_3D</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Buffer pixels)  {

    checkUnpackPBODisabled(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width            , height            , depth  , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexSubImage3D\" not available");
    }
        dispatch_glTexSubImage3D1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage3DOES}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>; <code>GL_OES_texture_3D</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage3DOES}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>; <code>GL_OES_texture_3D</code>   */
  public void glTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOEnabled(true);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTexSubImage3D\" not available");
    }
        dispatch_glTexSubImage3D1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage3DOES}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>; <code>GL_OES_texture_3D</code>   */
  private native void dispatch_glTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage1DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width); </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>   */
  public void glTextureStorage1DEXT(int texture, int target, int levels, int internalformat, int width)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureStorage1DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureStorage1DEXT\" not available");
    }
        dispatch_glTextureStorage1DEXT1(texture, target, levels, internalformat, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage1DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width); </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>   */
  public native void dispatch_glTextureStorage1DEXT1(int texture, int target, int levels, int internalformat, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage2DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>   */
  public void glTextureStorage2DEXT(int texture, int target, int levels, int internalformat, int width, int height)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureStorage2DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureStorage2DEXT\" not available");
    }
        dispatch_glTextureStorage2DEXT1(texture, target, levels, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage2DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>   */
  public native void dispatch_glTextureStorage2DEXT1(int texture, int target, int levels, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage3DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>   */
  public void glTextureStorage3DEXT(int texture, int target, int levels, int internalformat, int width, int height, int depth)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureStorage3DEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glTextureStorage3DEXT\" not available");
    }
        dispatch_glTextureStorage3DEXT1(texture, target, levels, internalformat, width, height, depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage3DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>   */
  public native void dispatch_glTextureStorage3DEXT1(int texture, int target, int levels, int internalformat, int width, int height, int depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1f}(GLint location, GLfloat x); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glUniform1f(int location, float x)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1f\" not available");
    }
        dispatch_glUniform1f1(location, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1f}(GLint location, GLfloat x); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glUniform1f1(int location, float x, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform1fv(int location, int count, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1fv\" not available");
    }
        dispatch_glUniform1fv1(location, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform1fv1(int location, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glUniform1fv(int location, int count, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1fv\" not available");
    }
        dispatch_glUniform1fv1(location, count, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1i}(GLint location, GLint x); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glUniform1i(int location, int x)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1i\" not available");
    }
        dispatch_glUniform1i1(location, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1i}(GLint location, GLint x); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glUniform1i1(int location, int x, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform1iv(int location, int count, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1iv\" not available");
    }
        dispatch_glUniform1iv1(location, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform1iv1(int location, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glUniform1iv(int location, int count, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform1iv\" not available");
    }
        dispatch_glUniform1iv1(location, count, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2f}(GLint location, GLfloat x, GLfloat y); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glUniform2f(int location, float x, float y)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2f\" not available");
    }
        dispatch_glUniform2f1(location, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2f}(GLint location, GLfloat x, GLfloat y); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glUniform2f1(int location, float x, float y, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform2fv(int location, int count, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2fv\" not available");
    }
        dispatch_glUniform2fv1(location, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform2fv1(int location, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glUniform2fv(int location, int count, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2fv\" not available");
    }
        dispatch_glUniform2fv1(location, count, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2i}(GLint location, GLint x, GLint y); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glUniform2i(int location, int x, int y)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2i\" not available");
    }
        dispatch_glUniform2i1(location, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2i}(GLint location, GLint x, GLint y); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glUniform2i1(int location, int x, int y, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform2iv(int location, int count, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2iv\" not available");
    }
        dispatch_glUniform2iv1(location, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform2iv1(int location, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glUniform2iv(int location, int count, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform2iv\" not available");
    }
        dispatch_glUniform2iv1(location, count, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3f}(GLint location, GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glUniform3f(int location, float x, float y, float z)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3f\" not available");
    }
        dispatch_glUniform3f1(location, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3f}(GLint location, GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glUniform3f1(int location, float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform3fv(int location, int count, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3fv\" not available");
    }
        dispatch_glUniform3fv1(location, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform3fv1(int location, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glUniform3fv(int location, int count, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3fv\" not available");
    }
        dispatch_glUniform3fv1(location, count, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3i}(GLint location, GLint x, GLint y, GLint z); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glUniform3i(int location, int x, int y, int z)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3i\" not available");
    }
        dispatch_glUniform3i1(location, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3i}(GLint location, GLint x, GLint y, GLint z); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glUniform3i1(int location, int x, int y, int z, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform3iv(int location, int count, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3iv\" not available");
    }
        dispatch_glUniform3iv1(location, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform3iv1(int location, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glUniform3iv(int location, int count, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform3iv\" not available");
    }
        dispatch_glUniform3iv1(location, count, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4f}(GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glUniform4f(int location, float x, float y, float z, float w)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4f\" not available");
    }
        dispatch_glUniform4f1(location, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4f}(GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glUniform4f1(int location, float x, float y, float z, float w, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform4fv(int location, int count, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4fv\" not available");
    }
        dispatch_glUniform4fv1(location, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform4fv1(int location, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glUniform4fv(int location, int count, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4fv\" not available");
    }
        dispatch_glUniform4fv1(location, count, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4i}(GLint location, GLint x, GLint y, GLint z, GLint w); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glUniform4i(int location, int x, int y, int z, int w)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4i;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4i\" not available");
    }
        dispatch_glUniform4i1(location, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4i}(GLint location, GLint x, GLint y, GLint z, GLint w); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glUniform4i1(int location, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform4iv(int location, int count, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4iv\" not available");
    }
        dispatch_glUniform4iv1(location, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform4iv1(int location, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glUniform4iv(int location, int count, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4iv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniform4iv\" not available");
    }
        dispatch_glUniform4iv1(location, count, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix2fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix2fv\" not available");
    }
        dispatch_glUniformMatrix2fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix2fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glUniformMatrix2fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix2fv\" not available");
    }
        dispatch_glUniformMatrix2fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix3fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix3fv\" not available");
    }
        dispatch_glUniformMatrix3fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix3fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glUniformMatrix3fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix3fv\" not available");
    }
        dispatch_glUniformMatrix3fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix4fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix4fv\" not available");
    }
        dispatch_glUniformMatrix4fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix4fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glUniformMatrix4fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUniformMatrix4fv\" not available");
    }
        dispatch_glUniformMatrix4fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glUnmapBufferOES}(GLenum target); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_OES_mapbuffer</code>   */
  public boolean glUnmapBuffer(int target)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUnmapBuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUnmapBuffer\" not available");
    }
        return dispatch_glUnmapBuffer1(target, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glUnmapBufferOES}(GLenum target); </code> <br>Part of <code>GL_VERSION_1_5</code>; <code>GL_OES_mapbuffer</code>   */
  public native boolean dispatch_glUnmapBuffer1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glUseProgram}(GLuint program); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glUseProgram(int program)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUseProgram;
    if (__addr_ == 0) {
      throw new GLException("Method \"glUseProgram\" not available");
    }
        dispatch_glUseProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUseProgram}(GLuint program); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glUseProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glValidateProgram}(GLuint program); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glValidateProgram(int program)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glValidateProgram;
    if (__addr_ == 0) {
      throw new GLException("Method \"glValidateProgram\" not available");
    }
        dispatch_glValidateProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glValidateProgram}(GLuint program); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glValidateProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1f}(GLuint indx, GLfloat x); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glVertexAttrib1f(int indx, float x)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1f\" not available");
    }
        dispatch_glVertexAttrib1f1(indx, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1f}(GLuint indx, GLfloat x); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glVertexAttrib1f1(int indx, float x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib1fv(int indx, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1fv\" not available");
    }
        dispatch_glVertexAttrib1fv1(indx, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib1fv1(int indx, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glVertexAttrib1fv(int indx, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib1fv\" not available");
    }
        dispatch_glVertexAttrib1fv1(indx, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2f}(GLuint indx, GLfloat x, GLfloat y); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glVertexAttrib2f(int indx, float x, float y)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2f\" not available");
    }
        dispatch_glVertexAttrib2f1(indx, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2f}(GLuint indx, GLfloat x, GLfloat y); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glVertexAttrib2f1(int indx, float x, float y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib2fv(int indx, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2fv\" not available");
    }
        dispatch_glVertexAttrib2fv1(indx, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib2fv1(int indx, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glVertexAttrib2fv(int indx, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib2fv\" not available");
    }
        dispatch_glVertexAttrib2fv1(indx, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3f}(GLuint indx, GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glVertexAttrib3f(int indx, float x, float y, float z)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3f\" not available");
    }
        dispatch_glVertexAttrib3f1(indx, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3f}(GLuint indx, GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glVertexAttrib3f1(int indx, float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib3fv(int indx, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3fv\" not available");
    }
        dispatch_glVertexAttrib3fv1(indx, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib3fv1(int indx, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glVertexAttrib3fv(int indx, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib3fv\" not available");
    }
        dispatch_glVertexAttrib3fv1(indx, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4f}(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glVertexAttrib4f(int indx, float x, float y, float z, float w)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4f;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4f\" not available");
    }
        dispatch_glVertexAttrib4f1(indx, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4f}(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glVertexAttrib4f1(int indx, float x, float y, float z, float w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib4fv(int indx, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4fv\" not available");
    }
        dispatch_glVertexAttrib4fv1(indx, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib4fv1(int indx, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glVertexAttrib4fv(int indx, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4fv;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttrib4fv\" not available");
    }
        dispatch_glVertexAttrib4fv1(indx, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribPointer}(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}   */
  public void glVertexAttribPointer(int indx, int size, int type, boolean normalized, int stride, Buffer ptr)  {

    checkArrayVBODisabled(true);
    Buffers.rangeCheck(ptr, 1);
    final boolean ptr_is_direct = Buffers.isDirect(ptr);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribPointer\" not available");
    }
        dispatch_glVertexAttribPointer1(indx, size, type, normalized, stride, ptr_is_direct ? ptr : Buffers.getArray(ptr), ptr_is_direct ? Buffers.getDirectBufferByteOffset(ptr) : Buffers.getIndirectBufferByteOffset(ptr), ptr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribPointer}(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glVertexAttribPointer1(int indx, int size, int type, boolean normalized, int stride, Object ptr, int ptr_byte_offset, boolean ptr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribPointer}(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glVertexAttribPointer(int indx, int size, int type, boolean normalized, int stride, long ptr_buffer_offset)  {

    checkArrayVBOEnabled(true);
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribPointer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glVertexAttribPointer\" not available");
    }
        dispatch_glVertexAttribPointer1(indx, size, type, normalized, stride, ptr_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribPointer}(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glVertexAttribPointer1(int indx, int size, int type, boolean normalized, int stride, long ptr_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glViewport}(GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glViewport(int x, int y, int width, int height)  {

    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glViewport;
    if (__addr_ == 0) {
      throw new GLException("Method \"glViewport\" not available");
    }
        dispatch_glViewport1(x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glViewport}(GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public native void dispatch_glViewport1(int x, int y, int width, int height, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
 private static final int params_offset = 0; // just a helper for JavaPrologue ..
      @Override
      public GLProfile getGLProfile() {
          return this.glProfile;
      }
      private final GLProfile glProfile;
  
      @Override
      public final int glGetBoundBuffer(int target) {
          return bufferStateTracker.getBoundBufferObject(target, this);
      }
  
      @Override
      public final long glGetBufferSize(int buffer) {
          return bufferSizeTracker.getDirectStateBufferSize(buffer, this);
      }
  
      @Override
      public final boolean glIsVBOArrayEnabled() {
          return checkArrayVBOEnabled(false);
      }
  
      @Override
      public final boolean glIsVBOElementArrayEnabled() {
          return checkElementVBOEnabled(false);
      }
  
      @Override
      public final boolean isGL() {
          return true;
      }
        
      @Override
      public final GL getGL() throws GLException {
          return this;
      }
  
      @Override
      public final boolean isFunctionAvailable(String glFunctionName) {
        return _context.isFunctionAvailable(glFunctionName);
      }
  
      @Override
      public final boolean isExtensionAvailable(String glExtensionName) {
        return _context.isExtensionAvailable(glExtensionName);
      }
  
      @Override
      public final Object getExtension(String extensionName) {
        // At this point we don't expose any extensions using this mechanism
        return null;
      }
  
      @Override
      public final GLContext getContext() {
        return _context;
      }
  
      private final GLContextImpl _context;
  
      /**
       * @see javax.media.opengl.GLContext#setSwapInterval(int)
       */
      @Override
      public final void setSwapInterval(int interval) {
        _context.setSwapInterval(interval);
      }
  
      /**
       * @see javax.media.opengl.GLContext#getSwapInterval()
       */
      @Override
      public final int getSwapInterval() {
        return _context.getSwapInterval();
      }
  
      @Override
      public final Object getPlatformGLExtensions() {
        return _context.getPlatformGLExtensions();
      }
  
      @Override
      public final int getBoundFramebuffer(int target) {
        return _context.getBoundFramebuffer(target);
      }
  
      @Override
      public final int getDefaultDrawFramebuffer() {
        return _context.getDefaultDrawFramebuffer();
      }
  
      @Override
      public final int getDefaultReadFramebuffer() {
        return _context.getDefaultReadFramebuffer();
      }
  
  
  public GLES2Impl(GLProfile glp, GLContextImpl context) {
    this._context = context; 
    if(null != context) {
        this.bufferSizeTracker  = context.getBufferSizeTracker();
        this.bufferStateTracker = context.getBufferStateTracker();
        this.glStateTracker     = context.getGLStateTracker();
    } else {
        this.bufferSizeTracker  = null;
        this.bufferStateTracker = null;
        this.glStateTracker     = null;
    }
    this.glProfile = glp;
  }
  
  @Override
  public final boolean isGL4bc() {
      return false;
  }
  
  @Override
  public final boolean isGL4() {
      return false;
  }
  
  @Override
  public final boolean isGL3bc() {
      return false;
  }
  
  @Override
  public final boolean isGL3() {
      return false;
  }
  
  public final boolean isGL2() {
      return false;
  }
  
  @Override
  public final boolean isGLES1() {
      return false;
  }
  
  @Override
  public final boolean isGLES2() {
      return true;
  }
  
  @Override
  public final boolean isGLES() {
      return true;
  }
  
  @Override
  public final boolean isGL2ES1() {
      return false;
  }
  
  @Override
  public final boolean isGL2ES2() {
      return true;
  }
  
  @Override
  public final boolean isGLES2Compatible() {
      return true;
  }
  
  @Override
  public final boolean isGL2GL3() {
      return false;
  }
  
  @Override
  public final boolean hasGLSL() {
      return true;
  }
  
  @Override
  public boolean isNPOTTextureAvailable() {
    return true;
  }
  
  @Override
  public final GL4bc getGL4bc() throws GLException {
      throw new GLException("Not a GL4bc implementation");
  }
  
  @Override
  public final GL4 getGL4() throws GLException {
      throw new GLException("Not a GL4 implementation");
  }
  
  @Override
  public final GL3bc getGL3bc() throws GLException {
      throw new GLException("Not a GL3bc implementation");
  }
  
  @Override
  public final GL3 getGL3() throws GLException {
      throw new GLException("Not a GL3 implementation");
  }
  
  @Override
  public final GL2 getGL2() throws GLException {
      throw new GLException("Not a GL2 implementation");
  }
  
  @Override
  public final GLES1 getGLES1() throws GLException {
      throw new GLException("Not a GLES1 implementation");
  }
  
  @Override
  public final GLES2 getGLES2() throws GLException {
      return this;
  }
  
  @Override
  public final GL2ES1 getGL2ES1() throws GLException {
      throw new GLException("Not a GL2ES1 implementation");
  }
  
  @Override
  public final GL2ES2 getGL2ES2() throws GLException {
      return this;
  }
  
  @Override
  public final GL2GL3 getGL2GL3() throws GLException {
      throw new GLException("Not a GL2GL3 implementation");
  }
  
  //
  // Helpers for ensuring the correct amount of texture data
  //
  
  private final GLBufferSizeTracker  bufferSizeTracker;
  private final GLBufferStateTracker bufferStateTracker;
  private final GLStateTracker       glStateTracker;
  
  private boolean bufferObjectExtensionsInitialized = false;
  private boolean haveOESFramebufferObject;
  
  private final void initBufferObjectExtensionChecks() {
    if (bufferObjectExtensionsInitialized)
      return;
    bufferObjectExtensionsInitialized = true;
    haveOESFramebufferObject  = isExtensionAvailable("GL_OES_framebuffer_object");
  }
  
  private final boolean checkBufferObject(boolean avail,
                                          boolean enabled,
                                          int state,
                                          String kind, boolean throwException) {
    if (!avail) {
      if (!enabled)
        return true;
      if(throwException) {
          throw new GLException("Required extensions not available to call this function");
      }
      return false;
    }
    int buffer = bufferStateTracker.getBoundBufferObject(state, this);
    if (enabled) {
      if (buffer == 0) {
        if(throwException) {
            throw new GLException(kind + " must be enabled to call this method");
        }
        return false;
      }
    } else {
      if (buffer != 0) {
        if(throwException) {
            throw new GLException(kind + " must be disabled to call this method");
        }
        return false;
      }
    }
    return true;
  }  
  
  private final boolean checkArrayVBODisabled(boolean throwException) { 
    initBufferObjectExtensionChecks();
    return checkBufferObject(true,
                      false,
                      GL.GL_ARRAY_BUFFER,
                      "array vertex_buffer_object", throwException);
  }
  
  private final boolean checkArrayVBOEnabled(boolean throwException) { 
    initBufferObjectExtensionChecks();
    return checkBufferObject(true,
                      true,
                      GL.GL_ARRAY_BUFFER,
                      "array vertex_buffer_object", throwException);
  }
  
  private final boolean checkElementVBODisabled(boolean throwException) { 
    initBufferObjectExtensionChecks();
    return checkBufferObject(true,
                      false,
                      GL.GL_ELEMENT_ARRAY_BUFFER,
                      "element vertex_buffer_object", throwException);
  }
  
  private final boolean checkElementVBOEnabled(boolean throwException) { 
    initBufferObjectExtensionChecks();
    return checkBufferObject(true,
                      true,
                      GL.GL_ELEMENT_ARRAY_BUFFER,
                      "element vertex_buffer_object", throwException);
  }
  
  private final boolean checkUnpackPBODisabled(boolean throwException) { 
      // PBO n/a for ES 1.1 or ES 2.0
      return true;
  }
  
  private final boolean checkUnpackPBOEnabled(boolean throwException) { 
      // PBO n/a for ES 1.1 or ES 2.0
      return false;
  }
  
  private final boolean checkPackPBODisabled(boolean throwException) { 
      // PBO n/a for ES 1.1 or ES 2.0
      return true;
  }
  
  private final boolean checkPackPBOEnabled(boolean throwException) { 
      // PBO n/a for ES 1.1 or ES 2.0
      return false;
  }
  
  private final HashMap<MemoryObject, MemoryObject> arbMemCache = new HashMap<MemoryObject, MemoryObject>();
  
  /** Entry point to C language function: <br> <code> LPVOID glMapBuffer(GLenum target, GLenum access); </code>    */
  @Override
  public final java.nio.ByteBuffer glMapBuffer(int target, int access) {
    final long __addr_ = ((GLES2ProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapBuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glMapBuffer\" not available");
    }
    final long sz = bufferSizeTracker.getBufferSize(bufferStateTracker, target, this);
    if (0 == sz) {
      return null;
    }
    final long addr = dispatch_glMapBuffer(target, access, __addr_);
    if (0 == addr) {
      return null;
    }
    ByteBuffer buffer;
    MemoryObject memObj0 = new MemoryObject(addr, sz); // object and key
    MemoryObject memObj1 = MemoryObject.getOrAddSafe(arbMemCache, memObj0);
    if(memObj0 == memObj1) {
      // just added ..
      if(null != memObj0.getBuffer()) {
          throw new InternalError();
      }
      buffer = newDirectByteBuffer(addr, sz);
      Buffers.nativeOrder(buffer);
      memObj0.setBuffer(buffer);
    } else {
      // already mapped
      buffer = memObj1.getBuffer();
      if(null == buffer) {
          throw new InternalError();
      }
    }
    buffer.position(0);
    return buffer;
  }
  
  /** Encapsulates function pointer for OpenGL function <br>: <code> LPVOID glMapBuffer(GLenum target, GLenum access); </code>    */
  native private long dispatch_glMapBuffer(int target, int access, long glProcAddress);
  
  native private ByteBuffer newDirectByteBuffer(long addr, long capacity);
  
  @Override
  public final void glClearDepth(double depth) {
      glClearDepthf((float)depth); 
  }
  
  @Override
  public final void glDepthRange(double zNear, double zFar) {
      glDepthRangef((float)zNear, (float)zFar); 
  }
  
  
      private int[] imageSizeTemp = new int[1];
  
      private final int imageSizeInBytes(int format, int type, int width, int height, int depth, boolean pack) {
          return GLBuffers.sizeof(this, imageSizeTemp, format, type, width, height, depth, pack) ;                                    
      }
  
    @Override
    public final void glVertexAttribPointer(GLArrayData array) {
      if(array.getComponentCount()==0) return;
      if(array.isVBO()) {
          glVertexAttribPointer(array.getLocation(), array.getComponentCount(), array.getComponentType(), 
                                array.getNormalized(), array.getStride(), array.getVBOOffset());
      } else {
          glVertexAttribPointer(array.getLocation(), array.getComponentCount(), array.getComponentType(), 
                                array.getNormalized(), array.getStride(), array.getBuffer());
      }
    }
  
    @Override
    public final void glUniform(GLUniformData data) {
      boolean done=false;
      if(data.isBuffer()) {
          Buffer buffer = data.getBuffer();
          if(data.isMatrix()) {
              if(buffer instanceof FloatBuffer) {
                  switch(data.columns()) {
                      case 2: glUniformMatrix2fv(data.getLocation(), data.count(), false, (FloatBuffer)buffer); done=true; break;
                      case 3: glUniformMatrix3fv(data.getLocation(), data.count(), false, (FloatBuffer)buffer); done=true; break;
                      case 4: glUniformMatrix4fv(data.getLocation(), data.count(), false, (FloatBuffer)buffer); done=true; break;
                  }
              }
              if(!done) {
                  throw new GLException("glUniformMatrix only available for 2fv, 3fv and 4fv");
              }
          } else {
              if(buffer instanceof IntBuffer) {
                  switch(data.components()) {
                      case 1: glUniform1iv(data.getLocation(), data.count(), (IntBuffer)buffer); done=true; break;
                      case 2: glUniform2iv(data.getLocation(), data.count(), (IntBuffer)buffer); done=true; break;
                      case 3: glUniform3iv(data.getLocation(), data.count(), (IntBuffer)buffer); done=true; break;
                      case 4: glUniform4iv(data.getLocation(), data.count(), (IntBuffer)buffer); done=true; break;
                  }
              } else if(buffer instanceof FloatBuffer) {
                  switch(data.components()) {
                      case 1: glUniform1fv(data.getLocation(), data.count(), (FloatBuffer)buffer); done=true; break;
                      case 2: glUniform2fv(data.getLocation(), data.count(), (FloatBuffer)buffer); done=true; break;
                      case 3: glUniform3fv(data.getLocation(), data.count(), (FloatBuffer)buffer); done=true; break;
                      case 4: glUniform4fv(data.getLocation(), data.count(), (FloatBuffer)buffer); done=true; break;
                  }
              }
              if(!done) {
                  throw new GLException("glUniform vector only available for 1[if]v 2[if]v, 3[if]v and 4[if]v");
              }
          }
      } else {
          Object obj = data.getObject();
          if(obj instanceof Integer) {
              glUniform1i(data.getLocation(), ((Integer)obj).intValue());
              done=true;
          } else if (obj instanceof Float) {
              glUniform1f(data.getLocation(), ((Float)obj).floatValue());
              done=true;
          }
          if(!done) {
              throw new GLException("glUniform atom only available for 1i and 1f");
          }
      }
    }
  
  // ---- End CustomJavaCode .cfg declarations

} // end of class GLES2Impl
