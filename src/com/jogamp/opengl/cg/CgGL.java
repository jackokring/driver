/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/procaddress/ProcAddressEmitter.java on Fri Aug 03 06:29:30 CEST 2012 ----! */

package com.jogamp.opengl.cg;

import jogamp.opengl.*;
import com.jogamp.common.os.DynamicLookupHelper;
import com.jogamp.common.os.DynamicLibraryBundle;
import com.jogamp.opengl.cg.CgDynamicLibraryBundleInfo;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class CgGL {

  /** Defined as part of enum type "CGtype" */
  public static final int CG_UNKNOWN_TYPE = 0;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_STRUCT = 1;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_ARRAY = 2;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_TYPE_START_ENUM = 1024;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_HALF = 1025;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_HALF2 = 1026;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_HALF3 = 1027;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_HALF4 = 1028;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_HALF1x1 = 1029;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_HALF1x2 = 1030;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_HALF1x3 = 1031;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_HALF1x4 = 1032;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_HALF2x1 = 1033;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_HALF2x2 = 1034;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_HALF2x3 = 1035;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_HALF2x4 = 1036;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_HALF3x1 = 1037;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_HALF3x2 = 1038;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_HALF3x3 = 1039;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_HALF3x4 = 1040;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_HALF4x1 = 1041;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_HALF4x2 = 1042;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_HALF4x3 = 1043;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_HALF4x4 = 1044;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FLOAT = 1045;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FLOAT2 = 1046;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FLOAT3 = 1047;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FLOAT4 = 1048;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FLOAT1x1 = 1049;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FLOAT1x2 = 1050;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FLOAT1x3 = 1051;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FLOAT1x4 = 1052;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FLOAT2x1 = 1053;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FLOAT2x2 = 1054;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FLOAT2x3 = 1055;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FLOAT2x4 = 1056;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FLOAT3x1 = 1057;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FLOAT3x2 = 1058;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FLOAT3x3 = 1059;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FLOAT3x4 = 1060;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FLOAT4x1 = 1061;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FLOAT4x2 = 1062;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FLOAT4x3 = 1063;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FLOAT4x4 = 1064;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_SAMPLER1D = 1065;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_SAMPLER2D = 1066;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_SAMPLER3D = 1067;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_SAMPLERRECT = 1068;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_SAMPLERCUBE = 1069;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FIXED = 1070;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FIXED2 = 1071;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FIXED3 = 1072;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FIXED4 = 1073;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FIXED1x1 = 1074;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FIXED1x2 = 1075;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FIXED1x3 = 1076;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FIXED1x4 = 1077;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FIXED2x1 = 1078;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FIXED2x2 = 1079;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FIXED2x3 = 1080;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FIXED2x4 = 1081;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FIXED3x1 = 1082;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FIXED3x2 = 1083;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FIXED3x3 = 1084;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FIXED3x4 = 1085;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FIXED4x1 = 1086;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FIXED4x2 = 1087;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FIXED4x3 = 1088;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FIXED4x4 = 1089;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_HALF1 = 1090;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FLOAT1 = 1091;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_FIXED1 = 1092;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_INT = 1093;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_INT1 = 1094;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_INT2 = 1095;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_INT3 = 1096;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_INT4 = 1097;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_INT1x1 = 1098;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_INT1x2 = 1099;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_INT1x3 = 1100;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_INT1x4 = 1101;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_INT2x1 = 1102;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_INT2x2 = 1103;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_INT2x3 = 1104;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_INT2x4 = 1105;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_INT3x1 = 1106;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_INT3x2 = 1107;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_INT3x3 = 1108;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_INT3x4 = 1109;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_INT4x1 = 1110;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_INT4x2 = 1111;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_INT4x3 = 1112;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_INT4x4 = 1113;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_BOOL = 1114;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_BOOL1 = 1115;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_BOOL2 = 1116;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_BOOL3 = 1117;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_BOOL4 = 1118;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_BOOL1x1 = 1119;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_BOOL1x2 = 1120;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_BOOL1x3 = 1121;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_BOOL1x4 = 1122;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_BOOL2x1 = 1123;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_BOOL2x2 = 1124;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_BOOL2x3 = 1125;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_BOOL2x4 = 1126;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_BOOL3x1 = 1127;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_BOOL3x2 = 1128;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_BOOL3x3 = 1129;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_BOOL3x4 = 1130;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_BOOL4x1 = 1131;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_BOOL4x2 = 1132;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_BOOL4x3 = 1133;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_BOOL4x4 = 1134;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_STRING = 1135;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_PROGRAM_TYPE = 1136;
  /** Defined as part of enum type "CGtype" */
  public static final int CG_TEXTURE = 1137;
  /** Defined as part of enum type "CGparameterclass" */
  public static final int CG_PARAMETERCLASS_UNKNOWN = 0;
  /** Defined as part of enum type "CGparameterclass" */
  public static final int CG_PARAMETERCLASS_SCALAR = 1;
  /** Defined as part of enum type "CGparameterclass" */
  public static final int CG_PARAMETERCLASS_VECTOR = 2;
  /** Defined as part of enum type "CGparameterclass" */
  public static final int CG_PARAMETERCLASS_MATRIX = 3;
  /** Defined as part of enum type "CGparameterclass" */
  public static final int CG_PARAMETERCLASS_STRUCT = 4;
  /** Defined as part of enum type "CGparameterclass" */
  public static final int CG_PARAMETERCLASS_ARRAY = 5;
  /** Defined as part of enum type "CGparameterclass" */
  public static final int CG_PARAMETERCLASS_SAMPLER = 6;
  /** Defined as part of enum type "CGparameterclass" */
  public static final int CG_PARAMETERCLASS_OBJECT = 7;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_UNKNOWN = 4096;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_IN = 4097;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_OUT = 4098;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_INOUT = 4099;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_MIXED = 4100;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_VARYING = 4101;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_UNIFORM = 4102;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_CONSTANT = 4103;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_PROGRAM_SOURCE = 4104;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_PROGRAM_ENTRY = 4105;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_COMPILED_PROGRAM = 4106;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_PROGRAM_PROFILE = 4107;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_GLOBAL = 4108;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_PROGRAM = 4109;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_DEFAULT = 4110;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_ERROR = 4111;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_SOURCE = 4112;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_OBJECT = 4113;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_COMPILE_MANUAL = 4114;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_COMPILE_IMMEDIATE = 4115;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_COMPILE_LAZY = 4116;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_CURRENT = 4117;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_LITERAL = 4118;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_VERSION = 4119;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_ROW_MAJOR = 4120;
  /** Defined as part of enum type "CGenum" */
  public static final int CG_COLUMN_MAJOR = 4121;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_NO_ERROR = 0;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_COMPILER_ERROR = 1;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_INVALID_PARAMETER_ERROR = 2;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_INVALID_PROFILE_ERROR = 3;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_PROGRAM_LOAD_ERROR = 4;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_PROGRAM_BIND_ERROR = 5;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_PROGRAM_NOT_LOADED_ERROR = 6;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_UNSUPPORTED_GL_EXTENSION_ERROR = 7;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_INVALID_VALUE_TYPE_ERROR = 8;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_NOT_MATRIX_PARAM_ERROR = 9;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_INVALID_ENUMERANT_ERROR = 10;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_NOT_4x4_MATRIX_ERROR = 11;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_FILE_READ_ERROR = 12;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_FILE_WRITE_ERROR = 13;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_NVPARSE_ERROR = 14;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_MEMORY_ALLOC_ERROR = 15;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_INVALID_CONTEXT_HANDLE_ERROR = 16;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_INVALID_PROGRAM_HANDLE_ERROR = 17;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_INVALID_PARAM_HANDLE_ERROR = 18;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_UNKNOWN_PROFILE_ERROR = 19;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_VAR_ARG_ERROR = 20;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_INVALID_DIMENSION_ERROR = 21;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_ARRAY_PARAM_ERROR = 22;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_OUT_OF_ARRAY_BOUNDS_ERROR = 23;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_CONFLICTING_TYPES_ERROR = 24;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_CONFLICTING_PARAMETER_TYPES_ERROR = 25;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_PARAMETER_IS_NOT_SHARED_ERROR = 26;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_INVALID_PARAMETER_VARIABILITY_ERROR = 27;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_CANNOT_DESTROY_PARAMETER_ERROR = 28;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_NOT_ROOT_PARAMETER_ERROR = 29;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_PARAMETERS_DO_NOT_MATCH_ERROR = 30;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_IS_NOT_PROGRAM_PARAMETER_ERROR = 31;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_INVALID_PARAMETER_TYPE_ERROR = 32;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_PARAMETER_IS_NOT_RESIZABLE_ARRAY_ERROR = 33;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_INVALID_SIZE_ERROR = 34;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_BIND_CREATES_CYCLE_ERROR = 35;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_ARRAY_TYPES_DO_NOT_MATCH_ERROR = 36;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_ARRAY_DIMENSIONS_DO_NOT_MATCH_ERROR = 37;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_ARRAY_HAS_WRONG_DIMENSION_ERROR = 38;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_TYPE_IS_NOT_DEFINED_IN_PROGRAM_ERROR = 39;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_INVALID_EFFECT_HANDLE_ERROR = 40;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_INVALID_STATE_HANDLE_ERROR = 41;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_INVALID_STATE_ASSIGNMENT_HANDLE_ERROR = 42;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_INVALID_PASS_HANDLE_ERROR = 43;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_INVALID_ANNOTATION_HANDLE_ERROR = 44;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_INVALID_TECHNIQUE_HANDLE_ERROR = 45;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_INVALID_PARAMETER_HANDLE_ERROR = 46;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_STATE_ASSIGNMENT_TYPE_MISMATCH_ERROR = 47;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_INVALID_FUNCTION_HANDLE_ERROR = 48;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_INVALID_TECHNIQUE_ERROR = 49;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_INVALID_POINTER_ERROR = 50;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_NOT_ENOUGH_DATA_ERROR = 51;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_NON_NUMERIC_PARAMETER_ERROR = 52;
  /** Defined as part of enum type "CGerror" */
  public static final int CG_ARRAY_SIZE_MISMATCH_ERROR = 53;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXUNIT0 = 2048;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXUNIT1 = 2049;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXUNIT2 = 2050;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXUNIT3 = 2051;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXUNIT4 = 2052;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXUNIT5 = 2053;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXUNIT6 = 2054;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXUNIT7 = 2055;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXUNIT8 = 2056;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXUNIT9 = 2057;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXUNIT10 = 2058;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXUNIT11 = 2059;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXUNIT12 = 2060;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXUNIT13 = 2061;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXUNIT14 = 2062;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXUNIT15 = 2063;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_ATTR0 = 2113;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_ATTR1 = 2114;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_ATTR2 = 2115;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_ATTR3 = 2116;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_ATTR4 = 2117;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_ATTR5 = 2118;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_ATTR6 = 2119;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_ATTR7 = 2120;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_ATTR8 = 2121;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_ATTR9 = 2122;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_ATTR10 = 2123;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_ATTR11 = 2124;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_ATTR12 = 2125;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_ATTR13 = 2126;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_ATTR14 = 2127;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_ATTR15 = 2128;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_C = 2178;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEX0 = 2179;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEX1 = 2180;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEX2 = 2181;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEX3 = 2192;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEX4 = 2193;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEX5 = 2194;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEX6 = 2195;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEX7 = 2196;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_HPOS = 2243;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COL0 = 2245;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COL1 = 2246;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COL2 = 2247;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COL3 = 2248;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_PSIZ = 2309;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_WPOS = 2373;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_POSITION0 = 2437;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_POSITION1 = 2438;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_POSITION2 = 2439;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_POSITION3 = 2440;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_POSITION4 = 2441;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_POSITION5 = 2442;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_POSITION6 = 2443;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_POSITION7 = 2444;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_POSITION8 = 2445;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_POSITION9 = 2446;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_POSITION10 = 2447;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_POSITION11 = 2448;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_POSITION12 = 2449;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_POSITION13 = 2450;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_POSITION14 = 2451;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_POSITION15 = 2452;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_DIFFUSE0 = 2501;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TANGENT0 = 2565;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TANGENT1 = 2566;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TANGENT2 = 2567;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TANGENT3 = 2568;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TANGENT4 = 2569;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TANGENT5 = 2570;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TANGENT6 = 2571;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TANGENT7 = 2572;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TANGENT8 = 2573;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TANGENT9 = 2574;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TANGENT10 = 2575;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TANGENT11 = 2576;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TANGENT12 = 2577;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TANGENT13 = 2578;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TANGENT14 = 2579;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TANGENT15 = 2580;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_SPECULAR0 = 2629;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDINDICES0 = 2693;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDINDICES1 = 2694;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDINDICES2 = 2695;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDINDICES3 = 2696;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDINDICES4 = 2697;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDINDICES5 = 2698;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDINDICES6 = 2699;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDINDICES7 = 2700;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDINDICES8 = 2701;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDINDICES9 = 2702;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDINDICES10 = 2703;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDINDICES11 = 2704;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDINDICES12 = 2705;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDINDICES13 = 2706;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDINDICES14 = 2707;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDINDICES15 = 2708;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COLOR0 = 2757;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COLOR1 = 2758;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COLOR2 = 2759;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COLOR3 = 2760;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COLOR4 = 2761;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COLOR5 = 2762;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COLOR6 = 2763;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COLOR7 = 2764;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COLOR8 = 2765;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COLOR9 = 2766;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COLOR10 = 2767;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COLOR11 = 2768;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COLOR12 = 2769;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COLOR13 = 2770;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COLOR14 = 2771;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COLOR15 = 2772;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_PSIZE0 = 2821;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_PSIZE1 = 2822;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_PSIZE2 = 2823;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_PSIZE3 = 2824;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_PSIZE4 = 2825;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_PSIZE5 = 2826;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_PSIZE6 = 2827;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_PSIZE7 = 2828;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_PSIZE8 = 2829;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_PSIZE9 = 2830;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_PSIZE10 = 2831;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_PSIZE11 = 2832;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_PSIZE12 = 2833;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_PSIZE13 = 2834;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_PSIZE14 = 2835;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_PSIZE15 = 2836;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BINORMAL0 = 2885;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BINORMAL1 = 2886;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BINORMAL2 = 2887;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BINORMAL3 = 2888;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BINORMAL4 = 2889;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BINORMAL5 = 2890;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BINORMAL6 = 2891;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BINORMAL7 = 2892;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BINORMAL8 = 2893;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BINORMAL9 = 2894;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BINORMAL10 = 2895;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BINORMAL11 = 2896;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BINORMAL12 = 2897;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BINORMAL13 = 2898;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BINORMAL14 = 2899;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BINORMAL15 = 2900;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_FOG0 = 2917;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_FOG1 = 2918;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_FOG2 = 2919;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_FOG3 = 2920;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_FOG4 = 2921;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_FOG5 = 2922;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_FOG6 = 2923;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_FOG7 = 2924;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_FOG8 = 2925;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_FOG9 = 2926;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_FOG10 = 2927;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_FOG11 = 2928;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_FOG12 = 2929;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_FOG13 = 2930;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_FOG14 = 2931;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_FOG15 = 2932;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_DEPTH0 = 2933;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_DEPTH1 = 2934;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_DEPTH2 = 2935;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_DEPTH3 = 2936;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_DEPTH4 = 2937;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_DEPTH5 = 2938;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_DEPTH6 = 2939;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_DEPTH7 = 2940;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_DEPTH8 = 2941;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_DEPTH9 = 29542;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_DEPTH10 = 2943;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_DEPTH11 = 2944;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_DEPTH12 = 2945;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_DEPTH13 = 2946;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_DEPTH14 = 2947;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_DEPTH15 = 2948;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_SAMPLE0 = 2949;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_SAMPLE1 = 2950;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_SAMPLE2 = 2951;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_SAMPLE3 = 2952;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_SAMPLE4 = 2953;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_SAMPLE5 = 2954;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_SAMPLE6 = 2955;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_SAMPLE7 = 2956;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_SAMPLE8 = 2957;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_SAMPLE9 = 2958;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_SAMPLE10 = 2959;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_SAMPLE11 = 2960;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_SAMPLE12 = 2961;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_SAMPLE13 = 2962;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_SAMPLE14 = 2963;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_SAMPLE15 = 2964;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDWEIGHT0 = 3028;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDWEIGHT1 = 3029;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDWEIGHT2 = 3030;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDWEIGHT3 = 3031;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDWEIGHT4 = 3032;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDWEIGHT5 = 3033;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDWEIGHT6 = 3034;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDWEIGHT7 = 3035;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDWEIGHT8 = 3036;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDWEIGHT9 = 3037;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDWEIGHT10 = 3038;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDWEIGHT11 = 3039;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDWEIGHT12 = 3040;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDWEIGHT13 = 3041;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDWEIGHT14 = 3042;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_BLENDWEIGHT15 = 3043;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_NORMAL0 = 3092;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_NORMAL1 = 3093;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_NORMAL2 = 3094;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_NORMAL3 = 3095;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_NORMAL4 = 3096;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_NORMAL5 = 3097;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_NORMAL6 = 3098;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_NORMAL7 = 3099;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_NORMAL8 = 3100;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_NORMAL9 = 3101;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_NORMAL10 = 3102;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_NORMAL11 = 3103;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_NORMAL12 = 3104;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_NORMAL13 = 3105;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_NORMAL14 = 3106;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_NORMAL15 = 3107;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_FOGCOORD = 3156;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXCOORD0 = 3220;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXCOORD1 = 3221;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXCOORD2 = 3222;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXCOORD3 = 3223;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXCOORD4 = 3224;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXCOORD5 = 3225;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXCOORD6 = 3226;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXCOORD7 = 3227;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXCOORD8 = 3228;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXCOORD9 = 3229;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXCOORD10 = 3230;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXCOORD11 = 3231;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXCOORD12 = 3232;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXCOORD13 = 3233;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXCOORD14 = 3234;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TEXCOORD15 = 3235;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COMBINER_CONST0 = 3284;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COMBINER_CONST1 = 3285;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COMBINER_STAGE_CONST0 = 3286;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_COMBINER_STAGE_CONST1 = 3287;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_OFFSET_TEXTURE_MATRIX = 3288;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_OFFSET_TEXTURE_SCALE = 3289;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_OFFSET_TEXTURE_BIAS = 3290;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_CONST_EYE = 3291;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_TESSFACTOR = 3255;
  /** Defined as part of enum type "CGresource" */
  public static final int CG_UNDEFINED = 3256;
  /** Defined as part of enum type "CGGLenum" */
  public static final int CG_GL_MATRIX_IDENTITY = 0;
  /** Defined as part of enum type "CGGLenum" */
  public static final int CG_GL_MATRIX_TRANSPOSE = 1;
  /** Defined as part of enum type "CGGLenum" */
  public static final int CG_GL_MATRIX_INVERSE = 2;
  /** Defined as part of enum type "CGGLenum" */
  public static final int CG_GL_MATRIX_INVERSE_TRANSPOSE = 3;
  /** Defined as part of enum type "CGGLenum" */
  public static final int CG_GL_MODELVIEW_MATRIX = 4;
  /** Defined as part of enum type "CGGLenum" */
  public static final int CG_GL_PROJECTION_MATRIX = 5;
  /** Defined as part of enum type "CGGLenum" */
  public static final int CG_GL_TEXTURE_MATRIX = 6;
  /** Defined as part of enum type "CGGLenum" */
  public static final int CG_GL_MODELVIEW_PROJECTION_MATRIX = 7;
  /** Defined as part of enum type "CGGLenum" */
  public static final int CG_GL_VERTEX = 8;
  /** Defined as part of enum type "CGGLenum" */
  public static final int CG_GL_FRAGMENT = 9;
  /** Defined as part of enum type "CGprofile" */
  public static final int CG_PROFILE_START = 6144;
  /** Defined as part of enum type "CGprofile" */
  public static final int CG_PROFILE_UNKNOWN = 6145;
  /** Defined as part of enum type "CGprofile" */
  public static final int CG_PROFILE_VP20 = 6146;
  /** Defined as part of enum type "CGprofile" */
  public static final int CG_PROFILE_FP20 = 6147;
  /** Defined as part of enum type "CGprofile" */
  public static final int CG_PROFILE_VP30 = 6148;
  /** Defined as part of enum type "CGprofile" */
  public static final int CG_PROFILE_FP30 = 6149;
  /** Defined as part of enum type "CGprofile" */
  public static final int CG_PROFILE_ARBVP1 = 6150;
  /** Defined as part of enum type "CGprofile" */
  public static final int CG_PROFILE_FP40 = 6151;
  /** Defined as part of enum type "CGprofile" */
  public static final int CG_PROFILE_ARBFP1 = 7000;
  /** Defined as part of enum type "CGprofile" */
  public static final int CG_PROFILE_VP40 = 7001;
  /** Defined as part of enum type "CGprofile" */
  public static final int CG_PROFILE_VS_1_1 = 6153;
  /** Defined as part of enum type "CGprofile" */
  public static final int CG_PROFILE_VS_2_0 = 6154;
  /** Defined as part of enum type "CGprofile" */
  public static final int CG_PROFILE_VS_2_X = 6155;
  /** Defined as part of enum type "CGprofile" */
  public static final int CG_PROFILE_PS_1_1 = 6159;
  /** Defined as part of enum type "CGprofile" */
  public static final int CG_PROFILE_PS_1_2 = 6160;
  /** Defined as part of enum type "CGprofile" */
  public static final int CG_PROFILE_PS_1_3 = 6161;
  /** Defined as part of enum type "CGprofile" */
  public static final int CG_PROFILE_PS_2_0 = 6162;
  /** Defined as part of enum type "CGprofile" */
  public static final int CG_PROFILE_PS_2_X = 6163;
  /** Defined as part of enum type "CGprofile" */
  public static final int GENERIC = 7002;
  /** Defined as part of enum type "CGprofile" */
  public static final int CG_PROFILE_MAX = 7100;
  public static final int CG_VERSION_NUM = 1400;

  /** Entry point (through function pointer) to C language function: <br> <code> void cgAddStateEnumerant(CGstate, const char *  name, int value); </code>    */
  public static void cgAddStateEnumerant(CGstate arg0, String name, int value)  {

    final long __addr_ = cgProcAddressTable._addressof_cgAddStateEnumerant;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgAddStateEnumerant\" not available");
    }
        dispatch_cgAddStateEnumerant1(((arg0 == null) ? null : arg0.getBuffer()), name, value, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgAddStateEnumerant(CGstate, const char *  name, int value); </code>    */
  private static native void dispatch_cgAddStateEnumerant1(ByteBuffer arg0, String name, int value, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgCallStateResetCallback(CGstateassignment); </code>    */
  public static boolean cgCallStateResetCallback(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCallStateResetCallback;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgCallStateResetCallback\" not available");
    }
        return dispatch_cgCallStateResetCallback1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgCallStateResetCallback(CGstateassignment); </code>    */
  private static native boolean dispatch_cgCallStateResetCallback1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgCallStateSetCallback(CGstateassignment); </code>    */
  public static boolean cgCallStateSetCallback(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCallStateSetCallback;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgCallStateSetCallback\" not available");
    }
        return dispatch_cgCallStateSetCallback1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgCallStateSetCallback(CGstateassignment); </code>    */
  private static native boolean dispatch_cgCallStateSetCallback1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgCallStateValidateCallback(CGstateassignment); </code>    */
  public static boolean cgCallStateValidateCallback(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCallStateValidateCallback;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgCallStateValidateCallback\" not available");
    }
        return dispatch_cgCallStateValidateCallback1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgCallStateValidateCallback(CGstateassignment); </code>    */
  private static native boolean dispatch_cgCallStateValidateCallback1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgCompileProgram(CGprogram program); </code>    */
  public static void cgCompileProgram(CGprogram program)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCompileProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgCompileProgram\" not available");
    }
        dispatch_cgCompileProgram1(((program == null) ? null : program.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgCompileProgram(CGprogram program); </code>    */
  private static native void dispatch_cgCompileProgram1(ByteBuffer program, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgConnectParameter(CGparameter from, CGparameter to); </code>    */
  public static void cgConnectParameter(CGparameter from, CGparameter to)  {

    final long __addr_ = cgProcAddressTable._addressof_cgConnectParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgConnectParameter\" not available");
    }
        dispatch_cgConnectParameter1(((from == null) ? null : from.getBuffer()), ((to == null) ? null : to.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgConnectParameter(CGparameter from, CGparameter to); </code>    */
  private static native void dispatch_cgConnectParameter1(ByteBuffer from, ByteBuffer to, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGprogram cgCopyProgram(CGprogram program); </code>    */
  public static CGprogram cgCopyProgram(CGprogram program)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCopyProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgCopyProgram\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgCopyProgram1(((program == null) ? null : program.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGprogram.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGprogram cgCopyProgram(CGprogram program); </code>    */
  private static native ByteBuffer dispatch_cgCopyProgram1(ByteBuffer program, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGstate cgCreateArraySamplerState(CGcontext, const char *  name, CGtype, int nelems); </code> 
      @param arg2 valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static CGstate cgCreateArraySamplerState(CGcontext arg0, String name, int arg2, int nelems)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateArraySamplerState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgCreateArraySamplerState\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateArraySamplerState1(((arg0 == null) ? null : arg0.getBuffer()), name, arg2, nelems, __addr_);
    if (_res == null) return null;
    return CGstate.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGstate cgCreateArraySamplerState(CGcontext, const char *  name, CGtype, int nelems); </code> 
      @param arg2 valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  private static native ByteBuffer dispatch_cgCreateArraySamplerState1(ByteBuffer arg0, String name, int arg2, int nelems, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGstate cgCreateArrayState(CGcontext, const char *  name, CGtype, int nelems); </code> 
      @param arg2 valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static CGstate cgCreateArrayState(CGcontext arg0, String name, int arg2, int nelems)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateArrayState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgCreateArrayState\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateArrayState1(((arg0 == null) ? null : arg0.getBuffer()), name, arg2, nelems, __addr_);
    if (_res == null) return null;
    return CGstate.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGstate cgCreateArrayState(CGcontext, const char *  name, CGtype, int nelems); </code> 
      @param arg2 valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  private static native ByteBuffer dispatch_cgCreateArrayState1(ByteBuffer arg0, String name, int arg2, int nelems, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGcontext cgCreateContext(void); </code>    */
  public static CGcontext cgCreateContext()  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgCreateContext\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateContext1(__addr_);
    if (_res == null) return null;
    return CGcontext.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGcontext cgCreateContext(void); </code>    */
  private static native ByteBuffer dispatch_cgCreateContext1(long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGeffect cgCreateEffect(CGcontext, const char *  code, const char *  *  args); </code>    */
  public static CGeffect cgCreateEffect(CGcontext arg0, String code, String[] args)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateEffect;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgCreateEffect\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateEffect1(((arg0 == null) ? null : arg0.getBuffer()), code, args, __addr_);
    if (_res == null) return null;
    return CGeffect.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGeffect cgCreateEffect(CGcontext, const char *  code, const char *  *  args); </code>    */
  private static native ByteBuffer dispatch_cgCreateEffect1(ByteBuffer arg0, String code, String[] args, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGeffect cgCreateEffectFromFile(CGcontext, const char *  filename, const char *  *  args); </code>    */
  public static CGeffect cgCreateEffectFromFile(CGcontext arg0, String filename, String[] args)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateEffectFromFile;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgCreateEffectFromFile\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateEffectFromFile1(((arg0 == null) ? null : arg0.getBuffer()), filename, args, __addr_);
    if (_res == null) return null;
    return CGeffect.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGeffect cgCreateEffectFromFile(CGcontext, const char *  filename, const char *  *  args); </code>    */
  private static native ByteBuffer dispatch_cgCreateEffectFromFile1(ByteBuffer arg0, String filename, String[] args, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgCreateParameter(CGcontext ctx, CGtype type); </code> 
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static CGparameter cgCreateParameter(CGcontext ctx, int type)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgCreateParameter\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateParameter1(((ctx == null) ? null : ctx.getBuffer()), type, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgCreateParameter(CGcontext ctx, CGtype type); </code> 
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  private static native ByteBuffer dispatch_cgCreateParameter1(ByteBuffer ctx, int type, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgCreateParameterArray(CGcontext ctx, CGtype type, int length); </code> 
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static CGparameter cgCreateParameterArray(CGcontext ctx, int type, int length)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateParameterArray;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgCreateParameterArray\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateParameterArray1(((ctx == null) ? null : ctx.getBuffer()), type, length, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgCreateParameterArray(CGcontext ctx, CGtype type, int length); </code> 
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  private static native ByteBuffer dispatch_cgCreateParameterArray1(ByteBuffer ctx, int type, int length, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgCreateParameterMultiDimArray(CGcontext ctx, CGtype type, int dim, const int *  lengths); </code> 
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>

      @param lengths a direct or array-backed {@link java.nio.IntBuffer}   */
  public static CGparameter cgCreateParameterMultiDimArray(CGcontext ctx, int type, int dim, IntBuffer lengths)  {

    final boolean lengths_is_direct = Buffers.isDirect(lengths);
    final long __addr_ = cgProcAddressTable._addressof_cgCreateParameterMultiDimArray;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgCreateParameterMultiDimArray\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateParameterMultiDimArray1(((ctx == null) ? null : ctx.getBuffer()), type, dim, lengths_is_direct ? lengths : Buffers.getArray(lengths), lengths_is_direct ? Buffers.getDirectBufferByteOffset(lengths) : Buffers.getIndirectBufferByteOffset(lengths), lengths_is_direct, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgCreateParameterMultiDimArray(CGcontext ctx, CGtype type, int dim, const int *  lengths); </code> 
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>

      @param lengths a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native ByteBuffer dispatch_cgCreateParameterMultiDimArray1(ByteBuffer ctx, int type, int dim, Object lengths, int lengths_byte_offset, boolean lengths_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgCreateParameterMultiDimArray(CGcontext ctx, CGtype type, int dim, const int *  lengths); </code> 
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static CGparameter cgCreateParameterMultiDimArray(CGcontext ctx, int type, int dim, int[] lengths, int lengths_offset)  {

    if(lengths != null && lengths.length <= lengths_offset)
      throw new CgException("array offset argument \"lengths_offset\" (" + lengths_offset + ") equals or exceeds array length (" + lengths.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgCreateParameterMultiDimArray;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgCreateParameterMultiDimArray\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateParameterMultiDimArray1(((ctx == null) ? null : ctx.getBuffer()), type, dim, lengths, Buffers.SIZEOF_INT * lengths_offset, false, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGprogram cgCreateProgram(CGcontext ctx, CGenum program_type, const char *  program, CGprofile profile, const char *  entry, const char *  *  args); </code> 
      @param program_type valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>

      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static CGprogram cgCreateProgram(CGcontext ctx, int program_type, String program, int profile, String entry, String[] args)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgCreateProgram\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateProgram1(((ctx == null) ? null : ctx.getBuffer()), program_type, program, profile, entry, args, __addr_);
    if (_res == null) return null;
    return CGprogram.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGprogram cgCreateProgram(CGcontext ctx, CGenum program_type, const char *  program, CGprofile profile, const char *  entry, const char *  *  args); </code> 
      @param program_type valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>

      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  private static native ByteBuffer dispatch_cgCreateProgram1(ByteBuffer ctx, int program_type, String program, int profile, String entry, String[] args, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGprogram cgCreateProgramFromEffect(CGeffect effect, CGprofile profile, const char *  entry, const char *  *  args); </code> 
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static CGprogram cgCreateProgramFromEffect(CGeffect effect, int profile, String entry, String[] args)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateProgramFromEffect;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgCreateProgramFromEffect\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateProgramFromEffect1(((effect == null) ? null : effect.getBuffer()), profile, entry, args, __addr_);
    if (_res == null) return null;
    return CGprogram.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGprogram cgCreateProgramFromEffect(CGeffect effect, CGprofile profile, const char *  entry, const char *  *  args); </code> 
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  private static native ByteBuffer dispatch_cgCreateProgramFromEffect1(ByteBuffer effect, int profile, String entry, String[] args, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGprogram cgCreateProgramFromFile(CGcontext ctx, CGenum program_type, const char *  program_file, CGprofile profile, const char *  entry, const char *  *  args); </code> 
      @param program_type valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>

      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static CGprogram cgCreateProgramFromFile(CGcontext ctx, int program_type, String program_file, int profile, String entry, String[] args)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateProgramFromFile;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgCreateProgramFromFile\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateProgramFromFile1(((ctx == null) ? null : ctx.getBuffer()), program_type, program_file, profile, entry, args, __addr_);
    if (_res == null) return null;
    return CGprogram.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGprogram cgCreateProgramFromFile(CGcontext ctx, CGenum program_type, const char *  program_file, CGprofile profile, const char *  entry, const char *  *  args); </code> 
      @param program_type valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>

      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  private static native ByteBuffer dispatch_cgCreateProgramFromFile1(ByteBuffer ctx, int program_type, String program_file, int profile, String entry, String[] args, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGstate cgCreateSamplerState(CGcontext, const char *  name, CGtype); </code> 
      @param arg2 valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static CGstate cgCreateSamplerState(CGcontext arg0, String name, int arg2)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateSamplerState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgCreateSamplerState\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateSamplerState1(((arg0 == null) ? null : arg0.getBuffer()), name, arg2, __addr_);
    if (_res == null) return null;
    return CGstate.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGstate cgCreateSamplerState(CGcontext, const char *  name, CGtype); </code> 
      @param arg2 valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  private static native ByteBuffer dispatch_cgCreateSamplerState1(ByteBuffer arg0, String name, int arg2, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGstate cgCreateState(CGcontext, const char *  name, CGtype); </code> 
      @param arg2 valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static CGstate cgCreateState(CGcontext arg0, String name, int arg2)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgCreateState\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateState1(((arg0 == null) ? null : arg0.getBuffer()), name, arg2, __addr_);
    if (_res == null) return null;
    return CGstate.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGstate cgCreateState(CGcontext, const char *  name, CGtype); </code> 
      @param arg2 valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  private static native ByteBuffer dispatch_cgCreateState1(ByteBuffer arg0, String name, int arg2, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgDestroyContext(CGcontext ctx); </code>    */
  public static void cgDestroyContext(CGcontext ctx)  {

    final long __addr_ = cgProcAddressTable._addressof_cgDestroyContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgDestroyContext\" not available");
    }
        dispatch_cgDestroyContext1(((ctx == null) ? null : ctx.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgDestroyContext(CGcontext ctx); </code>    */
  private static native void dispatch_cgDestroyContext1(ByteBuffer ctx, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgDestroyEffect(CGeffect); </code>    */
  public static void cgDestroyEffect(CGeffect arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgDestroyEffect;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgDestroyEffect\" not available");
    }
        dispatch_cgDestroyEffect1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgDestroyEffect(CGeffect); </code>    */
  private static native void dispatch_cgDestroyEffect1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgDestroyParameter(CGparameter param); </code>    */
  public static void cgDestroyParameter(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgDestroyParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgDestroyParameter\" not available");
    }
        dispatch_cgDestroyParameter1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgDestroyParameter(CGparameter param); </code>    */
  private static native void dispatch_cgDestroyParameter1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgDestroyProgram(CGprogram program); </code>    */
  public static void cgDestroyProgram(CGprogram program)  {

    final long __addr_ = cgProcAddressTable._addressof_cgDestroyProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgDestroyProgram\" not available");
    }
        dispatch_cgDestroyProgram1(((program == null) ? null : program.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgDestroyProgram(CGprogram program); </code>    */
  private static native void dispatch_cgDestroyProgram1(ByteBuffer program, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgDisconnectParameter(CGparameter param); </code>    */
  public static void cgDisconnectParameter(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgDisconnectParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgDisconnectParameter\" not available");
    }
        dispatch_cgDisconnectParameter1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgDisconnectParameter(CGparameter param); </code>    */
  private static native void dispatch_cgDisconnectParameter1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgEvaluateProgram(CGprogram, float * , int ncomps, int nx, int ny, int nz); </code> 
      @param arg1 a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgEvaluateProgram(CGprogram arg0, FloatBuffer arg1, int ncomps, int nx, int ny, int nz)  {

    final boolean arg1_is_direct = Buffers.isDirect(arg1);
    final long __addr_ = cgProcAddressTable._addressof_cgEvaluateProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgEvaluateProgram\" not available");
    }
        dispatch_cgEvaluateProgram1(((arg0 == null) ? null : arg0.getBuffer()), arg1_is_direct ? arg1 : Buffers.getArray(arg1), arg1_is_direct ? Buffers.getDirectBufferByteOffset(arg1) : Buffers.getIndirectBufferByteOffset(arg1), arg1_is_direct, ncomps, nx, ny, nz, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgEvaluateProgram(CGprogram, float * , int ncomps, int nx, int ny, int nz); </code> 
      @param arg1 a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgEvaluateProgram1(ByteBuffer arg0, Object arg1, int arg1_byte_offset, boolean arg1_is_direct, int ncomps, int nx, int ny, int nz, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgEvaluateProgram(CGprogram, float * , int ncomps, int nx, int ny, int nz); </code>    */
  public static void cgEvaluateProgram(CGprogram arg0, float[] arg1, int arg1_offset, int ncomps, int nx, int ny, int nz)  {

    if(arg1 != null && arg1.length <= arg1_offset)
      throw new CgException("array offset argument \"arg1_offset\" (" + arg1_offset + ") equals or exceeds array length (" + arg1.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgEvaluateProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgEvaluateProgram\" not available");
    }
        dispatch_cgEvaluateProgram1(((arg0 == null) ? null : arg0.getBuffer()), arg1, Buffers.SIZEOF_FLOAT * arg1_offset, false, ncomps, nx, ny, nz, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLBindProgram(CGprogram program); </code>    */
  public static void cgGLBindProgram(CGprogram program)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLBindProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLBindProgram\" not available");
    }
        dispatch_cgGLBindProgram1(((program == null) ? null : program.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLBindProgram(CGprogram program); </code>    */
  private static native void dispatch_cgGLBindProgram1(ByteBuffer program, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLDisableClientState(CGparameter param); </code>    */
  public static void cgGLDisableClientState(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLDisableClientState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLDisableClientState\" not available");
    }
        dispatch_cgGLDisableClientState1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLDisableClientState(CGparameter param); </code>    */
  private static native void dispatch_cgGLDisableClientState1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLDisableProfile(CGprofile profile); </code> 
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static void cgGLDisableProfile(int profile)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLDisableProfile;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLDisableProfile\" not available");
    }
        dispatch_cgGLDisableProfile1(profile, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLDisableProfile(CGprofile profile); </code> 
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static native void dispatch_cgGLDisableProfile1(int profile, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLDisableTextureParameter(CGparameter param); </code>    */
  public static void cgGLDisableTextureParameter(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLDisableTextureParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLDisableTextureParameter\" not available");
    }
        dispatch_cgGLDisableTextureParameter1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLDisableTextureParameter(CGparameter param); </code>    */
  private static native void dispatch_cgGLDisableTextureParameter1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLEnableClientState(CGparameter param); </code>    */
  public static void cgGLEnableClientState(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLEnableClientState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLEnableClientState\" not available");
    }
        dispatch_cgGLEnableClientState1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLEnableClientState(CGparameter param); </code>    */
  private static native void dispatch_cgGLEnableClientState1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLEnableProfile(CGprofile profile); </code> 
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static void cgGLEnableProfile(int profile)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLEnableProfile;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLEnableProfile\" not available");
    }
        dispatch_cgGLEnableProfile1(profile, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLEnableProfile(CGprofile profile); </code> 
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static native void dispatch_cgGLEnableProfile1(int profile, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLEnableTextureParameter(CGparameter param); </code>    */
  public static void cgGLEnableTextureParameter(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLEnableTextureParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLEnableTextureParameter\" not available");
    }
        dispatch_cgGLEnableTextureParameter1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLEnableTextureParameter(CGparameter param); </code>    */
  private static native void dispatch_cgGLEnableTextureParameter1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGprofile cgGLGetLatestProfile(CGGLenum profile_type); </code> 
      @param profile_type valid values are: <code>CG_GL_MATRIX_IDENTITY, CG_GL_MATRIX_TRANSPOSE, CG_GL_MATRIX_INVERSE, CG_GL_MATRIX_INVERSE_TRANSPOSE, CG_GL_MODELVIEW_MATRIX, CG_GL_PROJECTION_MATRIX, CG_GL_TEXTURE_MATRIX, CG_GL_MODELVIEW_PROJECTION_MATRIX, CG_GL_VERTEX, CG_GL_FRAGMENT</code>
   */
  public static int cgGLGetLatestProfile(int profile_type)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLGetLatestProfile;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetLatestProfile\" not available");
    }
        return dispatch_cgGLGetLatestProfile1(profile_type, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGprofile cgGLGetLatestProfile(CGGLenum profile_type); </code> 
      @param profile_type valid values are: <code>CG_GL_MATRIX_IDENTITY, CG_GL_MATRIX_TRANSPOSE, CG_GL_MATRIX_INVERSE, CG_GL_MATRIX_INVERSE_TRANSPOSE, CG_GL_MODELVIEW_MATRIX, CG_GL_PROJECTION_MATRIX, CG_GL_TEXTURE_MATRIX, CG_GL_MODELVIEW_PROJECTION_MATRIX, CG_GL_VERTEX, CG_GL_FRAGMENT</code>
   */
  public static native int dispatch_cgGLGetLatestProfile1(int profile_type, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgGLGetManageTextureParameters(CGcontext ctx); </code>    */
  public static boolean cgGLGetManageTextureParameters(CGcontext ctx)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLGetManageTextureParameters;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetManageTextureParameters\" not available");
    }
        return dispatch_cgGLGetManageTextureParameters1(((ctx == null) ? null : ctx.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgGLGetManageTextureParameters(CGcontext ctx); </code>    */
  private static native boolean dispatch_cgGLGetManageTextureParameters1(ByteBuffer ctx, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterArraydc(CGparameter param, long offset, long nelements, double *  matrices); </code> 
      @param matrices a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetMatrixParameterArraydc(CGparameter param, long offset, long nelements, DoubleBuffer matrices)  {

    final boolean matrices_is_direct = Buffers.isDirect(matrices);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterArraydc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetMatrixParameterArraydc\" not available");
    }
        dispatch_cgGLGetMatrixParameterArraydc1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices_is_direct ? matrices : Buffers.getArray(matrices), matrices_is_direct ? Buffers.getDirectBufferByteOffset(matrices) : Buffers.getIndirectBufferByteOffset(matrices), matrices_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterArraydc(CGparameter param, long offset, long nelements, double *  matrices); </code> 
      @param matrices a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetMatrixParameterArraydc1(ByteBuffer param, long offset, long nelements, Object matrices, int matrices_byte_offset, boolean matrices_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterArraydc(CGparameter param, long offset, long nelements, double *  matrices); </code>    */
  public static void cgGLGetMatrixParameterArraydc(CGparameter param, long offset, long nelements, double[] matrices, int matrices_offset)  {

    if(matrices != null && matrices.length <= matrices_offset)
      throw new CgException("array offset argument \"matrices_offset\" (" + matrices_offset + ") equals or exceeds array length (" + matrices.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterArraydc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetMatrixParameterArraydc\" not available");
    }
        dispatch_cgGLGetMatrixParameterArraydc1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices, Buffers.SIZEOF_DOUBLE * matrices_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterArraydr(CGparameter param, long offset, long nelements, double *  matrices); </code> 
      @param matrices a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetMatrixParameterArraydr(CGparameter param, long offset, long nelements, DoubleBuffer matrices)  {

    final boolean matrices_is_direct = Buffers.isDirect(matrices);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterArraydr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetMatrixParameterArraydr\" not available");
    }
        dispatch_cgGLGetMatrixParameterArraydr1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices_is_direct ? matrices : Buffers.getArray(matrices), matrices_is_direct ? Buffers.getDirectBufferByteOffset(matrices) : Buffers.getIndirectBufferByteOffset(matrices), matrices_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterArraydr(CGparameter param, long offset, long nelements, double *  matrices); </code> 
      @param matrices a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetMatrixParameterArraydr1(ByteBuffer param, long offset, long nelements, Object matrices, int matrices_byte_offset, boolean matrices_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterArraydr(CGparameter param, long offset, long nelements, double *  matrices); </code>    */
  public static void cgGLGetMatrixParameterArraydr(CGparameter param, long offset, long nelements, double[] matrices, int matrices_offset)  {

    if(matrices != null && matrices.length <= matrices_offset)
      throw new CgException("array offset argument \"matrices_offset\" (" + matrices_offset + ") equals or exceeds array length (" + matrices.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterArraydr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetMatrixParameterArraydr\" not available");
    }
        dispatch_cgGLGetMatrixParameterArraydr1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices, Buffers.SIZEOF_DOUBLE * matrices_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterArrayfc(CGparameter param, long offset, long nelements, float *  matrices); </code> 
      @param matrices a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetMatrixParameterArrayfc(CGparameter param, long offset, long nelements, FloatBuffer matrices)  {

    final boolean matrices_is_direct = Buffers.isDirect(matrices);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterArrayfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetMatrixParameterArrayfc\" not available");
    }
        dispatch_cgGLGetMatrixParameterArrayfc1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices_is_direct ? matrices : Buffers.getArray(matrices), matrices_is_direct ? Buffers.getDirectBufferByteOffset(matrices) : Buffers.getIndirectBufferByteOffset(matrices), matrices_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterArrayfc(CGparameter param, long offset, long nelements, float *  matrices); </code> 
      @param matrices a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetMatrixParameterArrayfc1(ByteBuffer param, long offset, long nelements, Object matrices, int matrices_byte_offset, boolean matrices_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterArrayfc(CGparameter param, long offset, long nelements, float *  matrices); </code>    */
  public static void cgGLGetMatrixParameterArrayfc(CGparameter param, long offset, long nelements, float[] matrices, int matrices_offset)  {

    if(matrices != null && matrices.length <= matrices_offset)
      throw new CgException("array offset argument \"matrices_offset\" (" + matrices_offset + ") equals or exceeds array length (" + matrices.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterArrayfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetMatrixParameterArrayfc\" not available");
    }
        dispatch_cgGLGetMatrixParameterArrayfc1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices, Buffers.SIZEOF_FLOAT * matrices_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterArrayfr(CGparameter param, long offset, long nelements, float *  matrices); </code> 
      @param matrices a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetMatrixParameterArrayfr(CGparameter param, long offset, long nelements, FloatBuffer matrices)  {

    final boolean matrices_is_direct = Buffers.isDirect(matrices);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterArrayfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetMatrixParameterArrayfr\" not available");
    }
        dispatch_cgGLGetMatrixParameterArrayfr1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices_is_direct ? matrices : Buffers.getArray(matrices), matrices_is_direct ? Buffers.getDirectBufferByteOffset(matrices) : Buffers.getIndirectBufferByteOffset(matrices), matrices_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterArrayfr(CGparameter param, long offset, long nelements, float *  matrices); </code> 
      @param matrices a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetMatrixParameterArrayfr1(ByteBuffer param, long offset, long nelements, Object matrices, int matrices_byte_offset, boolean matrices_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterArrayfr(CGparameter param, long offset, long nelements, float *  matrices); </code>    */
  public static void cgGLGetMatrixParameterArrayfr(CGparameter param, long offset, long nelements, float[] matrices, int matrices_offset)  {

    if(matrices != null && matrices.length <= matrices_offset)
      throw new CgException("array offset argument \"matrices_offset\" (" + matrices_offset + ") equals or exceeds array length (" + matrices.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterArrayfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetMatrixParameterArrayfr\" not available");
    }
        dispatch_cgGLGetMatrixParameterArrayfr1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices, Buffers.SIZEOF_FLOAT * matrices_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterdc(CGparameter param, double *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetMatrixParameterdc(CGparameter param, DoubleBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterdc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetMatrixParameterdc\" not available");
    }
        dispatch_cgGLGetMatrixParameterdc1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterdc(CGparameter param, double *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetMatrixParameterdc1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterdc(CGparameter param, double *  matrix); </code>    */
  public static void cgGLGetMatrixParameterdc(CGparameter param, double[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterdc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetMatrixParameterdc\" not available");
    }
        dispatch_cgGLGetMatrixParameterdc1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_DOUBLE * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterdr(CGparameter param, double *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetMatrixParameterdr(CGparameter param, DoubleBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterdr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetMatrixParameterdr\" not available");
    }
        dispatch_cgGLGetMatrixParameterdr1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterdr(CGparameter param, double *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetMatrixParameterdr1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterdr(CGparameter param, double *  matrix); </code>    */
  public static void cgGLGetMatrixParameterdr(CGparameter param, double[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterdr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetMatrixParameterdr\" not available");
    }
        dispatch_cgGLGetMatrixParameterdr1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_DOUBLE * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterfc(CGparameter param, float *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetMatrixParameterfc(CGparameter param, FloatBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetMatrixParameterfc\" not available");
    }
        dispatch_cgGLGetMatrixParameterfc1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterfc(CGparameter param, float *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetMatrixParameterfc1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterfc(CGparameter param, float *  matrix); </code>    */
  public static void cgGLGetMatrixParameterfc(CGparameter param, float[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetMatrixParameterfc\" not available");
    }
        dispatch_cgGLGetMatrixParameterfc1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_FLOAT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterfr(CGparameter param, float *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetMatrixParameterfr(CGparameter param, FloatBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetMatrixParameterfr\" not available");
    }
        dispatch_cgGLGetMatrixParameterfr1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterfr(CGparameter param, float *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetMatrixParameterfr1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetMatrixParameterfr(CGparameter param, float *  matrix); </code>    */
  public static void cgGLGetMatrixParameterfr(CGparameter param, float[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetMatrixParameterfr\" not available");
    }
        dispatch_cgGLGetMatrixParameterfr1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_FLOAT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter1d(CGparameter param, double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetParameter1d(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter1d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameter1d\" not available");
    }
        dispatch_cgGLGetParameter1d1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter1d(CGparameter param, double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetParameter1d1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter1d(CGparameter param, double *  v); </code>    */
  public static void cgGLGetParameter1d(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter1d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameter1d\" not available");
    }
        dispatch_cgGLGetParameter1d1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter1f(CGparameter param, float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetParameter1f(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter1f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameter1f\" not available");
    }
        dispatch_cgGLGetParameter1f1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter1f(CGparameter param, float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetParameter1f1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter1f(CGparameter param, float *  v); </code>    */
  public static void cgGLGetParameter1f(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter1f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameter1f\" not available");
    }
        dispatch_cgGLGetParameter1f1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter2d(CGparameter param, double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetParameter2d(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter2d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameter2d\" not available");
    }
        dispatch_cgGLGetParameter2d1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter2d(CGparameter param, double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetParameter2d1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter2d(CGparameter param, double *  v); </code>    */
  public static void cgGLGetParameter2d(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter2d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameter2d\" not available");
    }
        dispatch_cgGLGetParameter2d1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter2f(CGparameter param, float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetParameter2f(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter2f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameter2f\" not available");
    }
        dispatch_cgGLGetParameter2f1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter2f(CGparameter param, float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetParameter2f1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter2f(CGparameter param, float *  v); </code>    */
  public static void cgGLGetParameter2f(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter2f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameter2f\" not available");
    }
        dispatch_cgGLGetParameter2f1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter3d(CGparameter param, double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetParameter3d(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter3d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameter3d\" not available");
    }
        dispatch_cgGLGetParameter3d1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter3d(CGparameter param, double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetParameter3d1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter3d(CGparameter param, double *  v); </code>    */
  public static void cgGLGetParameter3d(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter3d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameter3d\" not available");
    }
        dispatch_cgGLGetParameter3d1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter3f(CGparameter param, float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetParameter3f(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameter3f\" not available");
    }
        dispatch_cgGLGetParameter3f1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter3f(CGparameter param, float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetParameter3f1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter3f(CGparameter param, float *  v); </code>    */
  public static void cgGLGetParameter3f(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameter3f\" not available");
    }
        dispatch_cgGLGetParameter3f1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter4d(CGparameter param, double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetParameter4d(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter4d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameter4d\" not available");
    }
        dispatch_cgGLGetParameter4d1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter4d(CGparameter param, double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetParameter4d1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter4d(CGparameter param, double *  v); </code>    */
  public static void cgGLGetParameter4d(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter4d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameter4d\" not available");
    }
        dispatch_cgGLGetParameter4d1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter4f(CGparameter param, float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetParameter4f(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter4f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameter4f\" not available");
    }
        dispatch_cgGLGetParameter4f1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter4f(CGparameter param, float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetParameter4f1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameter4f(CGparameter param, float *  v); </code>    */
  public static void cgGLGetParameter4f(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter4f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameter4f\" not available");
    }
        dispatch_cgGLGetParameter4f1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray1d(CGparameter param, long offset, long nelements, double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetParameterArray1d(CGparameter param, long offset, long nelements, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray1d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameterArray1d\" not available");
    }
        dispatch_cgGLGetParameterArray1d1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray1d(CGparameter param, long offset, long nelements, double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetParameterArray1d1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray1d(CGparameter param, long offset, long nelements, double *  v); </code>    */
  public static void cgGLGetParameterArray1d(CGparameter param, long offset, long nelements, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray1d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameterArray1d\" not available");
    }
        dispatch_cgGLGetParameterArray1d1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray1f(CGparameter param, long offset, long nelements, float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetParameterArray1f(CGparameter param, long offset, long nelements, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray1f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameterArray1f\" not available");
    }
        dispatch_cgGLGetParameterArray1f1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray1f(CGparameter param, long offset, long nelements, float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetParameterArray1f1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray1f(CGparameter param, long offset, long nelements, float *  v); </code>    */
  public static void cgGLGetParameterArray1f(CGparameter param, long offset, long nelements, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray1f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameterArray1f\" not available");
    }
        dispatch_cgGLGetParameterArray1f1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray2d(CGparameter param, long offset, long nelements, double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetParameterArray2d(CGparameter param, long offset, long nelements, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray2d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameterArray2d\" not available");
    }
        dispatch_cgGLGetParameterArray2d1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray2d(CGparameter param, long offset, long nelements, double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetParameterArray2d1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray2d(CGparameter param, long offset, long nelements, double *  v); </code>    */
  public static void cgGLGetParameterArray2d(CGparameter param, long offset, long nelements, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray2d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameterArray2d\" not available");
    }
        dispatch_cgGLGetParameterArray2d1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray2f(CGparameter param, long offset, long nelements, float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetParameterArray2f(CGparameter param, long offset, long nelements, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray2f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameterArray2f\" not available");
    }
        dispatch_cgGLGetParameterArray2f1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray2f(CGparameter param, long offset, long nelements, float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetParameterArray2f1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray2f(CGparameter param, long offset, long nelements, float *  v); </code>    */
  public static void cgGLGetParameterArray2f(CGparameter param, long offset, long nelements, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray2f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameterArray2f\" not available");
    }
        dispatch_cgGLGetParameterArray2f1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray3d(CGparameter param, long offset, long nelements, double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetParameterArray3d(CGparameter param, long offset, long nelements, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray3d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameterArray3d\" not available");
    }
        dispatch_cgGLGetParameterArray3d1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray3d(CGparameter param, long offset, long nelements, double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetParameterArray3d1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray3d(CGparameter param, long offset, long nelements, double *  v); </code>    */
  public static void cgGLGetParameterArray3d(CGparameter param, long offset, long nelements, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray3d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameterArray3d\" not available");
    }
        dispatch_cgGLGetParameterArray3d1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray3f(CGparameter param, long offset, long nelements, float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetParameterArray3f(CGparameter param, long offset, long nelements, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameterArray3f\" not available");
    }
        dispatch_cgGLGetParameterArray3f1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray3f(CGparameter param, long offset, long nelements, float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetParameterArray3f1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray3f(CGparameter param, long offset, long nelements, float *  v); </code>    */
  public static void cgGLGetParameterArray3f(CGparameter param, long offset, long nelements, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameterArray3f\" not available");
    }
        dispatch_cgGLGetParameterArray3f1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray4d(CGparameter param, long offset, long nelements, double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetParameterArray4d(CGparameter param, long offset, long nelements, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray4d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameterArray4d\" not available");
    }
        dispatch_cgGLGetParameterArray4d1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray4d(CGparameter param, long offset, long nelements, double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetParameterArray4d1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray4d(CGparameter param, long offset, long nelements, double *  v); </code>    */
  public static void cgGLGetParameterArray4d(CGparameter param, long offset, long nelements, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray4d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameterArray4d\" not available");
    }
        dispatch_cgGLGetParameterArray4d1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray4f(CGparameter param, long offset, long nelements, float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetParameterArray4f(CGparameter param, long offset, long nelements, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray4f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameterArray4f\" not available");
    }
        dispatch_cgGLGetParameterArray4f1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray4f(CGparameter param, long offset, long nelements, float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetParameterArray4f1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLGetParameterArray4f(CGparameter param, long offset, long nelements, float *  v); </code>    */
  public static void cgGLGetParameterArray4f(CGparameter param, long offset, long nelements, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray4f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetParameterArray4f\" not available");
    }
        dispatch_cgGLGetParameterArray4f1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> GLuint cgGLGetProgramID(CGprogram program); </code>    */
  public static int cgGLGetProgramID(CGprogram program)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLGetProgramID;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetProgramID\" not available");
    }
        return dispatch_cgGLGetProgramID1(((program == null) ? null : program.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> GLuint cgGLGetProgramID(CGprogram program); </code>    */
  private static native int dispatch_cgGLGetProgramID1(ByteBuffer program, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> GLenum cgGLGetTextureEnum(CGparameter param); </code>    */
  public static int cgGLGetTextureEnum(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLGetTextureEnum;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetTextureEnum\" not available");
    }
        return dispatch_cgGLGetTextureEnum1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> GLenum cgGLGetTextureEnum(CGparameter param); </code>    */
  private static native int dispatch_cgGLGetTextureEnum1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> GLuint cgGLGetTextureParameter(CGparameter param); </code>    */
  public static int cgGLGetTextureParameter(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLGetTextureParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLGetTextureParameter\" not available");
    }
        return dispatch_cgGLGetTextureParameter1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> GLuint cgGLGetTextureParameter(CGparameter param); </code>    */
  private static native int dispatch_cgGLGetTextureParameter1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgGLIsProfileSupported(CGprofile profile); </code> 
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static boolean cgGLIsProfileSupported(int profile)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLIsProfileSupported;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLIsProfileSupported\" not available");
    }
        return dispatch_cgGLIsProfileSupported1(profile, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgGLIsProfileSupported(CGprofile profile); </code> 
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static native boolean dispatch_cgGLIsProfileSupported1(int profile, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgGLIsProgramLoaded(CGprogram program); </code>    */
  public static boolean cgGLIsProgramLoaded(CGprogram program)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLIsProgramLoaded;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLIsProgramLoaded\" not available");
    }
        return dispatch_cgGLIsProgramLoaded1(((program == null) ? null : program.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgGLIsProgramLoaded(CGprogram program); </code>    */
  private static native boolean dispatch_cgGLIsProgramLoaded1(ByteBuffer program, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLLoadProgram(CGprogram program); </code>    */
  public static void cgGLLoadProgram(CGprogram program)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLLoadProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLLoadProgram\" not available");
    }
        dispatch_cgGLLoadProgram1(((program == null) ? null : program.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLLoadProgram(CGprogram program); </code>    */
  private static native void dispatch_cgGLLoadProgram1(ByteBuffer program, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLRegisterStates(CGcontext); </code>    */
  public static void cgGLRegisterStates(CGcontext arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLRegisterStates;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLRegisterStates\" not available");
    }
        dispatch_cgGLRegisterStates1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLRegisterStates(CGcontext); </code>    */
  private static native void dispatch_cgGLRegisterStates1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetManageTextureParameters(CGcontext ctx, CGbool flag); </code>    */
  public static void cgGLSetManageTextureParameters(CGcontext ctx, boolean flag)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetManageTextureParameters;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetManageTextureParameters\" not available");
    }
        dispatch_cgGLSetManageTextureParameters1(((ctx == null) ? null : ctx.getBuffer()), flag, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetManageTextureParameters(CGcontext ctx, CGbool flag); </code>    */
  private static native void dispatch_cgGLSetManageTextureParameters1(ByteBuffer ctx, boolean flag, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterArraydc(CGparameter param, long offset, long nelements, const double *  matrices); </code> 
      @param matrices a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetMatrixParameterArraydc(CGparameter param, long offset, long nelements, DoubleBuffer matrices)  {

    final boolean matrices_is_direct = Buffers.isDirect(matrices);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterArraydc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetMatrixParameterArraydc\" not available");
    }
        dispatch_cgGLSetMatrixParameterArraydc1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices_is_direct ? matrices : Buffers.getArray(matrices), matrices_is_direct ? Buffers.getDirectBufferByteOffset(matrices) : Buffers.getIndirectBufferByteOffset(matrices), matrices_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterArraydc(CGparameter param, long offset, long nelements, const double *  matrices); </code> 
      @param matrices a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetMatrixParameterArraydc1(ByteBuffer param, long offset, long nelements, Object matrices, int matrices_byte_offset, boolean matrices_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterArraydc(CGparameter param, long offset, long nelements, const double *  matrices); </code>    */
  public static void cgGLSetMatrixParameterArraydc(CGparameter param, long offset, long nelements, double[] matrices, int matrices_offset)  {

    if(matrices != null && matrices.length <= matrices_offset)
      throw new CgException("array offset argument \"matrices_offset\" (" + matrices_offset + ") equals or exceeds array length (" + matrices.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterArraydc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetMatrixParameterArraydc\" not available");
    }
        dispatch_cgGLSetMatrixParameterArraydc1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices, Buffers.SIZEOF_DOUBLE * matrices_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterArraydr(CGparameter param, long offset, long nelements, const double *  matrices); </code> 
      @param matrices a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetMatrixParameterArraydr(CGparameter param, long offset, long nelements, DoubleBuffer matrices)  {

    final boolean matrices_is_direct = Buffers.isDirect(matrices);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterArraydr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetMatrixParameterArraydr\" not available");
    }
        dispatch_cgGLSetMatrixParameterArraydr1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices_is_direct ? matrices : Buffers.getArray(matrices), matrices_is_direct ? Buffers.getDirectBufferByteOffset(matrices) : Buffers.getIndirectBufferByteOffset(matrices), matrices_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterArraydr(CGparameter param, long offset, long nelements, const double *  matrices); </code> 
      @param matrices a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetMatrixParameterArraydr1(ByteBuffer param, long offset, long nelements, Object matrices, int matrices_byte_offset, boolean matrices_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterArraydr(CGparameter param, long offset, long nelements, const double *  matrices); </code>    */
  public static void cgGLSetMatrixParameterArraydr(CGparameter param, long offset, long nelements, double[] matrices, int matrices_offset)  {

    if(matrices != null && matrices.length <= matrices_offset)
      throw new CgException("array offset argument \"matrices_offset\" (" + matrices_offset + ") equals or exceeds array length (" + matrices.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterArraydr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetMatrixParameterArraydr\" not available");
    }
        dispatch_cgGLSetMatrixParameterArraydr1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices, Buffers.SIZEOF_DOUBLE * matrices_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterArrayfc(CGparameter param, long offset, long nelements, const float *  matrices); </code> 
      @param matrices a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetMatrixParameterArrayfc(CGparameter param, long offset, long nelements, FloatBuffer matrices)  {

    final boolean matrices_is_direct = Buffers.isDirect(matrices);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterArrayfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetMatrixParameterArrayfc\" not available");
    }
        dispatch_cgGLSetMatrixParameterArrayfc1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices_is_direct ? matrices : Buffers.getArray(matrices), matrices_is_direct ? Buffers.getDirectBufferByteOffset(matrices) : Buffers.getIndirectBufferByteOffset(matrices), matrices_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterArrayfc(CGparameter param, long offset, long nelements, const float *  matrices); </code> 
      @param matrices a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetMatrixParameterArrayfc1(ByteBuffer param, long offset, long nelements, Object matrices, int matrices_byte_offset, boolean matrices_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterArrayfc(CGparameter param, long offset, long nelements, const float *  matrices); </code>    */
  public static void cgGLSetMatrixParameterArrayfc(CGparameter param, long offset, long nelements, float[] matrices, int matrices_offset)  {

    if(matrices != null && matrices.length <= matrices_offset)
      throw new CgException("array offset argument \"matrices_offset\" (" + matrices_offset + ") equals or exceeds array length (" + matrices.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterArrayfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetMatrixParameterArrayfc\" not available");
    }
        dispatch_cgGLSetMatrixParameterArrayfc1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices, Buffers.SIZEOF_FLOAT * matrices_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterArrayfr(CGparameter param, long offset, long nelements, const float *  matrices); </code> 
      @param matrices a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetMatrixParameterArrayfr(CGparameter param, long offset, long nelements, FloatBuffer matrices)  {

    final boolean matrices_is_direct = Buffers.isDirect(matrices);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterArrayfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetMatrixParameterArrayfr\" not available");
    }
        dispatch_cgGLSetMatrixParameterArrayfr1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices_is_direct ? matrices : Buffers.getArray(matrices), matrices_is_direct ? Buffers.getDirectBufferByteOffset(matrices) : Buffers.getIndirectBufferByteOffset(matrices), matrices_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterArrayfr(CGparameter param, long offset, long nelements, const float *  matrices); </code> 
      @param matrices a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetMatrixParameterArrayfr1(ByteBuffer param, long offset, long nelements, Object matrices, int matrices_byte_offset, boolean matrices_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterArrayfr(CGparameter param, long offset, long nelements, const float *  matrices); </code>    */
  public static void cgGLSetMatrixParameterArrayfr(CGparameter param, long offset, long nelements, float[] matrices, int matrices_offset)  {

    if(matrices != null && matrices.length <= matrices_offset)
      throw new CgException("array offset argument \"matrices_offset\" (" + matrices_offset + ") equals or exceeds array length (" + matrices.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterArrayfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetMatrixParameterArrayfr\" not available");
    }
        dispatch_cgGLSetMatrixParameterArrayfr1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices, Buffers.SIZEOF_FLOAT * matrices_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterdc(CGparameter param, const double *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetMatrixParameterdc(CGparameter param, DoubleBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterdc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetMatrixParameterdc\" not available");
    }
        dispatch_cgGLSetMatrixParameterdc1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterdc(CGparameter param, const double *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetMatrixParameterdc1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterdc(CGparameter param, const double *  matrix); </code>    */
  public static void cgGLSetMatrixParameterdc(CGparameter param, double[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterdc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetMatrixParameterdc\" not available");
    }
        dispatch_cgGLSetMatrixParameterdc1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_DOUBLE * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterdr(CGparameter param, const double *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetMatrixParameterdr(CGparameter param, DoubleBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterdr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetMatrixParameterdr\" not available");
    }
        dispatch_cgGLSetMatrixParameterdr1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterdr(CGparameter param, const double *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetMatrixParameterdr1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterdr(CGparameter param, const double *  matrix); </code>    */
  public static void cgGLSetMatrixParameterdr(CGparameter param, double[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterdr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetMatrixParameterdr\" not available");
    }
        dispatch_cgGLSetMatrixParameterdr1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_DOUBLE * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterfc(CGparameter param, const float *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetMatrixParameterfc(CGparameter param, FloatBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetMatrixParameterfc\" not available");
    }
        dispatch_cgGLSetMatrixParameterfc1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterfc(CGparameter param, const float *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetMatrixParameterfc1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterfc(CGparameter param, const float *  matrix); </code>    */
  public static void cgGLSetMatrixParameterfc(CGparameter param, float[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetMatrixParameterfc\" not available");
    }
        dispatch_cgGLSetMatrixParameterfc1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_FLOAT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterfr(CGparameter param, const float *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetMatrixParameterfr(CGparameter param, FloatBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetMatrixParameterfr\" not available");
    }
        dispatch_cgGLSetMatrixParameterfr1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterfr(CGparameter param, const float *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetMatrixParameterfr1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetMatrixParameterfr(CGparameter param, const float *  matrix); </code>    */
  public static void cgGLSetMatrixParameterfr(CGparameter param, float[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetMatrixParameterfr\" not available");
    }
        dispatch_cgGLSetMatrixParameterfr1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_FLOAT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetOptimalOptions(CGprofile profile); </code> 
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static void cgGLSetOptimalOptions(int profile)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetOptimalOptions;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetOptimalOptions\" not available");
    }
        dispatch_cgGLSetOptimalOptions1(profile, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetOptimalOptions(CGprofile profile); </code> 
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static native void dispatch_cgGLSetOptimalOptions1(int profile, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter1d(CGparameter param, double x); </code>    */
  public static void cgGLSetParameter1d(CGparameter param, double x)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter1d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter1d\" not available");
    }
        dispatch_cgGLSetParameter1d1(((param == null) ? null : param.getBuffer()), x, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter1d(CGparameter param, double x); </code>    */
  private static native void dispatch_cgGLSetParameter1d1(ByteBuffer param, double x, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter1dv(CGparameter param, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetParameter1dv(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter1dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter1dv\" not available");
    }
        dispatch_cgGLSetParameter1dv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter1dv(CGparameter param, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetParameter1dv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter1dv(CGparameter param, const double *  v); </code>    */
  public static void cgGLSetParameter1dv(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter1dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter1dv\" not available");
    }
        dispatch_cgGLSetParameter1dv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter1f(CGparameter param, float x); </code>    */
  public static void cgGLSetParameter1f(CGparameter param, float x)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter1f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter1f\" not available");
    }
        dispatch_cgGLSetParameter1f1(((param == null) ? null : param.getBuffer()), x, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter1f(CGparameter param, float x); </code>    */
  private static native void dispatch_cgGLSetParameter1f1(ByteBuffer param, float x, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter1fv(CGparameter param, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetParameter1fv(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter1fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter1fv\" not available");
    }
        dispatch_cgGLSetParameter1fv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter1fv(CGparameter param, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetParameter1fv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter1fv(CGparameter param, const float *  v); </code>    */
  public static void cgGLSetParameter1fv(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter1fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter1fv\" not available");
    }
        dispatch_cgGLSetParameter1fv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter2d(CGparameter param, double x, double y); </code>    */
  public static void cgGLSetParameter2d(CGparameter param, double x, double y)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter2d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter2d\" not available");
    }
        dispatch_cgGLSetParameter2d1(((param == null) ? null : param.getBuffer()), x, y, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter2d(CGparameter param, double x, double y); </code>    */
  private static native void dispatch_cgGLSetParameter2d1(ByteBuffer param, double x, double y, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter2dv(CGparameter param, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetParameter2dv(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter2dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter2dv\" not available");
    }
        dispatch_cgGLSetParameter2dv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter2dv(CGparameter param, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetParameter2dv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter2dv(CGparameter param, const double *  v); </code>    */
  public static void cgGLSetParameter2dv(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter2dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter2dv\" not available");
    }
        dispatch_cgGLSetParameter2dv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter2f(CGparameter param, float x, float y); </code>    */
  public static void cgGLSetParameter2f(CGparameter param, float x, float y)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter2f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter2f\" not available");
    }
        dispatch_cgGLSetParameter2f1(((param == null) ? null : param.getBuffer()), x, y, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter2f(CGparameter param, float x, float y); </code>    */
  private static native void dispatch_cgGLSetParameter2f1(ByteBuffer param, float x, float y, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter2fv(CGparameter param, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetParameter2fv(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter2fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter2fv\" not available");
    }
        dispatch_cgGLSetParameter2fv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter2fv(CGparameter param, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetParameter2fv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter2fv(CGparameter param, const float *  v); </code>    */
  public static void cgGLSetParameter2fv(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter2fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter2fv\" not available");
    }
        dispatch_cgGLSetParameter2fv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter3d(CGparameter param, double x, double y, double z); </code>    */
  public static void cgGLSetParameter3d(CGparameter param, double x, double y, double z)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter3d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter3d\" not available");
    }
        dispatch_cgGLSetParameter3d1(((param == null) ? null : param.getBuffer()), x, y, z, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter3d(CGparameter param, double x, double y, double z); </code>    */
  private static native void dispatch_cgGLSetParameter3d1(ByteBuffer param, double x, double y, double z, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter3dv(CGparameter param, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetParameter3dv(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter3dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter3dv\" not available");
    }
        dispatch_cgGLSetParameter3dv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter3dv(CGparameter param, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetParameter3dv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter3dv(CGparameter param, const double *  v); </code>    */
  public static void cgGLSetParameter3dv(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter3dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter3dv\" not available");
    }
        dispatch_cgGLSetParameter3dv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter3f(CGparameter param, float x, float y, float z); </code>    */
  public static void cgGLSetParameter3f(CGparameter param, float x, float y, float z)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter3f\" not available");
    }
        dispatch_cgGLSetParameter3f1(((param == null) ? null : param.getBuffer()), x, y, z, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter3f(CGparameter param, float x, float y, float z); </code>    */
  private static native void dispatch_cgGLSetParameter3f1(ByteBuffer param, float x, float y, float z, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter3fv(CGparameter param, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetParameter3fv(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter3fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter3fv\" not available");
    }
        dispatch_cgGLSetParameter3fv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter3fv(CGparameter param, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetParameter3fv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter3fv(CGparameter param, const float *  v); </code>    */
  public static void cgGLSetParameter3fv(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter3fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter3fv\" not available");
    }
        dispatch_cgGLSetParameter3fv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter4d(CGparameter param, double x, double y, double z, double w); </code>    */
  public static void cgGLSetParameter4d(CGparameter param, double x, double y, double z, double w)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter4d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter4d\" not available");
    }
        dispatch_cgGLSetParameter4d1(((param == null) ? null : param.getBuffer()), x, y, z, w, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter4d(CGparameter param, double x, double y, double z, double w); </code>    */
  private static native void dispatch_cgGLSetParameter4d1(ByteBuffer param, double x, double y, double z, double w, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter4dv(CGparameter param, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetParameter4dv(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter4dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter4dv\" not available");
    }
        dispatch_cgGLSetParameter4dv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter4dv(CGparameter param, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetParameter4dv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter4dv(CGparameter param, const double *  v); </code>    */
  public static void cgGLSetParameter4dv(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter4dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter4dv\" not available");
    }
        dispatch_cgGLSetParameter4dv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter4f(CGparameter param, float x, float y, float z, float w); </code>    */
  public static void cgGLSetParameter4f(CGparameter param, float x, float y, float z, float w)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter4f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter4f\" not available");
    }
        dispatch_cgGLSetParameter4f1(((param == null) ? null : param.getBuffer()), x, y, z, w, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter4f(CGparameter param, float x, float y, float z, float w); </code>    */
  private static native void dispatch_cgGLSetParameter4f1(ByteBuffer param, float x, float y, float z, float w, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter4fv(CGparameter param, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetParameter4fv(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter4fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter4fv\" not available");
    }
        dispatch_cgGLSetParameter4fv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter4fv(CGparameter param, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetParameter4fv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameter4fv(CGparameter param, const float *  v); </code>    */
  public static void cgGLSetParameter4fv(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter4fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameter4fv\" not available");
    }
        dispatch_cgGLSetParameter4fv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray1d(CGparameter param, long offset, long nelements, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetParameterArray1d(CGparameter param, long offset, long nelements, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray1d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameterArray1d\" not available");
    }
        dispatch_cgGLSetParameterArray1d1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray1d(CGparameter param, long offset, long nelements, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetParameterArray1d1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray1d(CGparameter param, long offset, long nelements, const double *  v); </code>    */
  public static void cgGLSetParameterArray1d(CGparameter param, long offset, long nelements, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray1d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameterArray1d\" not available");
    }
        dispatch_cgGLSetParameterArray1d1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray1f(CGparameter param, long offset, long nelements, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetParameterArray1f(CGparameter param, long offset, long nelements, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray1f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameterArray1f\" not available");
    }
        dispatch_cgGLSetParameterArray1f1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray1f(CGparameter param, long offset, long nelements, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetParameterArray1f1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray1f(CGparameter param, long offset, long nelements, const float *  v); </code>    */
  public static void cgGLSetParameterArray1f(CGparameter param, long offset, long nelements, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray1f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameterArray1f\" not available");
    }
        dispatch_cgGLSetParameterArray1f1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray2d(CGparameter param, long offset, long nelements, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetParameterArray2d(CGparameter param, long offset, long nelements, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray2d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameterArray2d\" not available");
    }
        dispatch_cgGLSetParameterArray2d1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray2d(CGparameter param, long offset, long nelements, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetParameterArray2d1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray2d(CGparameter param, long offset, long nelements, const double *  v); </code>    */
  public static void cgGLSetParameterArray2d(CGparameter param, long offset, long nelements, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray2d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameterArray2d\" not available");
    }
        dispatch_cgGLSetParameterArray2d1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray2f(CGparameter param, long offset, long nelements, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetParameterArray2f(CGparameter param, long offset, long nelements, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray2f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameterArray2f\" not available");
    }
        dispatch_cgGLSetParameterArray2f1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray2f(CGparameter param, long offset, long nelements, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetParameterArray2f1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray2f(CGparameter param, long offset, long nelements, const float *  v); </code>    */
  public static void cgGLSetParameterArray2f(CGparameter param, long offset, long nelements, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray2f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameterArray2f\" not available");
    }
        dispatch_cgGLSetParameterArray2f1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray3d(CGparameter param, long offset, long nelements, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetParameterArray3d(CGparameter param, long offset, long nelements, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray3d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameterArray3d\" not available");
    }
        dispatch_cgGLSetParameterArray3d1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray3d(CGparameter param, long offset, long nelements, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetParameterArray3d1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray3d(CGparameter param, long offset, long nelements, const double *  v); </code>    */
  public static void cgGLSetParameterArray3d(CGparameter param, long offset, long nelements, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray3d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameterArray3d\" not available");
    }
        dispatch_cgGLSetParameterArray3d1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray3f(CGparameter param, long offset, long nelements, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetParameterArray3f(CGparameter param, long offset, long nelements, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameterArray3f\" not available");
    }
        dispatch_cgGLSetParameterArray3f1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray3f(CGparameter param, long offset, long nelements, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetParameterArray3f1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray3f(CGparameter param, long offset, long nelements, const float *  v); </code>    */
  public static void cgGLSetParameterArray3f(CGparameter param, long offset, long nelements, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameterArray3f\" not available");
    }
        dispatch_cgGLSetParameterArray3f1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray4d(CGparameter param, long offset, long nelements, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetParameterArray4d(CGparameter param, long offset, long nelements, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray4d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameterArray4d\" not available");
    }
        dispatch_cgGLSetParameterArray4d1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray4d(CGparameter param, long offset, long nelements, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetParameterArray4d1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray4d(CGparameter param, long offset, long nelements, const double *  v); </code>    */
  public static void cgGLSetParameterArray4d(CGparameter param, long offset, long nelements, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray4d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameterArray4d\" not available");
    }
        dispatch_cgGLSetParameterArray4d1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray4f(CGparameter param, long offset, long nelements, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetParameterArray4f(CGparameter param, long offset, long nelements, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray4f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameterArray4f\" not available");
    }
        dispatch_cgGLSetParameterArray4f1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray4f(CGparameter param, long offset, long nelements, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetParameterArray4f1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterArray4f(CGparameter param, long offset, long nelements, const float *  v); </code>    */
  public static void cgGLSetParameterArray4f(CGparameter param, long offset, long nelements, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray4f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameterArray4f\" not available");
    }
        dispatch_cgGLSetParameterArray4f1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterPointer(CGparameter param, GLint fsize, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> 
      @param pointer a direct only {@link java.nio.Buffer}   */
  public static void cgGLSetParameterPointer(CGparameter param, int fsize, int type, int stride, Buffer pointer)  {

    if (!Buffers.isDirect(pointer))
      throw new CgException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterPointer;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetParameterPointer\" not available");
    }
        dispatch_cgGLSetParameterPointer0(((param == null) ? null : param.getBuffer()), fsize, type, stride, pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetParameterPointer(CGparameter param, GLint fsize, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> 
      @param pointer a direct only {@link java.nio.Buffer}   */
  private static native void dispatch_cgGLSetParameterPointer0(ByteBuffer param, int fsize, int type, int stride, Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetStateMatrixParameter(CGparameter param, CGGLenum matrix, CGGLenum transform); </code> 
      @param matrix valid values are: <code>CG_GL_MATRIX_IDENTITY, CG_GL_MATRIX_TRANSPOSE, CG_GL_MATRIX_INVERSE, CG_GL_MATRIX_INVERSE_TRANSPOSE, CG_GL_MODELVIEW_MATRIX, CG_GL_PROJECTION_MATRIX, CG_GL_TEXTURE_MATRIX, CG_GL_MODELVIEW_PROJECTION_MATRIX, CG_GL_VERTEX, CG_GL_FRAGMENT</code>

      @param transform valid values are: <code>CG_GL_MATRIX_IDENTITY, CG_GL_MATRIX_TRANSPOSE, CG_GL_MATRIX_INVERSE, CG_GL_MATRIX_INVERSE_TRANSPOSE, CG_GL_MODELVIEW_MATRIX, CG_GL_PROJECTION_MATRIX, CG_GL_TEXTURE_MATRIX, CG_GL_MODELVIEW_PROJECTION_MATRIX, CG_GL_VERTEX, CG_GL_FRAGMENT</code>
   */
  public static void cgGLSetStateMatrixParameter(CGparameter param, int matrix, int transform)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetStateMatrixParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetStateMatrixParameter\" not available");
    }
        dispatch_cgGLSetStateMatrixParameter1(((param == null) ? null : param.getBuffer()), matrix, transform, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetStateMatrixParameter(CGparameter param, CGGLenum matrix, CGGLenum transform); </code> 
      @param matrix valid values are: <code>CG_GL_MATRIX_IDENTITY, CG_GL_MATRIX_TRANSPOSE, CG_GL_MATRIX_INVERSE, CG_GL_MATRIX_INVERSE_TRANSPOSE, CG_GL_MODELVIEW_MATRIX, CG_GL_PROJECTION_MATRIX, CG_GL_TEXTURE_MATRIX, CG_GL_MODELVIEW_PROJECTION_MATRIX, CG_GL_VERTEX, CG_GL_FRAGMENT</code>

      @param transform valid values are: <code>CG_GL_MATRIX_IDENTITY, CG_GL_MATRIX_TRANSPOSE, CG_GL_MATRIX_INVERSE, CG_GL_MATRIX_INVERSE_TRANSPOSE, CG_GL_MODELVIEW_MATRIX, CG_GL_PROJECTION_MATRIX, CG_GL_TEXTURE_MATRIX, CG_GL_MODELVIEW_PROJECTION_MATRIX, CG_GL_VERTEX, CG_GL_FRAGMENT</code>
   */
  private static native void dispatch_cgGLSetStateMatrixParameter1(ByteBuffer param, int matrix, int transform, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetTextureParameter(CGparameter param, GLuint texobj); </code>    */
  public static void cgGLSetTextureParameter(CGparameter param, int texobj)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetTextureParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetTextureParameter\" not available");
    }
        dispatch_cgGLSetTextureParameter1(((param == null) ? null : param.getBuffer()), texobj, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetTextureParameter(CGparameter param, GLuint texobj); </code>    */
  private static native void dispatch_cgGLSetTextureParameter1(ByteBuffer param, int texobj, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetupSampler(CGparameter param, GLuint texobj); </code>    */
  public static void cgGLSetupSampler(CGparameter param, int texobj)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetupSampler;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLSetupSampler\" not available");
    }
        dispatch_cgGLSetupSampler1(((param == null) ? null : param.getBuffer()), texobj, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLSetupSampler(CGparameter param, GLuint texobj); </code>    */
  private static native void dispatch_cgGLSetupSampler1(ByteBuffer param, int texobj, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLUnbindProgram(CGprofile profile); </code> 
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static void cgGLUnbindProgram(int profile)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLUnbindProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGLUnbindProgram\" not available");
    }
        dispatch_cgGLUnbindProgram1(profile, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGLUnbindProgram(CGprofile profile); </code> 
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static native void dispatch_cgGLUnbindProgram1(int profile, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetAnnotationName(CGannotation); </code>    */
  public static String cgGetAnnotationName(CGannotation arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetAnnotationName;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetAnnotationName\" not available");
    }
        return dispatch_cgGetAnnotationName1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetAnnotationName(CGannotation); </code>    */
  private static native String dispatch_cgGetAnnotationName1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGtype cgGetAnnotationType(CGannotation); </code>    */
  public static int cgGetAnnotationType(CGannotation arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetAnnotationType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetAnnotationType\" not available");
    }
        return dispatch_cgGetAnnotationType1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGtype cgGetAnnotationType(CGannotation); </code>    */
  private static native int dispatch_cgGetAnnotationType1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetArrayDimension(CGparameter param); </code>    */
  public static int cgGetArrayDimension(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetArrayDimension;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetArrayDimension\" not available");
    }
        return dispatch_cgGetArrayDimension1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetArrayDimension(CGparameter param); </code>    */
  private static native int dispatch_cgGetArrayDimension1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetArrayParameter(CGparameter aparam, int index); </code>    */
  public static CGparameter cgGetArrayParameter(CGparameter aparam, int index)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetArrayParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetArrayParameter\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetArrayParameter1(((aparam == null) ? null : aparam.getBuffer()), index, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetArrayParameter(CGparameter aparam, int index); </code>    */
  private static native ByteBuffer dispatch_cgGetArrayParameter1(ByteBuffer aparam, int index, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetArraySize(CGparameter param, int dimension); </code>    */
  public static int cgGetArraySize(CGparameter param, int dimension)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetArraySize;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetArraySize\" not available");
    }
        return dispatch_cgGetArraySize1(((param == null) ? null : param.getBuffer()), dimension, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetArraySize(CGparameter param, int dimension); </code>    */
  private static native int dispatch_cgGetArraySize1(ByteBuffer param, int dimension, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetArrayTotalSize(CGparameter param); </code>    */
  public static int cgGetArrayTotalSize(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetArrayTotalSize;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetArrayTotalSize\" not available");
    }
        return dispatch_cgGetArrayTotalSize1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetArrayTotalSize(CGparameter param); </code>    */
  private static native int dispatch_cgGetArrayTotalSize1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGtype cgGetArrayType(CGparameter param); </code>    */
  public static int cgGetArrayType(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetArrayType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetArrayType\" not available");
    }
        return dispatch_cgGetArrayType1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGtype cgGetArrayType(CGparameter param); </code>    */
  private static native int dispatch_cgGetArrayType1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGenum cgGetAutoCompile(CGcontext ctx); </code>    */
  public static int cgGetAutoCompile(CGcontext ctx)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetAutoCompile;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetAutoCompile\" not available");
    }
        return dispatch_cgGetAutoCompile1(((ctx == null) ? null : ctx.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGenum cgGetAutoCompile(CGcontext ctx); </code>    */
  private static native int dispatch_cgGetAutoCompile1(ByteBuffer ctx, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetConnectedParameter(CGparameter param); </code>    */
  public static CGparameter cgGetConnectedParameter(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetConnectedParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetConnectedParameter\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetConnectedParameter1(((param == null) ? null : param.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetConnectedParameter(CGparameter param); </code>    */
  private static native ByteBuffer dispatch_cgGetConnectedParameter1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetConnectedToParameter(CGparameter param, int index); </code>    */
  public static CGparameter cgGetConnectedToParameter(CGparameter param, int index)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetConnectedToParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetConnectedToParameter\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetConnectedToParameter1(((param == null) ? null : param.getBuffer()), index, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetConnectedToParameter(CGparameter param, int index); </code>    */
  private static native ByteBuffer dispatch_cgGetConnectedToParameter1(ByteBuffer param, int index, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetDependentAnnotationParameter(CGannotation, int index); </code>    */
  public static CGparameter cgGetDependentAnnotationParameter(CGannotation arg0, int index)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetDependentAnnotationParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetDependentAnnotationParameter\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetDependentAnnotationParameter1(((arg0 == null) ? null : arg0.getBuffer()), index, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetDependentAnnotationParameter(CGannotation, int index); </code>    */
  private static native ByteBuffer dispatch_cgGetDependentAnnotationParameter1(ByteBuffer arg0, int index, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetDependentStateAssignmentParameter(CGstateassignment, int index); </code>    */
  public static CGparameter cgGetDependentStateAssignmentParameter(CGstateassignment arg0, int index)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetDependentStateAssignmentParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetDependentStateAssignmentParameter\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetDependentStateAssignmentParameter1(((arg0 == null) ? null : arg0.getBuffer()), index, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetDependentStateAssignmentParameter(CGstateassignment, int index); </code>    */
  private static native ByteBuffer dispatch_cgGetDependentStateAssignmentParameter1(ByteBuffer arg0, int index, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGcontext cgGetEffectContext(CGeffect); </code>    */
  public static CGcontext cgGetEffectContext(CGeffect arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetEffectContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetEffectContext\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetEffectContext1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGcontext.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGcontext cgGetEffectContext(CGeffect); </code>    */
  private static native ByteBuffer dispatch_cgGetEffectContext1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetEffectParameterBySemantic(CGeffect, const char * ); </code>    */
  public static CGparameter cgGetEffectParameterBySemantic(CGeffect arg0, String arg1)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetEffectParameterBySemantic;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetEffectParameterBySemantic\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetEffectParameterBySemantic1(((arg0 == null) ? null : arg0.getBuffer()), arg1, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetEffectParameterBySemantic(CGeffect, const char * ); </code>    */
  private static native ByteBuffer dispatch_cgGetEffectParameterBySemantic1(ByteBuffer arg0, String arg1, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGenum cgGetEnum(const char *  enum_string); </code>    */
  public static int cgGetEnum(String enum_string)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetEnum;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetEnum\" not available");
    }
        return dispatch_cgGetEnum1(enum_string, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGenum cgGetEnum(const char *  enum_string); </code>    */
  public static native int dispatch_cgGetEnum1(String enum_string, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetEnumString(CGenum en); </code> 
      @param en valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  public static String cgGetEnumString(int en)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetEnumString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetEnumString\" not available");
    }
        return dispatch_cgGetEnumString1(en, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetEnumString(CGenum en); </code> 
      @param en valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  public static native String dispatch_cgGetEnumString1(int en, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGerror cgGetError(void); </code>    */
  public static int cgGetError()  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetError;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetError\" not available");
    }
        return dispatch_cgGetError1(__addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGerror cgGetError(void); </code>    */
  public static native int dispatch_cgGetError1(long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetErrorString(CGerror error); </code> 
      @param error valid values are: <code>CG_NO_ERROR, CG_COMPILER_ERROR, CG_INVALID_PARAMETER_ERROR, CG_INVALID_PROFILE_ERROR, CG_PROGRAM_LOAD_ERROR, CG_PROGRAM_BIND_ERROR, CG_PROGRAM_NOT_LOADED_ERROR, CG_UNSUPPORTED_GL_EXTENSION_ERROR, CG_INVALID_VALUE_TYPE_ERROR, CG_NOT_MATRIX_PARAM_ERROR, CG_INVALID_ENUMERANT_ERROR, CG_NOT_4x4_MATRIX_ERROR, CG_FILE_READ_ERROR, CG_FILE_WRITE_ERROR, CG_NVPARSE_ERROR, CG_MEMORY_ALLOC_ERROR, CG_INVALID_CONTEXT_HANDLE_ERROR, CG_INVALID_PROGRAM_HANDLE_ERROR, CG_INVALID_PARAM_HANDLE_ERROR, CG_UNKNOWN_PROFILE_ERROR, CG_VAR_ARG_ERROR, CG_INVALID_DIMENSION_ERROR, CG_ARRAY_PARAM_ERROR, CG_OUT_OF_ARRAY_BOUNDS_ERROR, CG_CONFLICTING_TYPES_ERROR, CG_CONFLICTING_PARAMETER_TYPES_ERROR, CG_PARAMETER_IS_NOT_SHARED_ERROR, CG_INVALID_PARAMETER_VARIABILITY_ERROR, CG_CANNOT_DESTROY_PARAMETER_ERROR, CG_NOT_ROOT_PARAMETER_ERROR, CG_PARAMETERS_DO_NOT_MATCH_ERROR, CG_IS_NOT_PROGRAM_PARAMETER_ERROR, CG_INVALID_PARAMETER_TYPE_ERROR, CG_PARAMETER_IS_NOT_RESIZABLE_ARRAY_ERROR, CG_INVALID_SIZE_ERROR, CG_BIND_CREATES_CYCLE_ERROR, CG_ARRAY_TYPES_DO_NOT_MATCH_ERROR, CG_ARRAY_DIMENSIONS_DO_NOT_MATCH_ERROR, CG_ARRAY_HAS_WRONG_DIMENSION_ERROR, CG_TYPE_IS_NOT_DEFINED_IN_PROGRAM_ERROR, CG_INVALID_EFFECT_HANDLE_ERROR, CG_INVALID_STATE_HANDLE_ERROR, CG_INVALID_STATE_ASSIGNMENT_HANDLE_ERROR, CG_INVALID_PASS_HANDLE_ERROR, CG_INVALID_ANNOTATION_HANDLE_ERROR, CG_INVALID_TECHNIQUE_HANDLE_ERROR, CG_INVALID_PARAMETER_HANDLE_ERROR, CG_STATE_ASSIGNMENT_TYPE_MISMATCH_ERROR, CG_INVALID_FUNCTION_HANDLE_ERROR, CG_INVALID_TECHNIQUE_ERROR, CG_INVALID_POINTER_ERROR, CG_NOT_ENOUGH_DATA_ERROR, CG_NON_NUMERIC_PARAMETER_ERROR, CG_ARRAY_SIZE_MISMATCH_ERROR</code>
   */
  public static String cgGetErrorString(int error)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetErrorString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetErrorString\" not available");
    }
        return dispatch_cgGetErrorString1(error, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetErrorString(CGerror error); </code> 
      @param error valid values are: <code>CG_NO_ERROR, CG_COMPILER_ERROR, CG_INVALID_PARAMETER_ERROR, CG_INVALID_PROFILE_ERROR, CG_PROGRAM_LOAD_ERROR, CG_PROGRAM_BIND_ERROR, CG_PROGRAM_NOT_LOADED_ERROR, CG_UNSUPPORTED_GL_EXTENSION_ERROR, CG_INVALID_VALUE_TYPE_ERROR, CG_NOT_MATRIX_PARAM_ERROR, CG_INVALID_ENUMERANT_ERROR, CG_NOT_4x4_MATRIX_ERROR, CG_FILE_READ_ERROR, CG_FILE_WRITE_ERROR, CG_NVPARSE_ERROR, CG_MEMORY_ALLOC_ERROR, CG_INVALID_CONTEXT_HANDLE_ERROR, CG_INVALID_PROGRAM_HANDLE_ERROR, CG_INVALID_PARAM_HANDLE_ERROR, CG_UNKNOWN_PROFILE_ERROR, CG_VAR_ARG_ERROR, CG_INVALID_DIMENSION_ERROR, CG_ARRAY_PARAM_ERROR, CG_OUT_OF_ARRAY_BOUNDS_ERROR, CG_CONFLICTING_TYPES_ERROR, CG_CONFLICTING_PARAMETER_TYPES_ERROR, CG_PARAMETER_IS_NOT_SHARED_ERROR, CG_INVALID_PARAMETER_VARIABILITY_ERROR, CG_CANNOT_DESTROY_PARAMETER_ERROR, CG_NOT_ROOT_PARAMETER_ERROR, CG_PARAMETERS_DO_NOT_MATCH_ERROR, CG_IS_NOT_PROGRAM_PARAMETER_ERROR, CG_INVALID_PARAMETER_TYPE_ERROR, CG_PARAMETER_IS_NOT_RESIZABLE_ARRAY_ERROR, CG_INVALID_SIZE_ERROR, CG_BIND_CREATES_CYCLE_ERROR, CG_ARRAY_TYPES_DO_NOT_MATCH_ERROR, CG_ARRAY_DIMENSIONS_DO_NOT_MATCH_ERROR, CG_ARRAY_HAS_WRONG_DIMENSION_ERROR, CG_TYPE_IS_NOT_DEFINED_IN_PROGRAM_ERROR, CG_INVALID_EFFECT_HANDLE_ERROR, CG_INVALID_STATE_HANDLE_ERROR, CG_INVALID_STATE_ASSIGNMENT_HANDLE_ERROR, CG_INVALID_PASS_HANDLE_ERROR, CG_INVALID_ANNOTATION_HANDLE_ERROR, CG_INVALID_TECHNIQUE_HANDLE_ERROR, CG_INVALID_PARAMETER_HANDLE_ERROR, CG_STATE_ASSIGNMENT_TYPE_MISMATCH_ERROR, CG_INVALID_FUNCTION_HANDLE_ERROR, CG_INVALID_TECHNIQUE_ERROR, CG_INVALID_POINTER_ERROR, CG_NOT_ENOUGH_DATA_ERROR, CG_NON_NUMERIC_PARAMETER_ERROR, CG_ARRAY_SIZE_MISMATCH_ERROR</code>
   */
  public static native String dispatch_cgGetErrorString1(int error, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetFirstDependentParameter(CGparameter param); </code>    */
  public static CGparameter cgGetFirstDependentParameter(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstDependentParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetFirstDependentParameter\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstDependentParameter1(((param == null) ? null : param.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetFirstDependentParameter(CGparameter param); </code>    */
  private static native ByteBuffer dispatch_cgGetFirstDependentParameter1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGeffect cgGetFirstEffect(CGcontext); </code>    */
  public static CGeffect cgGetFirstEffect(CGcontext arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstEffect;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetFirstEffect\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstEffect1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGeffect.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGeffect cgGetFirstEffect(CGcontext); </code>    */
  private static native ByteBuffer dispatch_cgGetFirstEffect1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetFirstEffectParameter(CGeffect); </code>    */
  public static CGparameter cgGetFirstEffectParameter(CGeffect arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstEffectParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetFirstEffectParameter\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstEffectParameter1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetFirstEffectParameter(CGeffect); </code>    */
  private static native ByteBuffer dispatch_cgGetFirstEffectParameter1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGerror cgGetFirstError(void); </code>    */
  public static int cgGetFirstError()  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstError;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetFirstError\" not available");
    }
        return dispatch_cgGetFirstError1(__addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGerror cgGetFirstError(void); </code>    */
  public static native int dispatch_cgGetFirstError1(long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetFirstLeafEffectParameter(CGeffect); </code>    */
  public static CGparameter cgGetFirstLeafEffectParameter(CGeffect arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstLeafEffectParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetFirstLeafEffectParameter\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstLeafEffectParameter1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetFirstLeafEffectParameter(CGeffect); </code>    */
  private static native ByteBuffer dispatch_cgGetFirstLeafEffectParameter1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetFirstLeafParameter(CGprogram prog, CGenum name_space); </code> 
      @param name_space valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  public static CGparameter cgGetFirstLeafParameter(CGprogram prog, int name_space)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstLeafParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetFirstLeafParameter\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstLeafParameter1(((prog == null) ? null : prog.getBuffer()), name_space, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetFirstLeafParameter(CGprogram prog, CGenum name_space); </code> 
      @param name_space valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  private static native ByteBuffer dispatch_cgGetFirstLeafParameter1(ByteBuffer prog, int name_space, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetFirstParameter(CGprogram prog, CGenum name_space); </code> 
      @param name_space valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  public static CGparameter cgGetFirstParameter(CGprogram prog, int name_space)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetFirstParameter\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstParameter1(((prog == null) ? null : prog.getBuffer()), name_space, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetFirstParameter(CGprogram prog, CGenum name_space); </code> 
      @param name_space valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  private static native ByteBuffer dispatch_cgGetFirstParameter1(ByteBuffer prog, int name_space, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGannotation cgGetFirstParameterAnnotation(CGparameter); </code>    */
  public static CGannotation cgGetFirstParameterAnnotation(CGparameter arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstParameterAnnotation;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetFirstParameterAnnotation\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstParameterAnnotation1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGannotation.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGannotation cgGetFirstParameterAnnotation(CGparameter); </code>    */
  private static native ByteBuffer dispatch_cgGetFirstParameterAnnotation1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGpass cgGetFirstPass(CGtechnique); </code>    */
  public static CGpass cgGetFirstPass(CGtechnique arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstPass;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetFirstPass\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstPass1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGpass.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGpass cgGetFirstPass(CGtechnique); </code>    */
  private static native ByteBuffer dispatch_cgGetFirstPass1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGannotation cgGetFirstPassAnnotation(CGpass); </code>    */
  public static CGannotation cgGetFirstPassAnnotation(CGpass arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstPassAnnotation;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetFirstPassAnnotation\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstPassAnnotation1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGannotation.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGannotation cgGetFirstPassAnnotation(CGpass); </code>    */
  private static native ByteBuffer dispatch_cgGetFirstPassAnnotation1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGprogram cgGetFirstProgram(CGcontext ctx); </code>    */
  public static CGprogram cgGetFirstProgram(CGcontext ctx)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetFirstProgram\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstProgram1(((ctx == null) ? null : ctx.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGprogram.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGprogram cgGetFirstProgram(CGcontext ctx); </code>    */
  private static native ByteBuffer dispatch_cgGetFirstProgram1(ByteBuffer ctx, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGannotation cgGetFirstProgramAnnotation(CGprogram); </code>    */
  public static CGannotation cgGetFirstProgramAnnotation(CGprogram arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstProgramAnnotation;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetFirstProgramAnnotation\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstProgramAnnotation1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGannotation.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGannotation cgGetFirstProgramAnnotation(CGprogram); </code>    */
  private static native ByteBuffer dispatch_cgGetFirstProgramAnnotation1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGstate cgGetFirstSamplerState(CGcontext); </code>    */
  public static CGstate cgGetFirstSamplerState(CGcontext arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstSamplerState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetFirstSamplerState\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstSamplerState1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGstate.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGstate cgGetFirstSamplerState(CGcontext); </code>    */
  private static native ByteBuffer dispatch_cgGetFirstSamplerState1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGstateassignment cgGetFirstSamplerStateAssignment(CGparameter); </code>    */
  public static CGstateassignment cgGetFirstSamplerStateAssignment(CGparameter arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstSamplerStateAssignment;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetFirstSamplerStateAssignment\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstSamplerStateAssignment1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGstateassignment.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGstateassignment cgGetFirstSamplerStateAssignment(CGparameter); </code>    */
  private static native ByteBuffer dispatch_cgGetFirstSamplerStateAssignment1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGstate cgGetFirstState(CGcontext); </code>    */
  public static CGstate cgGetFirstState(CGcontext arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetFirstState\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstState1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGstate.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGstate cgGetFirstState(CGcontext); </code>    */
  private static native ByteBuffer dispatch_cgGetFirstState1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGstateassignment cgGetFirstStateAssignment(CGpass); </code>    */
  public static CGstateassignment cgGetFirstStateAssignment(CGpass arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstStateAssignment;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetFirstStateAssignment\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstStateAssignment1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGstateassignment.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGstateassignment cgGetFirstStateAssignment(CGpass); </code>    */
  private static native ByteBuffer dispatch_cgGetFirstStateAssignment1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetFirstStructParameter(CGparameter param); </code>    */
  public static CGparameter cgGetFirstStructParameter(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstStructParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetFirstStructParameter\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstStructParameter1(((param == null) ? null : param.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetFirstStructParameter(CGparameter param); </code>    */
  private static native ByteBuffer dispatch_cgGetFirstStructParameter1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGtechnique cgGetFirstTechnique(CGeffect); </code>    */
  public static CGtechnique cgGetFirstTechnique(CGeffect arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstTechnique;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetFirstTechnique\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstTechnique1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGtechnique.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGtechnique cgGetFirstTechnique(CGeffect); </code>    */
  private static native ByteBuffer dispatch_cgGetFirstTechnique1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGannotation cgGetFirstTechniqueAnnotation(CGtechnique); </code>    */
  public static CGannotation cgGetFirstTechniqueAnnotation(CGtechnique arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstTechniqueAnnotation;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetFirstTechniqueAnnotation\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstTechniqueAnnotation1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGannotation.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGannotation cgGetFirstTechniqueAnnotation(CGtechnique); </code>    */
  private static native ByteBuffer dispatch_cgGetFirstTechniqueAnnotation1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetLastErrorString(CGerror *  error); </code> 
      @param error a direct or array-backed {@link java.nio.IntBuffer}   */
  public static String cgGetLastErrorString(IntBuffer error)  {

    final boolean error_is_direct = Buffers.isDirect(error);
    final long __addr_ = cgProcAddressTable._addressof_cgGetLastErrorString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetLastErrorString\" not available");
    }
        return dispatch_cgGetLastErrorString1(error_is_direct ? error : Buffers.getArray(error), error_is_direct ? Buffers.getDirectBufferByteOffset(error) : Buffers.getIndirectBufferByteOffset(error), error_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetLastErrorString(CGerror *  error); </code> 
      @param error a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native String dispatch_cgGetLastErrorString1(Object error, int error_byte_offset, boolean error_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetLastErrorString(CGerror *  error); </code>    */
  public static String cgGetLastErrorString(int[] error, int error_offset)  {

    if(error != null && error.length <= error_offset)
      throw new CgException("array offset argument \"error_offset\" (" + error_offset + ") equals or exceeds array length (" + error.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetLastErrorString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetLastErrorString\" not available");
    }
        return dispatch_cgGetLastErrorString1(error, Buffers.SIZEOF_INT * error_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetLastListing(CGcontext ctx); </code>    */
  public static String cgGetLastListing(CGcontext ctx)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetLastListing;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetLastListing\" not available");
    }
        return dispatch_cgGetLastListing1(((ctx == null) ? null : ctx.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetLastListing(CGcontext ctx); </code>    */
  private static native String dispatch_cgGetLastListing1(ByteBuffer ctx, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGetMatrixParameterdc(CGparameter param, double *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGetMatrixParameterdc(CGparameter param, DoubleBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameterdc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetMatrixParameterdc\" not available");
    }
        dispatch_cgGetMatrixParameterdc1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGetMatrixParameterdc(CGparameter param, double *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGetMatrixParameterdc1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGetMatrixParameterdc(CGparameter param, double *  matrix); </code>    */
  public static void cgGetMatrixParameterdc(CGparameter param, double[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameterdc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetMatrixParameterdc\" not available");
    }
        dispatch_cgGetMatrixParameterdc1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_DOUBLE * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGetMatrixParameterdr(CGparameter param, double *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGetMatrixParameterdr(CGparameter param, DoubleBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameterdr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetMatrixParameterdr\" not available");
    }
        dispatch_cgGetMatrixParameterdr1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGetMatrixParameterdr(CGparameter param, double *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGetMatrixParameterdr1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGetMatrixParameterdr(CGparameter param, double *  matrix); </code>    */
  public static void cgGetMatrixParameterdr(CGparameter param, double[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameterdr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetMatrixParameterdr\" not available");
    }
        dispatch_cgGetMatrixParameterdr1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_DOUBLE * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGetMatrixParameterfc(CGparameter param, float *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGetMatrixParameterfc(CGparameter param, FloatBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameterfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetMatrixParameterfc\" not available");
    }
        dispatch_cgGetMatrixParameterfc1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGetMatrixParameterfc(CGparameter param, float *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGetMatrixParameterfc1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGetMatrixParameterfc(CGparameter param, float *  matrix); </code>    */
  public static void cgGetMatrixParameterfc(CGparameter param, float[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameterfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetMatrixParameterfc\" not available");
    }
        dispatch_cgGetMatrixParameterfc1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_FLOAT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGetMatrixParameterfr(CGparameter param, float *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGetMatrixParameterfr(CGparameter param, FloatBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameterfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetMatrixParameterfr\" not available");
    }
        dispatch_cgGetMatrixParameterfr1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGetMatrixParameterfr(CGparameter param, float *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGetMatrixParameterfr1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGetMatrixParameterfr(CGparameter param, float *  matrix); </code>    */
  public static void cgGetMatrixParameterfr(CGparameter param, float[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameterfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetMatrixParameterfr\" not available");
    }
        dispatch_cgGetMatrixParameterfr1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_FLOAT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGetMatrixParameteric(CGparameter param, int *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void cgGetMatrixParameteric(CGparameter param, IntBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameteric;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetMatrixParameteric\" not available");
    }
        dispatch_cgGetMatrixParameteric1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGetMatrixParameteric(CGparameter param, int *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_cgGetMatrixParameteric1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGetMatrixParameteric(CGparameter param, int *  matrix); </code>    */
  public static void cgGetMatrixParameteric(CGparameter param, int[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameteric;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetMatrixParameteric\" not available");
    }
        dispatch_cgGetMatrixParameteric1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_INT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGetMatrixParameterir(CGparameter param, int *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void cgGetMatrixParameterir(CGparameter param, IntBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameterir;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetMatrixParameterir\" not available");
    }
        dispatch_cgGetMatrixParameterir1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGetMatrixParameterir(CGparameter param, int *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_cgGetMatrixParameterir1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgGetMatrixParameterir(CGparameter param, int *  matrix); </code>    */
  public static void cgGetMatrixParameterir(CGparameter param, int[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameterir;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetMatrixParameterir\" not available");
    }
        dispatch_cgGetMatrixParameterir1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_INT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetNamedEffectParameter(CGeffect, const char * ); </code>    */
  public static CGparameter cgGetNamedEffectParameter(CGeffect arg0, String arg1)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedEffectParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNamedEffectParameter\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedEffectParameter1(((arg0 == null) ? null : arg0.getBuffer()), arg1, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetNamedEffectParameter(CGeffect, const char * ); </code>    */
  private static native ByteBuffer dispatch_cgGetNamedEffectParameter1(ByteBuffer arg0, String arg1, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetNamedParameter(CGprogram prog, const char *  name); </code>    */
  public static CGparameter cgGetNamedParameter(CGprogram prog, String name)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNamedParameter\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedParameter1(((prog == null) ? null : prog.getBuffer()), name, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetNamedParameter(CGprogram prog, const char *  name); </code>    */
  private static native ByteBuffer dispatch_cgGetNamedParameter1(ByteBuffer prog, String name, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGannotation cgGetNamedParameterAnnotation(CGparameter, const char * ); </code>    */
  public static CGannotation cgGetNamedParameterAnnotation(CGparameter arg0, String arg1)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedParameterAnnotation;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNamedParameterAnnotation\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedParameterAnnotation1(((arg0 == null) ? null : arg0.getBuffer()), arg1, __addr_);
    if (_res == null) return null;
    return CGannotation.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGannotation cgGetNamedParameterAnnotation(CGparameter, const char * ); </code>    */
  private static native ByteBuffer dispatch_cgGetNamedParameterAnnotation1(ByteBuffer arg0, String arg1, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGpass cgGetNamedPass(CGtechnique, const char *  name); </code>    */
  public static CGpass cgGetNamedPass(CGtechnique arg0, String name)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedPass;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNamedPass\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedPass1(((arg0 == null) ? null : arg0.getBuffer()), name, __addr_);
    if (_res == null) return null;
    return CGpass.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGpass cgGetNamedPass(CGtechnique, const char *  name); </code>    */
  private static native ByteBuffer dispatch_cgGetNamedPass1(ByteBuffer arg0, String name, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGannotation cgGetNamedPassAnnotation(CGpass, const char * ); </code>    */
  public static CGannotation cgGetNamedPassAnnotation(CGpass arg0, String arg1)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedPassAnnotation;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNamedPassAnnotation\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedPassAnnotation1(((arg0 == null) ? null : arg0.getBuffer()), arg1, __addr_);
    if (_res == null) return null;
    return CGannotation.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGannotation cgGetNamedPassAnnotation(CGpass, const char * ); </code>    */
  private static native ByteBuffer dispatch_cgGetNamedPassAnnotation1(ByteBuffer arg0, String arg1, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGannotation cgGetNamedProgramAnnotation(CGprogram, const char * ); </code>    */
  public static CGannotation cgGetNamedProgramAnnotation(CGprogram arg0, String arg1)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedProgramAnnotation;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNamedProgramAnnotation\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedProgramAnnotation1(((arg0 == null) ? null : arg0.getBuffer()), arg1, __addr_);
    if (_res == null) return null;
    return CGannotation.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGannotation cgGetNamedProgramAnnotation(CGprogram, const char * ); </code>    */
  private static native ByteBuffer dispatch_cgGetNamedProgramAnnotation1(ByteBuffer arg0, String arg1, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetNamedProgramParameter(CGprogram prog, CGenum name_space, const char *  name); </code> 
      @param name_space valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  public static CGparameter cgGetNamedProgramParameter(CGprogram prog, int name_space, String name)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedProgramParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNamedProgramParameter\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedProgramParameter1(((prog == null) ? null : prog.getBuffer()), name_space, name, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetNamedProgramParameter(CGprogram prog, CGenum name_space, const char *  name); </code> 
      @param name_space valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  private static native ByteBuffer dispatch_cgGetNamedProgramParameter1(ByteBuffer prog, int name_space, String name, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGstate cgGetNamedSamplerState(CGcontext, const char *  name); </code>    */
  public static CGstate cgGetNamedSamplerState(CGcontext arg0, String name)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedSamplerState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNamedSamplerState\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedSamplerState1(((arg0 == null) ? null : arg0.getBuffer()), name, __addr_);
    if (_res == null) return null;
    return CGstate.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGstate cgGetNamedSamplerState(CGcontext, const char *  name); </code>    */
  private static native ByteBuffer dispatch_cgGetNamedSamplerState1(ByteBuffer arg0, String name, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGstateassignment cgGetNamedSamplerStateAssignment(CGparameter, const char * ); </code>    */
  public static CGstateassignment cgGetNamedSamplerStateAssignment(CGparameter arg0, String arg1)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedSamplerStateAssignment;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNamedSamplerStateAssignment\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedSamplerStateAssignment1(((arg0 == null) ? null : arg0.getBuffer()), arg1, __addr_);
    if (_res == null) return null;
    return CGstateassignment.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGstateassignment cgGetNamedSamplerStateAssignment(CGparameter, const char * ); </code>    */
  private static native ByteBuffer dispatch_cgGetNamedSamplerStateAssignment1(ByteBuffer arg0, String arg1, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGstate cgGetNamedState(CGcontext, const char *  name); </code>    */
  public static CGstate cgGetNamedState(CGcontext arg0, String name)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNamedState\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedState1(((arg0 == null) ? null : arg0.getBuffer()), name, __addr_);
    if (_res == null) return null;
    return CGstate.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGstate cgGetNamedState(CGcontext, const char *  name); </code>    */
  private static native ByteBuffer dispatch_cgGetNamedState1(ByteBuffer arg0, String name, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGstateassignment cgGetNamedStateAssignment(CGpass, const char *  name); </code>    */
  public static CGstateassignment cgGetNamedStateAssignment(CGpass arg0, String name)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedStateAssignment;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNamedStateAssignment\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedStateAssignment1(((arg0 == null) ? null : arg0.getBuffer()), name, __addr_);
    if (_res == null) return null;
    return CGstateassignment.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGstateassignment cgGetNamedStateAssignment(CGpass, const char *  name); </code>    */
  private static native ByteBuffer dispatch_cgGetNamedStateAssignment1(ByteBuffer arg0, String name, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetNamedStructParameter(CGparameter param, const char *  name); </code>    */
  public static CGparameter cgGetNamedStructParameter(CGparameter param, String name)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedStructParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNamedStructParameter\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedStructParameter1(((param == null) ? null : param.getBuffer()), name, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetNamedStructParameter(CGparameter param, const char *  name); </code>    */
  private static native ByteBuffer dispatch_cgGetNamedStructParameter1(ByteBuffer param, String name, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGtechnique cgGetNamedTechnique(CGeffect, const char *  name); </code>    */
  public static CGtechnique cgGetNamedTechnique(CGeffect arg0, String name)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedTechnique;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNamedTechnique\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedTechnique1(((arg0 == null) ? null : arg0.getBuffer()), name, __addr_);
    if (_res == null) return null;
    return CGtechnique.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGtechnique cgGetNamedTechnique(CGeffect, const char *  name); </code>    */
  private static native ByteBuffer dispatch_cgGetNamedTechnique1(ByteBuffer arg0, String name, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGannotation cgGetNamedTechniqueAnnotation(CGtechnique, const char * ); </code>    */
  public static CGannotation cgGetNamedTechniqueAnnotation(CGtechnique arg0, String arg1)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedTechniqueAnnotation;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNamedTechniqueAnnotation\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedTechniqueAnnotation1(((arg0 == null) ? null : arg0.getBuffer()), arg1, __addr_);
    if (_res == null) return null;
    return CGannotation.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGannotation cgGetNamedTechniqueAnnotation(CGtechnique, const char * ); </code>    */
  private static native ByteBuffer dispatch_cgGetNamedTechniqueAnnotation1(ByteBuffer arg0, String arg1, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGtype cgGetNamedUserType(CGhandle handle, const char *  name); </code> 
      @param handle a direct or array-backed {@link java.nio.Buffer}   */
  public static int cgGetNamedUserType(Buffer handle, String name)  {

    final boolean handle_is_direct = Buffers.isDirect(handle);
    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedUserType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNamedUserType\" not available");
    }
        return dispatch_cgGetNamedUserType1(handle_is_direct ? handle : Buffers.getArray(handle), handle_is_direct ? Buffers.getDirectBufferByteOffset(handle) : Buffers.getIndirectBufferByteOffset(handle), handle_is_direct, name, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGtype cgGetNamedUserType(CGhandle handle, const char *  name); </code> 
      @param handle a direct or array-backed {@link java.nio.Buffer}   */
  private static native int dispatch_cgGetNamedUserType1(Object handle, int handle_byte_offset, boolean handle_is_direct, String name, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGannotation cgGetNextAnnotation(CGannotation); </code>    */
  public static CGannotation cgGetNextAnnotation(CGannotation arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNextAnnotation;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNextAnnotation\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNextAnnotation1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGannotation.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGannotation cgGetNextAnnotation(CGannotation); </code>    */
  private static native ByteBuffer dispatch_cgGetNextAnnotation1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGeffect cgGetNextEffect(CGeffect); </code>    */
  public static CGeffect cgGetNextEffect(CGeffect arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNextEffect;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNextEffect\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNextEffect1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGeffect.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGeffect cgGetNextEffect(CGeffect); </code>    */
  private static native ByteBuffer dispatch_cgGetNextEffect1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetNextLeafParameter(CGparameter current); </code>    */
  public static CGparameter cgGetNextLeafParameter(CGparameter current)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNextLeafParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNextLeafParameter\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNextLeafParameter1(((current == null) ? null : current.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetNextLeafParameter(CGparameter current); </code>    */
  private static native ByteBuffer dispatch_cgGetNextLeafParameter1(ByteBuffer current, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetNextParameter(CGparameter current); </code>    */
  public static CGparameter cgGetNextParameter(CGparameter current)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNextParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNextParameter\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNextParameter1(((current == null) ? null : current.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetNextParameter(CGparameter current); </code>    */
  private static native ByteBuffer dispatch_cgGetNextParameter1(ByteBuffer current, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGpass cgGetNextPass(CGpass); </code>    */
  public static CGpass cgGetNextPass(CGpass arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNextPass;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNextPass\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNextPass1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGpass.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGpass cgGetNextPass(CGpass); </code>    */
  private static native ByteBuffer dispatch_cgGetNextPass1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGprogram cgGetNextProgram(CGprogram current); </code>    */
  public static CGprogram cgGetNextProgram(CGprogram current)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNextProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNextProgram\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNextProgram1(((current == null) ? null : current.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGprogram.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGprogram cgGetNextProgram(CGprogram current); </code>    */
  private static native ByteBuffer dispatch_cgGetNextProgram1(ByteBuffer current, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGstate cgGetNextState(CGstate); </code>    */
  public static CGstate cgGetNextState(CGstate arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNextState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNextState\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNextState1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGstate.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGstate cgGetNextState(CGstate); </code>    */
  private static native ByteBuffer dispatch_cgGetNextState1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGstateassignment cgGetNextStateAssignment(CGstateassignment); </code>    */
  public static CGstateassignment cgGetNextStateAssignment(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNextStateAssignment;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNextStateAssignment\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNextStateAssignment1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGstateassignment.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGstateassignment cgGetNextStateAssignment(CGstateassignment); </code>    */
  private static native ByteBuffer dispatch_cgGetNextStateAssignment1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGtechnique cgGetNextTechnique(CGtechnique); </code>    */
  public static CGtechnique cgGetNextTechnique(CGtechnique arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNextTechnique;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNextTechnique\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNextTechnique1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGtechnique.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGtechnique cgGetNextTechnique(CGtechnique); </code>    */
  private static native ByteBuffer dispatch_cgGetNextTechnique1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetNumConnectedToParameters(CGparameter param); </code>    */
  public static int cgGetNumConnectedToParameters(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNumConnectedToParameters;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNumConnectedToParameters\" not available");
    }
        return dispatch_cgGetNumConnectedToParameters1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetNumConnectedToParameters(CGparameter param); </code>    */
  private static native int dispatch_cgGetNumConnectedToParameters1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetNumDependentAnnotationParameters(CGannotation); </code>    */
  public static int cgGetNumDependentAnnotationParameters(CGannotation arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNumDependentAnnotationParameters;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNumDependentAnnotationParameters\" not available");
    }
        return dispatch_cgGetNumDependentAnnotationParameters1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetNumDependentAnnotationParameters(CGannotation); </code>    */
  private static native int dispatch_cgGetNumDependentAnnotationParameters1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetNumDependentStateAssignmentParameters(CGstateassignment); </code>    */
  public static int cgGetNumDependentStateAssignmentParameters(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNumDependentStateAssignmentParameters;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNumDependentStateAssignmentParameters\" not available");
    }
        return dispatch_cgGetNumDependentStateAssignmentParameters1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetNumDependentStateAssignmentParameters(CGstateassignment); </code>    */
  private static native int dispatch_cgGetNumDependentStateAssignmentParameters1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetNumParentTypes(CGtype type); </code> 
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static int cgGetNumParentTypes(int type)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNumParentTypes;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNumParentTypes\" not available");
    }
        return dispatch_cgGetNumParentTypes1(type, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetNumParentTypes(CGtype type); </code> 
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static native int dispatch_cgGetNumParentTypes1(int type, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetNumUserTypes(CGhandle handle); </code> 
      @param handle a direct or array-backed {@link java.nio.Buffer}   */
  public static int cgGetNumUserTypes(Buffer handle)  {

    final boolean handle_is_direct = Buffers.isDirect(handle);
    final long __addr_ = cgProcAddressTable._addressof_cgGetNumUserTypes;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetNumUserTypes\" not available");
    }
        return dispatch_cgGetNumUserTypes1(handle_is_direct ? handle : Buffers.getArray(handle), handle_is_direct ? Buffers.getDirectBufferByteOffset(handle) : Buffers.getIndirectBufferByteOffset(handle), handle_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetNumUserTypes(CGhandle handle); </code> 
      @param handle a direct or array-backed {@link java.nio.Buffer}   */
  private static native int dispatch_cgGetNumUserTypes1(Object handle, int handle_byte_offset, boolean handle_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGresource cgGetParameterBaseResource(CGparameter param); </code>    */
  public static int cgGetParameterBaseResource(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterBaseResource;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterBaseResource\" not available");
    }
        return dispatch_cgGetParameterBaseResource1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGresource cgGetParameterBaseResource(CGparameter param); </code>    */
  private static native int dispatch_cgGetParameterBaseResource1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGtype cgGetParameterBaseType(CGparameter param); </code>    */
  public static int cgGetParameterBaseType(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterBaseType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterBaseType\" not available");
    }
        return dispatch_cgGetParameterBaseType1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGtype cgGetParameterBaseType(CGparameter param); </code>    */
  private static native int dispatch_cgGetParameterBaseType1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameterclass cgGetParameterClass(CGparameter param); </code>    */
  public static int cgGetParameterClass(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterClass;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterClass\" not available");
    }
        return dispatch_cgGetParameterClass1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameterclass cgGetParameterClass(CGparameter param); </code>    */
  private static native int dispatch_cgGetParameterClass1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterColumns(CGparameter param); </code>    */
  public static int cgGetParameterColumns(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterColumns;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterColumns\" not available");
    }
        return dispatch_cgGetParameterColumns1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterColumns(CGparameter param); </code>    */
  private static native int dispatch_cgGetParameterColumns1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGcontext cgGetParameterContext(CGparameter param); </code>    */
  public static CGcontext cgGetParameterContext(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterContext\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetParameterContext1(((param == null) ? null : param.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGcontext.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGcontext cgGetParameterContext(CGparameter param); </code>    */
  private static native ByteBuffer dispatch_cgGetParameterContext1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGenum cgGetParameterDirection(CGparameter param); </code>    */
  public static int cgGetParameterDirection(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterDirection;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterDirection\" not available");
    }
        return dispatch_cgGetParameterDirection1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGenum cgGetParameterDirection(CGparameter param); </code>    */
  private static native int dispatch_cgGetParameterDirection1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterIndex(CGparameter param); </code>    */
  public static int cgGetParameterIndex(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterIndex;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterIndex\" not available");
    }
        return dispatch_cgGetParameterIndex1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterIndex(CGparameter param); </code>    */
  private static native int dispatch_cgGetParameterIndex1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetParameterName(CGparameter param); </code>    */
  public static String cgGetParameterName(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterName;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterName\" not available");
    }
        return dispatch_cgGetParameterName1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetParameterName(CGparameter param); </code>    */
  private static native String dispatch_cgGetParameterName1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGtype cgGetParameterNamedType(CGparameter param); </code>    */
  public static int cgGetParameterNamedType(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterNamedType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterNamedType\" not available");
    }
        return dispatch_cgGetParameterNamedType1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGtype cgGetParameterNamedType(CGparameter param); </code>    */
  private static native int dispatch_cgGetParameterNamedType1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterOrdinalNumber(CGparameter param); </code>    */
  public static int cgGetParameterOrdinalNumber(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterOrdinalNumber;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterOrdinalNumber\" not available");
    }
        return dispatch_cgGetParameterOrdinalNumber1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterOrdinalNumber(CGparameter param); </code>    */
  private static native int dispatch_cgGetParameterOrdinalNumber1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGprogram cgGetParameterProgram(CGparameter param); </code>    */
  public static CGprogram cgGetParameterProgram(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterProgram\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetParameterProgram1(((param == null) ? null : param.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGprogram.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGprogram cgGetParameterProgram(CGparameter param); </code>    */
  private static native ByteBuffer dispatch_cgGetParameterProgram1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGresource cgGetParameterResource(CGparameter param); </code>    */
  public static int cgGetParameterResource(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterResource;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterResource\" not available");
    }
        return dispatch_cgGetParameterResource1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGresource cgGetParameterResource(CGparameter param); </code>    */
  private static native int dispatch_cgGetParameterResource1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> unsigned long cgGetParameterResourceIndex(CGparameter param); </code>    */
  public static long cgGetParameterResourceIndex(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterResourceIndex;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterResourceIndex\" not available");
    }
        return dispatch_cgGetParameterResourceIndex1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> unsigned long cgGetParameterResourceIndex(CGparameter param); </code>    */
  private static native long dispatch_cgGetParameterResourceIndex1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterRows(CGparameter param); </code>    */
  public static int cgGetParameterRows(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterRows;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterRows\" not available");
    }
        return dispatch_cgGetParameterRows1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterRows(CGparameter param); </code>    */
  private static native int dispatch_cgGetParameterRows1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetParameterSemantic(CGparameter param); </code>    */
  public static String cgGetParameterSemantic(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterSemantic;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterSemantic\" not available");
    }
        return dispatch_cgGetParameterSemantic1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetParameterSemantic(CGparameter param); </code>    */
  private static native String dispatch_cgGetParameterSemantic1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGtype cgGetParameterType(CGparameter param); </code>    */
  public static int cgGetParameterType(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterType\" not available");
    }
        return dispatch_cgGetParameterType1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGtype cgGetParameterType(CGparameter param); </code>    */
  private static native int dispatch_cgGetParameterType1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterValuedc(CGparameter param, int n, double *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static int cgGetParameterValuedc(CGparameter param, int n, DoubleBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValuedc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterValuedc\" not available");
    }
        return dispatch_cgGetParameterValuedc1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterValuedc(CGparameter param, int n, double *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native int dispatch_cgGetParameterValuedc1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterValuedc(CGparameter param, int n, double *  vals); </code>    */
  public static int cgGetParameterValuedc(CGparameter param, int n, double[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValuedc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterValuedc\" not available");
    }
        return dispatch_cgGetParameterValuedc1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_DOUBLE * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterValuedr(CGparameter param, int n, double *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static int cgGetParameterValuedr(CGparameter param, int n, DoubleBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValuedr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterValuedr\" not available");
    }
        return dispatch_cgGetParameterValuedr1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterValuedr(CGparameter param, int n, double *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native int dispatch_cgGetParameterValuedr1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterValuedr(CGparameter param, int n, double *  vals); </code>    */
  public static int cgGetParameterValuedr(CGparameter param, int n, double[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValuedr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterValuedr\" not available");
    }
        return dispatch_cgGetParameterValuedr1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_DOUBLE * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterValuefc(CGparameter param, int n, float *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static int cgGetParameterValuefc(CGparameter param, int n, FloatBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValuefc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterValuefc\" not available");
    }
        return dispatch_cgGetParameterValuefc1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterValuefc(CGparameter param, int n, float *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native int dispatch_cgGetParameterValuefc1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterValuefc(CGparameter param, int n, float *  vals); </code>    */
  public static int cgGetParameterValuefc(CGparameter param, int n, float[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValuefc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterValuefc\" not available");
    }
        return dispatch_cgGetParameterValuefc1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_FLOAT * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterValuefr(CGparameter param, int n, float *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static int cgGetParameterValuefr(CGparameter param, int n, FloatBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValuefr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterValuefr\" not available");
    }
        return dispatch_cgGetParameterValuefr1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterValuefr(CGparameter param, int n, float *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native int dispatch_cgGetParameterValuefr1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterValuefr(CGparameter param, int n, float *  vals); </code>    */
  public static int cgGetParameterValuefr(CGparameter param, int n, float[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValuefr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterValuefr\" not available");
    }
        return dispatch_cgGetParameterValuefr1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_FLOAT * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterValueic(CGparameter param, int n, int *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.IntBuffer}   */
  public static int cgGetParameterValueic(CGparameter param, int n, IntBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValueic;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterValueic\" not available");
    }
        return dispatch_cgGetParameterValueic1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterValueic(CGparameter param, int n, int *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native int dispatch_cgGetParameterValueic1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterValueic(CGparameter param, int n, int *  vals); </code>    */
  public static int cgGetParameterValueic(CGparameter param, int n, int[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValueic;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterValueic\" not available");
    }
        return dispatch_cgGetParameterValueic1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_INT * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterValueir(CGparameter param, int n, int *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.IntBuffer}   */
  public static int cgGetParameterValueir(CGparameter param, int n, IntBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValueir;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterValueir\" not available");
    }
        return dispatch_cgGetParameterValueir1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterValueir(CGparameter param, int n, int *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native int dispatch_cgGetParameterValueir1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetParameterValueir(CGparameter param, int n, int *  vals); </code>    */
  public static int cgGetParameterValueir(CGparameter param, int n, int[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValueir;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterValueir\" not available");
    }
        return dispatch_cgGetParameterValueir1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_INT * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGenum cgGetParameterVariability(CGparameter param); </code>    */
  public static int cgGetParameterVariability(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterVariability;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParameterVariability\" not available");
    }
        return dispatch_cgGetParameterVariability1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGenum cgGetParameterVariability(CGparameter param); </code>    */
  private static native int dispatch_cgGetParameterVariability1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGtype cgGetParentType(CGtype type, int index); </code> 
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static int cgGetParentType(int type, int index)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParentType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetParentType\" not available");
    }
        return dispatch_cgGetParentType1(type, index, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGtype cgGetParentType(CGtype type, int index); </code> 
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static native int dispatch_cgGetParentType1(int type, int index, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetPassName(CGpass); </code>    */
  public static String cgGetPassName(CGpass arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetPassName;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetPassName\" not available");
    }
        return dispatch_cgGetPassName1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetPassName(CGpass); </code>    */
  private static native String dispatch_cgGetPassName1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGtechnique cgGetPassTechnique(CGpass); </code>    */
  public static CGtechnique cgGetPassTechnique(CGpass arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetPassTechnique;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetPassTechnique\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetPassTechnique1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGtechnique.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGtechnique cgGetPassTechnique(CGpass); </code>    */
  private static native ByteBuffer dispatch_cgGetPassTechnique1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGprofile cgGetProfile(const char *  profile_string); </code>    */
  public static int cgGetProfile(String profile_string)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetProfile;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetProfile\" not available");
    }
        return dispatch_cgGetProfile1(profile_string, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGprofile cgGetProfile(const char *  profile_string); </code>    */
  public static native int dispatch_cgGetProfile1(String profile_string, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetProfileString(CGprofile profile); </code> 
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static String cgGetProfileString(int profile)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetProfileString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetProfileString\" not available");
    }
        return dispatch_cgGetProfileString1(profile, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetProfileString(CGprofile profile); </code> 
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static native String dispatch_cgGetProfileString1(int profile, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGcontext cgGetProgramContext(CGprogram prog); </code>    */
  public static CGcontext cgGetProgramContext(CGprogram prog)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetProgramContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetProgramContext\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetProgramContext1(((prog == null) ? null : prog.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGcontext.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGcontext cgGetProgramContext(CGprogram prog); </code>    */
  private static native ByteBuffer dispatch_cgGetProgramContext1(ByteBuffer prog, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGprofile cgGetProgramProfile(CGprogram prog); </code>    */
  public static int cgGetProgramProfile(CGprogram prog)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetProgramProfile;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetProgramProfile\" not available");
    }
        return dispatch_cgGetProgramProfile1(((prog == null) ? null : prog.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGprofile cgGetProgramProfile(CGprogram prog); </code>    */
  private static native int dispatch_cgGetProgramProfile1(ByteBuffer prog, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGprogram cgGetProgramStateAssignmentValue(CGstateassignment); </code>    */
  public static CGprogram cgGetProgramStateAssignmentValue(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetProgramStateAssignmentValue;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetProgramStateAssignmentValue\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetProgramStateAssignmentValue1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGprogram.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGprogram cgGetProgramStateAssignmentValue(CGstateassignment); </code>    */
  private static native ByteBuffer dispatch_cgGetProgramStateAssignmentValue1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetProgramString(CGprogram prog, CGenum pname); </code> 
      @param pname valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  public static String cgGetProgramString(CGprogram prog, int pname)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetProgramString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetProgramString\" not available");
    }
        return dispatch_cgGetProgramString1(((prog == null) ? null : prog.getBuffer()), pname, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetProgramString(CGprogram prog, CGenum pname); </code> 
      @param pname valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  private static native String dispatch_cgGetProgramString1(ByteBuffer prog, int pname, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGresource cgGetResource(const char *  resource_string); </code>    */
  public static int cgGetResource(String resource_string)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetResource;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetResource\" not available");
    }
        return dispatch_cgGetResource1(resource_string, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGresource cgGetResource(const char *  resource_string); </code>    */
  public static native int dispatch_cgGetResource1(String resource_string, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetResourceString(CGresource resource); </code> 
      @param resource valid values are: <code>CG_TEXUNIT0, CG_TEXUNIT1, CG_TEXUNIT2, CG_TEXUNIT3, CG_TEXUNIT4, CG_TEXUNIT5, CG_TEXUNIT6, CG_TEXUNIT7, CG_TEXUNIT8, CG_TEXUNIT9, CG_TEXUNIT10, CG_TEXUNIT11, CG_TEXUNIT12, CG_TEXUNIT13, CG_TEXUNIT14, CG_TEXUNIT15, CG_ATTR0, CG_ATTR1, CG_ATTR2, CG_ATTR3, CG_ATTR4, CG_ATTR5, CG_ATTR6, CG_ATTR7, CG_ATTR8, CG_ATTR9, CG_ATTR10, CG_ATTR11, CG_ATTR12, CG_ATTR13, CG_ATTR14, CG_ATTR15, CG_C, CG_TEX0, CG_TEX1, CG_TEX2, CG_TEX3, CG_TEX4, CG_TEX5, CG_TEX6, CG_TEX7, CG_HPOS, CG_COL0, CG_COL1, CG_COL2, CG_COL3, CG_PSIZ, CG_WPOS, CG_POSITION0, CG_POSITION1, CG_POSITION2, CG_POSITION3, CG_POSITION4, CG_POSITION5, CG_POSITION6, CG_POSITION7, CG_POSITION8, CG_POSITION9, CG_POSITION10, CG_POSITION11, CG_POSITION12, CG_POSITION13, CG_POSITION14, CG_POSITION15, CG_DIFFUSE0, CG_TANGENT0, CG_TANGENT1, CG_TANGENT2, CG_TANGENT3, CG_TANGENT4, CG_TANGENT5, CG_TANGENT6, CG_TANGENT7, CG_TANGENT8, CG_TANGENT9, CG_TANGENT10, CG_TANGENT11, CG_TANGENT12, CG_TANGENT13, CG_TANGENT14, CG_TANGENT15, CG_SPECULAR0, CG_BLENDINDICES0, CG_BLENDINDICES1, CG_BLENDINDICES2, CG_BLENDINDICES3, CG_BLENDINDICES4, CG_BLENDINDICES5, CG_BLENDINDICES6, CG_BLENDINDICES7, CG_BLENDINDICES8, CG_BLENDINDICES9, CG_BLENDINDICES10, CG_BLENDINDICES11, CG_BLENDINDICES12, CG_BLENDINDICES13, CG_BLENDINDICES14, CG_BLENDINDICES15, CG_COLOR0, CG_COLOR1, CG_COLOR2, CG_COLOR3, CG_COLOR4, CG_COLOR5, CG_COLOR6, CG_COLOR7, CG_COLOR8, CG_COLOR9, CG_COLOR10, CG_COLOR11, CG_COLOR12, CG_COLOR13, CG_COLOR14, CG_COLOR15, CG_PSIZE0, CG_PSIZE1, CG_PSIZE2, CG_PSIZE3, CG_PSIZE4, CG_PSIZE5, CG_PSIZE6, CG_PSIZE7, CG_PSIZE8, CG_PSIZE9, CG_PSIZE10, CG_PSIZE11, CG_PSIZE12, CG_PSIZE13, CG_PSIZE14, CG_PSIZE15, CG_BINORMAL0, CG_BINORMAL1, CG_BINORMAL2, CG_BINORMAL3, CG_BINORMAL4, CG_BINORMAL5, CG_BINORMAL6, CG_BINORMAL7, CG_BINORMAL8, CG_BINORMAL9, CG_BINORMAL10, CG_BINORMAL11, CG_BINORMAL12, CG_BINORMAL13, CG_BINORMAL14, CG_BINORMAL15, CG_FOG0, CG_FOG1, CG_FOG2, CG_FOG3, CG_FOG4, CG_FOG5, CG_FOG6, CG_FOG7, CG_FOG8, CG_FOG9, CG_FOG10, CG_FOG11, CG_FOG12, CG_FOG13, CG_FOG14, CG_FOG15, CG_DEPTH0, CG_DEPTH1, CG_DEPTH2, CG_DEPTH3, CG_DEPTH4, CG_DEPTH5, CG_DEPTH6, CG_DEPTH7, CG_DEPTH8, CG_DEPTH9, CG_DEPTH10, CG_DEPTH11, CG_DEPTH12, CG_DEPTH13, CG_DEPTH14, CG_DEPTH15, CG_SAMPLE0, CG_SAMPLE1, CG_SAMPLE2, CG_SAMPLE3, CG_SAMPLE4, CG_SAMPLE5, CG_SAMPLE6, CG_SAMPLE7, CG_SAMPLE8, CG_SAMPLE9, CG_SAMPLE10, CG_SAMPLE11, CG_SAMPLE12, CG_SAMPLE13, CG_SAMPLE14, CG_SAMPLE15, CG_BLENDWEIGHT0, CG_BLENDWEIGHT1, CG_BLENDWEIGHT2, CG_BLENDWEIGHT3, CG_BLENDWEIGHT4, CG_BLENDWEIGHT5, CG_BLENDWEIGHT6, CG_BLENDWEIGHT7, CG_BLENDWEIGHT8, CG_BLENDWEIGHT9, CG_BLENDWEIGHT10, CG_BLENDWEIGHT11, CG_BLENDWEIGHT12, CG_BLENDWEIGHT13, CG_BLENDWEIGHT14, CG_BLENDWEIGHT15, CG_NORMAL0, CG_NORMAL1, CG_NORMAL2, CG_NORMAL3, CG_NORMAL4, CG_NORMAL5, CG_NORMAL6, CG_NORMAL7, CG_NORMAL8, CG_NORMAL9, CG_NORMAL10, CG_NORMAL11, CG_NORMAL12, CG_NORMAL13, CG_NORMAL14, CG_NORMAL15, CG_FOGCOORD, CG_TEXCOORD0, CG_TEXCOORD1, CG_TEXCOORD2, CG_TEXCOORD3, CG_TEXCOORD4, CG_TEXCOORD5, CG_TEXCOORD6, CG_TEXCOORD7, CG_TEXCOORD8, CG_TEXCOORD9, CG_TEXCOORD10, CG_TEXCOORD11, CG_TEXCOORD12, CG_TEXCOORD13, CG_TEXCOORD14, CG_TEXCOORD15, CG_COMBINER_CONST0, CG_COMBINER_CONST1, CG_COMBINER_STAGE_CONST0, CG_COMBINER_STAGE_CONST1, CG_OFFSET_TEXTURE_MATRIX, CG_OFFSET_TEXTURE_SCALE, CG_OFFSET_TEXTURE_BIAS, CG_CONST_EYE, CG_TESSFACTOR, CG_UNDEFINED</code>
   */
  public static String cgGetResourceString(int resource)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetResourceString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetResourceString\" not available");
    }
        return dispatch_cgGetResourceString1(resource, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetResourceString(CGresource resource); </code> 
      @param resource valid values are: <code>CG_TEXUNIT0, CG_TEXUNIT1, CG_TEXUNIT2, CG_TEXUNIT3, CG_TEXUNIT4, CG_TEXUNIT5, CG_TEXUNIT6, CG_TEXUNIT7, CG_TEXUNIT8, CG_TEXUNIT9, CG_TEXUNIT10, CG_TEXUNIT11, CG_TEXUNIT12, CG_TEXUNIT13, CG_TEXUNIT14, CG_TEXUNIT15, CG_ATTR0, CG_ATTR1, CG_ATTR2, CG_ATTR3, CG_ATTR4, CG_ATTR5, CG_ATTR6, CG_ATTR7, CG_ATTR8, CG_ATTR9, CG_ATTR10, CG_ATTR11, CG_ATTR12, CG_ATTR13, CG_ATTR14, CG_ATTR15, CG_C, CG_TEX0, CG_TEX1, CG_TEX2, CG_TEX3, CG_TEX4, CG_TEX5, CG_TEX6, CG_TEX7, CG_HPOS, CG_COL0, CG_COL1, CG_COL2, CG_COL3, CG_PSIZ, CG_WPOS, CG_POSITION0, CG_POSITION1, CG_POSITION2, CG_POSITION3, CG_POSITION4, CG_POSITION5, CG_POSITION6, CG_POSITION7, CG_POSITION8, CG_POSITION9, CG_POSITION10, CG_POSITION11, CG_POSITION12, CG_POSITION13, CG_POSITION14, CG_POSITION15, CG_DIFFUSE0, CG_TANGENT0, CG_TANGENT1, CG_TANGENT2, CG_TANGENT3, CG_TANGENT4, CG_TANGENT5, CG_TANGENT6, CG_TANGENT7, CG_TANGENT8, CG_TANGENT9, CG_TANGENT10, CG_TANGENT11, CG_TANGENT12, CG_TANGENT13, CG_TANGENT14, CG_TANGENT15, CG_SPECULAR0, CG_BLENDINDICES0, CG_BLENDINDICES1, CG_BLENDINDICES2, CG_BLENDINDICES3, CG_BLENDINDICES4, CG_BLENDINDICES5, CG_BLENDINDICES6, CG_BLENDINDICES7, CG_BLENDINDICES8, CG_BLENDINDICES9, CG_BLENDINDICES10, CG_BLENDINDICES11, CG_BLENDINDICES12, CG_BLENDINDICES13, CG_BLENDINDICES14, CG_BLENDINDICES15, CG_COLOR0, CG_COLOR1, CG_COLOR2, CG_COLOR3, CG_COLOR4, CG_COLOR5, CG_COLOR6, CG_COLOR7, CG_COLOR8, CG_COLOR9, CG_COLOR10, CG_COLOR11, CG_COLOR12, CG_COLOR13, CG_COLOR14, CG_COLOR15, CG_PSIZE0, CG_PSIZE1, CG_PSIZE2, CG_PSIZE3, CG_PSIZE4, CG_PSIZE5, CG_PSIZE6, CG_PSIZE7, CG_PSIZE8, CG_PSIZE9, CG_PSIZE10, CG_PSIZE11, CG_PSIZE12, CG_PSIZE13, CG_PSIZE14, CG_PSIZE15, CG_BINORMAL0, CG_BINORMAL1, CG_BINORMAL2, CG_BINORMAL3, CG_BINORMAL4, CG_BINORMAL5, CG_BINORMAL6, CG_BINORMAL7, CG_BINORMAL8, CG_BINORMAL9, CG_BINORMAL10, CG_BINORMAL11, CG_BINORMAL12, CG_BINORMAL13, CG_BINORMAL14, CG_BINORMAL15, CG_FOG0, CG_FOG1, CG_FOG2, CG_FOG3, CG_FOG4, CG_FOG5, CG_FOG6, CG_FOG7, CG_FOG8, CG_FOG9, CG_FOG10, CG_FOG11, CG_FOG12, CG_FOG13, CG_FOG14, CG_FOG15, CG_DEPTH0, CG_DEPTH1, CG_DEPTH2, CG_DEPTH3, CG_DEPTH4, CG_DEPTH5, CG_DEPTH6, CG_DEPTH7, CG_DEPTH8, CG_DEPTH9, CG_DEPTH10, CG_DEPTH11, CG_DEPTH12, CG_DEPTH13, CG_DEPTH14, CG_DEPTH15, CG_SAMPLE0, CG_SAMPLE1, CG_SAMPLE2, CG_SAMPLE3, CG_SAMPLE4, CG_SAMPLE5, CG_SAMPLE6, CG_SAMPLE7, CG_SAMPLE8, CG_SAMPLE9, CG_SAMPLE10, CG_SAMPLE11, CG_SAMPLE12, CG_SAMPLE13, CG_SAMPLE14, CG_SAMPLE15, CG_BLENDWEIGHT0, CG_BLENDWEIGHT1, CG_BLENDWEIGHT2, CG_BLENDWEIGHT3, CG_BLENDWEIGHT4, CG_BLENDWEIGHT5, CG_BLENDWEIGHT6, CG_BLENDWEIGHT7, CG_BLENDWEIGHT8, CG_BLENDWEIGHT9, CG_BLENDWEIGHT10, CG_BLENDWEIGHT11, CG_BLENDWEIGHT12, CG_BLENDWEIGHT13, CG_BLENDWEIGHT14, CG_BLENDWEIGHT15, CG_NORMAL0, CG_NORMAL1, CG_NORMAL2, CG_NORMAL3, CG_NORMAL4, CG_NORMAL5, CG_NORMAL6, CG_NORMAL7, CG_NORMAL8, CG_NORMAL9, CG_NORMAL10, CG_NORMAL11, CG_NORMAL12, CG_NORMAL13, CG_NORMAL14, CG_NORMAL15, CG_FOGCOORD, CG_TEXCOORD0, CG_TEXCOORD1, CG_TEXCOORD2, CG_TEXCOORD3, CG_TEXCOORD4, CG_TEXCOORD5, CG_TEXCOORD6, CG_TEXCOORD7, CG_TEXCOORD8, CG_TEXCOORD9, CG_TEXCOORD10, CG_TEXCOORD11, CG_TEXCOORD12, CG_TEXCOORD13, CG_TEXCOORD14, CG_TEXCOORD15, CG_COMBINER_CONST0, CG_COMBINER_CONST1, CG_COMBINER_STAGE_CONST0, CG_COMBINER_STAGE_CONST1, CG_OFFSET_TEXTURE_MATRIX, CG_OFFSET_TEXTURE_SCALE, CG_OFFSET_TEXTURE_BIAS, CG_CONST_EYE, CG_TESSFACTOR, CG_UNDEFINED</code>
   */
  public static native String dispatch_cgGetResourceString1(int resource, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetSamplerStateAssignmentParameter(CGstateassignment); </code>    */
  public static CGparameter cgGetSamplerStateAssignmentParameter(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetSamplerStateAssignmentParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetSamplerStateAssignmentParameter\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetSamplerStateAssignmentParameter1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetSamplerStateAssignmentParameter(CGstateassignment); </code>    */
  private static native ByteBuffer dispatch_cgGetSamplerStateAssignmentParameter1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGstate cgGetSamplerStateAssignmentState(CGstateassignment); </code>    */
  public static CGstate cgGetSamplerStateAssignmentState(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetSamplerStateAssignmentState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetSamplerStateAssignmentState\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetSamplerStateAssignmentState1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGstate.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGstate cgGetSamplerStateAssignmentState(CGstateassignment); </code>    */
  private static native ByteBuffer dispatch_cgGetSamplerStateAssignmentState1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetSamplerStateAssignmentValue(CGstateassignment); </code>    */
  public static CGparameter cgGetSamplerStateAssignmentValue(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetSamplerStateAssignmentValue;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetSamplerStateAssignmentValue\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetSamplerStateAssignmentValue1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetSamplerStateAssignmentValue(CGstateassignment); </code>    */
  private static native ByteBuffer dispatch_cgGetSamplerStateAssignmentValue1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetStateAssignmentIndex(CGstateassignment); </code>    */
  public static int cgGetStateAssignmentIndex(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetStateAssignmentIndex;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetStateAssignmentIndex\" not available");
    }
        return dispatch_cgGetStateAssignmentIndex1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> int cgGetStateAssignmentIndex(CGstateassignment); </code>    */
  private static native int dispatch_cgGetStateAssignmentIndex1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGpass cgGetStateAssignmentPass(CGstateassignment); </code>    */
  public static CGpass cgGetStateAssignmentPass(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetStateAssignmentPass;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetStateAssignmentPass\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetStateAssignmentPass1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGpass.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGpass cgGetStateAssignmentPass(CGstateassignment); </code>    */
  private static native ByteBuffer dispatch_cgGetStateAssignmentPass1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGstate cgGetStateAssignmentState(CGstateassignment); </code>    */
  public static CGstate cgGetStateAssignmentState(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetStateAssignmentState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetStateAssignmentState\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetStateAssignmentState1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGstate.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGstate cgGetStateAssignmentState(CGstateassignment); </code>    */
  private static native ByteBuffer dispatch_cgGetStateAssignmentState1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetStateName(CGstate); </code>    */
  public static String cgGetStateName(CGstate arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetStateName;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetStateName\" not available");
    }
        return dispatch_cgGetStateName1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetStateName(CGstate); </code>    */
  private static native String dispatch_cgGetStateName1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGtype cgGetStateType(CGstate); </code>    */
  public static int cgGetStateType(CGstate arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetStateType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetStateType\" not available");
    }
        return dispatch_cgGetStateType1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGtype cgGetStateType(CGstate); </code>    */
  private static native int dispatch_cgGetStateType1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetString(CGenum sname); </code> 
      @param sname valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  public static String cgGetString(int sname)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetString\" not available");
    }
        return dispatch_cgGetString1(sname, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetString(CGenum sname); </code> 
      @param sname valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  public static native String dispatch_cgGetString1(int sname, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetStringAnnotationValue(CGannotation); </code>    */
  public static String cgGetStringAnnotationValue(CGannotation arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetStringAnnotationValue;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetStringAnnotationValue\" not available");
    }
        return dispatch_cgGetStringAnnotationValue1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetStringAnnotationValue(CGannotation); </code>    */
  private static native String dispatch_cgGetStringAnnotationValue1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetStringParameterValue(CGparameter param); </code>    */
  public static String cgGetStringParameterValue(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetStringParameterValue;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetStringParameterValue\" not available");
    }
        return dispatch_cgGetStringParameterValue1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetStringParameterValue(CGparameter param); </code>    */
  private static native String dispatch_cgGetStringParameterValue1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetStringStateAssignmentValue(CGstateassignment); </code>    */
  public static String cgGetStringStateAssignmentValue(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetStringStateAssignmentValue;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetStringStateAssignmentValue\" not available");
    }
        return dispatch_cgGetStringStateAssignmentValue1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetStringStateAssignmentValue(CGstateassignment); </code>    */
  private static native String dispatch_cgGetStringStateAssignmentValue1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGeffect cgGetTechniqueEffect(CGtechnique); </code>    */
  public static CGeffect cgGetTechniqueEffect(CGtechnique arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetTechniqueEffect;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetTechniqueEffect\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetTechniqueEffect1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGeffect.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGeffect cgGetTechniqueEffect(CGtechnique); </code>    */
  private static native ByteBuffer dispatch_cgGetTechniqueEffect1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetTechniqueName(CGtechnique); </code>    */
  public static String cgGetTechniqueName(CGtechnique arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetTechniqueName;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetTechniqueName\" not available");
    }
        return dispatch_cgGetTechniqueName1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetTechniqueName(CGtechnique); </code>    */
  private static native String dispatch_cgGetTechniqueName1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetTextureStateAssignmentValue(CGstateassignment); </code>    */
  public static CGparameter cgGetTextureStateAssignmentValue(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetTextureStateAssignmentValue;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetTextureStateAssignmentValue\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetTextureStateAssignmentValue1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGparameter cgGetTextureStateAssignmentValue(CGstateassignment); </code>    */
  private static native ByteBuffer dispatch_cgGetTextureStateAssignmentValue1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGtype cgGetType(const char *  type_string); </code>    */
  public static int cgGetType(String type_string)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetType\" not available");
    }
        return dispatch_cgGetType1(type_string, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGtype cgGetType(const char *  type_string); </code>    */
  public static native int dispatch_cgGetType1(String type_string, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetTypeString(CGtype type); </code> 
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static String cgGetTypeString(int type)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetTypeString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetTypeString\" not available");
    }
        return dispatch_cgGetTypeString1(type, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> const char *  cgGetTypeString(CGtype type); </code> 
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static native String dispatch_cgGetTypeString1(int type, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGtype cgGetUserType(CGhandle handle, int index); </code> 
      @param handle a direct or array-backed {@link java.nio.Buffer}   */
  public static int cgGetUserType(Buffer handle, int index)  {

    final boolean handle_is_direct = Buffers.isDirect(handle);
    final long __addr_ = cgProcAddressTable._addressof_cgGetUserType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgGetUserType\" not available");
    }
        return dispatch_cgGetUserType1(handle_is_direct ? handle : Buffers.getArray(handle), handle_is_direct ? Buffers.getDirectBufferByteOffset(handle) : Buffers.getIndirectBufferByteOffset(handle), handle_is_direct, index, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGtype cgGetUserType(CGhandle handle, int index); </code> 
      @param handle a direct or array-backed {@link java.nio.Buffer}   */
  private static native int dispatch_cgGetUserType1(Object handle, int handle_byte_offset, boolean handle_is_direct, int index, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsAnnotation(CGannotation); </code>    */
  public static boolean cgIsAnnotation(CGannotation arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsAnnotation;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgIsAnnotation\" not available");
    }
        return dispatch_cgIsAnnotation1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsAnnotation(CGannotation); </code>    */
  private static native boolean dispatch_cgIsAnnotation1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsContext(CGcontext ctx); </code>    */
  public static boolean cgIsContext(CGcontext ctx)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgIsContext\" not available");
    }
        return dispatch_cgIsContext1(((ctx == null) ? null : ctx.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsContext(CGcontext ctx); </code>    */
  private static native boolean dispatch_cgIsContext1(ByteBuffer ctx, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsEffect(CGeffect effect); </code>    */
  public static boolean cgIsEffect(CGeffect effect)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsEffect;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgIsEffect\" not available");
    }
        return dispatch_cgIsEffect1(((effect == null) ? null : effect.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsEffect(CGeffect effect); </code>    */
  private static native boolean dispatch_cgIsEffect1(ByteBuffer effect, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsInterfaceType(CGtype type); </code> 
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static boolean cgIsInterfaceType(int type)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsInterfaceType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgIsInterfaceType\" not available");
    }
        return dispatch_cgIsInterfaceType1(type, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsInterfaceType(CGtype type); </code> 
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static native boolean dispatch_cgIsInterfaceType1(int type, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsParameter(CGparameter param); </code>    */
  public static boolean cgIsParameter(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgIsParameter\" not available");
    }
        return dispatch_cgIsParameter1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsParameter(CGparameter param); </code>    */
  private static native boolean dispatch_cgIsParameter1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsParameterGlobal(CGparameter param); </code>    */
  public static boolean cgIsParameterGlobal(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsParameterGlobal;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgIsParameterGlobal\" not available");
    }
        return dispatch_cgIsParameterGlobal1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsParameterGlobal(CGparameter param); </code>    */
  private static native boolean dispatch_cgIsParameterGlobal1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsParameterReferenced(CGparameter param); </code>    */
  public static boolean cgIsParameterReferenced(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsParameterReferenced;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgIsParameterReferenced\" not available");
    }
        return dispatch_cgIsParameterReferenced1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsParameterReferenced(CGparameter param); </code>    */
  private static native boolean dispatch_cgIsParameterReferenced1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsParameterUsed(CGparameter param, CGhandle handle); </code> 
      @param handle a direct or array-backed {@link java.nio.Buffer}   */
  public static boolean cgIsParameterUsed(CGparameter param, Buffer handle)  {

    final boolean handle_is_direct = Buffers.isDirect(handle);
    final long __addr_ = cgProcAddressTable._addressof_cgIsParameterUsed;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgIsParameterUsed\" not available");
    }
        return dispatch_cgIsParameterUsed1(((param == null) ? null : param.getBuffer()), handle_is_direct ? handle : Buffers.getArray(handle), handle_is_direct ? Buffers.getDirectBufferByteOffset(handle) : Buffers.getIndirectBufferByteOffset(handle), handle_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsParameterUsed(CGparameter param, CGhandle handle); </code> 
      @param handle a direct or array-backed {@link java.nio.Buffer}   */
  private static native boolean dispatch_cgIsParameterUsed1(ByteBuffer param, Object handle, int handle_byte_offset, boolean handle_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsParentType(CGtype parent, CGtype child); </code> 
      @param parent valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>

      @param child valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static boolean cgIsParentType(int parent, int child)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsParentType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgIsParentType\" not available");
    }
        return dispatch_cgIsParentType1(parent, child, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsParentType(CGtype parent, CGtype child); </code> 
      @param parent valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>

      @param child valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static native boolean dispatch_cgIsParentType1(int parent, int child, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsPass(CGpass); </code>    */
  public static boolean cgIsPass(CGpass arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsPass;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgIsPass\" not available");
    }
        return dispatch_cgIsPass1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsPass(CGpass); </code>    */
  private static native boolean dispatch_cgIsPass1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsProgram(CGprogram program); </code>    */
  public static boolean cgIsProgram(CGprogram program)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgIsProgram\" not available");
    }
        return dispatch_cgIsProgram1(((program == null) ? null : program.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsProgram(CGprogram program); </code>    */
  private static native boolean dispatch_cgIsProgram1(ByteBuffer program, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsProgramCompiled(CGprogram program); </code>    */
  public static boolean cgIsProgramCompiled(CGprogram program)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsProgramCompiled;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgIsProgramCompiled\" not available");
    }
        return dispatch_cgIsProgramCompiled1(((program == null) ? null : program.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsProgramCompiled(CGprogram program); </code>    */
  private static native boolean dispatch_cgIsProgramCompiled1(ByteBuffer program, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsState(CGstate); </code>    */
  public static boolean cgIsState(CGstate arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgIsState\" not available");
    }
        return dispatch_cgIsState1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsState(CGstate); </code>    */
  private static native boolean dispatch_cgIsState1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsStateAssignment(CGstateassignment); </code>    */
  public static boolean cgIsStateAssignment(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsStateAssignment;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgIsStateAssignment\" not available");
    }
        return dispatch_cgIsStateAssignment1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsStateAssignment(CGstateassignment); </code>    */
  private static native boolean dispatch_cgIsStateAssignment1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsTechnique(CGtechnique); </code>    */
  public static boolean cgIsTechnique(CGtechnique arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsTechnique;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgIsTechnique\" not available");
    }
        return dispatch_cgIsTechnique1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsTechnique(CGtechnique); </code>    */
  private static native boolean dispatch_cgIsTechnique1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsTechniqueValidated(CGtechnique); </code>    */
  public static boolean cgIsTechniqueValidated(CGtechnique arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsTechniqueValidated;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgIsTechniqueValidated\" not available");
    }
        return dispatch_cgIsTechniqueValidated1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgIsTechniqueValidated(CGtechnique); </code>    */
  private static native boolean dispatch_cgIsTechniqueValidated1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgResetPassState(CGpass); </code>    */
  public static void cgResetPassState(CGpass arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgResetPassState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgResetPassState\" not available");
    }
        dispatch_cgResetPassState1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgResetPassState(CGpass); </code>    */
  private static native void dispatch_cgResetPassState1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetArraySize(CGparameter param, int size); </code>    */
  public static void cgSetArraySize(CGparameter param, int size)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetArraySize;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetArraySize\" not available");
    }
        dispatch_cgSetArraySize1(((param == null) ? null : param.getBuffer()), size, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetArraySize(CGparameter param, int size); </code>    */
  private static native void dispatch_cgSetArraySize1(ByteBuffer param, int size, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetAutoCompile(CGcontext ctx, CGenum flag); </code> 
      @param flag valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  public static void cgSetAutoCompile(CGcontext ctx, int flag)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetAutoCompile;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetAutoCompile\" not available");
    }
        dispatch_cgSetAutoCompile1(((ctx == null) ? null : ctx.getBuffer()), flag, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetAutoCompile(CGcontext ctx, CGenum flag); </code> 
      @param flag valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  private static native void dispatch_cgSetAutoCompile1(ByteBuffer ctx, int flag, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetLastListing(CGhandle handle, const char *  listing); </code> 
      @param handle a direct or array-backed {@link java.nio.Buffer}   */
  public static void cgSetLastListing(Buffer handle, String listing)  {

    final boolean handle_is_direct = Buffers.isDirect(handle);
    final long __addr_ = cgProcAddressTable._addressof_cgSetLastListing;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetLastListing\" not available");
    }
        dispatch_cgSetLastListing1(handle_is_direct ? handle : Buffers.getArray(handle), handle_is_direct ? Buffers.getDirectBufferByteOffset(handle) : Buffers.getIndirectBufferByteOffset(handle), handle_is_direct, listing, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetLastListing(CGhandle handle, const char *  listing); </code> 
      @param handle a direct or array-backed {@link java.nio.Buffer}   */
  private static native void dispatch_cgSetLastListing1(Object handle, int handle_byte_offset, boolean handle_is_direct, String listing, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetMatrixParameterdc(CGparameter param, const double *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgSetMatrixParameterdc(CGparameter param, DoubleBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameterdc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetMatrixParameterdc\" not available");
    }
        dispatch_cgSetMatrixParameterdc1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetMatrixParameterdc(CGparameter param, const double *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgSetMatrixParameterdc1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetMatrixParameterdc(CGparameter param, const double *  matrix); </code>    */
  public static void cgSetMatrixParameterdc(CGparameter param, double[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameterdc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetMatrixParameterdc\" not available");
    }
        dispatch_cgSetMatrixParameterdc1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_DOUBLE * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetMatrixParameterdr(CGparameter param, const double *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgSetMatrixParameterdr(CGparameter param, DoubleBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameterdr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetMatrixParameterdr\" not available");
    }
        dispatch_cgSetMatrixParameterdr1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetMatrixParameterdr(CGparameter param, const double *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgSetMatrixParameterdr1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetMatrixParameterdr(CGparameter param, const double *  matrix); </code>    */
  public static void cgSetMatrixParameterdr(CGparameter param, double[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameterdr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetMatrixParameterdr\" not available");
    }
        dispatch_cgSetMatrixParameterdr1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_DOUBLE * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetMatrixParameterfc(CGparameter param, const float *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgSetMatrixParameterfc(CGparameter param, FloatBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameterfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetMatrixParameterfc\" not available");
    }
        dispatch_cgSetMatrixParameterfc1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetMatrixParameterfc(CGparameter param, const float *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgSetMatrixParameterfc1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetMatrixParameterfc(CGparameter param, const float *  matrix); </code>    */
  public static void cgSetMatrixParameterfc(CGparameter param, float[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameterfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetMatrixParameterfc\" not available");
    }
        dispatch_cgSetMatrixParameterfc1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_FLOAT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetMatrixParameterfr(CGparameter param, const float *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgSetMatrixParameterfr(CGparameter param, FloatBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameterfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetMatrixParameterfr\" not available");
    }
        dispatch_cgSetMatrixParameterfr1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetMatrixParameterfr(CGparameter param, const float *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgSetMatrixParameterfr1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetMatrixParameterfr(CGparameter param, const float *  matrix); </code>    */
  public static void cgSetMatrixParameterfr(CGparameter param, float[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameterfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetMatrixParameterfr\" not available");
    }
        dispatch_cgSetMatrixParameterfr1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_FLOAT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetMatrixParameteric(CGparameter param, const int *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void cgSetMatrixParameteric(CGparameter param, IntBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameteric;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetMatrixParameteric\" not available");
    }
        dispatch_cgSetMatrixParameteric1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetMatrixParameteric(CGparameter param, const int *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_cgSetMatrixParameteric1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetMatrixParameteric(CGparameter param, const int *  matrix); </code>    */
  public static void cgSetMatrixParameteric(CGparameter param, int[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameteric;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetMatrixParameteric\" not available");
    }
        dispatch_cgSetMatrixParameteric1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_INT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetMatrixParameterir(CGparameter param, const int *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void cgSetMatrixParameterir(CGparameter param, IntBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameterir;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetMatrixParameterir\" not available");
    }
        dispatch_cgSetMatrixParameterir1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetMatrixParameterir(CGparameter param, const int *  matrix); </code> 
      @param matrix a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_cgSetMatrixParameterir1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetMatrixParameterir(CGparameter param, const int *  matrix); </code>    */
  public static void cgSetMatrixParameterir(CGparameter param, int[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameterir;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetMatrixParameterir\" not available");
    }
        dispatch_cgSetMatrixParameterir1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_INT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetMultiDimArraySize(CGparameter param, const int *  sizes); </code> 
      @param sizes a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void cgSetMultiDimArraySize(CGparameter param, IntBuffer sizes)  {

    final boolean sizes_is_direct = Buffers.isDirect(sizes);
    final long __addr_ = cgProcAddressTable._addressof_cgSetMultiDimArraySize;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetMultiDimArraySize\" not available");
    }
        dispatch_cgSetMultiDimArraySize1(((param == null) ? null : param.getBuffer()), sizes_is_direct ? sizes : Buffers.getArray(sizes), sizes_is_direct ? Buffers.getDirectBufferByteOffset(sizes) : Buffers.getIndirectBufferByteOffset(sizes), sizes_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetMultiDimArraySize(CGparameter param, const int *  sizes); </code> 
      @param sizes a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_cgSetMultiDimArraySize1(ByteBuffer param, Object sizes, int sizes_byte_offset, boolean sizes_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetMultiDimArraySize(CGparameter param, const int *  sizes); </code>    */
  public static void cgSetMultiDimArraySize(CGparameter param, int[] sizes, int sizes_offset)  {

    if(sizes != null && sizes.length <= sizes_offset)
      throw new CgException("array offset argument \"sizes_offset\" (" + sizes_offset + ") equals or exceeds array length (" + sizes.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetMultiDimArraySize;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetMultiDimArraySize\" not available");
    }
        dispatch_cgSetMultiDimArraySize1(((param == null) ? null : param.getBuffer()), sizes, Buffers.SIZEOF_INT * sizes_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter1d(CGparameter param, double x); </code>    */
  public static void cgSetParameter1d(CGparameter param, double x)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter1d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter1d\" not available");
    }
        dispatch_cgSetParameter1d1(((param == null) ? null : param.getBuffer()), x, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter1d(CGparameter param, double x); </code>    */
  private static native void dispatch_cgSetParameter1d1(ByteBuffer param, double x, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter1dv(CGparameter param, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgSetParameter1dv(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter1dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter1dv\" not available");
    }
        dispatch_cgSetParameter1dv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter1dv(CGparameter param, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgSetParameter1dv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter1dv(CGparameter param, const double *  v); </code>    */
  public static void cgSetParameter1dv(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter1dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter1dv\" not available");
    }
        dispatch_cgSetParameter1dv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter1f(CGparameter param, float x); </code>    */
  public static void cgSetParameter1f(CGparameter param, float x)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter1f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter1f\" not available");
    }
        dispatch_cgSetParameter1f1(((param == null) ? null : param.getBuffer()), x, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter1f(CGparameter param, float x); </code>    */
  private static native void dispatch_cgSetParameter1f1(ByteBuffer param, float x, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter1fv(CGparameter param, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgSetParameter1fv(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter1fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter1fv\" not available");
    }
        dispatch_cgSetParameter1fv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter1fv(CGparameter param, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgSetParameter1fv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter1fv(CGparameter param, const float *  v); </code>    */
  public static void cgSetParameter1fv(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter1fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter1fv\" not available");
    }
        dispatch_cgSetParameter1fv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter1i(CGparameter param, int x); </code>    */
  public static void cgSetParameter1i(CGparameter param, int x)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter1i;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter1i\" not available");
    }
        dispatch_cgSetParameter1i1(((param == null) ? null : param.getBuffer()), x, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter1i(CGparameter param, int x); </code>    */
  private static native void dispatch_cgSetParameter1i1(ByteBuffer param, int x, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter1iv(CGparameter param, const int *  v); </code> 
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void cgSetParameter1iv(CGparameter param, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter1iv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter1iv\" not available");
    }
        dispatch_cgSetParameter1iv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter1iv(CGparameter param, const int *  v); </code> 
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_cgSetParameter1iv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter1iv(CGparameter param, const int *  v); </code>    */
  public static void cgSetParameter1iv(CGparameter param, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter1iv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter1iv\" not available");
    }
        dispatch_cgSetParameter1iv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter2d(CGparameter param, double x, double y); </code>    */
  public static void cgSetParameter2d(CGparameter param, double x, double y)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter2d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter2d\" not available");
    }
        dispatch_cgSetParameter2d1(((param == null) ? null : param.getBuffer()), x, y, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter2d(CGparameter param, double x, double y); </code>    */
  private static native void dispatch_cgSetParameter2d1(ByteBuffer param, double x, double y, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter2dv(CGparameter param, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgSetParameter2dv(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter2dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter2dv\" not available");
    }
        dispatch_cgSetParameter2dv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter2dv(CGparameter param, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgSetParameter2dv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter2dv(CGparameter param, const double *  v); </code>    */
  public static void cgSetParameter2dv(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter2dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter2dv\" not available");
    }
        dispatch_cgSetParameter2dv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter2f(CGparameter param, float x, float y); </code>    */
  public static void cgSetParameter2f(CGparameter param, float x, float y)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter2f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter2f\" not available");
    }
        dispatch_cgSetParameter2f1(((param == null) ? null : param.getBuffer()), x, y, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter2f(CGparameter param, float x, float y); </code>    */
  private static native void dispatch_cgSetParameter2f1(ByteBuffer param, float x, float y, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter2fv(CGparameter param, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgSetParameter2fv(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter2fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter2fv\" not available");
    }
        dispatch_cgSetParameter2fv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter2fv(CGparameter param, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgSetParameter2fv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter2fv(CGparameter param, const float *  v); </code>    */
  public static void cgSetParameter2fv(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter2fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter2fv\" not available");
    }
        dispatch_cgSetParameter2fv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter2i(CGparameter param, int x, int y); </code>    */
  public static void cgSetParameter2i(CGparameter param, int x, int y)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter2i;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter2i\" not available");
    }
        dispatch_cgSetParameter2i1(((param == null) ? null : param.getBuffer()), x, y, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter2i(CGparameter param, int x, int y); </code>    */
  private static native void dispatch_cgSetParameter2i1(ByteBuffer param, int x, int y, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter2iv(CGparameter param, const int *  v); </code> 
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void cgSetParameter2iv(CGparameter param, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter2iv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter2iv\" not available");
    }
        dispatch_cgSetParameter2iv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter2iv(CGparameter param, const int *  v); </code> 
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_cgSetParameter2iv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter2iv(CGparameter param, const int *  v); </code>    */
  public static void cgSetParameter2iv(CGparameter param, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter2iv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter2iv\" not available");
    }
        dispatch_cgSetParameter2iv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter3d(CGparameter param, double x, double y, double z); </code>    */
  public static void cgSetParameter3d(CGparameter param, double x, double y, double z)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter3d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter3d\" not available");
    }
        dispatch_cgSetParameter3d1(((param == null) ? null : param.getBuffer()), x, y, z, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter3d(CGparameter param, double x, double y, double z); </code>    */
  private static native void dispatch_cgSetParameter3d1(ByteBuffer param, double x, double y, double z, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter3dv(CGparameter param, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgSetParameter3dv(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter3dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter3dv\" not available");
    }
        dispatch_cgSetParameter3dv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter3dv(CGparameter param, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgSetParameter3dv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter3dv(CGparameter param, const double *  v); </code>    */
  public static void cgSetParameter3dv(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter3dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter3dv\" not available");
    }
        dispatch_cgSetParameter3dv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter3f(CGparameter param, float x, float y, float z); </code>    */
  public static void cgSetParameter3f(CGparameter param, float x, float y, float z)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter3f\" not available");
    }
        dispatch_cgSetParameter3f1(((param == null) ? null : param.getBuffer()), x, y, z, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter3f(CGparameter param, float x, float y, float z); </code>    */
  private static native void dispatch_cgSetParameter3f1(ByteBuffer param, float x, float y, float z, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter3fv(CGparameter param, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgSetParameter3fv(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter3fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter3fv\" not available");
    }
        dispatch_cgSetParameter3fv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter3fv(CGparameter param, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgSetParameter3fv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter3fv(CGparameter param, const float *  v); </code>    */
  public static void cgSetParameter3fv(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter3fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter3fv\" not available");
    }
        dispatch_cgSetParameter3fv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter3i(CGparameter param, int x, int y, int z); </code>    */
  public static void cgSetParameter3i(CGparameter param, int x, int y, int z)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter3i;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter3i\" not available");
    }
        dispatch_cgSetParameter3i1(((param == null) ? null : param.getBuffer()), x, y, z, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter3i(CGparameter param, int x, int y, int z); </code>    */
  private static native void dispatch_cgSetParameter3i1(ByteBuffer param, int x, int y, int z, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter3iv(CGparameter param, const int *  v); </code> 
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void cgSetParameter3iv(CGparameter param, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter3iv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter3iv\" not available");
    }
        dispatch_cgSetParameter3iv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter3iv(CGparameter param, const int *  v); </code> 
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_cgSetParameter3iv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter3iv(CGparameter param, const int *  v); </code>    */
  public static void cgSetParameter3iv(CGparameter param, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter3iv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter3iv\" not available");
    }
        dispatch_cgSetParameter3iv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter4d(CGparameter param, double x, double y, double z, double w); </code>    */
  public static void cgSetParameter4d(CGparameter param, double x, double y, double z, double w)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter4d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter4d\" not available");
    }
        dispatch_cgSetParameter4d1(((param == null) ? null : param.getBuffer()), x, y, z, w, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter4d(CGparameter param, double x, double y, double z, double w); </code>    */
  private static native void dispatch_cgSetParameter4d1(ByteBuffer param, double x, double y, double z, double w, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter4dv(CGparameter param, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgSetParameter4dv(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter4dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter4dv\" not available");
    }
        dispatch_cgSetParameter4dv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter4dv(CGparameter param, const double *  v); </code> 
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgSetParameter4dv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter4dv(CGparameter param, const double *  v); </code>    */
  public static void cgSetParameter4dv(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter4dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter4dv\" not available");
    }
        dispatch_cgSetParameter4dv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter4f(CGparameter param, float x, float y, float z, float w); </code>    */
  public static void cgSetParameter4f(CGparameter param, float x, float y, float z, float w)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter4f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter4f\" not available");
    }
        dispatch_cgSetParameter4f1(((param == null) ? null : param.getBuffer()), x, y, z, w, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter4f(CGparameter param, float x, float y, float z, float w); </code>    */
  private static native void dispatch_cgSetParameter4f1(ByteBuffer param, float x, float y, float z, float w, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter4fv(CGparameter param, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgSetParameter4fv(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter4fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter4fv\" not available");
    }
        dispatch_cgSetParameter4fv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter4fv(CGparameter param, const float *  v); </code> 
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgSetParameter4fv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter4fv(CGparameter param, const float *  v); </code>    */
  public static void cgSetParameter4fv(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter4fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter4fv\" not available");
    }
        dispatch_cgSetParameter4fv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter4i(CGparameter param, int x, int y, int z, int w); </code>    */
  public static void cgSetParameter4i(CGparameter param, int x, int y, int z, int w)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter4i;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter4i\" not available");
    }
        dispatch_cgSetParameter4i1(((param == null) ? null : param.getBuffer()), x, y, z, w, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter4i(CGparameter param, int x, int y, int z, int w); </code>    */
  private static native void dispatch_cgSetParameter4i1(ByteBuffer param, int x, int y, int z, int w, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter4iv(CGparameter param, const int *  v); </code> 
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void cgSetParameter4iv(CGparameter param, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter4iv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter4iv\" not available");
    }
        dispatch_cgSetParameter4iv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter4iv(CGparameter param, const int *  v); </code> 
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_cgSetParameter4iv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameter4iv(CGparameter param, const int *  v); </code>    */
  public static void cgSetParameter4iv(CGparameter param, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter4iv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameter4iv\" not available");
    }
        dispatch_cgSetParameter4iv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameterSemantic(CGparameter param, const char *  semantic); </code>    */
  public static void cgSetParameterSemantic(CGparameter param, String semantic)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterSemantic;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameterSemantic\" not available");
    }
        dispatch_cgSetParameterSemantic1(((param == null) ? null : param.getBuffer()), semantic, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameterSemantic(CGparameter param, const char *  semantic); </code>    */
  private static native void dispatch_cgSetParameterSemantic1(ByteBuffer param, String semantic, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameterValuedc(CGparameter param, int n, const double *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgSetParameterValuedc(CGparameter param, int n, DoubleBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValuedc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameterValuedc\" not available");
    }
        dispatch_cgSetParameterValuedc1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameterValuedc(CGparameter param, int n, const double *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgSetParameterValuedc1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameterValuedc(CGparameter param, int n, const double *  vals); </code>    */
  public static void cgSetParameterValuedc(CGparameter param, int n, double[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValuedc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameterValuedc\" not available");
    }
        dispatch_cgSetParameterValuedc1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_DOUBLE * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameterValuedr(CGparameter param, int n, const double *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgSetParameterValuedr(CGparameter param, int n, DoubleBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValuedr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameterValuedr\" not available");
    }
        dispatch_cgSetParameterValuedr1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameterValuedr(CGparameter param, int n, const double *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgSetParameterValuedr1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameterValuedr(CGparameter param, int n, const double *  vals); </code>    */
  public static void cgSetParameterValuedr(CGparameter param, int n, double[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValuedr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameterValuedr\" not available");
    }
        dispatch_cgSetParameterValuedr1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_DOUBLE * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameterValuefc(CGparameter param, int n, const float *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgSetParameterValuefc(CGparameter param, int n, FloatBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValuefc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameterValuefc\" not available");
    }
        dispatch_cgSetParameterValuefc1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameterValuefc(CGparameter param, int n, const float *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgSetParameterValuefc1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameterValuefc(CGparameter param, int n, const float *  vals); </code>    */
  public static void cgSetParameterValuefc(CGparameter param, int n, float[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValuefc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameterValuefc\" not available");
    }
        dispatch_cgSetParameterValuefc1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_FLOAT * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameterValuefr(CGparameter param, int n, const float *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgSetParameterValuefr(CGparameter param, int n, FloatBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValuefr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameterValuefr\" not available");
    }
        dispatch_cgSetParameterValuefr1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameterValuefr(CGparameter param, int n, const float *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgSetParameterValuefr1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameterValuefr(CGparameter param, int n, const float *  vals); </code>    */
  public static void cgSetParameterValuefr(CGparameter param, int n, float[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValuefr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameterValuefr\" not available");
    }
        dispatch_cgSetParameterValuefr1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_FLOAT * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameterValueic(CGparameter param, int n, const int *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void cgSetParameterValueic(CGparameter param, int n, IntBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValueic;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameterValueic\" not available");
    }
        dispatch_cgSetParameterValueic1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameterValueic(CGparameter param, int n, const int *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_cgSetParameterValueic1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameterValueic(CGparameter param, int n, const int *  vals); </code>    */
  public static void cgSetParameterValueic(CGparameter param, int n, int[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValueic;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameterValueic\" not available");
    }
        dispatch_cgSetParameterValueic1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_INT * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameterValueir(CGparameter param, int n, const int *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void cgSetParameterValueir(CGparameter param, int n, IntBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValueir;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameterValueir\" not available");
    }
        dispatch_cgSetParameterValueir1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameterValueir(CGparameter param, int n, const int *  vals); </code> 
      @param vals a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_cgSetParameterValueir1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameterValueir(CGparameter param, int n, const int *  vals); </code>    */
  public static void cgSetParameterValueir(CGparameter param, int n, int[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValueir;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameterValueir\" not available");
    }
        dispatch_cgSetParameterValueir1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_INT * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameterVariability(CGparameter param, CGenum vary); </code> 
      @param vary valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  public static void cgSetParameterVariability(CGparameter param, int vary)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterVariability;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetParameterVariability\" not available");
    }
        dispatch_cgSetParameterVariability1(((param == null) ? null : param.getBuffer()), vary, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetParameterVariability(CGparameter param, CGenum vary); </code> 
      @param vary valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  private static native void dispatch_cgSetParameterVariability1(ByteBuffer param, int vary, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetPassProgramParameters(CGprogram); </code>    */
  public static void cgSetPassProgramParameters(CGprogram arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetPassProgramParameters;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetPassProgramParameters\" not available");
    }
        dispatch_cgSetPassProgramParameters1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetPassProgramParameters(CGprogram); </code>    */
  private static native void dispatch_cgSetPassProgramParameters1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetPassState(CGpass); </code>    */
  public static void cgSetPassState(CGpass arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetPassState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetPassState\" not available");
    }
        dispatch_cgSetPassState1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetPassState(CGpass); </code>    */
  private static native void dispatch_cgSetPassState1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetProgramProfile(CGprogram prog, CGprofile profile); </code> 
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static void cgSetProgramProfile(CGprogram prog, int profile)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetProgramProfile;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetProgramProfile\" not available");
    }
        dispatch_cgSetProgramProfile1(((prog == null) ? null : prog.getBuffer()), profile, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetProgramProfile(CGprogram prog, CGprofile profile); </code> 
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  private static native void dispatch_cgSetProgramProfile1(ByteBuffer prog, int profile, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetSamplerState(CGparameter); </code>    */
  public static void cgSetSamplerState(CGparameter arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetSamplerState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetSamplerState\" not available");
    }
        dispatch_cgSetSamplerState1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetSamplerState(CGparameter); </code>    */
  private static native void dispatch_cgSetSamplerState1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetStringParameterValue(CGparameter param, const char *  str); </code>    */
  public static void cgSetStringParameterValue(CGparameter param, String str)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetStringParameterValue;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgSetStringParameterValue\" not available");
    }
        dispatch_cgSetStringParameterValue1(((param == null) ? null : param.getBuffer()), str, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> void cgSetStringParameterValue(CGparameter param, const char *  str); </code>    */
  private static native void dispatch_cgSetStringParameterValue1(ByteBuffer param, String str, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgValidateTechnique(CGtechnique); </code>    */
  public static boolean cgValidateTechnique(CGtechnique arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgValidateTechnique;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"cgValidateTechnique\" not available");
    }
        return dispatch_cgValidateTechnique1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code> CGbool cgValidateTechnique(CGtechnique); </code>    */
  private static native boolean dispatch_cgValidateTechnique1(ByteBuffer arg0, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
  private static final DynamicLibraryBundle cgDynamicLookupHelper;
  private static final CgProcAddressTable cgProcAddressTable;
  
  static {
      cgProcAddressTable = new CgProcAddressTable();
      if(null==cgProcAddressTable) {
        throw new RuntimeException("Couldn't instantiate CgProcAddressTable");
      }
      cgDynamicLookupHelper = new DynamicLibraryBundle(new CgDynamicLibraryBundleInfo());
      if(null==cgDynamicLookupHelper) {
        throw new RuntimeException("Null CgDynamicLookupHelper");
      }
      if(!cgDynamicLookupHelper.isToolLibLoaded()) {
        throw new RuntimeException("Couln't load native Cg or CgGL library");
      }
      if(!cgDynamicLookupHelper.isGlueLibLoaded(CgDynamicLibraryBundleInfo.getCgGlueLibIndex())) {
        throw new RuntimeException("Couln't load native GLue/JNI library");
      }
      cgProcAddressTable.reset(cgDynamicLookupHelper);
  }
  
  public  static CgProcAddressTable getCgProcAddressTable() { return cgProcAddressTable; }
  
  /** A convenience method which reads all available data from the InputStream and then calls cgCreateProgram. */
  public static CGprogram cgCreateProgramFromStream(CGcontext ctx, int program_type, java.io.InputStream stream, int profile, java.lang.String entry, java.lang.String[] args) throws java.io.IOException {
    if (stream == null) {
      throw new java.io.IOException("null stream");
    }
    stream = new java.io.BufferedInputStream(stream);
    int avail = stream.available();
    byte[] data = new byte[avail];
    int numRead = 0;
    int pos = 0;
    do {
      if (pos + avail > data.length) {
        byte[] newData = new byte[pos + avail];
        System.arraycopy(data, 0, newData, 0, pos);
        data = newData;
      }
      numRead = stream.read(data, pos, avail);
      if (numRead >= 0) {
        pos += numRead;
      }
      avail = stream.available();
    } while (avail > 0 && numRead >= 0);
    String program = new String(data, 0, pos, "US-ASCII");
    return cgCreateProgram(ctx, program_type, program, profile, entry, args);
  }
  // ---- End CustomJavaCode .cfg declarations

} // end of class CgGL
